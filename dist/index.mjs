var Hm = Object.defineProperty;
var zm = (e, t, s) => t in e ? Hm(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var Ct = (e, t, s) => zm(e, typeof t != "symbol" ? t + "" : t, s);
import { defineComponent as Wo, mergeModels as yd, useTemplateRef as Wm, ref as it, toRefs as _m, watch as bd, useModel as Um, createElementBlock as ui, onMounted as dh, getCurrentInstance as xn, markRaw as Km, onUnmounted as $m, openBlock as pi, mergeDefaults as jm, isRef as qm, isReactive as Ym, isProxy as Xm, toRaw as Zm, createVNode as ch, render as Sd, createElementVNode as Qm, Fragment as Jm, renderList as eC, toDisplayString as hh, createCommentVNode as xd, unref as tC, normalizeStyle as sC } from "vue";
var Rs = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, s) {
    const i = t ? this.allAsyncListeners : this.allSyncListeners;
    let r = i.get(e);
    return !r && s && (r = /* @__PURE__ */ new Set(), i.set(e, r)), r;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, s = !1) {
    this.getListeners(e, s, !0).add(t);
  }
  removeEventListener(e, t, s = !1) {
    const i = this.getListeners(e, s, !1);
    i && (i.delete(t), i.size === 0 && (s ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const s = e.type;
    if (t && "event" in e) {
      const a = e.event;
      a instanceof Event && (e.eventPath = a.composedPath());
    }
    const i = (a, l) => a.forEach((d) => {
      if (!l.has(d))
        return;
      const c = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => d(e)) : () => d(e);
      t ? this.dispatchAsync(c) : c();
    }), r = this.getListeners(s, t, !1) ?? /* @__PURE__ */ new Set(), o = new Set(r);
    o.size > 0 && i(o, r), new Set(
      t ? this.globalAsyncListeners : this.globalSyncListeners
    ).forEach((a) => {
      const l = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => a(s, e)) : () => a(s, e);
      t ? this.dispatchAsync(l) : l();
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
function iC(e, t) {
  return t;
}
function uh(e) {
  return (e == null ? void 0 : e.getLocaleTextFunc()) ?? iC;
}
function gt(e, t, s) {
  s == null || typeof s == "string" && s == "" ? Xa(e, t) : ft(e, t, s);
}
function ft(e, t, s) {
  e.setAttribute(ph(t), s.toString());
}
function Xa(e, t) {
  e.removeAttribute(ph(t));
}
function ph(e) {
  return `aria-${e}`;
}
function re(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function rC(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function oC(e) {
  return parseInt(e.getAttribute("aria-posinset"), 10);
}
function nC(e) {
  return e.getAttribute("aria-label");
}
function oe(e, t) {
  gt(e, "label", t);
}
function vs(e, t) {
  gt(e, "labelledby", t);
}
function _o(e, t) {
  gt(e, "describedby", t);
}
function gh(e, t) {
  gt(e, "live", t);
}
function aC(e, t) {
  gt(e, "atomic", t);
}
function lC(e, t) {
  gt(e, "relevant", t);
}
function Sr(e, t) {
  gt(e, "level", t);
}
function co(e, t) {
  gt(e, "disabled", t);
}
function Za(e, t) {
  gt(e, "hidden", t);
}
function fh(e, t) {
  gt(e, "activedescendant", t);
}
function He(e, t) {
  ft(e, "expanded", t);
}
function mh(e) {
  Xa(e, "expanded");
}
function Uo(e, t) {
  ft(e, "setsize", t);
}
function Ko(e, t) {
  ft(e, "posinset", t);
}
function dC(e, t) {
  ft(e, "multiselectable", t);
}
function cC(e, t) {
  ft(e, "rowcount", t);
}
function Qa(e, t) {
  ft(e, "rowindex", t);
}
function hC(e, t) {
  ft(e, "colcount", t);
}
function Ja(e, t) {
  ft(e, "colindex", t);
}
function Ch(e, t) {
  ft(e, "colspan", t);
}
function uC(e, t) {
  ft(e, "sort", t);
}
function pC(e) {
  Xa(e, "sort");
}
function hr(e, t) {
  gt(e, "selected", t);
}
function vh(e, t) {
  ft(e, "checked", t === void 0 ? "mixed" : t);
}
function el(e, t) {
  gt(e, "controls", t.id), vs(t, e.id);
}
function tl(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var Fn, Rn, Pn, Tn, Dn, ha, ua, En;
function si() {
  return Fn === void 0 && (Fn = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), Fn;
}
function wh() {
  if (Rn === void 0) {
    const e = window;
    Rn = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return Rn;
}
function yh() {
  return Pn === void 0 && (Pn = /(firefox)/i.test(navigator.userAgent)), Pn;
}
function bh() {
  return Tn === void 0 && (Tn = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), Tn;
}
function fs() {
  return Dn === void 0 && (Dn = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), Dn;
}
function pa(e) {
  if (!e)
    return null;
  const t = e.tabIndex, s = e.getAttribute("tabIndex");
  return t === -1 && (s === null || s === "" && !yh()) ? null : t.toString();
}
function gC() {
  if (En !== void 0)
    return En;
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = yh() ? 6e6 : 1e9, s = document.createElement("div");
  for (document.body.appendChild(s); ; ) {
    const i = e * 2;
    if (s.style.height = i + "px", i > t || s.clientHeight !== i)
      break;
    e = i;
  }
  return document.body.removeChild(s), En = e, e;
}
function fC() {
  return ua == null && Sh(), ua;
}
function Sh() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let s = t.offsetWidth - t.clientWidth;
  s === 0 && t.clientWidth === 0 && (s = null), t.parentNode && t.parentNode.removeChild(t), s != null && (ua = s, ha = s === 0);
}
function xh() {
  return ha == null && Sh(), ha;
}
var Or;
function ho(e, t, s) {
  const i = e.parentElement;
  let r = i && i.firstChild;
  for (; r; )
    t && r.classList.toggle(t, r === e), s && r.classList.toggle(s, r !== e), r = r.nextSibling;
}
var mC = "[tabindex], input, select, button, textarea, [href]", Fh = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function sl(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, i = t.call(e, "input, select, button, textarea"), r = t.call(e, Fh), o = ke(e);
  return i && !r && o;
}
function O(e, t, s = {}) {
  const { skipAriaHidden: i } = s;
  e.classList.toggle("ag-hidden", !t), i || Za(e, !t);
}
function Rh(e, t, s = {}) {
  const { skipAriaHidden: i } = s;
  e.classList.toggle("ag-invisible", !t), i || Za(e, !t);
}
function lt(e, t) {
  const s = "disabled", i = t ? (r) => r.setAttribute(s, "") : (r) => r.removeAttribute(s);
  i(e), Ah(e.querySelectorAll("input"), (r) => i(r));
}
function Hs(e, t, s) {
  let i = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof s == "number") {
      if (++i > s)
        break;
    } else if (e === s)
      break;
  }
  return !1;
}
function ii(e) {
  const {
    height: t,
    width: s,
    borderTopWidth: i,
    borderRightWidth: r,
    borderBottomWidth: o,
    borderLeftWidth: n,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: d,
    paddingLeft: c,
    marginTop: h,
    marginRight: u,
    marginBottom: p,
    marginLeft: g,
    boxSizing: f
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(s || "0"),
    borderTopWidth: parseFloat(i || "0"),
    borderRightWidth: parseFloat(r || "0"),
    borderBottomWidth: parseFloat(o || "0"),
    borderLeftWidth: parseFloat(n || "0"),
    paddingTop: parseFloat(a || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(d || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(h || "0"),
    marginRight: parseFloat(u || "0"),
    marginBottom: parseFloat(p || "0"),
    marginLeft: parseFloat(g || "0"),
    boxSizing: f
  };
}
function $o(e) {
  const t = ii(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function yi(e) {
  const t = ii(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function jo(e) {
  const { height: t, marginBottom: s, marginTop: i } = ii(e);
  return Math.floor(t + s + i);
}
function $s(e) {
  const { width: t, marginLeft: s, marginRight: i } = ii(e);
  return Math.floor(t + s + i);
}
function Ph(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: s, borderLeftWidth: i, borderRightWidth: r, borderBottomWidth: o } = ii(e);
  return {
    top: t.top + (s || 0),
    left: t.left + (i || 0),
    right: t.right + (r || 0),
    bottom: t.bottom + (o || 0)
  };
}
function uo() {
  if (typeof Or == "boolean")
    return Or;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, Or = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), Or;
}
function po(e, t) {
  let s = e.scrollLeft;
  return t && (s = Math.abs(s), wh() && !uo() && (s = e.scrollWidth - e.getBoundingClientRect().width - s)), s;
}
function go(e, t, s) {
  s && (uo() ? t *= -1 : (si() || wh()) && (t = e.scrollWidth - e.getBoundingClientRect().width - t)), e.scrollLeft = t;
}
function X(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function ce(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function Th(e) {
  return !!e.offsetParent;
}
function ke(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!Th(e) || window.getComputedStyle(e).visibility !== "visible");
}
function Be(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function Dh(e, t, s) {
  s && s.nextSibling === t || (s ? s.nextSibling ? e.insertBefore(t, s.nextSibling) : e.appendChild(t) : e.firstChild && e.firstChild !== t && e.insertAdjacentElement("afterbegin", t));
}
function Eh(e, t) {
  for (let s = 0; s < t.length; s++) {
    const i = t[s], r = e.children[s];
    r !== i && e.insertBefore(i, r);
  }
}
function CC(e, t, s) {
  s ? s.insertAdjacentElement("afterend", t) : e.firstChild ? e.insertAdjacentElement("afterbegin", t) : e.appendChild(t);
}
function vC(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLocaleLowerCase()}`);
}
function Mh(e, t) {
  if (t)
    for (const [s, i] of Object.entries(t)) {
      if (!s || !s.length || i == null)
        continue;
      const r = vC(s), o = i.toString(), n = o.replace(/\s*!important/g, ""), a = n.length != o.length ? "important" : void 0;
      e.style.setProperty(r, n, a);
    }
}
function wC(e) {
  return e.clientWidth < e.scrollWidth;
}
function yC(e) {
  return e.clientHeight < e.scrollHeight;
}
function fo(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : yt(e, t);
}
function yt(e, t) {
  t = il(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function Qi(e, t) {
  t = il(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function il(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function qo(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function bC(e) {
  if (e == null)
    return [];
  const t = [];
  return Ah(e, (s) => t.push(s)), t;
}
function SC(e, t) {
  if (e)
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      t(i.name, i.value);
    }
}
function ht(e, t, s) {
  s == null || s === "" ? e.removeAttribute(t) : e.setAttribute(t, s.toString());
}
function Ah(e, t) {
  if (e != null)
    for (let s = 0; s < e.length; s++)
      t(e[s]);
}
function Ih(e, t) {
  e.then((s) => {
    const i = s.getGui();
    i != null && (typeof i == "object" ? t.appendChild(i) : t.innerHTML = i);
  });
}
function Rt(e, t, s) {
  const r = zh(e).ResizeObserver, o = r ? new r(s) : null;
  return o == null || o.observe(t), () => o == null ? void 0 : o.disconnect();
}
function ge(e) {
  return e == null || e === "" ? null : e;
}
function A(e) {
  return e != null && e !== "";
}
function Y(e) {
  return !A(e);
}
function qe(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function bi(e, t) {
  const s = e ? JSON.stringify(e) : null, i = t ? JSON.stringify(t) : null;
  return s === i;
}
function Qr(e, t, s = !1) {
  const i = e == null, r = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), i && r)
    return 0;
  if (i)
    return -1;
  if (r)
    return 1;
  function o(n, a) {
    return n > a ? 1 : n < a ? -1 : 0;
  }
  if (typeof e != "string" || !s)
    return o(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return o(e, t);
  }
}
var Lh = "https://www.ag-grid.com", Fd = {};
function rl(e, t) {
  Fd[t] || (e(), Fd[t] = !0);
}
function ws(e, t, ...s) {
  e.get("debug") && console.log("AG Grid: " + t, ...s);
}
function kt(e, ...t) {
  rl(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function gi(e, ...t) {
  rl(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
var Mn = [], An = !1;
function Rd(e) {
  Mn.push(e), !An && (An = !0, window.setTimeout(() => {
    const t = Mn.slice();
    Mn.length = 0, An = !1, t.forEach((s) => s());
  }, 0));
}
function Ce(e, t, s) {
  let i;
  return function(...r) {
    const o = this;
    window.clearTimeout(i), i = window.setTimeout(function() {
      e.isAlive() && t.apply(o, r);
    }, s);
  };
}
function Pd(e, t) {
  let s = 0;
  return function(...i) {
    const r = this, o = (/* @__PURE__ */ new Date()).getTime();
    o - s < t || (s = o, e.apply(r, i));
  };
}
function kh(e, t, s = 100, i) {
  const r = (/* @__PURE__ */ new Date()).getTime();
  let o = null, n = !1;
  const a = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - r > s;
    (e() || l) && (t(), n = !0, o != null && (window.clearInterval(o), o = null));
  };
  a(), n || (o = window.setInterval(a, 10));
}
var G = "33.0.2", Td = 2e3, Dd = 100, Oh = "_version_", Jr = null, Si = `${Lh}/javascript-data-grid`;
function xC(e) {
  Jr = e;
}
function FC(e) {
  Si = e;
}
function Gh(e, t, s) {
  return (Jr == null ? void 0 : Jr.getConsoleMessage(e, t)) ?? [DC(e, t, s)];
}
function ol(e, t, s, i) {
  e(`error #${t}`, ...Gh(t, s, i));
}
function RC(e) {
  if (!e)
    return String(e);
  const t = {};
  for (const s of Object.keys(e))
    typeof e[s] != "object" && typeof e[s] != "function" && (t[s] = e[s]);
  return JSON.stringify(t);
}
function PC(e) {
  let t = e;
  return e instanceof Error ? t = e.toString() : typeof e == "object" && (t = RC(e)), t;
}
function mo(e) {
  return e === void 0 ? "undefined" : e === null ? "null" : e;
}
function ga(e, t) {
  return `${e}?${t.toString()}`;
}
function TC(e, t, s) {
  const i = Array.from(t.entries()).sort((o, n) => n[1].length - o[1].length);
  let r = ga(e, t);
  for (const [o, n] of i) {
    if (o === Oh)
      continue;
    const a = r.length - s;
    if (a <= 0)
      break;
    const l = "...", d = a + l.length, c = n.length - d > Dd ? n.slice(0, n.length - d) + l : n.slice(0, Dd) + l;
    t.set(o, c), r = ga(e, t);
  }
  return r;
}
function Bh(e, t) {
  const s = new URLSearchParams();
  s.append(Oh, G), t && Object.entries(t).forEach(([o, n]) => {
    s.append(o, PC(n));
  });
  const i = `${Si}/errors/${e}`, r = ga(i, s);
  return r.length <= Td ? r : TC(i, s, Td);
}
var DC = (e, t, s) => {
  const i = Bh(e, t);
  return `${s ? s + ` 
` : ""}Visit ${i}${s ? "" : ` 
  Alternatively register the ValidationModule to see the full message in the console.`}`;
};
function R(...e) {
  ol(kt, e[0], e[1]);
}
function z(...e) {
  ol(gi, e[0], e[1]);
}
function fa(e, t, s) {
  ol(gi, e, t, s);
}
function Vh(e, t) {
  const s = t[0];
  return `error #${s} ` + Gh(s, t[1], e).join(" ");
}
function ut(...e) {
  return Vh(void 0, e);
}
function Nh(...e) {
  return Vh(`
`, e);
}
function Hh(e, t) {
  return e.get("rowModelType") === t;
}
function J(e, t) {
  return Hh(e, "clientSide");
}
function Te(e, t) {
  return Hh(e, "serverSide");
}
function ye(e, t) {
  return e.get("domLayout") === t;
}
function ot(e) {
  return Ri(e) !== void 0;
}
function nl(e) {
  return typeof e.get("getRowHeight") == "function";
}
function EC(e, t) {
  return t ? !e.get("enableStrictPivotColumnOrder") : e.get("maintainColumnOrder");
}
function Ie(e, t, s = !1, i) {
  const { gos: r, environment: o } = e;
  if (i == null && (i = o.getDefaultRowHeight()), nl(r)) {
    if (s)
      return { height: i, estimated: !0 };
    const l = {
      node: t,
      data: t.data
    }, d = r.getCallback("getRowHeight")(l);
    if (ma(d))
      return d === 0 && R(23), { height: Math.max(1, d), estimated: !1 };
  }
  if (t.detail && r.get("masterDetail"))
    return MC(r);
  const n = r.get("rowHeight");
  return { height: n && ma(n) ? n : i, estimated: !1 };
}
function MC(e) {
  if (e.get("detailRowAutoHeight"))
    return { height: 1, estimated: !1 };
  const t = e.get("detailRowHeight");
  return ma(t) ? { height: t, estimated: !1 } : { height: 300, estimated: !1 };
}
function Ye(e) {
  const { environment: t, gos: s } = e, i = s.get("rowHeight");
  if (!i || Y(i))
    return t.getDefaultRowHeight();
  const r = t.refreshRowHeightVariable();
  return r !== -1 ? r : (R(24), t.getDefaultRowHeight());
}
function ma(e) {
  return !isNaN(e) && typeof e == "number" && isFinite(e);
}
function Co(e, t, s) {
  const i = t[e.getDomDataKey()];
  return i ? i[s] : void 0;
}
function js(e, t, s, i) {
  const r = e.getDomDataKey();
  let o = t[r];
  Y(o) && (o = {}, t[r] = o), o[s] = i;
}
function Z(e) {
  const { gos: t, eGridDiv: s } = e;
  let i = null;
  const r = t.get("getDocument");
  return r && A(r) ? i = r() : s && (i = s.ownerDocument), i && A(i) ? i : document;
}
function zh(e) {
  return Z(e).defaultView || window;
}
function xi(e) {
  return e.eGridDiv.getRootNode();
}
function q(e) {
  return xi(e).activeElement;
}
function Yo(e) {
  let t = null, s = null;
  try {
    t = Z(e).fullscreenElement;
  } catch {
  } finally {
    t || (t = xi(e));
    const i = t.querySelector("body");
    i ? s = i : t instanceof ShadowRoot ? s = t : t instanceof Document ? s = t == null ? void 0 : t.documentElement : s = t;
  }
  return s;
}
function AC(e) {
  const t = Yo(e);
  return (t == null ? void 0 : t.clientWidth) ?? (window.innerHeight || -1);
}
function IC(e) {
  const t = Yo(e);
  return (t == null ? void 0 : t.clientHeight) ?? (window.innerHeight || -1);
}
function Ca(e, t, s) {
  const r = e.getBoundingClientRect().height, o = AC(s) - 2, n = IC(s) - 2;
  if (!e.offsetParent)
    return;
  const l = Ph(e.offsetParent), { clientY: d, clientX: c } = t;
  let h = d - l.top - r / 2, u = c - l.left - 10;
  const p = Z(s), g = p.defaultView || window, f = g.pageYOffset || p.documentElement.scrollTop, m = g.pageXOffset || p.documentElement.scrollLeft;
  o > 0 && u + e.clientWidth > o + m && (u = o + m - e.clientWidth), u < 0 && (u = 0), n > 0 && h + e.clientHeight > n + f && (h = n + f - e.clientHeight), h < 0 && (h = 0), e.style.left = `${u}px`, e.style.top = `${h}px`;
}
function ys(e) {
  const t = Z(e), s = q(e);
  return s === null || s === t.body;
}
function fi(e) {
  return e.get("ensureDomOrder") ? !1 : e.get("animateRows");
}
function Xo(e) {
  return !(e.get("paginateChildRows") || e.get("groupHideOpenParents") || ye(e, "print"));
}
function wt(e) {
  const t = e.get("autoGroupColumnDef");
  return !(t != null && t.comparator) && !e.get("treeData");
}
function ur(e) {
  const t = e.get("groupAggFiltering");
  if (typeof t == "function")
    return e.getCallback("groupAggFiltering");
  if (t === !0)
    return () => !0;
}
function Zo(e) {
  return e.get("grandTotalRow");
}
function Fi(e) {
  const t = e.get("groupTotalRow");
  return typeof t == "function" ? e.getCallback("groupTotalRow") : () => t ?? void 0;
}
function al(e) {
  return e.exists("groupDisplayType") ? e.get("groupDisplayType") === "multipleColumns" : e.get("groupHideOpenParents");
}
function Qo(e, t) {
  return t ? !1 : e.get("groupDisplayType") === "groupRows";
}
function Yt(e) {
  const t = e.getCallback("getRowId");
  return t === void 0 ? t : (s) => {
    let i = t(s);
    return typeof i != "string" && (R(25, { id: i }), i = String(i)), i;
  };
}
function LC(e, t) {
  const s = e.get("groupHideParentOfSingleChild");
  return !!(s === !0 || s === "leafGroupsOnly" && t.leafGroup || e.get("groupRemoveSingleChildren") || e.get("groupRemoveLowestSingleChildren") && t.leafGroup);
}
function Wh(e) {
  const t = e.get("maxConcurrentDatasourceRequests");
  return t > 0 ? t : void 0;
}
function _h(e, t) {
  const s = e.get("suppressGroupChangesColumnVisibility");
  if (s === !0 || t && s === "suppressHideOnGroup" || !t && s === "suppressShowOnUngroup")
    return !1;
  const i = e.get("suppressRowGroupHidesColumns");
  if (t && i === !0)
    return !1;
  const r = e.get("suppressMakeColumnVisibleAfterUnGroup");
  return !(!t && r === !0);
}
function zs(e) {
  return (e == null ? void 0 : e.checkboxes) ?? !0;
}
function eo(e) {
  return (e == null ? void 0 : e.mode) === "multiRow" && (e.headerCheckbox ?? !0);
}
function vo(e) {
  if (typeof e == "object")
    return e.checkboxLocation ?? "selectionColumn";
}
function In(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? !1;
}
function ll(e) {
  return typeof e.get("rowSelection") != "string";
}
function kC(e) {
  return e.get("cellSelection") !== void 0;
}
function Gr(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? (t == null ? void 0 : t.suppressMultiRanges) ?? !1 : !1 : e.get("suppressMultiRangeSelection");
}
function Ve(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? !!t : e.get("enableRangeSelection");
}
function Ln(e) {
  var i;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" && ((i = t.handle) == null ? void 0 : i.mode) === "fill" ? t.handle : void 0 : {
    mode: "fill",
    setFillValue: e.get("fillOperation"),
    direction: e.get("fillHandleDirection"),
    suppressClearOnFillReduction: e.get("suppressClearOnFillReduction")
  };
}
function Uh(e) {
  const t = e.get("rowSelection") ?? "single";
  if (typeof t == "string") {
    const s = e.get("suppressRowClickSelection"), i = e.get("suppressRowDeselection");
    return s && i ? !1 : s ? "enableDeselection" : i ? "enableSelection" : !0;
  }
  return t.mode === "singleRow" || t.mode === "multiRow" ? t.enableClickSelection ?? !1 : !1;
}
function OC(e) {
  const t = Uh(e);
  return t === !0 || t === "enableSelection";
}
function Ed(e) {
  const t = Uh(e);
  return t === !0 || t === "enableDeselection";
}
function va(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("isRowSelectable") : t == null ? void 0 : t.isRowSelectable;
}
function Ri(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string")
    switch (t) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  switch (t == null ? void 0 : t.mode) {
    case "multiRow":
    case "singleRow":
      return t.mode;
    default:
      return;
  }
}
function bs(e) {
  return Ri(e) === "multiRow";
}
function GC(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("rowMultiSelectWithClick") : (t == null ? void 0 : t.enableSelectionWithoutKeys) ?? !1;
}
function wo(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") {
    const s = e.get("groupSelectsChildren"), i = e.get("groupSelectsFiltered");
    return s && i ? "filteredDescendants" : s ? "descendants" : "self";
  }
  return (t == null ? void 0 : t.mode) === "multiRow" ? t.groupSelects : void 0;
}
function Kh(e, t = !0) {
  const s = e.get("rowSelection");
  return typeof s != "object" ? t ? "all" : void 0 : s.mode === "multiRow" ? s.selectAll : "all";
}
function qs(e) {
  const t = wo(e);
  return t === "descendants" || t === "filteredDescendants";
}
function kn(e) {
  return e.isModuleRegistered("SetFilter") && !e.get("suppressSetFilterByDefault");
}
function we(e) {
  return e.get("columnMenu") === "legacy";
}
function $h(e) {
  return !we(e);
}
function dl(e) {
  return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substring(1);
}
function BC(e, t, s) {
  typeof e != "object" && (e = {});
  const i = { ...e };
  return s.forEach((r) => {
    const o = t[r];
    typeof o < "u" && (i[r] = o);
  }), i;
}
function VC(e, t) {
  if (!e)
    return;
  const s = {};
  let i = !1;
  if (Object.keys(e).forEach((n) => {
    s[n] = e[n], i = !0;
  }), !i)
    return;
  const r = {
    type: "gridOptionsChanged",
    options: s
  };
  t.dispatchEvent(r);
  const o = {
    type: "componentStateChanged",
    ...s
  };
  t.dispatchEvent(o);
}
var jh = "__ag_Grid_Stop_Propagation", NC = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], HC = ["wheel"], On = {};
function he(e) {
  e[jh] = !0;
}
function nt(e) {
  return e[jh] === !0;
}
var qh = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (s) => {
    if (typeof On[s] == "boolean")
      return On[s];
    const i = document.createElement(e[s] || "div");
    return s = "on" + s, On[s] = s in i;
  };
})();
function Yh(e, t, s) {
  let i = t;
  for (; i; ) {
    const r = Co(e, i, s);
    if (r)
      return r;
    i = i.parentElement;
  }
  return null;
}
function wa(e, t) {
  return !t || !e ? !1 : WC(t).indexOf(e) >= 0;
}
function zC(e) {
  const t = [];
  let s = e.target;
  for (; s; )
    t.push(s), s = s.parentElement;
  return t;
}
function WC(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : zC(t);
}
function _C(e, t, s, i) {
  const r = Xh(s);
  let o;
  r != null && (o = { passive: r }), e && e.addEventListener && e.addEventListener(t, s, i, o);
}
var Xh = (e) => {
  const t = NC.includes(e), s = HC.includes(e);
  if (t)
    return !0;
  if (s)
    return !1;
}, P = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.beans = e, this.stubContext = e.context, this.eventSvc = e.eventSvc, this.gos = e.gos;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  destroy() {
    const { destroyFunctions: e } = this;
    for (let t = 0; t < e.length; t++)
      e[t]();
    e.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventSvc to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t, s) {
    this.localEventService || (this.localEventService = new Rs()), this.localEventService.addEventListener(e, t, s);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t, s) {
    var i;
    (i = this.localEventService) == null || i.removeEventListener(e, t, s);
  }
  dispatchLocalEvent(e) {
    var t;
    (t = this.localEventService) == null || t.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventSvc, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const s = [];
    for (const i of Object.keys(t)) {
      const r = t[i];
      r && s.push(this._setupListener(e, i, r));
    }
    return s;
  }
  _setupListener(e, t, s) {
    if (this.destroyed)
      return () => null;
    e instanceof HTMLElement ? _C(this.beans.frameworkOverrides, e, t, s) : e.addEventListener(t, s);
    const i = () => (e.removeEventListener(t, s), null);
    return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((r) => r !== i), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(e, t) {
    const { gos: s } = this;
    s.addPropertyEventListener(e, t);
    const i = () => (s.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((r) => r !== i), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const s = e.join("-") + this.propertyListenerId++, i = (r) => {
      if (r.changeSet) {
        if (r.changeSet && r.changeSet.id === this.lastChangeSetIdLookup[s])
          return;
        this.lastChangeSetIdLookup[s] = r.changeSet.id;
      }
      const o = {
        type: "gridPropertyChanged",
        changeSet: r.changeSet,
        source: r.source
      };
      t(o);
    };
    e.forEach((r) => this.setupGridOptionListener(r, i));
  }
  getLocaleTextFunc() {
    return uh(this.beans.localeSvc);
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  /** doesn't throw an error if `bean` is undefined */
  createOptionalManagedBean(e, t) {
    return e ? this.createManagedBean(e, t) : void 0;
  }
  createManagedBean(e, t) {
    const s = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), s;
  }
  createBean(e, t, s) {
    return (t || this.stubContext).createBean(e, s);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
}, Zh = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function UC(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let s = 0; s < e.length; s++)
        t(s.toString(), e[s]);
      return;
    }
    for (const [s, i] of Object.entries(e))
      t(s, i);
  }
}
function pe(e, t, s = !0, i = !1) {
  A(t) && UC(t, (r, o) => {
    if (Zh.has(r))
      return;
    let n = e[r];
    n !== o && (i && n == null && o != null && typeof o == "object" && o.constructor === Object && (n = {}, e[r] = n), Md(o) && Md(n) && !Array.isArray(n) ? pe(n, o, s, i) : (s || o !== void 0) && (e[r] = o));
  });
}
function Ji(e, t, s) {
  if (!t || !e)
    return;
  if (!s)
    return e[t];
  const i = t.split(".");
  let r = e;
  for (let o = 0; o < i.length; o++) {
    if (r == null)
      return;
    r = r[i[o]];
  }
  return r;
}
function Md(e) {
  return typeof e == "object" && e !== null;
}
var KC = {
  resizable: !0,
  sortable: !0
}, $C = 0;
function Qh() {
  return $C++;
}
function Bt(e) {
  return e instanceof Jo;
}
var Jo = class extends P {
  constructor(e, t, s, i) {
    super(), this.colDef = e, this.userProvidedColDef = t, this.colId = s, this.primary = i, this.isColumn = !0, this.instanceId = Qh(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.colEventSvc = new Rs(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.flex = null;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState() {
    const {
      colDef: e,
      beans: { sortSvc: t, pinnedCols: s, colFlex: i }
    } = this;
    t == null || t.initCol(this);
    const r = e.hide;
    r !== void 0 ? this.visible = !r : this.visible = !e.initialHide, s == null || s.initCol(this), i == null || i.initCol(this);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, s) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.dispatchColEvent("colDefChanged", s);
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  getParent() {
    return this.parent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.setState(), this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const {
      gos: e,
      colDef: { field: t, tooltipField: s }
    } = this, i = e.get("suppressFieldDotNotation");
    this.fieldContainsDots = A(t) && t.indexOf(".") >= 0 && !i, this.tooltipFieldContainsDots = A(s) && s.indexOf(".") >= 0 && !i;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? this.beans.environment.getDefaultColumnMinWidth(), this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    var e;
    (e = this.beans.tooltipSvc) == null || e.initCol(this);
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const s = e.width, i = e.initialWidth;
    return s != null ? t = s : i != null ? t = i : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    var t;
    return ((t = this.beans.showRowGroupCols) == null ? void 0 : t.isRowGroupDisplayed(this, e)) ?? !1;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  addEventListener(e, t) {
    var i, r, o;
    this.frameworkEventListenerService = (r = (i = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : r.call(
      i,
      this.frameworkEventListenerService,
      this.colEventSvc
    );
    const s = ((o = this.frameworkEventListenerService) == null ? void 0 : o.wrap(t)) ?? t;
    this.colEventSvc.addEventListener(e, s);
  }
  removeEventListener(e, t) {
    var i;
    const s = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(t)) ?? t;
    this.colEventSvc.removeEventListener(e, s);
  }
  createColumnFunctionCallbackParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    var t;
    return ((t = this.beans.cellNavigation) == null ? void 0 : t.isSuppressNavigable(this, e)) ?? !1;
  }
  isCellEditable(e) {
    var t;
    return ((t = this.beans.editSvc) == null ? void 0 : t.isCellEditable(this, e)) ?? !1;
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    var t;
    return ((t = this.beans.selectionSvc) == null ? void 0 : t.isCellCheckboxSelection(this, e)) ?? !1;
  }
  isSuppressPaste(e) {
    var t;
    return this.isColumnFunc(e, ((t = this.colDef) == null ? void 0 : t.suppressPaste) ?? null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? KC[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const s = this.createColumnFunctionCallbackParams(e);
      return t(s);
    }
    return !1;
  }
  createColumnEvent(e, t) {
    return this.gos.addGridCommonParams({
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return Y(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return A(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchColEvent("leftChanged", t));
  }
  isFilterActive() {
    return this.filterActive;
  }
  /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
  isHovered() {
    var e;
    return R(261), !!((e = this.beans.colHover) != null && e.isHovered(this));
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.dispatchColEvent("firstRightPinnedChanged", t));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.dispatchColEvent("lastLeftPinnedChanged", t));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const s = e === !0;
    this.visible !== s && (this.visible = s, this.dispatchColEvent("visibleChanged", t)), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    return !this.getColDef().suppressSpanHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let s = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        s = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: s };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (Y(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), s = this.colDef.colSpan(t);
    return Math.max(s, 1);
  }
  getRowSpan(e) {
    if (Y(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), s = this.colDef.rowSpan(t);
    return Math.max(s, 1);
  }
  setActualWidth(e, t, s = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), s || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.dispatchColEvent("widthChanged", e);
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex;
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchColEvent(e, t, s) {
    const i = this.createColumnEvent(e, t);
    s && pe(i, s), this.colEventSvc.dispatchEvent(i);
  }
  dispatchStateUpdatedEvent(e) {
    this.colEventSvc.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
};
function ae(e) {
  return e instanceof er;
}
var er = class extends P {
  constructor(e, t, s, i) {
    super(), this.colGroupDef = e, this.groupId = t, this.padding = s, this.level = i, this.isColumn = !1, this.expandable = !1, this.instanceId = Qh(), this.expandableListenerRemoveCallback = null, this.expanded = !!(e != null && e.openByDefault);
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      Bt(t) ? e.push(t) : ae(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, s = !1;
    const i = this.findChildrenRemovingPadding();
    for (let o = 0, n = i.length; o < n; o++) {
      const a = i[o];
      if (!a.isVisible())
        continue;
      const l = a.getColumnGroupShow();
      l === "open" ? (e = !0, s = !0) : l === "closed" ? (t = !0, s = !0) : (e = !0, t = !0);
    }
    const r = e && t && s;
    this.expandable !== r && (this.expandable = r, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (s) => {
      s.forEach((i) => {
        ae(i) && i.isPadding() ? t(i.children) : e.push(i);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, jC = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
}, qC = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = qe(e);
    let s = 0;
    for (; ; ) {
      let i = e ?? t;
      if (i ? s !== 0 && (i += "_" + s) : i = s, !this.existingKeys[i])
        return this.existingKeys[i] = !0, String(i);
      s++;
    }
  }
}, me = Object.freeze([]);
function V(e) {
  if (e != null && e.length)
    return e[e.length - 1];
}
function Re(e, t, s) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((i, r) => s ? s(i, t[r]) : t[r] === i);
}
function YC(e) {
  return e.sort((t, s) => t - s);
}
function be(e, t) {
  const s = e.indexOf(t);
  s >= 0 && e.splice(s, 1);
}
function Ad(e, t, s) {
  for (let i = 0; i < t.length; i++)
    be(e, t[i]);
  for (let i = t.length - 1; i >= 0; i--)
    e.splice(s, 0, t[i]);
}
function Jh(e, t) {
  const s = [], i = [], r = [];
  return e.forEach((n) => {
    const a = n.getColDef().lockPosition;
    a === "right" ? r.push(n) : a === "left" || a === !0 ? s.push(n) : i.push(n);
  }), t.get("enableRtl") ? [...r, ...i, ...s] : [...s, ...i, ...r];
}
function eu(e, t) {
  let s = !0;
  return jt(null, t, (i) => {
    if (!ae(i))
      return;
    const r = i, o = r.getColGroupDef();
    if (!(o && o.marryChildren))
      return;
    const a = [];
    r.getLeafColumns().forEach((u) => {
      const p = e.indexOf(u);
      a.push(p);
    });
    const l = Math.max.apply(Math, a), d = Math.min.apply(Math, a), c = l - d, h = r.getLeafColumns().length - 1;
    c > h && (s = !1);
  }), s;
}
function tu(e, t) {
  if (!e || e.length == 0)
    return;
  const s = t(e[0]);
  for (let i = 1; i < e.length; i++)
    if (s !== t(e[i]))
      return;
  return s;
}
function su(e, t, s) {
  if (!t.length)
    return;
  const i = t.length === 1 ? t[0] : null, r = tu(t, (o) => o.getPinned());
  e.dispatchEvent({
    type: "columnPinned",
    // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
    pinned: r ?? null,
    columns: t,
    column: i,
    source: s
  });
}
function XC(e, t, s) {
  if (!t.length)
    return;
  const i = t.length === 1 ? t[0] : null, r = tu(t, (o) => o.isVisible());
  e.dispatchEvent({
    type: "columnVisible",
    visible: r,
    columns: t,
    column: i,
    source: s
  });
}
function iu(e, t, s, i) {
  e.dispatchEvent({
    type: t,
    columns: s,
    column: s && s.length == 1 ? s[0] : null,
    source: i
  });
}
function Pi(e, t, s, i, r = null) {
  t != null && t.length && e.dispatchEvent({
    type: "columnResized",
    columns: t,
    column: t.length === 1 ? t[0] : null,
    flexColumns: r,
    finished: s,
    source: i
  });
}
function Xe(e, t, s) {
  var y;
  const {
    colModel: i,
    rowGroupColsSvc: r,
    pivotColsSvc: o,
    autoColSvc: n,
    selectionColSvc: a,
    colAnimation: l,
    visibleCols: d,
    pivotResultCols: c,
    environment: h,
    valueColsSvc: u,
    eventSvc: p,
    gos: g
  } = e, f = i.getColDefCols() || [];
  if (!(f != null && f.length))
    return !1;
  if (t != null && t.state && !t.state.forEach)
    return R(32), !1;
  const m = (F, D, x, T, I) => {
    if (!F)
      return;
    const E = tv(D, t.defaultState), M = E("flex").value1;
    if (gu(
      e,
      F,
      E("hide").value1,
      E("sort").value1,
      E("sortIndex").value1,
      E("pinned").value1,
      M,
      s
    ), M == null) {
      const N = E("width").value1;
      if (N != null) {
        const _ = F.getColDef().minWidth ?? h.getDefaultColumnMinWidth();
        _ != null && N >= _ && F.setActualWidth(N, s);
      }
    }
    I || !F.isPrimary() || (u == null || u.syncColumnWithState(F, s, E), r == null || r.syncColumnWithState(F, s, E, x), o == null || o.syncColumnWithState(F, s, E, T));
  }, C = (F, D, x) => {
    var _e, zt;
    const T = ou(e, s), I = D.slice(), E = {}, M = {}, N = [], _ = [], H = [];
    let W = 0;
    const K = (r == null ? void 0 : r.columns.slice()) ?? [], se = (o == null ? void 0 : o.columns.slice()) ?? [];
    F.forEach((ee) => {
      const Ni = ee.colId;
      if (Ni.startsWith(Ss)) {
        N.push(ee), H.push(ee);
        return;
      }
      if (Ot(Ni)) {
        _.push(ee), H.push(ee);
        return;
      }
      const oi = x(Ni);
      oi ? (m(oi, ee, E, M, !1), be(I, oi)) : (H.push(ee), W += 1);
    });
    const Se = (ee) => m(ee, null, E, M, !1);
    I.forEach(Se), r == null || r.sortColumns(Id.bind(r, E, K)), o == null || o.sortColumns(Id.bind(o, M, se)), i.refreshCols(!1);
    const et = (ee, Ni, Sn = []) => {
      Ni.forEach((oi) => {
        const wd = ee(oi.colId);
        be(Sn, wd), m(wd, oi, null, null, !0);
      }), Sn.forEach(Se);
    };
    return et(
      (ee) => (n == null ? void 0 : n.getAutoCol(ee)) ?? null,
      N,
      (_e = n == null ? void 0 : n.getAutoCols()) == null ? void 0 : _e.slice()
    ), et(
      (ee) => (a == null ? void 0 : a.getSelectionCol(ee)) ?? null,
      _,
      (zt = a == null ? void 0 : a.getSelectionCols()) == null ? void 0 : zt.slice()
    ), ZC(t, i, g), d.refresh(s), p.dispatchEvent({
      type: "columnEverythingChanged",
      source: s
    }), T(), { unmatchedAndAutoStates: H, unmatchedCount: W };
  };
  l == null || l.start();
  let { unmatchedAndAutoStates: v, unmatchedCount: b } = C(
    t.state || [],
    f,
    (F) => i.getColDefCol(F)
  );
  if (v.length > 0 || A(t.defaultState)) {
    const F = ((y = c == null ? void 0 : c.getPivotResultCols()) == null ? void 0 : y.list) ?? [];
    b = C(
      v,
      F,
      (D) => (c == null ? void 0 : c.getPivotResultCol(D)) ?? null
    ).unmatchedCount;
  }
  return l == null || l.finish(), b === 0;
}
function ru(e, t) {
  const { colModel: s, autoColSvc: i } = e, r = s.getColDefCols();
  if (!(r != null && r.length))
    return;
  const o = s.getColDefColTree(), n = cl(o), a = [];
  let l = 1e3, d = 1e3, c = [];
  const h = i == null ? void 0 : i.getAutoCols();
  h && (c = c.concat(h)), n && (c = c.concat(n)), c.forEach((u) => {
    const p = nu(u);
    Y(p.rowGroupIndex) && p.rowGroup && (p.rowGroupIndex = l++), Y(p.pivotIndex) && p.pivot && (p.pivotIndex = d++), a.push(p);
  }), Xe(e, { state: a, applyOrder: !0 }, t);
}
function ou(e, t) {
  const { rowGroupColsSvc: s, pivotColsSvc: i, valueColsSvc: r, colModel: o, sortSvc: n, eventSvc: a } = e, l = {
    rowGroupColumns: (s == null ? void 0 : s.columns.slice()) ?? [],
    pivotColumns: (i == null ? void 0 : i.columns.slice()) ?? [],
    valueColumns: (r == null ? void 0 : r.columns.slice()) ?? []
  }, d = pr(e), c = {};
  return d.forEach((h) => {
    c[h.colId] = h;
  }), () => {
    const h = o.getAllCols(), u = (x, T, I, E) => {
      const M = T.map(E), N = I.map(E);
      if (Re(M, N))
        return;
      const H = new Set(T);
      I.forEach((K) => {
        H.delete(K) || H.add(K);
      });
      const W = [...H];
      a.dispatchEvent({
        type: x,
        columns: W,
        column: W.length === 1 ? W[0] : null,
        source: t
      });
    }, p = (x) => {
      const T = [];
      return h.forEach((I) => {
        const E = c[I.getColId()];
        E && x(E, I) && T.push(I);
      }), T;
    }, g = (x) => x.getColId();
    u(
      "columnRowGroupChanged",
      l.rowGroupColumns,
      (s == null ? void 0 : s.columns) ?? [],
      g
    ), u(
      "columnPivotChanged",
      l.pivotColumns,
      (i == null ? void 0 : i.columns) ?? [],
      g
    );
    const m = p((x, T) => {
      const I = x.aggFunc != null, E = I != T.isValueActive(), M = I && x.aggFunc != T.getAggFunc();
      return E || M;
    });
    m.length > 0 && iu(a, "columnValueChanged", m, t), Pi(a, p((x, T) => x.width != T.getActualWidth()), !0, t), su(a, p((x, T) => x.pinned != T.getPinned()), t), XC(a, p((x, T) => x.hide == T.isVisible()), t);
    const F = p((x, T) => x.sort != T.getSort() || x.sortIndex != T.getSortIndex());
    F.length > 0 && (n == null || n.dispatchSortChangedEvents(t, F));
    const D = pr(e);
    JC(d, D, t, o, a);
  };
}
function pr(e) {
  const { colModel: t, rowGroupColsSvc: s, pivotColsSvc: i } = e, r = t.getColDefCols();
  if (Y(r) || !t.isAlive())
    return [];
  const o = t.getAllCols(), n = s == null ? void 0 : s.columns, a = i == null ? void 0 : i.columns, l = (h) => {
    const u = h.isRowGroupActive() && n ? n.indexOf(h) : null, p = h.isPivotActive() && a ? a.indexOf(h) : null, g = h.isValueActive() ? h.getAggFunc() : null, f = h.getSort() != null ? h.getSort() : null, m = h.getSortIndex() != null ? h.getSortIndex() : null;
    return {
      colId: h.getColId(),
      width: h.getActualWidth(),
      hide: !h.isVisible(),
      pinned: h.getPinned(),
      sort: f,
      sortIndex: m,
      aggFunc: g,
      rowGroup: h.isRowGroupActive(),
      rowGroupIndex: u,
      pivot: h.isPivotActive(),
      pivotIndex: p,
      flex: h.getFlex() ?? null
    };
  }, d = o.map((h) => l(h)), c = new Map(
    t.getCols().map((h, u) => [h.getColId(), u])
  );
  return d.sort((h, u) => {
    const p = c.has(h.colId) ? c.get(h.colId) : -1, g = c.has(u.colId) ? c.get(u.colId) : -1;
    return p - g;
  }), d;
}
function nu(e) {
  const t = (g, f) => g ?? f ?? null, s = e.getColDef(), i = t(s.sort, s.initialSort), r = t(s.sortIndex, s.initialSortIndex), o = t(s.hide, s.initialHide), n = t(s.pinned, s.initialPinned), a = t(s.width, s.initialWidth), l = t(s.flex, s.initialFlex);
  let d = t(s.rowGroupIndex, s.initialRowGroupIndex), c = t(s.rowGroup, s.initialRowGroup);
  d == null && (c == null || c == !1) && (d = null, c = null);
  let h = t(s.pivotIndex, s.initialPivotIndex), u = t(s.pivot, s.initialPivot);
  h == null && (u == null || u == !1) && (h = null, u = null);
  const p = t(s.aggFunc, s.initialAggFunc);
  return {
    colId: e.getColId(),
    sort: i,
    sortIndex: r,
    hide: o,
    pinned: n,
    width: a,
    flex: l,
    rowGroup: c,
    rowGroupIndex: d,
    pivot: u,
    pivotIndex: h,
    aggFunc: p
  };
}
function ZC(e, t, s) {
  if (!e.applyOrder || !e.state)
    return;
  const i = [];
  e.state.forEach((r) => {
    r.colId != null && i.push(r.colId);
  }), QC(t.cols, i, t, s);
}
function QC(e, t, s, i) {
  if (e == null)
    return;
  let r = [];
  const o = {};
  t.forEach((a) => {
    if (o[a])
      return;
    const l = e.map[a];
    l && (r.push(l), o[a] = !0);
  });
  let n = 0;
  if (e.list.forEach((a) => {
    const l = a.getColId();
    if (o[l] != null)
      return;
    l.startsWith(Ss) ? r.splice(n++, 0, a) : r.push(a);
  }), r = Jh(r, i), !eu(r, s.getColTree())) {
    R(39);
    return;
  }
  e.list = r;
}
function JC(e, t, s, i, r) {
  const o = {};
  t.forEach((c) => o[c.colId] = c);
  const n = {};
  e.forEach((c) => {
    o[c.colId] && (n[c.colId] = !0);
  });
  const a = e.filter((c) => n[c.colId]), l = t.filter((c) => n[c.colId]), d = [];
  l.forEach((c, h) => {
    const u = a && a[h];
    if (u && u.colId !== c.colId) {
      const p = i.getCol(u.colId);
      p && d.push(p);
    }
  }), d.length && r.dispatchEvent({
    type: "columnMoved",
    columns: d,
    column: d.length === 1 ? d[0] : null,
    finished: !0,
    source: s
  });
}
var Id = (e, t, s, i) => {
  const r = e[s.getId()], o = e[i.getId()], n = r != null, a = o != null;
  if (n && a)
    return r - o;
  if (n)
    return -1;
  if (a)
    return 1;
  const l = t.indexOf(s), d = t.indexOf(i), c = l >= 0, h = d >= 0;
  return c && h ? l - d : c ? -1 : 1;
}, au = "ag-Grid-SelectionColumn", ev = class extends P {
  constructor() {
    super(...arguments), this.beanName = "selectionColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener("rowSelection", (e) => {
      this.onSelectionOptionsChanged(
        e.currentValue,
        e.previousValue,
        Ws(e.source)
      );
    });
  }
  addSelectionCols(e) {
    const t = this.selectionCols;
    t != null && (e.list = t.list.concat(e.list), e.tree = t.tree.concat(e.tree), hu(e));
  }
  createSelectionCols(e, t) {
    var u, p;
    const s = () => {
      var g;
      xs(this.beans, (g = this.selectionCols) == null ? void 0 : g.tree), this.selectionCols = null;
    }, i = e.treeDepth, o = (((u = this.selectionCols) == null ? void 0 : u.treeDepth) ?? -1) == i, n = this.generateSelectionCols();
    if (cu(n, ((p = this.selectionCols) == null ? void 0 : p.list) ?? []) && o)
      return;
    s();
    const { colGroupSvc: l } = this.beans, d = (l == null ? void 0 : l.findDepth(e.tree)) ?? 0, c = (l == null ? void 0 : l.balanceTreeForAutoCols(n, d)) ?? [];
    this.selectionCols = {
      list: n,
      tree: c,
      treeDepth: d,
      map: {}
    }, t((g) => {
      if (!g)
        return null;
      const f = g.filter((m) => !Ot(m));
      return [...n, ...f];
    });
  }
  isSelectionColumnEnabled() {
    var n, a;
    const { gos: e, beans: t } = this, s = e.get("rowSelection");
    if (typeof s != "object" || !ot(e))
      return !1;
    const i = (((a = (n = t.autoColSvc) == null ? void 0 : n.getAutoCols()) == null ? void 0 : a.length) ?? 0) > 0;
    if (s.checkboxLocation === "autoGroupColumn" && i)
      return !1;
    const r = !!zs(s), o = eo(s);
    return r || o;
  }
  generateSelectionCols() {
    if (!this.isSelectionColumnEnabled())
      return [];
    const { gos: e, validation: t } = this.beans, s = e.get("selectionColumnDef"), r = {
      // overridable properties
      width: 50,
      resizable: !1,
      suppressHeaderMenuButton: !0,
      sortable: !1,
      suppressMovable: !0,
      lockPosition: e.get("enableRtl") ? "right" : "left",
      comparator(a, l, d, c) {
        const h = d.isSelected(), u = c.isSelected();
        return h === u ? 0 : h ? 1 : -1;
      },
      editable: !1,
      suppressFillHandle: !0,
      // overrides
      ...s,
      // non-overridable properties
      colId: au
    }, o = r.colId;
    t == null || t.validateColDef(r, o, !0);
    const n = new Jo(r, null, o, !1);
    return this.createBean(n), [n];
  }
  putSelectionColsFirstInList(e, t) {
    if (!t)
      return null;
    const s = t.filter((i) => !Ot(i));
    return [...e, ...s];
  }
  getSelectionCol(e) {
    var t;
    return ((t = this.selectionCols) == null ? void 0 : t.list.find((s) => hl(s, e))) ?? null;
  }
  getSelectionCols() {
    var e;
    return ((e = this.selectionCols) == null ? void 0 : e.list) ?? null;
  }
  onSelectionOptionsChanged(e, t, s) {
    const i = t && typeof t != "string" ? zs(t) : void 0, r = e && typeof e != "string" ? zs(e) : void 0, o = i !== r, n = t && typeof t != "string" ? eo(t) : void 0, a = e && typeof e != "string" ? eo(e) : void 0, l = n !== a, d = vo(e), c = vo(t);
    (o || l || d !== c) && this.beans.colModel.refreshAll(s);
  }
  destroy() {
    var e;
    xs(this.beans, (e = this.selectionCols) == null ? void 0 : e.tree), super.destroy();
  }
  refreshVisibility(e) {
    if (!this.isSelectionColumnEnabled())
      return;
    const t = this.beans, s = t.visibleCols.getAllTrees() ?? [];
    if (s.length !== 0) {
      if (!s.some(lu)) {
        const i = pr(t).find((r) => Ot(r.colId));
        i && Xe(
          t,
          {
            state: [{ colId: i.colId, hide: !i.hide }]
          },
          e
        );
      }
      if (s.length === 1) {
        const i = s[0], r = du(i);
        if (!r)
          return;
        Xe(t, { state: [{ colId: r.getColId(), hide: !0 }] }, e);
      }
    }
  }
}, lu = (e) => {
  var t;
  return e.isColumn ? Ot(e) : ((t = e.getChildren()) == null ? void 0 : t.some(lu)) ?? !1;
};
function du(e) {
  if (e.isColumn)
    return Ot(e) ? e : null;
  const t = e.getChildren() ?? [];
  for (const s of t) {
    const i = du(s);
    if (i)
      return i;
  }
  return null;
}
var Ss = "ag-Grid-AutoColumn";
function cl(e) {
  const t = [], s = (i) => {
    for (let r = 0; r < i.length; r++) {
      const o = i[r];
      Bt(o) ? t.push(o) : ae(o) && s(o.getChildren());
    }
  };
  return s(e), t;
}
function _t(e) {
  return e.reduce((t, s) => t + s.getActualWidth(), 0);
}
function xs(e, t, s) {
  const i = {};
  if (!t)
    return;
  jt(null, t, (o) => {
    i[o.getInstanceId()] = o;
  }), s && jt(null, s, (o) => {
    i[o.getInstanceId()] = null;
  });
  const r = Object.values(i).filter((o) => o != null);
  e.context.destroyBeans(r);
}
function en(e) {
  return e.getId().startsWith(Ss);
}
function Ot(e) {
  const t = typeof e == "string" ? e : "getColId" in e ? e.getColId() : e.colId;
  return (t == null ? void 0 : t.startsWith(au)) ?? !1;
}
function yo(e) {
  let t = [];
  return e instanceof Array ? t = e : typeof e == "string" && (t = e.split(",")), t;
}
function cu(e, t) {
  return Re(e, t, (s, i) => s.getColId() === i.getColId());
}
function hu(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function Ws(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function hl(e, t) {
  const s = e === t, i = e.getColDef() === t, r = e.getColId() == t;
  return s || i || r;
}
var tv = (e, t) => (s, i) => {
  const r = {
    value1: void 0,
    value2: void 0
  };
  let o = !1;
  return e && (e[s] !== void 0 && (r.value1 = e[s], o = !0), A(i) && e[i] !== void 0 && (r.value2 = e[i], o = !0)), !o && t && (t[s] !== void 0 && (r.value1 = t[s]), A(i) && t[i] !== void 0 && (r.value2 = t[i])), r;
};
function uu(e, t = null, s, i, r) {
  const o = new qC(), { existingCols: n, existingGroups: a, existingColKeys: l } = sv(i);
  o.addExistingKeys(l);
  const d = pu(
    e,
    t,
    0,
    s,
    n,
    o,
    a,
    r
  ), { colGroupSvc: c } = e, h = (c == null ? void 0 : c.findMaxDepth(d, 0)) ?? 0, u = c ? c.balanceColumnTree(d, 0, h, o) : d;
  return jt(null, u, (g, f) => {
    ae(g) && g.setupExpandable(), g.originalParent = f;
  }), {
    columnTree: u,
    treeDept: h
  };
}
function sv(e) {
  const t = [], s = [], i = [];
  return e && jt(null, e, (r) => {
    if (ae(r)) {
      const o = r;
      s.push(o);
    } else {
      const o = r;
      i.push(o.getId()), t.push(o);
    }
  }), { existingCols: t, existingGroups: s, existingColKeys: i };
}
function pu(e, t, s, i, r, o, n, a) {
  if (!t)
    return [];
  const { colGroupSvc: l } = e, d = new Array(t.length);
  for (let c = 0; c < d.length; c++) {
    const h = t[c];
    l && av(h) ? d[c] = l.createProvidedColumnGroup(
      i,
      h,
      s,
      r,
      o,
      n,
      a
    ) : d[c] = iv(e, i, h, r, o, a);
  }
  return d;
}
function iv(e, t, s, i, r, o) {
  var l;
  const n = rv(s, i);
  n && (i == null || i.splice(n.idx, 1));
  let a = n == null ? void 0 : n.column;
  if (a) {
    const d = bo(e, s, a.getColId());
    a.setColDef(d, s, o), fu(e, a, d, o);
  } else {
    const d = r.getUniqueKey(s.colId, s.field), c = bo(e, s, d);
    a = new Jo(c, s, d, t), e.context.createBean(a);
  }
  return (l = e.dataTypeSvc) == null || l.addColumnListeners(a), a;
}
function gu(e, t, s, i, r, o, n, a) {
  const { sortSvc: l, pinnedCols: d, colFlex: c } = e;
  s !== void 0 && t.setVisible(!s, a), l && (l.updateColSort(t, i, a), r !== void 0 && l.setColSortIndex(t, r)), o !== void 0 && (d == null || d.setColPinned(t, o)), n !== void 0 && (c == null || c.setColFlex(t, n));
}
function fu(e, t, s, i) {
  gu(
    e,
    t,
    s.hide,
    s.sort,
    s.sortIndex,
    s.pinned,
    s.flex,
    i
  );
  const r = t.getFlex();
  if (!(r != null && r > 0))
    if (s.width != null)
      t.setActualWidth(s.width, i);
    else {
      const o = t.getActualWidth();
      t.setActualWidth(o, i);
    }
}
function rv(e, t) {
  if (t)
    for (let s = 0; s < t.length; s++) {
      const i = t[s].getUserProvidedColDef();
      if (!i)
        continue;
      if (e.colId != null) {
        if (t[s].getId() === e.colId)
          return { idx: s, column: t[s] };
        continue;
      }
      if (e.field != null) {
        if (i.field === e.field)
          return { idx: s, column: t[s] };
        continue;
      }
      if (i === e)
        return { idx: s, column: t[s] };
    }
}
function bo(e, t, s, i) {
  const { gos: r, dataTypeSvc: o, validation: n } = e, a = {}, l = r.get("defaultColDef");
  pe(a, l, !1, !0);
  const d = ov(e, a, t, s);
  d && nv(e, d, a), pe(a, t, !1, !0);
  const c = r.get("autoGroupColumnDef"), h = wt(r);
  return t.rowGroup && c && h && pe(
    a,
    { sort: c.sort, initialSort: c.initialSort },
    !1,
    !0
  ), o == null || o.validateColDef(a), n == null || n.validateColDef(a, s, i), a;
}
function ov(e, t, s, i) {
  var n;
  const r = (n = e.dataTypeSvc) == null ? void 0 : n.updateColDefAndGetColumnType(t, s, i), o = s.type ?? r ?? t.type;
  return t.type = o, o ? yo(o) : void 0;
}
function nv(e, t, s) {
  if (!t.length)
    return;
  const i = Object.assign({}, jC), r = e.gos.get("columnTypes") || {};
  for (const [o, n] of Object.entries(r))
    o in i ? R(34, { key: o }) : (n.type && R(35), i[o] = n);
  t.forEach((o) => {
    const n = i[o.trim()];
    n ? pe(s, n, !1, !0) : R(36, { t: o });
  });
}
function av(e) {
  return e.children !== void 0;
}
function jt(e, t, s) {
  if (t)
    for (let i = 0; i < t.length; i++) {
      const r = t[i];
      ae(r) && jt(r, r.getChildren(), s), s(r, e);
    }
}
var lv = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colModel", this.pivotMode = !1, this.ready = !1, this.changeEventsDispatching = !1;
  }
  postConstruct() {
    this.pivotMode = this.gos.get("pivotMode"), this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (e) => this.refreshAll(Ws(e.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      (e) => this.recreateColumnDefs(Ws(e.source))
    ), this.addManagedPropertyListener(
      "pivotMode",
      (e) => this.setPivotMode(this.gos.get("pivotMode"), Ws(e.source))
    );
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e) {
    var v, b, y;
    const { beans: t } = this, {
      valueCache: s,
      colAutosize: i,
      rowGroupColsSvc: r,
      pivotColsSvc: o,
      valueColsSvc: n,
      visibleCols: a,
      colViewport: l,
      eventSvc: d
    } = t, c = this.colDefs ? ou(t, e) : void 0;
    s == null || s.expire();
    const h = (v = this.colDefCols) == null ? void 0 : v.list, u = (b = this.colDefCols) == null ? void 0 : b.tree, p = uu(t, this.colDefs, !0, u, e);
    xs(t, (y = this.colDefCols) == null ? void 0 : y.tree, p.columnTree);
    const g = p.columnTree, f = p.treeDept, m = cl(g), C = {};
    m.forEach((F) => C[F.getId()] = F), this.colDefCols = { tree: g, treeDepth: f, list: m, map: C }, r == null || r.extractCols(e, h), o == null || o.extractCols(e, h), n == null || n.extractCols(e, h), this.ready = !0, this.refreshCols(!0), a.refresh(e), l.checkViewportColumns(), d.dispatchEvent({
      type: "columnEverythingChanged",
      source: e
    }), c && (this.changeEventsDispatching = !0, c(), this.changeEventsDispatching = !1), d.dispatchEvent({
      type: "newColumnsLoaded",
      source: e
    }), e === "gridInitializing" && (i == null || i.applyAutosizeStrategy());
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultCols.setPivotResultCols
  refreshCols(e) {
    var g;
    if (!this.colDefCols)
      return;
    const t = (g = this.cols) == null ? void 0 : g.tree;
    this.saveColOrder();
    const {
      autoColSvc: s,
      selectionColSvc: i,
      quickFilter: r,
      pivotResultCols: o,
      showRowGroupCols: n,
      rowAutoHeight: a,
      visibleCols: l,
      colViewport: d,
      eventSvc: c
    } = this.beans, h = this.selectCols(o, this.colDefCols);
    s == null || s.createAutoCols(h, (f) => {
      this.lastOrder = f(this.lastOrder), this.lastPivotOrder = f(this.lastPivotOrder);
    }), s == null || s.addAutoCols(h), i == null || i.createSelectionCols(h, (f) => {
      this.lastOrder = f(this.lastOrder) ?? null, this.lastPivotOrder = f(this.lastPivotOrder) ?? null;
    }), i == null || i.addSelectionCols(h);
    const u = EC(this.gos, this.showingPivotResult);
    (!e || u) && this.restoreColOrder(h), this.positionLockedCols(h), n == null || n.refresh(), r == null || r.refreshCols(), this.setColSpanActive(), a == null || a.setAutoHeightActive(h), l.clear(), d.clear(), !Re(t, this.cols.tree) && c.dispatchEvent({
      type: "gridColumnsChanged"
    });
  }
  selectCols(e, t) {
    const s = (e == null ? void 0 : e.getPivotResultCols()) ?? null;
    this.showingPivotResult = s != null;
    const { map: i, list: r, tree: o, treeDepth: n } = s ?? t;
    return this.cols = {
      list: r.slice(),
      map: { ...i },
      tree: o.slice(),
      treeDepth: n
    }, s && (s.list.some((l) => {
      var d;
      return ((d = this.cols) == null ? void 0 : d.map[l.getColId()]) !== void 0;
    }) || (this.lastPivotOrder = null)), this.cols;
  }
  getColsToShow() {
    var i;
    if (!this.cols)
      return [];
    const e = this.isPivotMode() && !this.showingPivotResult, t = (i = this.beans.valueColsSvc) == null ? void 0 : i.columns;
    return this.cols.list.filter((r) => {
      const o = en(r);
      if (e) {
        const n = t == null ? void 0 : t.includes(r);
        return o || n;
      } else
        return o || r.isVisible();
    });
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.ready && (this.refreshCols(!1), this.beans.visibleCols.refresh(e));
  }
  setColsVisible(e, t = !1, s) {
    Xe(
      this.beans,
      {
        state: e.map((i) => ({
          colId: typeof i == "string" ? i : i.getColId(),
          hide: !t
        }))
      },
      s
    );
  }
  restoreColOrder(e) {
    const t = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!t)
      return;
    const s = new Map(t.map((d, c) => [d, c]));
    if (!e.list.some((d) => s.has(d)))
      return;
    const r = new Map(e.list.map((d) => [d, !0])), o = t.filter((d) => r.has(d)), n = new Map(o.map((d) => [d, !0])), a = e.list.filter((d) => !n.has(d)), l = o.slice();
    a.forEach((d) => {
      let c = d.getOriginalParent();
      if (!c) {
        l.push(d);
        return;
      }
      const h = [];
      for (; !h.length && c; )
        c.getLeafColumns().forEach((f) => {
          const m = l.indexOf(f) >= 0, C = h.indexOf(f) < 0;
          m && C && h.push(f);
        }), c = c.getOriginalParent();
      if (!h.length) {
        l.push(d);
        return;
      }
      const u = h.map((g) => l.indexOf(g)), p = Math.max(...u);
      l.splice(p + 1, 0, d);
    }), e.list = l;
  }
  positionLockedCols(e) {
    e.list = Jh(e.list, this.gos);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = ((e = this.cols) == null ? void 0 : e.list) ?? null : this.lastOrder = ((t = this.cols) == null ? void 0 : t.list) ?? null;
  }
  getColumnDefs() {
    var e, t;
    return this.colDefCols ? (t = this.beans.colDefFactory) == null ? void 0 : t.getColumnDefs(
      this.colDefCols.list,
      this.showingPivotResult,
      this.lastOrder,
      ((e = this.cols) == null ? void 0 : e.list) ?? []
    ) : void 0;
  }
  setColSpanActive() {
    var e;
    this.colSpanActive = !!((e = this.cols) != null && e.list.some((t) => t.getColDef().colSpan != null));
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    if (e === this.pivotMode || (this.pivotMode = e, !this.ready))
      return;
    this.refreshCols(!1);
    const { visibleCols: s, eventSvc: i } = this.beans;
    s.refresh(t), i.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  // + clientSideRowModel
  isPivotActive() {
    var t;
    const e = (t = this.beans.pivotColsSvc) == null ? void 0 : t.columns;
    return this.pivotMode && !!(e != null && e.length);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    var t;
    this.cols && ((t = this.beans.autoColSvc) == null || t.updateAutoCols(e), this.createColsFromColDefs(e));
  }
  setColumnDefs(e, t) {
    this.colDefs = e, this.createColsFromColDefs(t);
  }
  destroy() {
    var e;
    xs(this.beans, (e = this.colDefCols) == null ? void 0 : e.tree), super.destroy();
  }
  getColTree() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.tree) ?? [];
  }
  // + columnSelectPanel
  getColDefColTree() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.tree) ?? [];
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.list) ?? null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  // returns colDefCols, pivotResultCols and autoCols
  getAllCols() {
    var r, o, n, a;
    const { pivotResultCols: e, autoColSvc: t, selectionColSvc: s } = this.beans, i = (r = e == null ? void 0 : e.getPivotResultCols()) == null ? void 0 : r.list;
    return [
      ((o = this.colDefCols) == null ? void 0 : o.list) ?? [],
      ((n = t == null ? void 0 : t.autoCols) == null ? void 0 : n.list) ?? [],
      ((a = s == null ? void 0 : s.selectionCols) == null ? void 0 : a.list) ?? [],
      i ?? []
    ].flat();
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  getColFromCollection(e, t) {
    var r;
    if (t == null)
      return null;
    const { map: s, list: i } = t;
    if (typeof e == "string" && s[e])
      return s[e];
    for (let o = 0; o < i.length; o++)
      if (hl(i[o], e))
        return i[o];
    return ((r = this.beans.autoColSvc) == null ? void 0 : r.getAutoCol(e)) ?? null;
  }
}, ul = class extends P {
  constructor() {
    super(...arguments), this.dispatchColumnChangedEvent = iu, this.columns = [];
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.aggFuncSvc = e.aggFuncSvc, this.visibleCols = e.visibleCols;
  }
  sortColumns(e) {
    this.columns.sort(e);
  }
  setColumns(e, t) {
    this.setColList(e, this.columns, this.eventName, !0, !0, this.columnProcessors.set, t);
  }
  addColumns(e, t) {
    this.updateColList(e, this.columns, !0, !0, this.columnProcessors.add, this.eventName, t);
  }
  removeColumns(e, t) {
    this.updateColList(e, this.columns, !1, !0, this.columnProcessors.remove, this.eventName, t);
  }
  setColList(e = [], t, s, i, r, o, n) {
    const a = this.colModel.getCols();
    if (!a || a.length === 0)
      return;
    const l = /* @__PURE__ */ new Map();
    t.forEach((c, h) => l.set(c, h)), t.length = 0, A(e) && e.forEach((c) => {
      const h = this.colModel.getColDefCol(c);
      h && t.push(h);
    }), t.forEach((c, h) => {
      const u = l.get(c);
      if (u === void 0) {
        l.set(c, 0);
        return;
      }
      i && u !== h || l.delete(c);
    }), (this.colModel.getColDefCols() || []).forEach((c) => {
      const h = t.indexOf(c) >= 0;
      o(c, h, n);
    }), r && this.colModel.refreshCols(!1), this.visibleCols.refresh(n), this.dispatchColumnChangedEvent(this.eventSvc, s, [...l.keys()], n);
  }
  updateColList(e = [], t, s, i, r, o, n) {
    if (!e || e.length === 0)
      return;
    let a = !1;
    const l = /* @__PURE__ */ new Set();
    if (e.forEach((c) => {
      if (!c)
        return;
      const h = this.colModel.getColDefCol(c);
      if (h) {
        if (l.add(h), s) {
          if (t.indexOf(h) >= 0)
            return;
          t.push(h);
        } else {
          const u = t.indexOf(h);
          if (u < 0)
            return;
          for (let p = u + 1; p < t.length; p++)
            l.add(t[p]);
          be(t, h);
        }
        r(h, s, n), a = !0;
      }
    }), !a)
      return;
    i && this.colModel.refreshCols(!1), this.visibleCols.refresh(n);
    const d = Array.from(l);
    this.eventSvc.dispatchEvent({
      type: o,
      columns: d,
      column: d.length === 1 ? d[0] : null,
      source: n
    });
  }
  extractCols(e, t = []) {
    const s = this.columns, i = [], r = [], { setFlagFunc: o, getIndexFunc: n, getInitialIndexFunc: a, getValueFunc: l, getInitialValueFunc: d } = this.columnExtractors;
    (this.colModel.getColDefCols() || []).forEach((p) => {
      const g = t.indexOf(p) < 0, f = p.getColDef(), m = l(f), C = d(f), v = n(f), b = a(f);
      let y;
      m !== void 0 ? y = m : v !== void 0 ? v === null ? y = !1 : y = v >= 0 : g ? C !== void 0 ? y = C : b !== void 0 ? y = b != null && b >= 0 : y = !1 : y = s.indexOf(p) >= 0, y && ((g ? v != null || b != null : v != null) ? i.push(p) : r.push(p));
    });
    const h = (p) => {
      const g = n(p.getColDef()), f = a(p.getColDef());
      return g ?? f;
    };
    i.sort((p, g) => {
      const f = h(p), m = h(g);
      return f === m ? 0 : f < m ? -1 : 1;
    });
    const u = [].concat(i);
    return s.forEach((p) => {
      r.indexOf(p) >= 0 && u.push(p);
    }), r.forEach((p) => {
      u.indexOf(p) < 0 && u.push(p);
    }), s.forEach((p) => {
      u.indexOf(p) < 0 && o(p, !1, e);
    }), u.forEach((p) => {
      s.indexOf(p) < 0 && o(p, !0, e);
    }), this.columns = u;
  }
  restoreColumnOrder(e, t) {
    const s = this.columns, i = this.colModel.getColDefCols();
    if (!s.length || !i)
      return e;
    const r = Object.keys(t), o = new Set(r), n = new Set(r), a = new Set(
      s.map((b) => {
        const y = b.getColId();
        return n.delete(y), y;
      }).concat(r)
    ), l = [], d = {};
    let c = 0;
    for (let b = 0; b < i.length; b++) {
      const y = i[b].getColId();
      a.has(y) && (l.push(y), d[y] = c++);
    }
    let h = 1e3, u = !1, p = 0;
    const g = this.columnOrdering.enableProp, f = this.columnOrdering.initialEnableProp, m = this.columnOrdering.indexProp, C = this.columnOrdering.initialIndexProp, v = (b) => {
      const y = d[b];
      for (let F = p; F < y; F++) {
        const D = l[F];
        n.has(D) && (t[D][m] = h++, n.delete(D));
      }
      p = y;
    };
    return s.forEach((b) => {
      const y = b.getColId();
      if (o.has(y))
        v(y), t[y][m] = h++;
      else {
        const F = b.getColDef();
        (F[m] === null || F[m] === void 0 && F[C] == null) && (u || (F[g] || F[g] === void 0 && F[f] ? v(y) : (n.forEach((T) => {
          t[T][m] = h + d[T];
        }), h += l.length, u = !0)), e[y] || (e[y] = { colId: y }), e[y][m] = h++);
      }
    }), e;
  }
}, mu = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let s;
    return typeof t != "number" ? s = 0 : s = t + 1, this.existingIds[e] = s, s;
  }
};
function xr(e, t, s) {
  return s && e.addDestroyFunc(() => t.destroyBean(s)), s ?? e;
}
var dv = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    this.addOrRemoveCssClass(e, !0);
  }
  removeCssClass(e) {
    this.addOrRemoveCssClass(e, !1);
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const i = (e || "").split(" ");
      if (i.length > 1) {
        i.forEach((r) => this.addOrRemoveCssClass(r, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const i = this.getGui();
      i && i.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
}, cv = 0, S = null, L = class extends P {
  constructor(e, t) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = cv++, this.cssClassManager = new dv(() => this.eGui), this.componentSelectors = new Map((t ?? []).map((s) => [s.selector, s])), e && this.setTemplate(e);
  }
  preConstruct() {
    var t, s, i;
    this.wireTemplate(this.getGui());
    const e = "component-" + ((s = (t = Object.getPrototypeOf(this)) == null ? void 0 : t.constructor) == null ? void 0 : s.name);
    (i = this.css) == null || i.forEach((r) => this.beans.environment.addGlobalCSS(r, e));
  }
  wireTemplate(e, t) {
    e && this.gos && (this.applyElementsToComponent(e), this.createChildComponentsFromTags(e, t));
  }
  getCompId() {
    return this.compId;
  }
  getDataRefAttribute(e) {
    return e.getAttribute ? e.getAttribute("data-ref") : null;
  }
  applyElementsToComponent(e, t, s, i = null) {
    if (t === void 0 && (t = this.getDataRefAttribute(e)), t) {
      const r = this[t];
      if (r === S)
        this[t] = i ?? e;
      else {
        const o = s && s[t];
        if (!this.suppressDataRefValidation && !o)
          throw new Error(`data-ref: ${t} on ${this.constructor.name} with ${r}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(e, t) {
    bC(e.childNodes).forEach((i) => {
      if (!(i instanceof HTMLElement))
        return;
      const r = this.createComponentFromElement(
        i,
        (o) => {
          o.getGui() && this.copyAttributesFromNode(i, o.getGui());
        },
        t
      );
      if (r) {
        if (r.addItems && i.children.length) {
          this.createChildComponentsFromTags(i, t);
          const o = Array.prototype.slice.call(i.children);
          r.addItems(o);
        }
        this.swapComponentForNode(r, e, i);
      } else i.childNodes && this.createChildComponentsFromTags(i, t);
    });
  }
  createComponentFromElement(e, t, s) {
    const i = e.nodeName, r = this.getDataRefAttribute(e), o = i.indexOf("AG-") === 0, n = o ? this.componentSelectors.get(i) : null;
    let a = null;
    if (n) {
      const l = s && r ? s[r] : void 0;
      a = new n.component(l), a.setParentComponent(this), this.createBean(a, null, t);
    } else if (o)
      throw new Error(`selector: ${i}`);
    return this.applyElementsToComponent(e, r, s, a), a;
  }
  copyAttributesFromNode(e, t) {
    SC(e.attributes, (s, i) => t.setAttribute(s, i));
  }
  swapComponentForNode(e, t, s) {
    const i = e.getGui();
    t.replaceChild(i, s), t.insertBefore(document.createComment(s.nodeName), i), this.addDestroyFunc(this.destroyBean.bind(this, e));
  }
  activateTabIndex(e) {
    const t = this.gos.get("tabIndex");
    e || (e = []), e.length || e.push(this.getGui()), e.forEach((s) => s.setAttribute("tabindex", t.toString()));
  }
  setTemplate(e, t, s) {
    const i = Be(e);
    this.setTemplateFromElement(i, t, s);
  }
  setTemplateFromElement(e, t, s, i = !1) {
    if (this.eGui = e, this.suppressDataRefValidation = i, t)
      for (let r = 0; r < t.length; r++) {
        const o = t[r];
        this.componentSelectors.set(o.selector, o);
      }
    this.wireTemplate(e, s);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(e) {
    this.eGui = e;
  }
  queryForHtmlElement(e) {
    return this.eGui.querySelector(e);
  }
  getContainerAndElement(e, t) {
    let s = t;
    return e == null ? null : (s || (s = this.eGui), qo(e) ? {
      element: e,
      parent: s
    } : {
      element: e.getGui(),
      parent: s
    });
  }
  prependChild(e, t) {
    const { element: s, parent: i } = this.getContainerAndElement(e, t) || {};
    !s || !i || i.insertAdjacentElement("afterbegin", s);
  }
  appendChild(e, t) {
    const { element: s, parent: i } = this.getContainerAndElement(e, t) || {};
    !s || !i || i.appendChild(s);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(e, t = {}) {
    if (e !== this.visible) {
      this.visible = e;
      const { skipAriaHidden: s } = t;
      Rh(this.eGui, e, { skipAriaHidden: s });
    }
  }
  setDisplayed(e, t = {}) {
    if (e !== this.displayed) {
      this.displayed = e;
      const { skipAriaHidden: s } = t;
      O(this.eGui, e, { skipAriaHidden: s });
      const i = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(i);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), super.destroy();
  }
  addGuiEventListener(e, t, s) {
    this.eGui.addEventListener(e, t, s), this.addDestroyFunc(() => this.eGui.removeEventListener(e, t));
  }
  addCssClass(e) {
    this.cssClassManager.addCssClass(e);
  }
  removeCssClass(e) {
    this.cssClassManager.removeCssClass(e);
  }
  containsCssClass(e) {
    return this.cssClassManager.containsCssClass(e);
  }
  addOrRemoveCssClass(e, t) {
    this.cssClassManager.addOrRemoveCssClass(e, t);
  }
  registerCSS(e) {
    this.css || (this.css = []), this.css.push(e);
  }
};
function hv(e) {
  return typeof e.then == "function";
}
var U = class qi {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (s) => this.onDone(s),
      (s) => this.onReject(s)
    );
  }
  static all(t) {
    return t.length ? new qi((s) => {
      let i = t.length;
      const r = new Array(i);
      t.forEach((o, n) => {
        o.then((a) => {
          r[n] = a, i--, i === 0 && s(r);
        });
      });
    }) : qi.resolve();
  }
  static resolve(t = null) {
    return new qi((s) => s(t));
  }
  then(t) {
    return new qi((s) => {
      this.status === 1 ? s(t(this.resolution)) : this.waiters.push((i) => s(t(i)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((s) => s(t));
  }
  onReject(t) {
  }
};
function uv(e) {
  return e ? e.prototype && "getGui" in e.prototype : !1;
}
function Cu(e, t, s, i) {
  const { name: r } = s;
  let o, n, a, l, d, c;
  if (t) {
    const h = t, u = h[r + "Selector"], p = u ? u(i) : null, g = (f) => {
      typeof f == "string" ? o = f : f != null && f !== !0 && (e.isFrameworkComponent(f) ? a = f : n = f);
    };
    p ? (g(p.component), l = p.params, d = p.popup, c = p.popupPosition) : g(h[r]);
  }
  return { compName: o, jsComp: n, fwComp: a, paramsFromSelector: l, popupFromSelector: d, popupPositionFromSelector: c };
}
var pv = class extends P {
  constructor() {
    super(...arguments), this.beanName = "userCompFactory";
  }
  wireBeans(e) {
    this.agCompUtils = e.agCompUtils, this.registry = e.registry, this.frameworkCompWrapper = e.frameworkCompWrapper, this.gridOptions = e.gridOptions;
  }
  getCompDetailsFromGridOptions(e, t, s, i = !1) {
    return this.getCompDetails(this.gridOptions, e, t, s, i);
  }
  getCompDetails(e, t, s, i, r = !1) {
    var v;
    const { name: o, cellRenderer: n } = t;
    let { compName: a, jsComp: l, fwComp: d, paramsFromSelector: c, popupFromSelector: h, popupPositionFromSelector: u } = Cu(this.beans.frameworkOverrides, e, t, i), p;
    const g = (b) => {
      const y = this.registry.getUserComponent(o, b);
      y && (l = y.componentFromFramework ? void 0 : y.component, d = y.componentFromFramework ? y.component : void 0, p = y.params);
    };
    if (a != null && g(a), l == null && d == null && s != null && g(s), l && n && !uv(l) && (l = (v = this.agCompUtils) == null ? void 0 : v.adaptFunction(t, l)), !l && !d) {
      const { validation: b } = this.beans;
      r && (a !== s || !s) ? a ? b != null && b.isProvidedUserComp(a) || z(50, { compName: a }) : s ? b || z(260, {
        ...this.gos.getModuleErrorParams(),
        propName: o,
        compName: s
      }) : z(216, { name: o }) : s && !b && z(146, { comp: s });
      return;
    }
    const f = this.mergeParams(e, t, i, c, p), m = l == null, C = l ?? d;
    return {
      componentFromFramework: m,
      componentClass: C,
      params: f,
      type: t,
      popupFromSelector: h,
      popupPositionFromSelector: u,
      newAgStackInstance: () => this.newAgStackInstance(C, m, f, t)
    };
  }
  newAgStackInstance(e, t, s, i) {
    var a;
    const r = !t;
    let o;
    r ? o = new e() : o = this.frameworkCompWrapper.wrap(
      e,
      i.mandatoryMethods,
      i.optionalMethods,
      i
    ), this.createBean(o);
    const n = (a = o.init) == null ? void 0 : a.call(o, s);
    return n == null ? U.resolve(o) : n.then(() => o);
  }
  /**
   * merges params with application provided params
   * used by Floating Filter
   */
  mergeParams(e, t, s, i = null, r) {
    const o = this.gos.getGridCommonParams();
    pe(o, s), r && pe(o, r);
    const n = e, a = n && n[t.name + "Params"];
    if (typeof a == "function") {
      const l = a(s);
      pe(o, l);
    } else typeof a == "object" && pe(o, a);
    return pe(o, i), o;
  }
}, gv = {
  name: "dateComponent",
  mandatoryMethods: ["getDate", "setDate"],
  optionalMethods: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "refresh"]
}, fv = {
  name: "dragAndDropImageComponent",
  mandatoryMethods: ["setIcon", "setLabel"]
}, mv = { name: "headerComponent", optionalMethods: ["refresh"] }, Cv = { name: "innerHeaderComponent" }, vv = { name: "innerHeaderGroupComponent" }, wv = { name: "headerGroupComponent" }, yv = {
  name: "innerRenderer",
  cellRenderer: !0,
  optionalMethods: ["afterGuiAttached"]
}, bv = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, Sv = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"]
}, xv = { name: "loadingCellRenderer", cellRenderer: !0 }, Fv = {
  name: "cellEditor",
  mandatoryMethods: ["getValue"],
  optionalMethods: [
    "isPopup",
    "isCancelBeforeStart",
    "isCancelAfterEnd",
    "getPopupPosition",
    "focusIn",
    "focusOut",
    "afterGuiAttached",
    "refresh"
  ]
}, Rv = { name: "loadingOverlayComponent", optionalMethods: ["refresh"] }, Pv = { name: "noRowsOverlayComponent", optionalMethods: ["refresh"] }, Tv = { name: "tooltipComponent" }, pl = {
  name: "filter",
  mandatoryMethods: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
  optionalMethods: [
    "afterGuiAttached",
    "afterGuiDetached",
    "onNewRowsLoaded",
    "getModelAsString",
    "onFloatingFilterChanged",
    "onAnyFilterChanged",
    "refresh"
  ]
}, Dv = {
  name: "floatingFilterComponent",
  mandatoryMethods: ["onParentModelChanged"],
  optionalMethods: ["afterGuiAttached", "refresh"]
}, Ev = {
  name: "fullWidthCellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, Mv = { name: "loadingCellRenderer", cellRenderer: !0 }, Av = {
  name: "groupRowRenderer",
  optionalMethods: ["afterGuiAttached"],
  cellRenderer: !0
}, Iv = { name: "detailCellRenderer", optionalMethods: ["refresh"], cellRenderer: !0 };
function Lv(e, t) {
  return e.getCompDetailsFromGridOptions(fv, "agDragAndDropImage", t, !0);
}
function Gn(e, t, s) {
  return e.getCompDetails(t, yv, void 0, s);
}
function kv(e, t, s) {
  return e.getCompDetails(t, mv, "agColumnHeader", s);
}
function Ov(e, t, s) {
  return e.getCompDetails(t, Cv, void 0, s);
}
function Gv(e, t) {
  const s = t.columnGroup.getColGroupDef();
  return e.getCompDetails(s, wv, "agColumnGroupHeader", t);
}
function Bv(e, t, s) {
  return e.getCompDetails(t, vv, void 0, s);
}
function Vv(e, t) {
  return e.getCompDetailsFromGridOptions(Ev, void 0, t, !0);
}
function Nv(e, t) {
  return e.getCompDetailsFromGridOptions(Mv, "agLoadingCellRenderer", t, !0);
}
function Hv(e, t) {
  return e.getCompDetailsFromGridOptions(Av, "agGroupRowRenderer", t, !0);
}
function zv(e, t) {
  return e.getCompDetailsFromGridOptions(Iv, "agDetailCellRenderer", t, !0);
}
function So(e, t, s) {
  return e.getCompDetails(t, bv, void 0, s);
}
function vu(e, t, s) {
  return e.getCompDetails(
    t,
    Sv,
    void 0,
    s
  );
}
function Wv(e, t, s) {
  return e.getCompDetails(t, xv, "agSkeletonCellRenderer", s, !0);
}
function Ld(e, t, s) {
  return e.getCompDetails(t, Fv, "agCellEditor", s, !0);
}
function wu(e, t, s, i) {
  return e.getCompDetails(t, pl, i, s, !0);
}
function _v(e, t) {
  return e.getCompDetailsFromGridOptions(gv, "agDateInput", t, !0);
}
function Uv(e, t) {
  return e.getCompDetailsFromGridOptions(Rv, "agLoadingOverlay", t, !0);
}
function Kv(e, t) {
  return e.getCompDetailsFromGridOptions(Pv, "agNoRowsOverlay", t, !0);
}
function $v(e, t) {
  return e.getCompDetails(t.colDef, Tv, "agTooltipComponent", t, !0);
}
function yu(e, t, s, i) {
  return e.getCompDetails(t, Dv, i, s);
}
function jv(e, t) {
  return Cu(e, t, pl);
}
function qv(e, t, s) {
  return e.mergeParams(t, pl, s);
}
function Ys(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var bu = /* @__PURE__ */ new Set(), xo = {}, _s = {}, to, Su = !1;
function Yv(e) {
  const [t, s] = e.version.split(".") || [], [i, r] = to.split(".") || [];
  return t === i && s === r;
}
function Xv(e) {
  to || (to = e.version);
  const t = (s) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${s} Please update all modules to the same version.`;
  if (e.version ? Yv(e) || gi(
    t(
      `'${e.moduleName}' is version ${e.version} but the other modules are version ${to}.`
    )
  ) : gi(t(`'${e.moduleName}' is incompatible.`)), e.validate) {
    const s = e.validate();
    s.isValid || gi(`${s.message}`);
  }
}
function gr(e, t) {
  Xv(e);
  const s = e.rowModels ?? ["all"];
  bu.add(e);
  let i;
  t !== void 0 ? (Su = !0, _s[t] === void 0 && (_s[t] = {}), i = _s[t]) : i = xo, s.forEach((r) => {
    i[r] === void 0 && (i[r] = {}), i[r][e.moduleName] = e;
  }), e.dependsOn && e.dependsOn.forEach((r) => gr(r, t));
}
function Zv(e) {
  delete _s[e];
}
function xu(e, t, s) {
  const i = (r) => {
    var o, n, a;
    return !!((o = xo[r]) != null && o[e]) || !!((a = (n = _s[t]) == null ? void 0 : n[r]) != null && a[e]);
  };
  return i(s) || i("all");
}
function gl() {
  return Su;
}
function Qv(e, t) {
  const s = _s[e] ?? {};
  return [
    ...Object.values(xo.all ?? {}),
    ...Object.values(s.all ?? {}),
    ...Object.values(xo[t] ?? {}),
    ...Object.values(s[t] ?? {})
  ];
}
function Jv() {
  return new Set(bu);
}
function ew(e, t) {
  const s = _s[e] ?? {};
  return [...Object.values(s.all ?? {}), ...Object.values(s[t] ?? {})];
}
var Fu = class {
  /**
   * @deprecated v33 Use `registerModules([module])` instead.
   */
  static register(e) {
    gr(e, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(e) {
    e.forEach((t) => gr(t, void 0));
  }
}, tw = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    Object.entries(e.providedBeanInstances).forEach(([s, i]) => {
      this.beans[s] = i;
    }), e.beanClasses.forEach((s) => {
      const i = new s();
      i.beanName ? this.beans[i.beanName] = i : console.error(`Bean ${s.name} is missing beanName`), this.createdBeans.push(i);
    }), (t = e.derivedBeans) == null || t.forEach((s) => {
      const { beanName: i, bean: r } = s(this);
      this.beans[i] = r, this.createdBeans.push(r);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e)
      throw Error("null bean");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((s) => {
      var i, r;
      (i = s.preWireBeans) == null || i.call(s, this.beans), (r = s.wireBeans) == null || r.call(s, this.beans);
    }), e.forEach((s) => {
      var i;
      return (i = s.preConstruct) == null ? void 0 : i.call(s);
    }), t && e.forEach(t), e.forEach((s) => {
      var i;
      return (i = s.postConstruct) == null ? void 0 : i.call(s);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, sw = class extends tw {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, this.destroyCallback = e.destroyCallback, super.init(e);
  }
  destroy() {
    var e;
    super.destroy(), Zv(this.gridId), (e = this.destroyCallback) == null || e.call(this);
  }
  getGridId() {
    return this.gridId;
  }
}, iw = "ag-column-first", rw = "ag-column-last";
function fl(e, t, s, i) {
  return Y(e) ? [] : Tu(e.headerClass, e, t, s, i);
}
function Ru(e, t, s, i) {
  return Y(e) ? [] : Tu(e.toolPanelClass, e, t, s, i);
}
function Pu(e, t, s) {
  e.addOrRemoveCssClass(iw, s.isColAtEdge(t, "first")), e.addOrRemoveCssClass(rw, s.isColAtEdge(t, "last"));
}
function ow(e, t, s, i) {
  return t.addGridCommonParams({
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: s,
    columnGroup: i
  });
}
function Tu(e, t, s, i, r) {
  if (Y(e))
    return [];
  let o;
  if (typeof e == "function") {
    const n = ow(t, s, i, r);
    o = e(n);
  } else
    o = e;
  return typeof o == "string" ? [o] : Array.isArray(o) ? [...o] : [];
}
function pt(e, t) {
  const s = zh(e);
  s.requestAnimationFrame ? s.requestAnimationFrame(t) : s.webkitRequestAnimationFrame ? s.webkitRequestAnimationFrame(t) : s.setTimeout(t, 0);
}
var nw = class extends P {
  constructor() {
    super(...arguments), this.beanName = "animationFrameSvc", this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  setScrollTop(e) {
    const { gos: t, pagination: s } = this.beans, i = t.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, i && e === 0) {
      const r = (s == null ? void 0 : s.getCurrentPage()) ?? 0;
      r !== this.lastPage && (this.lastPage = r, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  postConstruct() {
    this.active = !this.gos.get("suppressAnimationFrame");
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.active === !1 && R(92, { methodName: e });
  }
  createTask(e, t, s) {
    this.verifyAnimationFrameOn(s);
    const i = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[s], i), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort(
      (s, i) => s.index !== i.index ? t * (i.index - s.index) : i.createOrder - s.createOrder
    ), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, s = t.list, i = this.createTasksP2, r = i.list, o = this.destroyTasks, n = (/* @__PURE__ */ new Date()).getTime();
    let a = (/* @__PURE__ */ new Date()).getTime() - n;
    const l = e <= 0, d = this.beans.ctrlsSvc.getScrollFeature();
    for (; l || a < e; ) {
      if (!d.scrollGridIfNeeded()) {
        let h;
        if (s.length)
          this.sortTaskList(t), h = s.pop().task;
        else if (r.length)
          this.sortTaskList(i), h = r.pop().task;
        else if (o.length)
          h = o.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(h) || h();
      }
      a = (/* @__PURE__ */ new Date()).getTime() - n;
    }
    s.length || r.length || o.length ? this.requestFrame() : this.ticking = !1;
  }
  flushAllFrames() {
    this.active && this.executeFrame(-1);
  }
  schedule() {
    this.active && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    pt(this.beans, e);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
}, w = {
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  DELETE: "Delete",
  F2: "F2",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PAGE_HOME: "Home",
  PAGE_END: "End",
  // these should be used with `event.code` instead of `event.key`
  // as `event.key` changes when non-latin keyboards are used
  A: "KeyA",
  C: "KeyC",
  D: "KeyD",
  V: "KeyV",
  X: "KeyX",
  Y: "KeyY",
  Z: "KeyZ"
}, ya = !1, Fo = 0;
function aw(e) {
  Fo > 0 || (e.addEventListener("keydown", Ro), e.addEventListener("mousedown", Ro));
}
function lw(e) {
  Fo > 0 || (e.removeEventListener("keydown", Ro), e.removeEventListener("mousedown", Ro));
}
function Ro(e) {
  const t = ya, s = e.type === "keydown";
  s && (e.ctrlKey || e.metaKey || e.altKey) || t !== s && (ya = s);
}
function dw(e) {
  const t = Z(e);
  return aw(t), Fo++, () => {
    Fo--, lw(t);
  };
}
function tn() {
  return ya;
}
function Du(e, t, s) {
  t.addManagedElementListeners(s, {
    keydown: (i) => {
      if (!i.defaultPrevented && i.key === w.TAB) {
        const r = i.shiftKey;
        Pe(e, s, !1, r) || Xt(e, r) && i.preventDefault();
      }
    }
  });
}
function bt(e, t, s = !1) {
  const i = mC;
  let r = Fh;
  t && (r += ", " + t), s && (r += ', [tabindex="-1"]');
  const o = Array.prototype.slice.apply(e.querySelectorAll(i)).filter((l) => ke(l)), n = Array.prototype.slice.apply(e.querySelectorAll(r));
  return n.length ? ((l, d) => l.filter((c) => d.indexOf(c) === -1))(o, n) : o;
}
function ve(e, t = !1, s = !1) {
  const i = bt(e, null, s), r = t ? V(i) : i[0];
  return r ? (r.focus({ preventScroll: !0 }), !0) : !1;
}
function Pe(e, t, s, i) {
  const r = bt(t, s ? ':not([tabindex="-1"])' : null), o = q(e);
  let n;
  s ? n = r.findIndex((l) => l.contains(o)) : n = r.indexOf(o);
  const a = n + (i ? -1 : 1);
  return a < 0 || a >= r.length ? null : r[a];
}
function ml(e, t = 5) {
  let s = 0;
  for (; e && pa(e) === null && ++s <= t; )
    e = e.parentElement;
  return pa(e) === null ? null : e;
}
function Eu(e, t) {
  return e.ctrlsSvc.get("gridCtrl").focusInnerElement(t);
}
function mi(e) {
  var t;
  return e.gos.get("suppressHeaderFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function Mu(e) {
  var t;
  return e.gos.get("suppressCellFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function Xt(e, t, s = !1) {
  const i = e.ctrlsSvc.get("gridCtrl");
  return !s && i.focusNextInnerContainer(t) ? !0 : ((s || !t && !i.isDetailGrid()) && i.forceFocusOutOfContainer(t), !1);
}
var cw = /[&<>"']/g, hw = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Q(e, t) {
  if (e == null)
    return null;
  const s = e.toString().toString();
  return t ? s : s.replace(cw, (i) => hw[i]);
}
function uw(e, t = !1) {
  return e === w.DELETE ? !0 : !t && e === w.BACKSPACE ? bh() : !1;
}
var pw = class extends P {
  constructor(e, t, s, i) {
    super(), this.cellCtrl = e, this.rowNode = s, this.rowCtrl = i, this.beans = t;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case w.ENTER:
        this.onEnterKeyDown(e);
        break;
      case w.F2:
        this.onF2KeyDown(e);
        break;
      case w.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case w.TAB:
        this.onTabKeyDown(e);
        break;
      case w.BACKSPACE:
      case w.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case w.DOWN:
      case w.UP:
      case w.RIGHT:
      case w.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    var s;
    this.cellCtrl.editing || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : (s = this.beans.navigation) == null || s.navigateToNextCell(e, t, this.cellCtrl.cellPosition, !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    const { rangeSvc: t, navigation: s } = this.beans;
    if (!t)
      return;
    const i = t.extendLatestRangeInDirection(e);
    i && (s == null || s.ensureCellVisible(i));
  }
  onTabKeyDown(e) {
    var t;
    (t = this.beans.navigation) == null || t.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    var l;
    const { cellCtrl: s, beans: i, rowNode: r } = this, { gos: o, rangeSvc: n, eventSvc: a } = i;
    if (!s.editing) {
      if (a.dispatchEvent({ type: "keyShortcutChangedCellStart" }), uw(e, o.get("enableCellEditingOnBackspace"))) {
        if (n && Ve(o))
          n.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (s.isCellEditable()) {
          const { column: d } = s, c = this.beans.valueSvc.getDeleteValue(d, r);
          r.setDataValue(d, c, "cellClear");
        }
      } else
        (l = i.editSvc) == null || l.startRowOrCellEdit(s, e, t);
      a.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    var i, r;
    const { cellCtrl: t, beans: s } = this;
    if (t.editing || this.rowCtrl.editing)
      t.stopEditingAndFocus(!1, e.shiftKey);
    else if (s.gos.get("enterNavigatesVertically")) {
      const o = e.shiftKey ? w.UP : w.DOWN;
      (i = s.navigation) == null || i.navigateToNextCell(null, o, t.cellPosition, !1);
    } else
      (r = s.editSvc) == null || r.startRowOrCellEdit(t, w.ENTER, e), t.editing && e.preventDefault();
  }
  onF2KeyDown(e) {
    var i;
    const { cellCtrl: t, beans: s } = this;
    t.editing || (i = s.editSvc) == null || i.startRowOrCellEdit(t, w.F2, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(e) {
    var i;
    const { cellCtrl: t, beans: s } = this;
    t.editing && ((i = s.editSvc) == null || i.stopRowOrCellEdit(t, !0), t.focusCell(!0));
  }
  processCharacter(e) {
    var r;
    if (e.target !== this.eGui || this.cellCtrl.editing)
      return;
    const i = e.key;
    i === w.SPACE ? this.onSpaceKeyDown(e) : (r = this.beans.editSvc) != null && r.startRowOrCellEdit(this.cellCtrl, i, e) && e.preventDefault();
  }
  onSpaceKeyDown(e) {
    var s;
    const { gos: t } = this.beans;
    !this.cellCtrl.editing && ot(t) && ((s = this.beans.selectionSvc) == null || s.handleSelectionEvent(e, this.rowNode, "spaceKey")), e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, gw = class extends P {
  constructor(e, t, s) {
    super(), this.cellCtrl = e, this.column = s, this.beans = t;
  }
  onMouseEvent(e, t) {
    if (!nt(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    var d;
    if ((d = this.beans.touchSvc) != null && d.handleCellDoubleClick(this, e))
      return;
    const { eventSvc: t, rangeSvc: s, gos: i, editSvc: r } = this.beans, o = e.ctrlKey || e.metaKey;
    s && o && s.getCellRangeCount(this.cellCtrl.cellPosition) > 1 && s.intersectLastRange(!0);
    const n = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(n);
    const a = this.column.getColDef();
    a.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        a.onCellClicked(n);
      });
    }, 0), (i.get("singleClickEdit") || a.singleClickEdit) && !i.get("suppressClickEdit") && !(e.shiftKey && (s == null ? void 0 : s.getCellRanges().length) != 0) && (r == null || r.startRowOrCellEdit(this.cellCtrl));
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: s, cellCtrl: i } = this, { eventSvc: r, frameworkOverrides: o, gos: n, editSvc: a } = s, l = t.getColDef(), d = i.createEvent(e, "cellDoubleClicked");
    r.dispatchEvent(d), typeof l.onCellDoubleClicked == "function" && window.setTimeout(() => {
      o.wrapOutgoing(() => {
        l.onCellDoubleClicked(d);
      });
    }, 0), !n.get("singleClickEdit") && !n.get("suppressClickEdit") && (a == null || a.startRowOrCellEdit(i, null, e));
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: s, shiftKey: i } = e, r = e.target, { cellCtrl: o, beans: n } = this, { eventSvc: a, rangeSvc: l, focusSvc: d, gos: c } = n;
    if (this.isRightClickInExistingRange(e))
      return;
    const h = l && !l.isEmpty(), u = this.containsWidget(r), { cellPosition: p } = o;
    if (!i || !h) {
      const f = c.get("enableCellTextSelection") && e.defaultPrevented, m = (si() || f) && !o.editing && !sl(r) && !u;
      o.focusCell(m);
    }
    if (i && h && !d.isCellFocused(p)) {
      e.preventDefault();
      const g = d.getFocusedCell();
      if (g) {
        const { column: f, rowIndex: m, rowPinned: C } = g, v = n.rowRenderer.getRowByPosition({ rowIndex: m, rowPinned: C }), b = v == null ? void 0 : v.getCellCtrl(f);
        b != null && b.editing && b.stopEditing(), d.setFocusedCell({
          column: f,
          rowIndex: m,
          rowPinned: C,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!u) {
      if (l)
        if (i)
          l.extendLatestRangeToCell(p);
        else {
          const g = t || s;
          l.setRangeToCell(p, g);
        }
      a.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeSvc: t } = this.beans;
    if (t) {
      const s = t.isCellInAnyRange(this.cellCtrl.cellPosition), i = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (s && i)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Hs(e, "ag-selection-checkbox", 3) || Hs(e, "ag-drag-handle", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: s } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOut")), s == null || s.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: s } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOver")), s == null || s.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const { eGui: t } = this.cellCtrl, s = t.contains(e.target), i = t.contains(e.relatedTarget);
    return s && i;
  }
  destroy() {
    super.destroy();
  }
}, fw = class extends P {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.column, this.rowNode = e.rowNode;
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    Re(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventSvc, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const { column: e, rowNode: t } = this, s = e.getColSpan(t), i = [];
    if (s === 1)
      i.push(e);
    else {
      let r = e;
      const o = e.getPinned();
      for (let n = 0; r && n < s && (i.push(r), r = this.beans.visibleCols.getColAfter(r), !(!r || Y(r) || o !== r.getPinned())); n++)
        ;
    }
    return i;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = V(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.printLayout || this.column.getPinned() === "left")
      return e;
    const { visibleCols: t } = this.beans, s = t.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const i = t.bodyWidth;
      return s + i + (e || 0);
    }
    return s + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const s = Ye(this.beans) * this.rowSpan;
    this.eGui.style.height = `${s}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, mw = "ag-cell", Cw = "ag-cell-auto-height", vw = "ag-cell-normal-height", ww = "ag-cell-focus", yw = "ag-cell-first-right-pinned", bw = "ag-cell-last-left-pinned", Sw = "ag-cell-not-inline-editing", xw = "ag-cell-wrap-text", Po = "cellCtrl";
function Cl(e, t) {
  return Yh(e, t, Po);
}
var Fw = 0, so = class extends P {
  constructor(e, t, s, i) {
    super(), this.column = e, this.rowNode = t, this.rowCtrl = i, this.rangeFeature = void 0, this.positionFeature = void 0, this.customStyleFeature = void 0, this.tooltipFeature = void 0, this.mouseListener = void 0, this.keyboardListener = void 0, this.suppressRefreshCell = !1, this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], this.beans = s, this.instanceId = e.getId() + "-" + Fw++, this.colIdSanitised = Q(this.column.getId()), this.createCellPosition(), this.updateAndFormatValue(!1);
  }
  shouldRestoreFocus() {
    return this.beans.focusSvc.shouldRestoreFocus(this.cellPosition);
  }
  onFocusOut() {
    this.beans.focusSvc.clearRestoreFocus();
  }
  addFeatures() {
    var i;
    const { beans: e } = this;
    this.positionFeature = new fw(this, e), this.customStyleFeature = (i = e.cellStyles) == null ? void 0 : i.createCellCustomStyleFeature(this, e), this.mouseListener = new gw(this, e, this.column), this.keyboardListener = new pw(this, e, this.rowNode, this.rowCtrl), this.column.isTooltipEnabled() && this.enableTooltipFeature();
    const { rangeSvc: t } = e;
    t && Ve(e.gos) && (this.rangeFeature = t.createCellRangeFeature(e, this));
  }
  removeFeatures() {
    const e = this.beans.context;
    this.positionFeature = e.destroyBean(this.positionFeature), this.customStyleFeature = e.destroyBean(this.customStyleFeature), this.mouseListener = e.destroyBean(this.mouseListener), this.keyboardListener = e.destroyBean(this.keyboardListener), this.rangeFeature = e.destroyBean(this.rangeFeature), this.disableTooltipFeature();
  }
  enableTooltipFeature(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.enableCellTooltipFeature(this, e, t);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  setComp(e, t, s, i, r, o) {
    var n, a, l, d, c;
    this.comp = e, this.eGui = t, this.printLayout = i, o ?? (o = this), this.addDomData(o), this.addFeatures(), o.addDestroyFunc(() => this.removeFeatures()), this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(s, o), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (n = this.positionFeature) == null || n.setComp(t), (a = this.customStyleFeature) == null || a.setComp(e), (l = this.tooltipFeature) == null || l.refreshTooltip(), (d = this.keyboardListener) == null || d.setComp(this.eGui), this.rangeFeature && this.rangeFeature.setComp(e, t), r && this.isCellEditable() ? (c = this.beans.editSvc) == null || c.startEditing(this) : this.showValue(), this.onCompAttachedFuncs.length && (this.onCompAttachedFuncs.forEach((h) => h()), this.onCompAttachedFuncs = []);
  }
  setupAutoHeight(e, t) {
    var s;
    this.isAutoHeight = this.column.isAutoHeight(), !(!this.isAutoHeight || !e) && ((s = this.beans.rowAutoHeight) == null || s.setupCellAutoHeight(this, e, t));
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const e = this.column.getColDef();
    return e.cellRenderer != null || e.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(e = !1) {
    var d;
    const { beans: t, column: s, rowNode: i, rangeFeature: r } = this, { userCompFactory: o } = t, n = this.getValueToDisplay();
    let a;
    if (i.stub && ((d = i.groupData) == null ? void 0 : d[s.getId()]) == null) {
      const c = this.createCellRendererParams();
      a = Wv(o, s.getColDef(), c);
    } else if (this.isCellRenderer()) {
      const c = this.createCellRendererParams();
      a = So(o, s.getColDef(), c);
    }
    this.comp.setRenderDetails(a, n, e), r && pt(t, () => r == null ? void 0 : r.refreshHandle());
  }
  setupControlComps() {
    const e = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(e)), this.includeRowDrag = this.isIncludeControl(e.rowDrag), this.includeDndSource = this.isIncludeControl(e.dndSource), this.comp.setIncludeSelection(this.includeSelection), this.comp.setIncludeDndSource(this.includeDndSource), this.comp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(e) {
    return this.rowNode.rowPinned != null ? !1 : typeof e == "function" || e === !0;
  }
  isCheckboxSelection(e) {
    const { rowSelection: t } = this.beans.gridOptions;
    return e.checkboxSelection || Ot(this.column) && t && typeof t != "string" && zs(t);
  }
  refreshShouldDestroy() {
    const e = this.column.getColDef(), t = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(e)), s = this.includeRowDrag != this.isIncludeControl(e.rowDrag), i = this.includeDndSource != this.isIncludeControl(e.dndSource), r = this.isAutoHeight != this.column.isAutoHeight();
    return t || s || i || r;
  }
  onPopupEditorClosed() {
    this.editing && this.stopEditingAndFocus();
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(e = !1) {
    var t;
    return ((t = this.beans.editSvc) == null ? void 0 : t.stopEditing(this, e)) ?? !1;
  }
  createCellRendererParams() {
    const {
      value: e,
      valueFormatted: t,
      column: s,
      rowNode: i,
      comp: r,
      eGui: o,
      beans: { valueSvc: n, gos: a }
    } = this;
    return a.addGridCommonParams({
      value: e,
      valueFormatted: t,
      getValue: () => n.getValueForDisplay(s, i),
      setValue: (d) => n.setValue(i, s, d),
      formatValue: this.formatValue.bind(this),
      data: i.data,
      node: i,
      pinned: s.getPinned(),
      colDef: s.getColDef(),
      column: s,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: o,
      eParentOfValue: r.getParentOfValue(),
      registerRowDragger: (d, c, h, u) => this.registerRowDragger(d, c, u),
      setTooltip: (d, c) => {
        var h;
        a.assertModuleRegistered("Tooltip", 3), this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(d, c), (h = this.tooltipFeature) == null || h.refreshTooltip();
      }
    });
  }
  onCellChanged(e) {
    e.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(e) {
    var t;
    this.refreshShouldDestroy() ? (t = this.rowCtrl) == null || t.recreateCell(this) : this.refreshCell(e);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(e) {
    var d, c, h, u, p, g;
    if (this.suppressRefreshCell || this.editing)
      return;
    const t = this.column.getColDef(), s = e != null && !!e.newData, i = e != null && !!e.suppressFlash, r = t.field == null && t.valueGetter == null && t.showRowGroup == null, o = e && e.forceRefresh || r || s, n = !!this.comp, a = this.updateAndFormatValue(n), l = o || a;
    if (n) {
      if (l) {
        this.showValue(s);
        const f = (d = this.beans.filterManager) == null ? void 0 : d.isSuppressFlashingCellsBecauseFiltering();
        !i && !f && t.enableCellChangeFlash && ((c = this.beans.cellFlashSvc) == null || c.flashCell(this)), (h = this.customStyleFeature) == null || h.applyUserStyles(), (u = this.customStyleFeature) == null || u.applyClassesFromColDef();
      }
      (p = this.tooltipFeature) == null || p.refreshTooltip(), (g = this.customStyleFeature) == null || g.applyCellClassRules();
    }
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(e = !1, t = !1) {
    var s;
    (s = this.beans.editSvc) == null || s.stopEditingAndFocus(this, e, t);
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  formatValue(e) {
    return this.callValueFormatter(e) ?? e;
  }
  callValueFormatter(e) {
    return this.beans.valueSvc.formatValue(this.column, this.rowNode, e);
  }
  updateAndFormatValue(e) {
    const t = this.value, s = this.valueFormatted;
    return this.value = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode), this.valueFormatted = this.callValueFormatter(this.value), e ? !this.valuesAreEqual(t, this.value) || this.valueFormatted != s : !0;
  }
  valuesAreEqual(e, t) {
    const s = this.column.getColDef();
    return s.equals ? s.equals(e, t) : e === t;
  }
  addDomData(e) {
    const t = this.eGui;
    js(this.beans.gos, t, Po, this), e.addDestroyFunc(() => js(this.beans.gos, t, Po, null));
  }
  createEvent(e, t) {
    const { rowNode: s, column: i, value: r } = this;
    return this.beans.gos.addGridCommonParams({
      type: t,
      node: s,
      data: s.data,
      value: r,
      column: i,
      colDef: i.getColDef(),
      rowPinned: s.rowPinned,
      event: e,
      rowIndex: s.rowIndex
    });
  }
  processCharacter(e) {
    var t;
    (t = this.keyboardListener) == null || t.processCharacter(e);
  }
  onKeyDown(e) {
    var t;
    (t = this.keyboardListener) == null || t.onKeyDown(e);
  }
  onMouseEvent(e, t) {
    var s;
    (s = this.mouseListener) == null || s.onMouseEvent(e, t);
  }
  getColSpanningList() {
    return this.positionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var e;
    this.comp && ((e = this.positionFeature) == null || e.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { comp: e, column: t, beans: s } = this;
    Pu(e, t, s.visibleCols);
  }
  refreshAriaColIndex() {
    const e = this.beans.visibleCols.getAriaColIndex(this.column);
    Ja(this.eGui, e);
  }
  onWidthChanged() {
    var e;
    return (e = this.positionFeature) == null ? void 0 : e.onWidthChanged();
  }
  getRowPosition() {
    const { rowIndex: e, rowPinned: t } = this.cellPosition;
    return {
      rowIndex: e,
      rowPinned: t
    };
  }
  updateRangeBordersIfRangeCount() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.updateRangeBordersIfRangeCount());
  }
  onCellSelectionChanged() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.onCellSelectionChanged());
  }
  isRangeSelectionEnabled() {
    return this.rangeFeature != null;
  }
  focusCell(e = !1) {
    this.beans.focusSvc.setFocusedCell({
      rowIndex: this.cellPosition.rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: e
    });
  }
  onRowIndexChanged() {
    var e;
    this.createCellPosition(), this.onCellFocused(), (e = this.rangeFeature) == null || e.onCellSelectionChanged();
  }
  onSuppressCellFocusChanged(e) {
    this.eGui && ht(this.eGui, "tabindex", e ? void 0 : -1);
  }
  onFirstRightPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isFirstRightPinned();
    this.comp.addOrRemoveCssClass(yw, e);
  }
  onLastLeftPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isLastLeftPinned();
    this.comp.addOrRemoveCssClass(bw, e);
  }
  onCellFocused(e) {
    var r;
    const { beans: t } = this;
    if (Mu(t))
      return;
    const s = t.focusSvc.isCellFocused(this.cellPosition);
    if (!this.comp) {
      s && (e != null && e.forceBrowserFocus) && (this.focusEventToRestore = e);
      return;
    }
    if (this.focusEventToRestore = void 0, this.comp.addOrRemoveCssClass(ww, s), s && e && e.forceBrowserFocus) {
      let o = this.comp.getFocusableElement();
      if (this.editing) {
        const n = bt(o, null, !0);
        n.length && (o = n[0]);
      }
      o.focus({ preventScroll: !!e.preventScrollOnBrowserFocus });
    }
    const i = t.gos.get("editType") === "fullRow";
    !s && !i && this.editing && ((r = t.editSvc) == null || r.stopRowOrCellEdit(this)), s && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    const { rowIndex: e, rowPinned: t } = this.rowNode;
    this.cellPosition = {
      rowIndex: e,
      rowPinned: ge(t),
      column: this.column
    };
  }
  setInlineEditingCss() {
    var e;
    (e = this.beans.editSvc) == null || e.setInlineEditingCss(this.rowCtrl);
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    const { comp: e } = this;
    e.addOrRemoveCssClass(mw, !0), e.addOrRemoveCssClass(Sw, !0);
    const t = this.column.isAutoHeight() == !0;
    e.addOrRemoveCssClass(Cw, t), e.addOrRemoveCssClass(vw, !t);
  }
  onColumnHover() {
    var e;
    (e = this.beans.colHover) == null || e.onCellColumnHover(this.column, this.comp);
  }
  onColDefChanged() {
    var e;
    this.comp && (this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (e = this.beans.editSvc) == null || e.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 }));
  }
  setWrapText() {
    const e = this.column.getColDef().wrapText == !0;
    this.comp.addOrRemoveCssClass(xw, e);
  }
  dispatchCellContextMenuEvent(e) {
    const t = this.column.getColDef(), s = this.createEvent(e, "cellContextMenu"), { beans: i } = this;
    i.eventSvc.dispatchEvent(s), t.onCellContextMenu && window.setTimeout(() => {
      i.frameworkOverrides.wrapOutgoing(() => {
        t.onCellContextMenu(s);
      });
    }, 0);
  }
  getCellRenderer() {
    var e;
    return ((e = this.comp) == null ? void 0 : e.getCellRenderer()) ?? null;
  }
  destroy() {
    this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    var t;
    const e = (t = this.beans.selectionSvc) == null ? void 0 : t.createCheckboxSelectionComponent();
    if (e)
      return this.beans.context.createBean(e), e.init({ rowNode: this.rowNode, column: this.column }), e;
  }
  createDndSource() {
    const e = this.beans.registry.createDynamicBean(
      "dndSourceComp",
      !1,
      this.rowNode,
      this.column,
      this.eGui
    );
    return e && this.beans.context.createBean(e), e;
  }
  registerRowDragger(e, t, s) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(e, t);
      return;
    }
    const i = this.createRowDragComp(e, t, s);
    i && (this.customRowDragComp = i, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(i), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(e, t, s) {
    var r;
    const i = (r = this.beans.rowDragSvc) == null ? void 0 : r.createRowDragCompForCell(
      this.rowNode,
      this.column,
      () => this.value,
      e,
      t,
      s
    );
    if (i)
      return this.beans.context.createBean(i), i;
  }
  cellEditorAttached() {
    this.onEditorAttachedFuncs.forEach((e) => e()), this.onEditorAttachedFuncs = [];
  }
}, Au = "__ag_grid_instance";
function Iu(e, t) {
  t[Au] = e.gridInstanceId;
}
function To(e, t) {
  return Lu(e, t.target);
}
function Lu(e, t) {
  let s = t;
  for (; s; ) {
    const i = s[Au];
    if (A(i))
      return i === e.gridInstanceId;
    s = s.parentElement;
  }
  return !1;
}
function ku(e, t) {
  var s;
  return ((s = Cl(e, t.target)) == null ? void 0 : s.cellPosition) ?? null;
}
function tr(e, t) {
  const s = ye(e.gos, "normal"), i = t;
  let r, o;
  if (i.clientX != null || i.clientY != null ? (r = i.clientX, o = i.clientY) : (r = i.x, o = i.y), s) {
    const n = e.ctrlsSvc.getScrollFeature(), a = n.getVScrollPosition(), l = n.getHScrollPosition();
    r += l.left, o += a.top;
  }
  return { x: r, y: o };
}
var xt = /* @__PURE__ */ ((e) => (e[e.ToolPanel = 0] = "ToolPanel", e[e.HeaderCell = 1] = "HeaderCell", e[e.RowDrag = 2] = "RowDrag", e[e.ChartPanel = 3] = "ChartPanel", e[e.AdvancedFilterBuilder = 4] = "AdvancedFilterBuilder", e))(xt || {}), Rw = class extends P {
  constructor() {
    super(...arguments), this.beanName = "dragAndDrop", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.dragSvc = e.dragSvc, this.environment = e.environment, this.userCompFactory = e.userCompFactory;
  }
  addDragSource(e, t = !1) {
    const s = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: s, dragSource: e }), this.dragSvc.addDragSource(s);
  }
  getDragAndDropImageComponent() {
    const { dragAndDropImageComp: e } = this;
    return !e || !e.comp ? null : e.comp;
  }
  removeDragSource(e) {
    const { dragSourceAndParamsList: t, dragSvc: s } = this, i = t.find((r) => r.dragSource === e);
    i && (s.removeDragSource(i.params), be(t, i));
  }
  destroy() {
    const { dragSourceAndParamsList: e, dragSvc: t, dropTargets: s } = this;
    e.forEach((i) => t.removeDragSource(i.params)), e.length = 0, s.length = 0, this.clearDragAndDropProperties(), super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    var s;
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = e.getDragItem(), (s = e.onDragStarted) == null || s.call(e), this.createDragAndDropImageComponent();
  }
  onDragStop(e) {
    var s, i;
    (i = (s = this.dragSource) == null ? void 0 : s.onDragStopped) == null || i.call(s);
    const { lastDropTarget: t } = this;
    if (t != null && t.onDragStop) {
      const r = this.createDropTargetEvent(t, e, null, null, !1);
      t.onDragStop(r);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var s;
    const { dragSource: e, lastDropTarget: t } = this;
    (s = e == null ? void 0 : e.onDragCancelled) == null || s.call(e), t != null && t.onDragCancel && t.onDragCancel(
      this.createDropTargetEvent(t, this.eventLastTime, null, null, !1)
    ), this.clearDragAndDropProperties();
  }
  clearDragAndDropProperties() {
    this.eventLastTime = null, this.dragging = !1, this.lastDropTarget = void 0, this.dragItem = null, this.dragSource = null, this.removeDragAndDropImageComponent();
  }
  onDragging(e, t = !1) {
    var c, h;
    const s = this.getHorizontalDirection(e), i = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionDragAndDropImageComp(e);
    const r = this.dropTargets.filter((u) => this.isMouseOnDropTarget(e, u)), o = this.findCurrentDropTarget(e, r), { lastDropTarget: n, dragSource: a, dragAndDropImageComp: l, dragItem: d } = this;
    if (o !== n) {
      if (this.leaveLastTargetIfExists(e, s, i, t), n !== null && o === null && ((c = a == null ? void 0 : a.onGridExit) == null || c.call(a, d)), n === null && o !== null && ((h = a == null ? void 0 : a.onGridEnter) == null || h.call(a, d)), this.enterDragTargetIfExists(o, e, s, i, t), o && l) {
        const { comp: u, promise: p } = l;
        u ? u.setIcon(o.getIconName ? o.getIconName() : null, !1) : p.then((g) => {
          g && g.setIcon(o.getIconName ? o.getIconName() : null, !1);
        });
      }
      this.lastDropTarget = o;
    } else if (o && o.onDragging) {
      const u = this.createDropTargetEvent(o, e, s, i, t);
      o.onDragging(u);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, s = [[e.getContainer()]];
    return t ? s.concat(t) : s;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const s = this.getAllContainersFromDropTarget(t);
    let i = !1;
    const r = (a, l) => {
      for (const d of l) {
        const { width: c, height: h, left: u, right: p, top: g, bottom: f } = d.getBoundingClientRect();
        if (c === 0 || h === 0)
          return !1;
        const m = a.clientX >= u && a.clientX < p, C = a.clientY >= g && a.clientY < f;
        if (!m || !C)
          return !1;
      }
      return !0;
    };
    for (const a of s)
      if (r(e, a)) {
        i = !0;
        break;
      }
    const { eElement: o, type: n } = this.dragSource;
    return t.targetContainsSource && !t.getContainer().contains(o) ? !1 : i && t.isInterestedIn(n, o);
  }
  findCurrentDropTarget(e, t) {
    const s = t.length;
    if (s === 0)
      return null;
    if (s === 1)
      return t[0];
    const r = xi(this.beans).elementsFromPoint(e.clientX, e.clientY);
    for (const o of r)
      for (const n of t)
        if (this.getAllContainersFromDropTarget(n).flatMap((l) => l).indexOf(o) !== -1)
          return n;
    return null;
  }
  enterDragTargetIfExists(e, t, s, i, r) {
    if (e && e.onDragEnter) {
      const o = this.createDropTargetEvent(
        e,
        t,
        s,
        i,
        r
      );
      e.onDragEnter(o);
    }
  }
  leaveLastTargetIfExists(e, t, s, i) {
    const { lastDropTarget: r } = this;
    if (!r)
      return;
    if (r.onDragLeave) {
      const n = this.createDropTargetEvent(
        r,
        e,
        t,
        s,
        i
      );
      r.onDragLeave(n);
    }
    const o = this.getDragAndDropImageComponent();
    o && o.setIcon(null, !1);
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((s) => s.external).find((s) => s.getContainer() === e.getContainer()) || null;
  }
  isDropZoneWithinThisGrid(e) {
    const s = this.ctrlsSvc.getGridBodyCtrl().eGridBody, { dropZoneTarget: i } = e;
    return s.contains(i);
  }
  getHorizontalDirection(e) {
    var i;
    const t = (i = this.eventLastTime) == null ? void 0 : i.clientX, s = e.clientX;
    return t === s ? null : t > s ? "left" : "right";
  }
  getVerticalDirection(e) {
    var i;
    const t = (i = this.eventLastTime) == null ? void 0 : i.clientY, s = e.clientY;
    return t === s ? null : t > s ? "up" : "down";
  }
  createDropTargetEvent(e, t, s, i, r) {
    const o = e.getContainer(), n = o.getBoundingClientRect(), { dragItem: a, dragSource: l, gos: d } = this, c = t.clientX - n.left, h = t.clientY - n.top;
    return d.addGridCommonParams({
      event: t,
      x: c,
      y: h,
      vDirection: i,
      hDirection: s,
      dragSource: l,
      fromNudge: r,
      dragItem: a,
      dropZoneTarget: o
    });
  }
  positionDragAndDropImageComp(e) {
    const t = this.getDragAndDropImageComponent();
    t && Ca(t.getGui(), e, this.beans);
  }
  removeDragAndDropImageComponent() {
    var t;
    const { dragAndDropImageComp: e } = this;
    if (e) {
      const { comp: s } = e;
      if (s) {
        const i = s.getGui();
        (t = this.dragAndDropImageParent) == null || t.removeChild(i), this.destroyBean(s);
      }
    }
    this.dragAndDropImageComp = null;
  }
  createDragAndDropImageComponent() {
    const { dragSource: e } = this;
    if (!e)
      return;
    const t = Lv(this.userCompFactory, {
      dragSource: e
    });
    if (!t)
      return;
    const s = t.newAgStackInstance();
    this.dragAndDropImageComp = {
      promise: s
    }, s.then((i) => {
      !i || !this.isAlive() || (this.processDragAndDropImageComponent(i), this.dragAndDropImageComp.comp = i);
    });
  }
  processDragAndDropImageComponent(e) {
    const { dragSource: t, environment: s } = this;
    if (!t)
      return;
    const i = e.getGui();
    i.style.setProperty("position", "absolute"), i.style.setProperty("z-index", "9999"), Iu(this.gos, i), s.applyThemeClasses(i), e.setIcon(null, !1);
    let { dragItemName: r } = t;
    typeof r == "function" && (r = r()), e.setLabel(r || ""), i.style.top = "20px", i.style.left = "20px";
    const o = Yo(this.beans);
    this.dragAndDropImageParent = o, o ? o.appendChild(i) : R(54);
  }
  registerGridDropTarget(e, t) {
    const s = {
      getContainer: e,
      isInterestedIn: (i) => i === 1 || i === 0,
      getIconName: () => "notAllowed"
    };
    this.addDropTarget(s), t.addDestroyFunc(() => this.removeDropTarget(s));
  }
}, vl = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const s = t || this.shouldSkipVerticalScroll();
    if (s && this.shouldSkipHorizontalScroll())
      return;
    const i = this.scrollContainer.getBoundingClientRect(), r = this.scrollByTick;
    this.tickLeft = e.clientX < i.left + r, this.tickRight = e.clientX > i.right - r, this.tickUp = e.clientY < i.top + r && !s, this.tickDown = e.clientY > i.bottom - r && !s, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
};
function ns(e) {
  const { rowIndex: t, rowPinned: s, column: i } = e;
  return `${t}.${s ?? "null"}.${i.getId()}`;
}
function Ti(e, t) {
  const s = e.column === t.column, i = e.rowPinned === t.rowPinned, r = e.rowIndex === t.rowIndex;
  return s && i && r;
}
function Me(e, t) {
  switch (e.rowPinned) {
    case "top":
      if (t.rowPinned !== "top")
        return !0;
      break;
    case "bottom":
      if (t.rowPinned !== "bottom")
        return !1;
      break;
    default:
      if (A(t.rowPinned))
        return t.rowPinned !== "top";
      break;
  }
  return e.rowIndex < t.rowIndex;
}
function fe(e, t) {
  return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
}
function Pw(e) {
  let t = 0, s;
  const { pinnedRowModel: i, rowModel: r, pageBounds: o } = e;
  return i != null && i.getPinnedTopRowCount() ? s = "top" : r.getRowCount() ? (s = null, t = o.getFirstRow()) : i != null && i.getPinnedBottomRowCount() && (s = "bottom"), s === void 0 ? null : { rowIndex: t, rowPinned: s };
}
function Tw(e) {
  let t, s = null;
  const { pinnedRowModel: i, pageBounds: r } = e, o = i == null ? void 0 : i.getPinnedBottomRowCount(), n = i == null ? void 0 : i.getPinnedTopRowCount();
  return o ? (s = "bottom", t = o - 1) : e.rowModel.getRowCount() ? (s = null, t = r.getLastRow()) : n && (s = "top", t = n - 1), t === void 0 ? null : { rowIndex: t, rowPinned: s };
}
function St(e, t) {
  var s, i;
  switch (t.rowPinned) {
    case "top":
      return (s = e.pinnedRowModel) == null ? void 0 : s.getPinnedTopRow(t.rowIndex);
    case "bottom":
      return (i = e.pinnedRowModel) == null ? void 0 : i.getPinnedBottomRow(t.rowIndex);
    default:
      return e.rowModel.getRow(t.rowIndex);
  }
}
function It(e, t) {
  const s = e.rowRenderer.getRowByPosition(t);
  return s ? s.getCellCtrl(t.column) : null;
}
var Dw = class extends P {
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    const { rowModel: e, gos: t, ctrlsSvc: s } = this.beans;
    J(t) && (this.clientSideRowModel = e), s.whenReady(this, (i) => {
      const r = i.gridBodyCtrl;
      this.autoScrollService = new vl({
        scrollContainer: r.eBodyViewport,
        scrollAxis: "y",
        getVerticalPosition: () => r.scrollFeature.getVScrollPosition().top,
        setVerticalPosition: (o) => r.scrollFeature.setVerticalScrollPosition(o),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    const { rowGroupColsSvc: e, filterManager: t, sortSvc: s } = this.beans;
    return !!(((e == null ? void 0 : e.columns) ?? []).length || (t == null ? void 0 : t.isAnyFilterPresent()) || (s == null ? void 0 : s.isSortActive()));
  }
  getRowNodes(e) {
    var i;
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const r = [...((i = this.beans.selectionSvc) == null ? void 0 : i.getSelectedNodes()) ?? []].sort((o, n) => o.rowIndex == null || n.rowIndex == null ? 0 : this.getRowIndexNumber(o) - this.getRowIndexNumber(n));
      if (r.indexOf(t) !== -1)
        return r;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent("rowDragEnter", e), this.getRowNodes(e).forEach((t) => {
      this.setRowNodeDragging(t, !0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent("rowDragMove", e), this.lastDraggingEvent = e;
    const t = tr(this.beans, e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const { dragAndDrop: s, gos: i } = this.beans, r = this.isFromThisGrid(e), o = i.get("rowDragManaged"), n = e.dragItem.rowNodes;
    o && this.shouldPreventRowMove() || (i.get("suppressMoveWhenRowDragging") || !r ? s.isDropZoneWithinThisGrid(e) && this.clientSideRowModel.highlightRowAtPixel(n[0], t) : this.moveRows(n, t));
  }
  getRowIndexNumber(e) {
    const t = e.getRowIndexString();
    return parseInt(V(t.split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel, s = t.getLastHighlightedRowNode(), i = s && s.highlighted === "Below", r = tr(this.beans, e).y, o = e.dragItem.rowNodes;
    let n = i ? 1 : 0;
    if (this.isFromThisGrid(e))
      o.forEach((a) => {
        a.rowTop < r && (n -= 1);
      }), this.moveRows(o, r, n);
    else {
      const a = Yt(this.gos);
      let l = t.getRowIndexAtPixel(r) + 1;
      t.getHighlightPosition(r) === "Above" && l--, t.updateRowData({
        add: o.filter(
          (d) => !t.getRowNode(
            (a == null ? void 0 : a({ data: d.data, level: 0, rowPinned: d.rowPinned })) ?? d.data.id
          )
        ).map((d) => d.data),
        addIndex: l
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, s = 0) {
    const i = this.beans.focusSvc, r = i.getFocusedCell(), o = r && It(this.beans, r);
    this.clientSideRowModel.ensureRowsAtPixel(e, t, s) && (o ? o.focusCell() : i.clearFocusedCell());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      R(55);
      return;
    }
    const t = this.beans.dragAndDrop;
    if (t.findExternalZone(e)) {
      R(56);
      return;
    }
    let s = {
      getContainer: e.getContainer
    };
    e.fromGrid ? s = e : (e.onDragEnter && (s.onDragEnter = (r) => {
      e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", r));
    }), e.onDragLeave && (s.onDragLeave = (r) => {
      e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", r));
    }), e.onDragging && (s.onDragging = (r) => {
      e.onDragging(this.draggingToRowDragEvent("rowDragMove", r));
    }), e.onDragStop && (s.onDragStop = (r) => {
      e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", r));
    }), e.onDragCancel && (s.onDragCancel = (r) => {
      e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", r));
    }));
    const i = {
      isInterestedIn: (r) => r === 2,
      getIconName: () => "move",
      external: !0,
      ...s
    };
    t.addDropTarget(i), this.addDestroyFunc(() => t.removeDropTarget(i));
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), s = this.onDragEnter.bind(this), i = this.onDragLeave.bind(this), r = this.onDragging.bind(this), o = this.onDragStop.bind(this), n = this.onDragCancel.bind(this);
    let a;
    return e ? a = {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (l) => {
        s(l), e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", l));
      } : s,
      onDragLeave: e.onDragLeave ? (l) => {
        i(l), e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", l));
      } : i,
      onDragging: e.onDragging ? (l) => {
        r(l), e.onDragging(this.draggingToRowDragEvent("rowDragMove", l));
      } : r,
      onDragStop: e.onDragStop ? (l) => {
        o(l), e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", l));
      } : o,
      onDragCancel: e.onDragCancel ? (l) => {
        n(l), e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", l));
      } : n,
      fromGrid: !0
    } : a = {
      getContainer: t,
      onDragEnter: s,
      onDragLeave: i,
      onDragging: r,
      onDragStop: o,
      onDragCancel: n,
      /* @private */
      fromGrid: !0
    }, a;
  }
  draggingToRowDragEvent(e, t) {
    const s = this.beans, { pageBounds: i, rowModel: r, gos: o } = s, n = tr(s, t).y, a = n > i.getCurrentPageHeight();
    let l = -1, d;
    return a || (l = r.getRowIndexAtPixel(n), d = r.getRow(l)), o.addGridCommonParams({
      type: e,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: l,
      overNode: d,
      y: n,
      vDirection: t.vDirection
    });
  }
  dispatchGridEvent(e, t) {
    const s = this.draggingToRowDragEvent(e, t);
    this.eventSvc.dispatchEvent(s);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent("rowDragEnd", e), this.stopDragging(e);
    const { dragAndDrop: t, gos: s } = this.beans;
    s.get("rowDragManaged") && (s.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && t.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  onDragCancel(e) {
    this.dispatchGridEvent("rowDragCancel", e), this.stopDragging(e);
    const { dragAndDrop: t, gos: s } = this.beans;
    s.get("rowDragManaged") && (s.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && t.isDropZoneWithinThisGrid(e) && this.clearRowHighlight();
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      this.setRowNodeDragging(t, !1);
    });
  }
  setRowNodeDragging(e, t) {
    e.dragging !== t && (e.dragging = t, e.dispatchRowEvent("draggingChanged"));
  }
};
function Ou(e, t, s) {
  if (s === 0)
    return !1;
  const i = Math.abs(e.clientX - t.clientX), r = Math.abs(e.clientY - t.clientY);
  return Math.max(i, r) <= s;
}
var Ew = class extends P {
  constructor() {
    super(...arguments), this.beanName = "dragSvc", this.dragEndFunctions = [], this.dragSources = [];
  }
  destroy() {
    const { dragSources: e } = this;
    e.forEach(this.removeListener.bind(this)), e.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, s = e.mouseDownListener;
    if (t.removeEventListener("mousedown", s), e.touchEnabled) {
      const i = e.touchStartListener;
      t.removeEventListener("touchstart", i, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const { dragSources: t } = this, s = t.find((i) => i.dragSource === e);
    s && (this.removeListener(s), be(t, s));
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: s, includeTouch: i, stopPropagationForTouch: r } = e;
    s.addEventListener("mousedown", t);
    let o = null;
    const n = this.gos.get("suppressTouch");
    i && !n && (o = (a) => {
      sl(a.target) || (r && a.stopPropagation(), this.onTouchStart(e, a));
    }, s.addEventListener("touchstart", o, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: o,
      touchEnabled: !!i
    });
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const s = t.touches[0];
    this.touchLastTime = s, this.touchStart = s;
    const i = (l) => this.onTouchMove(l, e.eElement), r = (l) => this.onTouchUp(l, e.eElement), o = (l) => {
      l.cancelable && l.preventDefault();
    }, n = t.target, a = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: xi(this.beans),
        type: "touchmove",
        listener: o,
        options: { passive: !1 }
      },
      { target: n, type: "touchmove", listener: i, options: { passive: !0 } },
      { target: n, type: "touchend", listener: r, options: { passive: !0 } },
      { target: n, type: "touchcancel", listener: r, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onCommonMove(s, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const s = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || s._alreadyProcessedByDragService || (s._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const i = (d) => this.onMouseMove(d, e.eElement), r = (d) => this.onMouseUp(d, e.eElement), o = (d) => d.preventDefault(), n = (d) => {
      d.key === w.ESCAPE && this.cancelDrag(e.eElement);
    }, a = xi(this.beans), l = [
      { target: a, type: "mousemove", listener: i },
      { target: a, type: "mouseup", listener: r },
      { target: a, type: "contextmenu", listener: o },
      { target: a, type: "keydown", listener: n }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: s, type: i, listener: r, options: o } = t;
      s.addEventListener(i, r, o);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: s, type: i, listener: r, options: o } = t;
        s.removeEventListener(i, r, o);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: s } = this.currentDragParams, i = A(s) ? s : 4;
    return Ou(e, t, i);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, s) {
    var i;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(e, t))
        return;
      if (this.dragging = !0, this.eventSvc.dispatchEvent({
        type: "dragStarted",
        target: s
      }), this.currentDragParams.onDragStart(t), !this.currentDragParams) {
        this.dragging = !1;
        return;
      }
      this.currentDragParams.onDragging(t);
    }
    (i = this.currentDragParams) == null || i.onDragging(e);
  }
  onTouchMove(e, t) {
    const s = this.getFirstActiveTouch(e.touches);
    s && this.onCommonMove(s, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var s;
    si() && ((s = Z(this.beans).getSelection()) == null || s.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const { gos: t } = this, s = t.get("enableCellTextSelection"), i = e.type === "mousemove", r = (o) => {
      const n = o.target, a = n == null ? void 0 : n.tagName.toLocaleLowerCase();
      return !!(a != null && a.match("^a$|textarea|input|select|button"));
    };
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      s && i && e.cancelable && To(t, e) && !r(e)
    );
  }
  onTouchUp(e, t) {
    let s = this.getFirstActiveTouch(e.changedTouches);
    s || (s = this.touchLastTime), this.onUpCommon(s, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    this.dragging && (this.dragging = !1, this.currentDragParams.onDragStop(e), this.eventSvc.dispatchEvent({
      type: "dragStopped",
      target: t
    })), this.resetDragProperties();
  }
  cancelDrag(e) {
    var t, s;
    this.eventSvc.dispatchEvent({
      type: "dragCancelled",
      target: e
    }), (s = (t = this.currentDragParams) == null ? void 0 : t.onDragCancel) == null || s.call(t), this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null;
    const { dragEndFunctions: e } = this;
    e.forEach((t) => t()), e.length = 0;
  }
};
function Gu(e, t) {
  return e + "_" + t;
}
function de(e) {
  return e instanceof Bu;
}
var Bu = class extends P {
  constructor(e, t, s, i) {
    super(), this.providedColumnGroup = e, this.groupId = t, this.partId = s, this.pinned = i, this.isColumn = !1, this.displayedChildren = [], this.autoHeaderHeight = null, this.parent = null;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  getUniqueId() {
    return Gu(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      de(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = V(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    var t;
    let e = 0;
    return (t = this.displayedChildren) == null || t.forEach((s) => {
      e += s.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  isAutoHeaderHeight() {
    var e;
    return !!((e = this.getColGroupDef()) != null && e.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      Bt(t) ? e.push(t) : de(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      Bt(t) ? e.push(t) : de(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((s) => {
      if (de(s) && (!s.displayedChildren || !s.displayedChildren.length))
        return;
      switch (s.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(s);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(s);
          break;
        default:
          this.displayedChildren.push(s);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, fr = "row-group-", Vu = "t-", Nu = "b-", Mw = 0, Qe = class {
  constructor(e) {
    this.master = !1, this.detail = void 0, this.rowIndex = null, this.key = null, this.sourceRowIndex = -1, this.childrenMapped = {}, this.treeNode = null, this.treeNodeFlags = 0, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = Mw++, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.__selected = !1, this.beans = e;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(e) {
    this.setDataCommon(e, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(e) {
    this.setDataCommon(e, !0);
  }
  setDataCommon(e, t) {
    var r, o, n;
    const s = this.data;
    this.data = e, (r = this.beans.valueCache) == null || r.onDataChanged(), this.updateDataOnDetailNode(), (o = this.beans.selectionSvc) == null || o.updateRowSelectable(this), this.resetQuickFilterAggregateText();
    const i = this.createDataChangedEvent(e, s, t);
    (n = this.__localEventService) == null || n.dispatchEvent(i);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(e, t, s) {
    return {
      type: "dataChanged",
      node: this,
      oldData: t,
      newData: e,
      update: s
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (z(13), null) : this.rowPinned === "top" ? Vu + this.rowIndex : this.rowPinned === "bottom" ? Nu + this.rowIndex : this.rowIndex.toString();
  }
  setDataAndId(e, t) {
    var n, a;
    const { selectionSvc: s } = this.beans, i = (n = s == null ? void 0 : s.createDaemonNode) == null ? void 0 : n.call(s, this), r = this.data;
    this.data = e, this.updateDataOnDetailNode(), this.setId(t), s && (s.updateRowSelectable(this), s.syncInRowNode(this, i));
    const o = this.createDataChangedEvent(e, r, !1);
    (a = this.__localEventService) == null || a.dispatchEvent(o);
  }
  setId(e) {
    var s;
    const t = Yt(this.beans.gos);
    if (t)
      if (this.data) {
        const i = ((s = this.parent) == null ? void 0 : s.getRoute()) ?? [];
        this.id = t({
          data: this.data,
          parentKeys: i.length > 0 ? i : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith(fr) && z(14, {
          groupPrefix: fr
        });
      } else
        this.id = void 0;
    else
      this.id = e;
  }
  setRowTop(e) {
    this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.dispatchRowEvent("topChanged"), this.setDisplayed(e !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setHovered(e) {
    this.hovered = e;
  }
  isHovered() {
    return this.hovered;
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(e, t = !1) {
    this.rowHeight = e, this.rowHeightEstimated = t, this.dispatchRowEvent("heightChanged");
  }
  setExpanded(e, t, s) {
    var i;
    (i = this.beans.expansionSvc) == null || i.setExpanded(this, e, t, s);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(e, t, s) {
    const { colModel: i, valueSvc: r, gos: o, selectionSvc: n } = this.beans, a = typeof e != "string" ? e : i.getCol(e) ?? i.getColDefCol(e);
    if (!a)
      return !1;
    const l = r.getValueForDisplay(a, this);
    if (o.get("readOnlyEdit")) {
      const {
        beans: { eventSvc: c },
        data: h,
        rowIndex: u,
        rowPinned: p
      } = this;
      return c.dispatchEvent({
        type: "cellEditRequest",
        event: null,
        rowIndex: u,
        rowPinned: p,
        column: a,
        colDef: a.colDef,
        data: h,
        node: this,
        oldValue: l,
        newValue: t,
        value: t,
        source: s
      }), !1;
    }
    const d = r.setValue(this, a, t, s);
    return this.dispatchCellChangedEvent(a, t, l), n == null || n.updateRowSelectable(this), d;
  }
  updateHasChildren() {
    let e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    const { rowChildrenSvc: t } = this.beans;
    t && (e = t.getHasChildrenValue(this)), e !== this.__hasChildren && (this.__hasChildren = !!e, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  dispatchCellChangedEvent(e, t, s) {
    var r;
    const i = {
      type: "cellChanged",
      node: this,
      column: e,
      newValue: t,
      oldValue: s
    };
    (r = this.__localEventService) == null || r.dispatchEvent(i);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    var e;
    return ((e = this.beans.expansionSvc) == null ? void 0 : e.isExpandable(this)) ?? !1;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.__selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(e) {
    var t;
    (t = this.childrenAfterGroup) == null || t.forEach((s) => s.depthFirstSearch(e)), e(this);
  }
  dispatchRowEvent(e) {
    var t;
    (t = this.__localEventService) == null || t.dispatchEvent({
      type: e,
      node: this
    });
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(e, t = !1, s = "api") {
    var i;
    (i = this.beans.selectionSvc) == null || i.setNodesSelected({
      nodes: [this],
      newValue: e,
      clearSelection: t,
      source: s
    });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return !!this.rowPinned;
  }
  /** Add an event listener. */
  addEventListener(e, t) {
    var i, r, o, n;
    (i = this.beans.validation) == null || i.checkRowEvents(e), this.__localEventService || (this.__localEventService = new Rs()), this.frameworkEventListenerService = (o = (r = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : o.call(
      r,
      this.frameworkEventListenerService,
      this.__localEventService
    );
    const s = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(t)) ?? t;
    this.__localEventService.addEventListener(e, s);
  }
  /** Remove event listener. */
  removeEventListener(e, t) {
    var i;
    if (!this.__localEventService)
      return;
    const s = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(t)) ?? t;
    this.__localEventService.removeEventListener(e, s), this.__localEventService.noRegisteredListenersExist() && (this.__localEventService = null);
  }
  /**
   * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
   *
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (R(61), this.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of keys to the row node. Returns undefined if the node has no key.
   */
  getRoute() {
    if (this.level === -1)
      return [];
    if (this.key == null)
      return;
    const e = [];
    let t = this;
    for (; t && t.key != null; )
      e.push(t.key), t = t.parent;
    return e.reverse();
  }
  setFirstChild(e) {
    this.firstChild !== e && (this.firstChild = e, this.dispatchRowEvent("firstChildChanged"));
  }
  setDisplayed(e) {
    this.displayed !== e && (this.displayed = e, this.dispatchRowEvent("displayedChanged"));
  }
  setRowIndex(e) {
    this.rowIndex !== e && (this.rowIndex = e, this.dispatchRowEvent("rowIndexChanged"));
  }
  setAllChildrenCount(e) {
    this.allChildrenCount !== e && (this.allChildrenCount = e, this.dispatchRowEvent("allChildrenCountChanged"));
  }
  setUiLevel(e) {
    this.uiLevel !== e && (this.uiLevel = e, this.dispatchRowEvent("uiLevelChanged"));
  }
};
function Hu(e, t, s) {
  return t.addGridCommonParams({
    type: s,
    node: e,
    data: e.data,
    rowIndex: e.rowIndex,
    rowPinned: e.rowPinned
  });
}
var sn = class extends L {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-filter"></div>'
    ), this.column = e, this.source = t, this.filterWrapper = null;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e;
    return ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null;
  }
  afterInit() {
    var e, t;
    return ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) ?? U.resolve();
  }
  afterGuiAttached(e) {
    var t, s;
    (s = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || s.then((i) => {
      var r;
      (r = i == null ? void 0 : i.afterGuiAttached) == null || r.call(i, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((s) => {
      var i;
      (i = s == null ? void 0 : s.afterGuiDetached) == null || i.call(s);
    });
  }
  createFilter(e) {
    var i, r;
    const { column: t, source: s } = this;
    this.filterWrapper = ((i = this.beans.filterManager) == null ? void 0 : i.getOrCreateFilterWrapper(t)) ?? null, (r = this.filterWrapper) != null && r.filterPromise && this.filterWrapper.filterPromise.then((o) => {
      const n = o.getGui();
      A(n) || R(69, { guiFromFilter: n }), this.appendChild(n), e && this.eventSvc.dispatchEvent({
        type: "filterOpened",
        column: t,
        source: s,
        eGui: this.getGui()
      });
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.beans.colModel.getColDefCol(this.column) && (X(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, zu = "ag-resizer-wrapper", is = (e, t) => `<div data-ref="${e}Resizer" class="ag-resizer ag-resizer-${t}"></div>`, Aw = (
  /* html */
  `<div class="${zu}">
        ${is("eTopLeft", "topLeft")}
        ${is("eTop", "top")}
        ${is("eTopRight", "topRight")}
        ${is("eRight", "right")}
        ${is("eBottomRight", "bottomRight")}
        ${is("eBottom", "bottom")}
        ${is("eBottomLeft", "bottomLeft")}
        ${is("eLeft", "left")}
    </div>`
), rn = class extends P {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.dragSvc = e.dragSvc;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, s = t / 2 - this.getWidth() / 2, i = e / 2 - this.getHeight() / 2;
    this.offsetElement(s, i);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: s, width: i, minHeight: r, height: o, x: n, y: a } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, d = 0;
    const c = ke(this.element);
    if (c) {
      const h = this.findBoundaryElement(), u = window.getComputedStyle(h);
      if (u.minWidth != null) {
        const p = h.offsetWidth - this.element.offsetWidth;
        d = parseInt(u.minWidth, 10) - p;
      }
      if (u.minHeight != null) {
        const p = h.offsetHeight - this.element.offsetHeight;
        l = parseInt(u.minHeight, 10) - p;
      }
    }
    if (this.minHeight = r || l, this.minWidth = s || d, i && this.setWidth(i), o && this.setHeight(o), (!i || !o) && this.refreshSize(), e)
      this.center();
    else if (n || a)
      this.offsetElement(n, a);
    else if (c && t) {
      let h = this.boundaryEl, u = !0;
      if (h || (h = this.findBoundaryElement(), u = !1), h) {
        const p = parseFloat(h.style.top), g = parseFloat(h.style.left);
        u ? this.offsetElement(isNaN(g) ? 0 : g, isNaN(p) ? 0 : p) : this.setPosition(g, p);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    var i, r;
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const s = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? ((i = this.dragSvc) == null || i.addDragSource(s), this.moveElementDragListener = s) : ((r = this.dragSvc) == null || r.removeDragSource(s), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      var n;
      const i = !!e[t], r = this.getResizerElement(t), o = {
        dragStartPixels: 0,
        eElement: r,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (i || !this.isAlive() && !i) && (i ? ((n = this.dragSvc) == null || n.addDragSource(o), this.resizeListeners.push(o), r.style.pointerEvents = "all") : r.style.pointerEvents = "none", this.resizable[t] = i);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, s = this.element;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Qi(s, e), e = jo(s), i = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const r = this.getAvailableHeight();
      r && e > r && (e = r);
    }
    this.getHeight() !== e && (i ? (s.style.maxHeight = "unset", s.style.minHeight = "unset") : t ? Qi(s, e) : (s.style.height = `${e}px`, s.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: s } = this.offsetParent;
    if (!s)
      return null;
    const i = this.element.getBoundingClientRect(), r = this.offsetParent.getBoundingClientRect(), o = e ? this.position.y : i.top, n = e ? 0 : r.top;
    let a = 0;
    if (t) {
      const d = this.element.parentElement;
      if (d) {
        const { bottom: c } = d.getBoundingClientRect();
        a = c - i.bottom;
      }
    }
    return s + n - o - a;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: s } = this.config;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      yt(t, e), e = $s(t), i = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: r } = this.offsetParent, o = s ? this.position.x : this.element.getBoundingClientRect().left;
      r && e + o > r && (e = r - o);
    }
    this.getWidth() !== e && (i ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? yt(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    var r;
    const { forcePopupParentAsOffsetParent: s } = this.config, i = s ? this.boundaryEl : this.element;
    i && ((r = this.popupSvc) == null || r.positionPopup({
      ePopup: i,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(i.style.left), parseFloat(i.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    var s;
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const i = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${i}px`);
    };
    e && this.popupSvc ? this.resizeObserverSubscriber = Rt(
      this.beans,
      (s = this.popupSvc) == null ? void 0 : s.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: s, isTop: i, anywhereWithin: r, topBuffer: o } = e, n = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!s, !!r, n) ? 0 : n, d = this.shouldSkipY(t, !!i, o, a) ? 0 : a;
    return { movementX: l, movementY: d };
  }
  shouldSkipX(e, t, s, i) {
    const r = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), n = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.x : r.left;
    let l = a <= 0 && o.left >= e.clientX || o.right <= e.clientX && o.right <= n.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    i < 0 && e.clientX > a + o.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    i > 0 && e.clientX < a + o.left : s ? l = i < 0 && e.clientX > n.right || i > 0 && e.clientX < a + o.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    i < 0 && e.clientX > n.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    i > 0 && e.clientX < n.right, l);
  }
  shouldSkipY(e, t, s = 0, i) {
    const r = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), n = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.y : r.top;
    let l = a <= 0 && o.top >= e.clientY || o.bottom <= e.clientY && o.bottom <= n.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    i < 0 && e.clientY > a + o.top + s || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    i > 0 && e.clientY < a + o.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    i < 0 && e.clientY > n.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    i > 0 && e.clientY < n.bottom, l);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[data-ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[data-ref=eTopResizer]") },
      topRight: { element: e.querySelector("[data-ref=eTopRightResizer]") },
      right: { element: e.querySelector("[data-ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[data-ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[data-ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[data-ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[data-ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const s = new DOMParser().parseFromString(Aw, "text/html").body;
    e.appendChild(s.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${zu}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: s, forcePopupParentAsOffsetParent: i } = this.config;
    !s && !i && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((s) => !s.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, s = 0;
    for (let i = 0; i < e.length; i++) {
      const r = e[i], o = !!r.style.flex && r.style.flex !== "0 0 auto";
      if (r === this.element)
        continue;
      let n = this.minHeight || 0, a = this.minWidth || 0;
      if (o) {
        const l = window.getComputedStyle(r);
        l.minHeight && (n = parseInt(l.minHeight, 10)), l.minWidth && (a = parseInt(l.minWidth, 10));
      } else
        n = r.offsetHeight, a = r.offsetWidth;
      t += n, s += a;
    }
    return { height: t, width: s };
  }
  applySizeToSiblings(e) {
    let t = null;
    const s = this.getSiblings();
    if (s) {
      for (let i = 0; i < s.length; i++) {
        const r = s[i];
        r !== t && (e ? r.style.height = `${r.offsetHeight}px` : r.style.width = `${r.offsetWidth}px`, r.style.flex = "0 0 auto", r === this.element && (t = s[i + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: s } = this.config, { isTop: i, isRight: r, isBottom: o, isLeft: n } = this.currentResizer, a = r || n, l = o || i, { movementX: d, movementY: c } = this.calculateMouseMovement({ e, isLeft: n, isTop: i }), h = this.position.x, u = this.position.y;
    let p = 0, g = 0;
    if (a && d) {
      const f = n ? -1 : 1, m = this.getWidth(), C = m + d * f;
      let v = !1;
      n && (p = m - C, (h + p <= 0 || C <= this.minWidth) && (v = !0, p = 0)), v || this.setWidth(C);
    }
    if (l && c) {
      const f = i ? -1 : 1, m = this.getHeight(), C = m + c * f;
      let v = !1;
      i ? (g = m - C, (u + g <= 0 || C <= this.minHeight) && (v = !0, g = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && m < C && this.getMinSizeOfSiblings().height + C > this.element.parentElement.offsetHeight && (v = !0), v || this.setHeight(C);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || s) && p || g) && this.offsetElement(h + p, u + g);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: s } = this.position;
    let i;
    this.config.calculateTopBuffer && (i = this.config.calculateTopBuffer());
    const { movementX: r, movementY: o } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: i
    });
    this.offsetElement(t + r, s + o), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent && this.popupSvc ? this.offsetParent = this.popupSvc.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    var e;
    for (; this.resizeListeners.length; ) {
      const t = this.resizeListeners.pop();
      (e = this.dragSvc) == null || e.removeDragSource(t);
    }
  }
  destroy() {
    var e;
    super.destroy(), this.moveElementDragListener && ((e = this.dragSvc) == null || e.removeDragSource(this.moveElementDragListener)), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, Wu = "ag-focus-managed", Ps = class extends P {
  constructor(e, t = {}) {
    super(), this.eFocusable = e, this.callbacks = t, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (s) => {
        if (s.defaultPrevented)
          return;
        const i = Pe(this.beans, this.eFocusable, !1, s.shiftKey);
        i && (i.focus(), s.preventDefault());
      },
      ...t
    };
  }
  postConstruct() {
    const {
      eFocusable: e,
      callbacks: { onFocusIn: t, onFocusOut: s }
    } = this;
    e.classList.add(Wu), this.addKeyDownListeners(e), t && this.addManagedElementListeners(e, { focusin: t }), s && this.addManagedElementListeners(e, { focusout: s });
  }
  addKeyDownListeners(e) {
    this.addManagedElementListeners(e, {
      keydown: (t) => {
        if (t.defaultPrevented || nt(t))
          return;
        const { callbacks: s } = this;
        if (s.shouldStopEventPropagation(t)) {
          he(t);
          return;
        }
        t.key === w.TAB ? s.onTabKeyDown(t) : s.handleKeyDown && s.handleKeyDown(t);
      }
    });
  }
}, _u = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
function wl(e, t) {
  const { debounceMs: s } = e;
  return Do(e) ? (s != null && R(71), 0) : s ?? t;
}
function Do(e) {
  var t;
  return (((t = e.buttons) == null ? void 0 : t.indexOf("apply")) ?? -1) >= 0;
}
var on = class extends L {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.eFilterBody = S, this.buttonListeners = [], this.defaultDebounceMs = 0;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(
      new Ps(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = new rn(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const s = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(s, this.getAgComponents(), e), t = this.getGui(), t == null || t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.params.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.params = e, this.applyActive = Do(e), this.resetButtonsPanel(e);
  }
  updateParams(e) {
    this.params = e, this.applyActive = Do(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel(e, t) {
    const { buttons: s, readOnly: i } = t ?? {}, { buttons: r, readOnly: o } = e;
    if (i === o && bi(s, r))
      return;
    const n = r && r.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (X(this.eButtonsPanel), this.buttonListeners.forEach((d) => d()), this.buttonListeners = []) : n && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !n) {
      this.eButtonsPanel && ce(this.eButtonsPanel);
      return;
    }
    const a = document.createDocumentFragment(), l = (d) => {
      let c;
      const h = d ? this.translate(`${d}Filter`) : void 0;
      switch (d) {
        case "apply":
          c = (g) => this.onBtApply(!1, !1, g);
          break;
        case "clear":
          c = () => this.onBtClear();
          break;
        case "reset":
          c = () => this.onBtReset();
          break;
        case "cancel":
          c = (g) => {
            this.onBtCancel(g);
          };
          break;
        default:
          R(75);
          return;
      }
      const p = Be(
        /* html */
        `<button
                    type="${d === "apply" ? "submit" : "button"}"
                    data-ref="${d}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${h}
                </button>`
      );
      this.buttonListeners.push(...this.addManagedElementListeners(p, { click: c })), a.append(p);
    };
    r.forEach((d) => l(d)), this.eButtonsPanel.append(a), this.getGui().appendChild(this.eButtonsPanel);
  }
  setupOnBtApplyDebounce() {
    const e = wl(this.params, this.defaultDebounceMs), t = Ce(this, this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ?? null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.params.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const s = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(s) : this.resetUiToDefaults().then(s);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const s = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(s, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, s) {
    s && s.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.params.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: i } = this.params;
    i && this.applyActive && !e && !t && this.close(s);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, s = t && t.key;
    let i;
    (s === "Enter" || s === "Space") && (i = { keyboardEvent: t }), this.hidePopup(i), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.params.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const s = this.isModelValid(this.getModelFromUi()), i = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      i && lt(i, !s);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    const { positionableFeature: t, gos: s } = this;
    if (!t || e === "toolPanel")
      return;
    e === "floatingFilter" || e === "columnFilter" ? (t.restoreLastSize(), t.setResizable(
      s.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (t.removeSizeFromEl(), t.setResizable(!1)), t.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    var e;
    this.checkApplyDebounce(), (e = this.positionableFeature) == null || e.constrainSizeToAvailableHeight(!1);
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.resetButtonsPanel(e, t), !0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.getLocaleTextFunc()(e, _u[e]);
  }
  getCellValue(e) {
    return this.params.getValue(e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
};
function Uu(e, t, s) {
  if (t == null)
    return null;
  let i = null;
  const { compName: r, jsComp: o, fwComp: n } = jv(e, t);
  return r ? i = {
    agSetColumnFilter: "agSetColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[r] : o == null && n == null && t.filter === !0 && (i = s()), i;
}
var vt = {
  AUTO_HEIGHT: "ag-layout-auto-height",
  NORMAL: "ag-layout-normal",
  PRINT: "ag-layout-print"
}, yl = class extends P {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.gos.get("domLayout"), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, s = t.autoHeight ? vt.AUTO_HEIGHT : t.print ? vt.PRINT : vt.NORMAL;
    this.view.updateLayoutClasses(s, t);
  }
}, rs = "Viewport", kd = "fakeVScrollComp", Od = [
  "fakeHScrollComp",
  "centerHeader",
  "topCenter",
  "bottomCenter",
  "stickyTopCenter",
  "stickyBottomCenter"
], Iw = class extends P {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.scrollTimer = 0, this.needsRefreshedScrollPosition = !0, this.eBodyViewport = e, this.resetLastHScrollDebounced = Ce(
      this,
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      500
    ), this.resetLastVScrollDebounced = Ce(
      this,
      () => this.lastScrollSource[
        0
        /* Vertical */
      ] = null,
      500
    );
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.animationFrameSvc = e.animationFrameSvc, this.visibleCols = e.visibleCols;
  }
  destroy() {
    super.destroy(), window.clearTimeout(this.scrollTimer);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    const e = this.requireUpdatedScrollPosition.bind(this);
    this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      gridSizeChanged: e
    }), this.addManagedElementListeners(this.eBodyViewport, {
      scroll: e
    }), this.ctrlsSvc.whenReady(this, (t) => {
      this.centerRowsCtrl = t.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  requireUpdatedScrollPosition() {
    this.needsRefreshedScrollPosition = !0;
  }
  addScrollListener() {
    this.addHorizontalScrollListeners(), this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
      scroll: this.onHScroll.bind(this, rs)
    });
    for (const e of Od) {
      const t = this.ctrlsSvc.get(e);
      this.registerScrollPartner(t, this.onHScroll.bind(this, e));
    }
  }
  addVerticalScrollListeners() {
    const e = this.ctrlsSvc.get("fakeVScrollComp"), t = this.gos.get("debounceVerticalScrollbar"), s = t ? Ce(this, this.onVScroll.bind(this, rs), 100) : this.onVScroll.bind(this, rs), i = t ? Ce(this, this.onVScroll.bind(this, kd), 100) : this.onVScroll.bind(this, kd);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: s }), this.registerScrollPartner(e, i);
  }
  registerScrollPartner(e, t) {
    e.onScrollCallback(t);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    this.centerRowsCtrl != null && (e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft()), this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)));
  }
  setScrollLeftForAllContainersExceptCurrent(e) {
    for (const t of [...Od, rs]) {
      if (this.lastScrollSource[
        1
        /* Horizontal */
      ] === t)
        continue;
      const s = this.getViewportForSource(t);
      go(s, e, this.enableRtl);
    }
  }
  getViewportForSource(e) {
    return e === rs ? this.centerRowsCtrl.eViewport : this.ctrlsSvc.get(e).eViewport;
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (t === 0 ? this.lastScrollSource[0] = e : this.lastScrollSource[1] = e, !0) : this.lastScrollSource[t] === e;
  }
  onHScroll(e) {
    if (!this.isControllingScroll(
      e,
      1
      /* Horizontal */
    ))
      return;
    const t = this.centerRowsCtrl.eViewport, { scrollLeft: s } = t;
    if (this.shouldBlockScrollUpdate(1, s, !0))
      return;
    const i = po(this.getViewportForSource(e), this.enableRtl);
    this.doHorizontalScroll(i), this.resetLastHScrollDebounced();
  }
  onVScroll(e) {
    if (!this.isControllingScroll(
      e,
      0
      /* Vertical */
    ))
      return;
    let t;
    if (e === rs ? t = this.eBodyViewport.scrollTop : t = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition(), this.shouldBlockScrollUpdate(0, t, !0))
      return;
    const { animationFrameSvc: s } = this;
    s == null || s.setScrollTop(t), this.nextScrollTop = t, e === rs ? this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, !s || this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : s.schedule(), this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventSvc.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = window.setTimeout(() => {
      this.scrollTimer = 0, this.eventSvc.dispatchEvent({
        ...t,
        type: "bodyScrollEnd"
      });
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, s = !1) {
    return s && !fs() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = $o(this.eBodyViewport), { scrollHeight: s } = this.eBodyViewport;
    return e < 0 || e + t > s;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: s } = this.centerRowsCtrl.eViewport;
    if (this.enableRtl && uo()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > s;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScroll(rs);
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const i = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && uo() ? e = e > 0 ? 0 : i : e = Math.min(Math.max(e, 0), i)), go(this.centerRowsCtrl.eViewport, Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    if (!this.needsRefreshedScrollPosition) {
      const { lastOffsetHeight: s, lastScrollTop: i } = this;
      return {
        top: i,
        bottom: i + s
      };
    }
    this.needsRefreshedScrollPosition = !1;
    const { scrollTop: e, offsetHeight: t } = this.eBodyViewport;
    return this.lastScrollTop = e, this.lastOffsetHeight = t, {
      top: e,
      bottom: e + t
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.eViewport.scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.eViewport.scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const { rowModel: s } = this.beans, i = s.getRowCount();
    let r = -1;
    for (let o = 0; o < i; o++) {
      const n = s.getRow(o);
      if (typeof e == "function") {
        if (n && e(n)) {
          r = o;
          break;
        }
      } else if (e === n || e === n.data) {
        r = o;
        break;
      }
    }
    r >= 0 && this.ensureIndexVisible(r, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (ye(this.gos, "print"))
      return;
    const { rowModel: s } = this.beans, i = s.getRowCount();
    if (typeof e != "number" || e < 0 || e >= i) {
      R(88, { index: e });
      return;
    }
    const o = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel"), {
      frameworkOverrides: n,
      pagination: a,
      pageBounds: l,
      rowContainerHeight: d,
      rowRenderer: c
    } = this.beans;
    n.wrapIncoming(() => {
      var m;
      o || a == null || a.goToPageWithIndex(e);
      const h = this.ctrlsSvc.getGridBodyCtrl(), u = h.stickyTopHeight, p = h.stickyBottomHeight, g = s.getRow(e);
      let f;
      do {
        const C = g.rowTop, v = g.rowHeight, b = l.getPixelOffset(), y = g.rowTop - b, F = y + g.rowHeight, D = this.getVScrollPosition(), x = d.divStretchOffset, T = D.top + x, I = D.bottom + x, E = I - T, M = d.getScrollPositionForPixel(y), N = d.getScrollPositionForPixel(F - E), _ = Math.min((M + N) / 2, y), H = T + u > y, W = I - p < F;
        let K = null;
        t === "top" ? K = M : t === "bottom" ? K = N : t === "middle" ? K = _ : H ? K = M - u : W && (K = N + p), K !== null && (this.setVerticalScrollPosition(K), c.redraw({ afterScroll: !0 })), f = C !== g.rowTop || v !== g.rowHeight;
      } while (f);
      (m = this.animationFrameSvc) == null || m.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const { colModel: s, frameworkOverrides: i } = this.beans, r = s.getCol(e);
    if (!r || r.isPinned() || !this.visibleCols.isColDisplayed(r))
      return;
    const o = this.getPositionedHorizontalScroll(r, t);
    i.wrapIncoming(() => {
      var n;
      o !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(o), this.centerRowsCtrl.onHorizontalViewportChanged(), (n = this.animationFrameSvc) == null || n.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: s, columnAfterEnd: i } = this.isColumnOutsideViewport(e), r = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), o = this.centerRowsCtrl.getCenterWidth(), n = this.enableRtl;
    let a = (n ? s : i) || r, l = n ? i : s;
    t !== "auto" && (a = t === "start", l = t === "end");
    const d = t === "middle";
    if (a || l || d) {
      const { colLeft: c, colMiddle: h, colRight: u } = this.getColumnBounds(e);
      return d ? h - o / 2 : a ? n ? u : c : n ? c - o : u - o;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: s } = this.getViewportBounds(), { colLeft: i, colRight: r } = this.getColumnBounds(e), o = this.enableRtl, n = o ? t > r : s < r, a = o ? s < i : t > i;
    return { columnBeforeStart: n, columnAfterEnd: a };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, s = this.visibleCols.bodyWidth, i = e.getActualWidth(), r = e.getLeft(), o = t ? -1 : 1, n = t ? s - r : r, a = n + i * o, l = n + i / 2 * o;
    return { colLeft: n, colMiddle: l, colRight: a };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), s = t, i = e + t;
    return { start: s, end: i, width: e };
  }
}, bl = class extends P {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = ye(this.gos, "print"), { visibleCols: t, scrollVisibleSvc: s } = this.beans, i = t.bodyWidth, r = t.getColsLeftWidth(), o = t.getDisplayedColumnsRightWidth();
    let n;
    e ? n = i + r + o : (n = i, this.addSpacer && (this.gos.get("enableRtl") ? r : o) === 0 && s.verticalScrollShowing && (n += s.getScrollbarWidth())), this.callback(n);
  }
}, Lw = class extends P {
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  wireBeans(e) {
    this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const { beans: e, centerContainerCtrl: t, gridBodyCtrl: s } = this, i = () => {
      pt(e, () => {
        this.onCenterViewportResized();
      });
    };
    t.registerViewportResizeListener(i), s.registerBodyViewportResizeListener(i);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.scrollVisibleSvc.updateScrollGap(), this.centerContainerCtrl.isViewportInTheDOMTree()) {
      const { pinnedCols: e, colFlex: t } = this.beans;
      e == null || e.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const s = this.centerContainerCtrl.getCenterWidth();
      s !== this.centerWidth && (this.centerWidth = s, t == null || t.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.scrollFeature.checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.eBodyViewport, t = $o(e);
    this.bodyHeight !== t && (this.bodyHeight = t, this.eventSvc.dispatchEvent({
      type: "bodyHeightChanged"
    }));
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleSvc.setScrollsVisible(e);
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(e, t);
  }
};
function Sl(e, t, s, i, r, o) {
  if (s == null && t == null)
    return;
  const n = {}, a = {}, l = (d, c) => {
    d.split(" ").forEach((h) => {
      h.trim() != "" && c(h);
    });
  };
  if (s) {
    const d = Object.keys(s);
    for (let c = 0; c < d.length; c++) {
      const h = d[c], u = s[h];
      let p;
      typeof u == "string" ? p = e ? e.evaluate(u, i) : !0 : typeof u == "function" && (p = u(i)), l(h, (g) => {
        p ? n[g] = !0 : a[g] = !0;
      });
    }
  }
  t && o && Object.keys(t).forEach(
    (d) => l(d, (c) => {
      n[c] || (a[c] = !0);
    })
  ), o && Object.keys(a).forEach(o), Object.keys(n).forEach(r);
}
function Gd(e) {
  if (e.group)
    return e.level;
  const t = e.parent;
  return t ? t.level + 1 : 0;
}
var kw = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowStyleSvc";
  }
  processClassesFromGridOptions(e, t) {
    const s = this.gos, i = (n) => {
      typeof n == "string" ? e.push(n) : Array.isArray(n) && n.forEach((a) => e.push(a));
    }, r = s.get("rowClass");
    r && i(r);
    const o = s.getCallback("getRowClass");
    if (o) {
      const n = {
        data: t.data,
        node: t,
        rowIndex: t.rowIndex
      }, a = o(n);
      i(a);
    }
  }
  preProcessRowClassRules(e, t) {
    this.processRowClassRules(
      t,
      (s) => {
        e.push(s);
      },
      () => {
      }
    );
  }
  processRowClassRules(e, t, s) {
    const { gos: i, expressionSvc: r } = this.beans, o = i.addGridCommonParams({
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    Sl(
      r,
      void 0,
      i.get("rowClassRules"),
      o,
      t,
      s
    );
  }
  processStylesFromGridOptions(e) {
    const t = this.gos, s = t.get("rowStyle"), i = t.getCallback("getRowStyle");
    let r;
    if (i) {
      const o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      };
      r = i(o);
    }
    if (r || s)
      return Object.assign({}, s, r);
  }
}, Ow = 0, mr = "renderedRow", ba = class extends P {
  constructor(e, t, s, i, r) {
    var o;
    super(), this.rowNode = e, this.useAnimationFrameForCreate = i, this.printLayout = r, this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKey = null, this.beans = t, this.gos = t.gos, this.paginationPage = ((o = t.pagination) == null ? void 0 : o.getCurrentPage()) ?? 0, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = e.id + "-" + Ow++, this.rowId = Q(e.id), this.initRowBusinessKey(), this.rowFocused = t.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = Gd(this.rowNode), this.setRowType(), this.setAnimateFlags(s), this.rowStyles = this.processStylesFromGridOptions(), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const e = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKey = Q(e);
  }
  updateGui(e, t) {
    e === "left" ? this.leftGui = t : e === "right" ? this.rightGui = t : e === "fullWidth" ? this.fullWidthGui = t : this.centerGui = t;
  }
  setComp(e, t, s, i) {
    i = xr(this, this.beans.context, i);
    const r = { rowComp: e, element: t, containerType: s, compBean: i };
    this.allRowGuis.push(r), this.updateGui(s, r), this.initialiseRowComp(r), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(e) {
    this.allRowGuis = this.allRowGuis.filter((t) => t.containerType !== e), this.updateGui(e, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(e) {
    const t = e ? "none" : "";
    this.allRowGuis.forEach((s) => s.element.style.display = t);
  }
  initialiseRowComp(e) {
    var r;
    const t = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.listenOnDomOrder(e), (r = this.beans.rowAutoHeight) == null || r.checkAutoHeights(this.rowNode), this.onRowHeightChanged(e), this.updateRowIndexes(e), this.setFocusedClasses(e), this.setStylesFromGridOptions(!1, e), ot(t) && this.rowNode.selectable && this.onRowSelected(e), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const s = e.rowComp;
    this.getInitialRowClasses(e.containerType).forEach((o) => s.addOrRemoveCssClass(o, !0)), this.executeSlideAndFadeAnimations(e), this.rowNode.group && He(e.element, this.rowNode.expanded == !0), this.setRowCompRowId(s), this.setRowCompRowBusinessKey(s), js(t, e.element, mr, this), e.compBean.addDestroyFunc(() => js(t, e.element, mr, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameSvc.createTask(
      this.addHoverFunctionality.bind(this, e),
      this.rowNode.rowIndex,
      "createTasksP2"
    ) : this.addHoverFunctionality(e), this.isFullWidth() && this.setupFullWidth(e), t.get("rowDragEntireRow") && this.addRowDraggerToRow(e), this.useAnimationFrameForCreate && this.beans.animationFrameSvc.addDestroyTask(() => {
      this.isAlive() && e.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(e) {
    this.businessKey != null && e.setRowBusinessKey(this.businessKey);
  }
  setRowCompRowId(e) {
    const t = Q(this.rowNode.id);
    this.rowId = t, t != null && e.setRowId(t);
  }
  executeSlideAndFadeAnimations(e) {
    const { containerType: t } = e;
    this.slideInAnimation[t] && (Rd(() => {
      this.onTopChanged();
    }), this.slideInAnimation[t] = !1), this.fadeInAnimation[t] && (Rd(() => {
      e.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[t] = !1);
  }
  addRowDraggerToRow(e) {
    var i;
    const t = (i = this.beans.rowDragSvc) == null ? void 0 : i.createRowDragCompForRow(this.rowNode, e.element);
    if (!t)
      return;
    const s = this.createBean(t, this.beans.context);
    this.rowDragComps.push(s), e.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((r) => r !== s), this.destroyBean(s, this.beans.context);
    });
  }
  setupFullWidth(e) {
    const t = this.getPinnedForContainer(e.containerType), s = this.createFullWidthCompDetails(e.element, t);
    e.rowComp.showFullWidth(s);
  }
  getFullWidthCellRenderers() {
    var e, t;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((s) => {
      var i;
      return (i = s == null ? void 0 : s.rowComp) == null ? void 0 : i.getFullWidthCellRenderer();
    }) : [(t = (e = this.fullWidthGui) == null ? void 0 : e.rowComp) == null ? void 0 : t.getFullWidthCellRenderer()];
  }
  executeProcessRowPostCreateFunc() {
    const e = this.gos.getCallback("processRowPostCreate");
    if (!e || !this.areAllContainersReady())
      return;
    const t = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    e(t);
  }
  areAllContainersReady() {
    const {
      leftGui: e,
      centerGui: t,
      rightGui: s,
      beans: { visibleCols: i }
    } = this, r = !!e || !i.isPinningLeft(), o = !!t, n = !!s || !i.isPinningRight();
    return r && o && n;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this.rowNode }) : !1;
  }
  setRowType() {
    const e = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents"), t = this.isNodeFullWidthCell(), s = this.gos.get("masterDetail") && this.rowNode.detail, i = this.beans.colModel.isPivotMode(), o = !!this.rowNode.group && !this.rowNode.footer && Qo(this.gos, i);
    e ? this.rowType = "FullWidthLoading" : s ? this.rowType = "FullWidthDetail" : t ? this.rowType = "FullWidth" : o ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(e = !1, t = !1) {
    if (this.isFullWidth())
      return;
    const { animationFrameSvc: s } = this.beans;
    if (!s || e || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(t);
      return;
    }
    this.updateColumnListsPending || (s.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    ), this.updateColumnListsPending = !0);
  }
  createCellCtrls(e, t, s = null) {
    const i = {
      list: [],
      map: {}
    }, r = (o, n) => {
      i.list.push(n), i.map[o] = n;
    };
    return t.forEach((o) => {
      const n = o.getInstanceId();
      let a = e.map[n];
      a || (a = new so(o, this.rowNode, this.beans, this)), r(n, a);
    }), e.list.forEach((o) => {
      const n = o.column.getInstanceId();
      if (i.map[n] != null)
        return;
      if (!this.isCellEligibleToBeRemoved(o, s)) {
        r(n, o);
        return;
      }
      o.destroy();
    }), i;
  }
  updateColumnListsImpl(e) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(e);
  }
  setCellCtrls(e) {
    this.allRowGuis.forEach((t) => {
      const s = this.getCellCtrlsForContainer(t.containerType);
      t.rowComp.setCellCtrls(s, e);
    });
  }
  getCellCtrlsForContainer(e) {
    switch (e) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const e = this.beans.colViewport, t = this.beans.visibleCols;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t.allCols), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const s = e.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, s);
      const i = t.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const r = t.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, r, "right");
    }
  }
  isCellEligibleToBeRemoved(e, t) {
    const { column: r } = e;
    if (r.getPinned() != t)
      return !0;
    const { editing: o, cellPosition: n } = e, { focusSvc: a, visibleCols: l } = this.beans, d = a.isCellFocused(n);
    return o || d ? !(l.allCols.indexOf(r) >= 0) : !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || ye(this.gos, "print");
  }
  listenOnDomOrder(e) {
    const t = () => {
      e.rowComp.setDomOrder(this.getDomOrder());
    };
    e.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], t);
  }
  setAnimateFlags(e) {
    if (this.rowNode.sticky || !e)
      return;
    const t = A(this.rowNode.oldRowTop), { visibleCols: s } = this.beans, i = s.isPinningLeft(), r = s.isPinningRight();
    if (t) {
      const { slideInAnimation: o } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        o.fullWidth = !0;
        return;
      }
      o.center = !0, o.left = i, o.right = r;
    } else {
      const { fadeInAnimation: o } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        o.fullWidth = !0;
        return;
      }
      o.center = !0, o.left = i, o.right = r;
    }
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const e = (n, a) => n ? n.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(n.element, a).params) : !0, t = e(this.fullWidthGui, null), s = e(this.centerGui, null), i = e(this.leftGui, "left"), r = e(this.rightGui, "right");
    return t && s && i && r;
  }
  addListeners() {
    var e;
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      ...((e = this.beans.expansionSvc) == null ? void 0 : e.getRowExpandedListeners(this)) ?? {}
    }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this)
    }), this.addManagedListeners(this.beans.eventSvc, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context);
    }), this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    ), this.addManagedPropertyListener("rowDragEntireRow", () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((s) => {
          this.addRowDraggerToRow(s);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onRowIndexChanged());
      },
      cellChanged: (e) => {
        this.getAllCellCtrls().forEach((t) => t.onCellChanged(e));
      }
    });
  }
  onRowNodeDataChanged(e) {
    if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (s) => s.refreshCell({
        suppressFlash: !e.update,
        newData: !e.update
      })
    ), this.allRowGuis.forEach((s) => {
      this.setRowCompRowId(s.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(s.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const e = this.rowNode.highlighted;
    this.allRowGuis.forEach((t) => {
      const s = e === "Above", i = e === "Below";
      t.rowComp.addOrRemoveCssClass("ag-row-highlight-above", s), t.rowComp.addOrRemoveCssClass("ag-row-highlight-below", i);
    });
  }
  postProcessRowDragging() {
    const e = this.rowNode.dragging;
    this.allRowGuis.forEach((t) => t.rowComp.addOrRemoveCssClass("ag-row-dragging", e));
  }
  onDisplayedColumnsChanged() {
    var e;
    this.updateColumnLists(!0), (e = this.beans.rowAutoHeight) == null || e.checkAutoHeights(this.rowNode);
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: ge(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  findFullWidthRowGui(e) {
    return this.allRowGuis.find((t) => t.element.contains(e));
  }
  onKeyboardNavigate(e) {
    const t = this.findFullWidthRowGui(e.target);
    if (!((t ? t.element : null) === e.target))
      return;
    const r = this.rowNode, { focusSvc: o, navigation: n } = this.beans, a = o.getFocusedCell(), l = {
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      column: (a == null ? void 0 : a.column) ?? this.getColumnForFullWidth(t)
    };
    n == null || n.navigateToNextCell(e, e.key, l, !0), e.preventDefault();
  }
  onTabKeyDown(e) {
    var a;
    if (e.defaultPrevented || nt(e))
      return;
    const t = this.allRowGuis.find(
      (l) => l.element.contains(e.target)
    ), s = t ? t.element : null, i = s === e.target, r = q(this.beans);
    let o = !1;
    s && r && (o = s.contains(r) && r.classList.contains("ag-cell"));
    let n = null;
    !i && !o && (n = Pe(this.beans, s, !1, e.shiftKey)), (this.isFullWidth() && i || !n) && ((a = this.beans.navigation) == null || a.onTabKeyDown(this, e));
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var t;
    const e = (t = this.allRowGuis.find((s) => ke(s.element))) == null ? void 0 : t.element;
    return e ? e.getBoundingClientRect().top : 0;
  }
  onSuppressCellFocusChanged(e) {
    const t = this.isFullWidth() && e ? void 0 : -1;
    this.allRowGuis.forEach((s) => {
      ht(s.element, "tabindex", t);
    });
  }
  onFullWidthRowFocused(e) {
    var r;
    const t = this.rowNode, s = e ? this.isFullWidth() && e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned : !1, i = this.fullWidthGui ? this.fullWidthGui.element : (r = this.centerGui) == null ? void 0 : r.element;
    i && (i.classList.toggle("ag-full-width-focus", s), s && (e != null && e.forceBrowserFocus) && i.focus({ preventScroll: !0 }));
  }
  recreateCell(e) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, e), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, e), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, e), e.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(e, t) {
    const s = {
      list: [],
      map: {}
    };
    return e.list.forEach((i) => {
      i !== t && (s.list.push(i), s.map[i.column.getInstanceId()] = i);
    }), s;
  }
  onMouseEvent(e, t) {
    switch (e) {
      case "dblclick":
        this.onRowDblClick(t);
        break;
      case "click":
        this.onRowClick(t);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(t);
        break;
    }
  }
  createRowEvent(e, t) {
    const { rowNode: s } = this;
    return this.gos.addGridCommonParams({
      type: e,
      node: s,
      data: s.data,
      rowIndex: s.rowIndex,
      rowPinned: s.rowPinned,
      event: t
    });
  }
  createRowEventWithSource(e, t) {
    const s = this.createRowEvent(e, t);
    return s.source = this, s;
  }
  onRowDblClick(e) {
    nt(e) || this.beans.eventSvc.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", e));
  }
  getColumnForFullWidth(e) {
    const { visibleCols: t } = this.beans;
    switch (e == null ? void 0 : e.containerType) {
      case "center":
        return t.centerCols[0];
      case "left":
        return t.leftCols[0];
      case "right":
        return t.rightCols[0];
      default:
        return t.allCols[0];
    }
  }
  onRowMouseDown(e) {
    if (this.lastMouseDownOnDragger = Hs(e.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const t = this.rowNode, { rangeSvc: s, focusSvc: i } = this.beans;
    s == null || s.removeAllCellRanges();
    const r = this.findFullWidthRowGui(e.target), o = r == null ? void 0 : r.element, n = e.target;
    let a = !0;
    o && o.contains(n) && sl(n) && (a = !1), i.setFocusedCell({
      rowIndex: t.rowIndex,
      column: this.getColumnForFullWidth(r),
      rowPinned: t.rowPinned,
      forceBrowserFocus: a
    });
  }
  onRowClick(e) {
    if (nt(e) || this.lastMouseDownOnDragger)
      return;
    const { eventSvc: s, selectionSvc: i } = this.beans;
    s.dispatchEvent(this.createRowEventWithSource("rowClicked", e)), i == null || i.handleSelectionEvent(e, this.rowNode, "rowClicked");
  }
  setupDetailRowAutoHeight(e) {
    var t;
    this.rowType === "FullWidthDetail" && ((t = this.beans.masterDetailSvc) == null || t.setupDetailRowAutoHeight(this, e));
  }
  createFullWidthCompDetails(e, t) {
    const { gos: s, rowNode: i } = this, r = s.addGridCommonParams({
      fullWidth: !0,
      data: i.data,
      node: i,
      value: i.key,
      valueFormatted: i.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: e,
      eParentOfValue: e,
      pinned: t,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (n, a, l, d) => this.addFullWidthRowDragging(n, a, l, d),
      setTooltip: (n, a) => {
        s.assertModuleRegistered("Tooltip", 3), this.refreshRowTooltip(n, a);
      }
    }), o = this.beans.userCompFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return zv(o, r);
      case "FullWidthGroup":
        return Hv(o, r);
      case "FullWidthLoading":
        return Nv(o, r);
      default:
        return Vv(o, r);
    }
  }
  refreshRowTooltip(e, t) {
    var s;
    this.fullWidthGui && (this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.refreshRowTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    ));
  }
  addFullWidthRowDragging(e, t, s = "", i) {
    const { rowDragSvc: r, context: o } = this.beans;
    if (!r || !this.isFullWidth())
      return;
    const n = r.createRowDragComp(
      () => s,
      this.rowNode,
      void 0,
      e,
      t,
      i
    );
    this.createBean(n, o), this.addDestroyFunc(() => {
      this.destroyBean(n, o);
    });
  }
  onUiLevelChanged() {
    const e = Gd(this.rowNode);
    if (this.rowLevel != e) {
      const t = "ag-row-level-" + e, s = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((i) => {
        i.rowComp.addOrRemoveCssClass(t, !0), i.rowComp.addOrRemoveCssClass(s, !1);
      });
    }
    this.rowLevel = e;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const e = this.isFirstRowOnPage(), t = this.isLastRowOnPage();
    this.firstRowOnPage !== e && (this.firstRowOnPage = e, this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass("ag-row-first", e))), this.lastRowOnPage !== t && (this.lastRowOnPage = t, this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass("ag-row-last", t)));
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    var t;
    const e = [];
    (t = this.beans.rowStyleSvc) == null || t.processClassesFromGridOptions(e, this.rowNode), e.length && e.forEach((s) => {
      this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(s, !0));
    });
  }
  postProcessRowClassRules() {
    var e;
    (e = this.beans.rowStyleSvc) == null || e.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass(t, !1));
      }
    );
  }
  setStylesFromGridOptions(e, t) {
    e && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(t, (s) => s.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(e) {
    return e === "left" || e === "right" ? e : null;
  }
  getInitialRowClasses(e) {
    var a;
    const t = this.getPinnedForContainer(e), s = this.isFullWidth(), { rowNode: i, beans: r } = this, o = [];
    o.push("ag-row"), o.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), this.fadeInAnimation[e] && o.push("ag-opacity-zero"), o.push(i.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd"), i.isRowPinned() && o.push("ag-row-pinned"), i.isSelected() && o.push("ag-row-selected"), i.footer && o.push("ag-row-footer"), o.push("ag-row-level-" + this.rowLevel), i.stub && o.push("ag-row-loading"), s && o.push("ag-full-width-row"), (a = r.expansionSvc) == null || a.addExpandedCss(o, i), i.dragging && o.push("ag-row-dragging");
    const { rowStyleSvc: n } = r;
    return n && (n.processClassesFromGridOptions(o, i), n.preProcessRowClassRules(o, i)), o.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), this.isFirstRowOnPage() && o.push("ag-row-first"), this.isLastRowOnPage() && o.push("ag-row-last"), s && (t === "left" && o.push("ag-cell-last-left-pinned"), t === "right" && o.push("ag-cell-first-right-pinned")), o;
  }
  processStylesFromGridOptions() {
    var e;
    return ((e = this.beans.rowStyleSvc) == null ? void 0 : e.processStylesFromGridOptions(this.rowNode)) ?? this.emptyStyle;
  }
  onRowSelected(e) {
    var t;
    (t = this.beans.selectionSvc) == null || t.onRowCtrlSelected(
      this,
      (s) => {
        (s === this.centerGui || s === this.fullWidthGui) && this.announceDescription();
      },
      e
    );
  }
  announceDescription() {
    var e;
    (e = this.beans.selectionSvc) == null || e.announceAriaRowSelection(this.rowNode);
  }
  addHoverFunctionality(e) {
    if (!this.active)
      return;
    const { element: t, compBean: s } = e, { rowNode: i, beans: r, gos: o } = this;
    s.addManagedListeners(t, {
      mouseenter: () => i.dispatchRowEvent("mouseEnter"),
      mouseleave: () => i.dispatchRowEvent("mouseLeave")
    }), s.addManagedListeners(i, {
      mouseEnter: () => {
        var n;
        !((n = r.dragSvc) != null && n.dragging) && !o.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), i.setHovered(!0));
      },
      mouseLeave: () => {
        t.classList.remove("ag-row-hover"), i.setHovered(!1);
      }
    });
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(e) {
    const t = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition(), s = this.applyPaginationOffset(t.top, !0) - 100, i = this.applyPaginationOffset(t.bottom, !0) + 100;
    return Math.min(Math.max(s, e), i);
  }
  forEachGui(e, t) {
    e ? t(e) : this.allRowGuis.forEach(t);
  }
  onRowHeightChanged(e) {
    if (this.rowNode.rowHeight == null)
      return;
    const t = this.rowNode.rowHeight, s = this.beans.environment.getDefaultRowHeight(), r = nl(this.gos) ? Ie(this.beans, this.rowNode).height : void 0, o = r ? `${Math.min(s, r) - 2}px` : void 0;
    this.forEachGui(e, (n) => {
      n.element.style.height = `${t}px`, o && n.element.style.setProperty("--ag-line-height", o);
    });
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(e = !1) {
    this.active = !1;
    const { rowNode: t } = this;
    if (!e && fi(this.gos) && !t.sticky)
      if (t.rowTop != null) {
        const r = this.roundRowTopToBounds(t.rowTop);
        this.setRowTop(r);
      } else
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
    t.setHovered(!1);
    const s = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(s), this.beans.eventSvc.dispatchEvent(s), super.destroy();
  }
  destroySecondPass() {
    var t;
    this.allRowGuis.length = 0, (t = this.beans.editSvc) == null || t.stopRowEditing(this);
    const e = (s) => (s.list.forEach((i) => i.destroy()), { list: [], map: {} });
    this.centerCellCtrls = e(this.centerCellCtrls), this.leftCellCtrls = e(this.leftCellCtrls), this.rightCellCtrls = e(this.rightCellCtrls);
  }
  setFocusedClasses(e) {
    this.forEachGui(e, (t) => {
      t.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), t.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const { focusSvc: e, editSvc: t } = this.beans, s = e.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    s !== this.rowFocused && (this.rowFocused = s, this.setFocusedClasses()), !s && this.editing && (t == null || t.stopRowEditing(this, !1));
  }
  onPaginationChanged() {
    var t;
    const e = ((t = this.beans.pagination) == null ? void 0 : t.getCurrentPage()) ?? 0;
    this.paginationPage !== e && (this.paginationPage = e, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(e, t = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return e;
    const s = this.beans.pageBounds.getPixelOffset();
    return e + s * (t ? 1 : -1);
  }
  setRowTop(e) {
    if (!this.printLayout && A(e)) {
      const t = this.applyPaginationOffset(e), r = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? t : this.beans.rowContainerHeight.getRealPixelPosition(t)}px`;
      this.setRowTopStyle(r);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(e) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(e) : void 0;
  }
  getInitialTransform(e) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(e)})`;
  }
  getInitialRowTopShared(e) {
    if (this.printLayout)
      return "";
    const t = this.rowNode;
    let s;
    if (t.sticky)
      s = t.stickyRowTop;
    else {
      const i = this.slideInAnimation[e] ? this.roundRowTopToBounds(t.oldRowTop) : t.rowTop, r = this.applyPaginationOffset(i);
      s = t.isRowPinned() ? r : this.beans.rowContainerHeight.getRealPixelPosition(r);
    }
    return s + "px";
  }
  setRowTopStyle(e) {
    this.allRowGuis.forEach(
      (t) => this.suppressRowTransform ? t.rowComp.setTop(e) : t.rowComp.setTransform(`translateY(${e})`)
    );
  }
  getCellCtrl(e, t = !1) {
    let s = null;
    return this.getAllCellCtrls().forEach((i) => {
      i.column == e && (s = i);
    }), s != null || t || this.getAllCellCtrls().forEach((i) => {
      i.getColSpanningList().indexOf(e) >= 0 && (s = i);
    }), s;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  updateRowIndexes(e) {
    var o, n;
    const t = this.rowNode.getRowIndexString();
    if (t === null)
      return;
    const s = (((o = this.beans.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : o.getRowCount()) ?? 0) + (((n = this.beans.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), i = this.rowNode.rowIndex % 2 === 0, r = s + this.rowNode.rowIndex + 1;
    this.forEachGui(e, (a) => {
      a.rowComp.setRowIndex(t), a.rowComp.addOrRemoveCssClass("ag-row-even", i), a.rowComp.addOrRemoveCssClass("ag-row-odd", !i), Qa(a.element, r);
    });
  }
};
function xl(e) {
  var s;
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : ((s = e.key) == null ? void 0 : s.length) === 1;
}
function Sa(e, t, s, i, r) {
  const o = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!o)
    return !1;
  const n = e.addGridCommonParams({
    event: t,
    editing: r,
    column: i,
    node: s,
    data: s.data,
    colDef: i.getColDef()
  });
  return !!(o && o(n));
}
var Gw = 65, Bw = 67, Vw = 86, Nw = 68, Hw = 90, zw = 89;
function Ww(e) {
  const { keyCode: t } = e;
  let s;
  switch (t) {
    case Gw:
      s = w.A;
      break;
    case Bw:
      s = w.C;
      break;
    case Vw:
      s = w.V;
      break;
    case Nw:
      s = w.D;
      break;
    case Hw:
      s = w.Z;
      break;
    case zw:
      s = w.Y;
      break;
    default:
      s = e.code;
  }
  return s;
}
var _w = class extends P {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    var e;
    this.addKeyboardListeners(), this.addMouseListeners(), (e = this.beans.touchSvc) == null || e.mockRowContextMenu(this);
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", qh("touchstart") ? "touchstart" : "mousedown"].forEach((s) => {
      const i = this.processMouseEvent.bind(this, s);
      this.addManagedElementListeners(this.element, { [s]: i });
    });
  }
  processMouseEvent(e, t) {
    var r;
    if (!To(this.gos, t) || nt(t))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    e === "contextmenu" ? (r = this.beans.contextMenuSvc) == null || r.handleContextMenuMouseEvent(t, void 0, i, s) : (s && s.onMouseEvent(e, t), i && i.onMouseEvent(e, t));
  }
  getControlsForEventTarget(e) {
    const { gos: t } = this;
    return {
      cellCtrl: Cl(t, e),
      rowCtrl: Yh(t, e, mr)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (s ? this.processCellKeyboardEvent(s, e, t) : i && i.isFullWidth() && this.processFullWidthRowKeyboardEvent(i, e, t));
  }
  processCellKeyboardEvent(e, t, s) {
    var a;
    const { rowNode: i, column: r, editing: o } = e;
    !Sa(
      this.gos,
      s,
      i,
      r,
      o
    ) && t === "keydown" && (!o && ((a = this.beans.navigation) != null && a.handlePageScrollingKey(s)) || e.onKeyDown(s), this.doGridOperations(s, e.editing), xl(s) && e.processCharacter(s)), t === "keydown" && this.eventSvc.dispatchEvent(e.createEvent(s, "cellKeyDown"));
  }
  processFullWidthRowKeyboardEvent(e, t, s) {
    const { rowNode: i } = e, { focusSvc: r, navigation: o } = this.beans, n = r.getFocusedCell(), a = n && n.column;
    if (!Sa(this.gos, s, i, a, !1)) {
      const d = s.key;
      if (t === "keydown")
        switch (d) {
          case w.PAGE_HOME:
          case w.PAGE_END:
          case w.PAGE_UP:
          case w.PAGE_DOWN:
            o == null || o.handlePageScrollingKey(s, !0);
            break;
          case w.UP:
          case w.DOWN:
            e.onKeyboardNavigate(s);
            break;
          case w.TAB:
            e.onTabKeyDown(s);
            break;
        }
    }
    t === "keydown" && this.eventSvc.dispatchEvent(e.createRowEvent("cellKeyDown", s));
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !To(this.gos, e))
      return;
    const s = Ww(e), { clipboardSvc: i, undoRedo: r } = this.beans;
    if (s === w.A)
      return this.onCtrlAndA(e);
    if (s === w.C)
      return this.onCtrlAndC(i, e);
    if (s === w.D)
      return this.onCtrlAndD(i, e);
    if (s === w.V)
      return this.onCtrlAndV(i, e);
    if (s === w.X)
      return this.onCtrlAndX(i, e);
    if (s === w.Y)
      return this.onCtrlAndY(r);
    if (s === w.Z)
      return this.onCtrlAndZ(r, e);
  }
  onCtrlAndA(e) {
    const {
      beans: { pinnedRowModel: t, rowModel: s, visibleCols: i, rangeSvc: r, selectionSvc: o },
      gos: n
    } = this;
    if (r && Ve(n) && s.isRowsToRender()) {
      const [a, l] = [
        (t == null ? void 0 : t.isEmpty("top")) ?? !0,
        (t == null ? void 0 : t.isEmpty("bottom")) ?? !0
      ], d = a ? null : "top";
      let c, h;
      l ? (c = null, h = s.getRowCount() - 1) : (c = "bottom", h = (t == null ? void 0 : t.getPinnedBottomRowCount()) ?? -1);
      const u = i.allCols;
      if (!(u != null && u.length))
        return;
      r.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: d,
        rowEndIndex: h,
        rowEndPinned: c,
        columnStart: u[0],
        columnEnd: V(u)
      });
    } else o && (o == null || o.selectAllRowNodes({ source: "keyboardSelectAll", selectAll: Kh(n) }));
    e.preventDefault();
  }
  onCtrlAndC(e, t) {
    if (!e || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || (t.preventDefault(), e.copyToClipboard());
  }
  onCtrlAndX(e, t) {
    if (!e || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || (t.preventDefault(), e.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e, t) {
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || e && !this.gos.get("suppressClipboardPaste") && e.pasteFromClipboard();
  }
  onCtrlAndD(e, t) {
    e && !this.gos.get("suppressClipboardPaste") && e.copyRangeDown(), t.preventDefault();
  }
  onCtrlAndZ(e, t) {
    !this.gos.get("undoRedoCellEditing") || !e || (t.preventDefault(), t.shiftKey ? e.redo("ui") : e.undo("ui"));
  }
  onCtrlAndY(e) {
    e == null || e.redo("ui");
  }
}, Ku = class extends P {
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight)
    });
  }
  onHeightChanged(e) {
    const t = e.uiContainerHeight, s = t != null ? `${t}px` : "";
    this.eContainer.style.height = s, this.eViewport && (this.eViewport.style.height = s);
  }
}, Br = (e) => e.topRowCtrls, Vr = (e) => e.getStickyTopRowCtrls(), Nr = (e) => e.getStickyBottomRowCtrls(), Hr = (e) => e.bottomRowCtrls, zr = (e) => e.allRowCtrls, Uw = {
  center: {
    type: "center",
    container: "ag-center-cols-container",
    viewport: "ag-center-cols-viewport",
    getRowCtrls: zr
  },
  left: {
    type: "left",
    container: "ag-pinned-left-cols-container",
    pinnedType: "left",
    getRowCtrls: zr
  },
  right: {
    type: "right",
    container: "ag-pinned-right-cols-container",
    pinnedType: "right",
    getRowCtrls: zr
  },
  fullWidth: {
    type: "fullWidth",
    container: "ag-full-width-container",
    fullWidth: !0,
    getRowCtrls: zr
  },
  topCenter: {
    type: "center",
    container: "ag-floating-top-container",
    viewport: "ag-floating-top-viewport",
    getRowCtrls: Br
  },
  topLeft: {
    type: "left",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: Br
  },
  topRight: {
    type: "right",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: Br
  },
  topFullWidth: {
    type: "fullWidth",
    container: "ag-floating-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Br
  },
  stickyTopCenter: {
    type: "center",
    container: "ag-sticky-top-container",
    viewport: "ag-sticky-top-viewport",
    getRowCtrls: Vr
  },
  stickyTopLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: Vr
  },
  stickyTopRight: {
    type: "right",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: Vr
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Vr
  },
  stickyBottomCenter: {
    type: "center",
    container: "ag-sticky-bottom-container",
    viewport: "ag-sticky-bottom-viewport",
    getRowCtrls: Nr
  },
  stickyBottomLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: Nr
  },
  stickyBottomRight: {
    type: "right",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: Nr
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: Nr
  },
  bottomCenter: {
    type: "center",
    container: "ag-floating-bottom-container",
    viewport: "ag-floating-bottom-viewport",
    getRowCtrls: Hr
  },
  bottomLeft: {
    type: "left",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: Hr
  },
  bottomRight: {
    type: "right",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: Hr
  },
  bottomFullWidth: {
    type: "fullWidth",
    container: "ag-floating-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: Hr
  }
};
function di(e) {
  return Uw[e];
}
var Kw = ["topCenter", "topLeft", "topRight"], $w = ["bottomCenter", "bottomLeft", "bottomRight"], jw = ["center", "left", "right"], qw = ["center", "left", "right", "fullWidth"], Yw = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], Xw = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], Zw = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], $u = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], ju = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], Qw = [
  ...$u,
  "stickyTopFullWidth",
  ...ju,
  "stickyBottomFullWidth"
], Jw = [
  ...Kw,
  ...$w,
  ...jw,
  ...$u,
  ...ju
], ey = class extends P {
  constructor(e) {
    super(), this.name = e, this.visible = !0, this.EMPTY_CTRLS = [], this.options = di(e);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new Lw(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.beans.ctrlsSvc.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  setComp(e, t, s) {
    this.comp = e, this.eContainer = t, this.eViewport = s, this.createManagedBean(new _w(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder();
    const { pinnedCols: i, rangeSvc: r } = this.beans, o = () => this.onPinnedWidthChanged();
    this.forContainers(Xw, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        i == null ? void 0 : i.createPinnedWidthFeature(this.eContainer, !0)
      ), this.addManagedEventListeners({ leftPinnedWidthChanged: o });
    }), this.forContainers(Zw, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        i == null ? void 0 : i.createPinnedWidthFeature(this.eContainer, !1)
      ), this.addManagedEventListeners({ rightPinnedWidthChanged: o });
    }), this.forContainers(
      qw,
      () => this.createManagedBean(
        new Ku(this.eContainer, this.name === "center" ? s : void 0)
      )
    ), r && this.forContainers(
      Jw,
      () => this.createManagedBean(r.createDragListenerFeature(this.eContainer))
    ), this.forContainers(
      Yw,
      () => this.createManagedBean(new bl((n) => this.comp.setContainerWidth(`${n}px`)))
    ), this.visible = this.isContainerVisible(), this.addListeners(), this.registerWithCtrlsService();
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  addListeners() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll)
    }), this.onDisplayedColumnsChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if (Qw.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const s = this.gos.get("ensureDomOrder"), i = ye(this.gos, "print");
      this.comp.setDomOrder(s || i);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const { dragSvc: e } = this.beans;
    if (!e)
      return;
    const t = (s) => {
      e.dragging && s.cancelable && s.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", t, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", t));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), s = this.getCenterViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(t, s, e);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return yi(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return po(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = Rt(this.beans, this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return Th(this.eViewport);
  }
  getViewportScrollLeft() {
    return po(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || wC(this.eViewport);
  }
  setHorizontalScroll(e) {
    this.comp.setHorizontalScroll(e);
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    go(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.beans.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const s = ye(this.gos, "print"), r = this.gos.get("embedFullWidthRows") || s, o = t.filter((n) => {
      const a = n.isFullWidth();
      return this.options.fullWidth ? !r && a : r || !a;
    });
    this.comp.setRowCtrls({ rowCtrls: o, useFlushSync: e });
  }
}, qu = "ag-force-vertical-scroll", ty = "ag-selectable", sy = "ag-column-moving", iy = class extends P {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colModel = e.colModel, this.scrollVisibleSvc = e.scrollVisibleSvc, this.pinnedRowModel = e.pinnedRowModel, this.filterManager = e.filterManager, this.rowGroupColsSvc = e.rowGroupColsSvc;
  }
  setComp(e, t, s, i, r, o, n) {
    var a, l;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = s, this.eTop = i, this.eBottom = r, this.eStickyTop = o, this.eStickyBottom = n, this.eCenterColsViewport = s.querySelector(
      `.${di("center").viewport}`
    ), this.eFullWidthContainer = s.querySelector(
      `.${di("fullWidth").container}`
    ), this.eStickyTopFullWidthContainer = o.querySelector(
      `.${di("stickyTopFullWidth").container}`
    ), this.eStickyBottomFullWidthContainer = n.querySelector(
      `.${di("stickyBottomFullWidth").container}`
    ), this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (d) => this.setCellTextSelection(d.currentValue)
    ), this.createManagedBean(new yl(this.comp)), this.scrollFeature = this.createManagedBean(new Iw(this.eBodyViewport)), (a = this.beans.rowDragSvc) == null || a.setupRowDrag(this.eBodyViewport, this), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([i, s, r, o, n]), this.setGridRootRole(), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.updateScrollingClasses(), (l = this.filterManager) == null || l.setupAdvFilterHeaderComp(i), this.ctrlsSvc.register("gridBodyCtrl", this);
  }
  addEventListeners() {
    const e = this.setFloatingHeights.bind(this), t = this.setGridRootRole.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.updateScrollingClasses.bind(this),
      pinnedRowDataChanged: e,
      pinnedHeightChanged: e,
      headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
      columnRowGroupChanged: t,
      columnPivotChanged: t
    }), this.addManagedPropertyListener("treeData", t);
  }
  onGridColumnsChanged() {
    const e = this.beans.colModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  onScrollVisibilityChanged() {
    const { scrollVisibleSvc: e } = this, t = e.verticalScrollShowing;
    this.setVerticalScrollPaddingVisible(t), this.setStickyWidth(t), this.setStickyBottomOffsetBottom();
    const s = t && e.getScrollbarWidth() || 0, i = xh() ? 16 : 0, r = `calc(100% + ${s + i}px)`;
    pt(this.beans, () => this.comp.setBodyViewportWidth(r)), this.updateScrollingClasses();
  }
  setGridRootRole() {
    const { rowGroupColsSvc: e, colModel: t } = this;
    let s = this.gos.get("treeData");
    if (!s) {
      const i = t.isPivotMode();
      s = (e ? e.columns.length : 0) >= (i ? 2 : 1);
    }
    this.comp.setGridRootRole(s ? "treegrid" : "grid");
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (s) => {
          const { target: i } = s, r = Hs(i, "ag-root", t);
          t.classList.toggle("ag-has-focus", !r);
        },
        focusout: (s) => {
          const { target: i, relatedTarget: r } = s, o = t.contains(r), n = Hs(
            r,
            "ag-root",
            t
          );
          Hs(i, "ag-root", t) || (!o || n) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(sy, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(ty, e);
  }
  updateScrollingClasses() {
    const {
      eGridBody: { classList: e },
      scrollVisibleSvc: t
    } = this;
    e.toggle("ag-body-vertical-content-no-gap", !t.verticalScrollGap), e.toggle("ag-body-horizontal-content-no-gap", !t.horizontalScrollGap);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    var e;
    (e = this.beans.editSvc) == null || e.addStopEditingWhenGridLosesFocus([
      this.eBodyViewport,
      this.eBottom,
      this.eTop,
      this.eStickyTop,
      this.eStickyBottom
    ]);
  }
  updateRowCount() {
    var r, o;
    const e = (((r = this.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : r.getRowCount()) ?? 0) + (((o = this.filterManager) == null ? void 0 : o.getHeaderRowCount()) ?? 0), { rowModel: t } = this.beans, s = t.isLastRowIndexKnown() ? t.getRowCount() : -1, i = s === -1 ? -1 : e + s;
    this.comp.setRowCount(i);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? qu : null, s = ye(this.gos, "normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || s && yC(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const { rowContainerHeight: e, environment: t } = this.beans;
    let s = t.sizesMeasured;
    const i = () => {
      const r = s && fi(this.gos) && !e.stretching, o = r ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(o, r);
    };
    i(), this.addManagedEventListeners({ heightScaleChanged: i }), this.addManagedPropertyListener("animateRows", i), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !s && t.sizesMeasured && (s = !0, i());
      }
    });
  }
  addBodyViewportListener() {
    const { popupSvc: e, touchSvc: t } = this.beans, s = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: s }), t == null || t.mockBodyContextMenu(this, s), this.addManagedElementListeners(this.eBodyViewport, {
      wheel: this.onBodyViewportWheel.bind(this, e)
    }), this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) }), this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) }), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX: t, deltaY: s, shiftKey: i } = e;
    (i || Math.abs(t) > Math.abs(s)) && To(this.gos, e) && this.scrollGridBodyToMatchEvent(e);
  }
  onStickyWheel(e) {
    const { deltaX: t, deltaY: s, shiftKey: i } = e, r = i || Math.abs(t) > Math.abs(s), o = e.target;
    r ? (this.eStickyTopFullWidthContainer.contains(o) || this.eStickyBottomFullWidthContainer.contains(o)) && this.scrollGridBodyToMatchEvent(e) : (e.preventDefault(), this.scrollVertically(s));
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX: t, deltaY: s } = e;
    e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || s });
  }
  onBodyViewportContextMenu(e, t, s) {
    var r;
    if (!e && !s)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || s).preventDefault();
    const { target: i } = e || t;
    (i === this.eBodyViewport || i === this.ctrlsSvc.get("center").eViewport) && ((r = this.beans.contextMenuSvc) == null || r.showContextMenu({
      mouseEvent: e,
      touchEvent: s,
      value: null,
      anchorToElement: this.eGridBody
    }));
  }
  onBodyViewportWheel(e, t) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && e != null && e.hasAnchoredPopup() && t.preventDefault();
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.scrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this, t = (e == null ? void 0 : e.getPinnedTopTotalHeight()) ?? 0, s = (e == null ? void 0 : e.getPinnedBottomTotalHeight()) ?? 0;
    this.comp.setTopHeight(t), this.comp.setBottomHeight(s), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(s ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.scrollVisibleSvc.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  setStickyTopOffsetTop() {
    var r, o;
    const t = this.ctrlsSvc.get("gridHeaderCtrl").headerHeight + (((r = this.filterManager) == null ? void 0 : r.getHeaderHeight()) ?? 0), s = ((o = this.pinnedRowModel) == null ? void 0 : o.getPinnedTopTotalHeight()) ?? 0;
    let i = 0;
    t > 0 && (i += t), s > 0 && (i += s), i > 0 && (i += 1), this.comp.setStickyTopTop(`${i}px`);
  }
  setStickyBottomOffsetBottom() {
    const { pinnedRowModel: e, scrollVisibleSvc: t, comp: s } = this, i = (e == null ? void 0 : e.getPinnedBottomTotalHeight()) ?? 0, o = t.horizontalScrollShowing && t.getScrollbarWidth() || 0, n = i + o;
    s.setStickyBottomBottom(`${n}px`);
  }
}, Yu = class extends L {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = S, this.eContainer = S, this.hideTimeout = 0, this.setTemplate(e);
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", bh() || fs());
  }
  destroy() {
    super.destroy(), window.clearTimeout(this.hideTimeout);
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = xh(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.addOrRemoveCssClass("ag-scrollbar-active", !0), s = () => this.addOrRemoveCssClass("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: s,
      touchend: s
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), pt(this.beans, () => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout && (window.clearTimeout(this.hideTimeout), this.hideTimeout = 0), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = 0;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.eViewport;
    kh(
      () => ke(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
}, ry = class extends Yu {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
      "horizontal"
    ), this.eLeftSpacer = S, this.eRightSpacer = S, this.setScrollVisibleDebounce = 0;
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.refreshCompBottom.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.beans.ctrlsSvc.register("fakeHScrollComp", this), this.createManagedBean(new bl((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  destroy() {
    window.clearTimeout(this.setScrollVisibleDebounce), super.destroy();
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  refreshCompBottom() {
    var t;
    if (!this.invisibleScrollbar)
      return;
    const e = ((t = this.beans.pinnedRowModel) == null ? void 0 : t.getPinnedBottomTotalHeight()) ?? 0;
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleSvc.verticalScrollShowing;
    let t = this.visibleCols.getDisplayedColumnsRightWidth();
    const s = !this.enableRtl && e, i = this.scrollVisibleSvc.getScrollbarWidth();
    s && (t += i), yt(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= i);
    let r = this.visibleCols.getColsLeftWidth();
    this.enableRtl && e && (r += i), yt(this.eLeftSpacer, r), this.eLeftSpacer.classList.toggle("ag-scroller-corner", r <= i);
  }
  setScrollVisible() {
    const e = this.scrollVisibleSvc.horizontalScrollShowing, t = this.invisibleScrollbar, s = this.gos.get("suppressHorizontalScroll"), i = e && this.scrollVisibleSvc.getScrollbarWidth() || 0, o = s ? 0 : i === 0 && t ? 16 : i, n = () => {
      this.setScrollVisibleDebounce = 0, this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Qi(this.getGui(), o), Qi(this.eViewport, o), Qi(this.eContainer, o), this.setDisplayed(e, { skipAriaHidden: !0 });
    };
    window.clearTimeout(this.setScrollVisibleDebounce), e ? this.setScrollVisibleDebounce = window.setTimeout(n, 100) : n();
  }
  getScrollPosition() {
    return po(this.eViewport, this.enableRtl);
  }
  setScrollPosition(e) {
    ke(this.eViewport) || this.attemptSettingScrollPosition(e), go(this.eViewport, e, this.enableRtl);
  }
}, oy = {
  selector: "AG-FAKE-HORIZONTAL-SCROLL",
  component: ry
}, ny = class extends Yu {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
      "vertical"
    );
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new Ku(this.eContainer));
    const { ctrlsSvc: e } = this.beans;
    e.register("fakeVScrollComp", this), this.addManagedEventListeners({
      rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, e)
    });
  }
  setScrollVisible() {
    const { scrollVisibleSvc: e } = this.beans, t = e.verticalScrollShowing, s = this.invisibleScrollbar, i = t && e.getScrollbarWidth() || 0, r = i === 0 && s ? 16 : i;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", s), yt(this.getGui(), r), yt(this.eViewport, r), yt(this.eContainer, r), this.setDisplayed(t, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged(e) {
    const s = e.getGridBodyCtrl().eBodyViewport, i = this.getScrollPosition(), r = s.scrollTop;
    i != r && this.setScrollPosition(r, !0);
  }
  getScrollPosition() {
    return this.eViewport.scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !ke(this.eViewport) && this.attemptSettingScrollPosition(e), this.eViewport.scrollTop = e;
  }
}, ay = {
  selector: "AG-FAKE-VERTICAL-SCROLL",
  component: ny
};
function Xu(e) {
  return e.cols ? e.cols.treeDepth + 1 : -1;
}
function Kt(e) {
  var t;
  return ((t = e.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : t.getRowCount()) ?? 0;
}
function Fl(e) {
  const t = [], s = e.ctrlsSvc.getHeaderRowContainerCtrls();
  for (const i of s) {
    if (!i)
      continue;
    const r = i.getGroupRowCount() || 0;
    for (let o = 0; o < r; o++) {
      const n = i.getGroupRowCtrlAtIndex(o), a = t[o];
      if (n) {
        const l = ly(e, n);
        (a == null || l > a) && (t[o] = l);
      }
    }
  }
  return t;
}
function ly(e, t) {
  const s = e.colModel.isPivotMode() ? cy(e) : Zu(e);
  let i = 0;
  const r = t.getHeaderCtrls();
  for (const o of r) {
    const { column: n } = o;
    if (n.isAutoHeaderHeight()) {
      const a = n.getAutoHeaderHeight();
      a != null && a > i && (i = a);
    }
  }
  return Math.max(s, i);
}
function Rl(e) {
  const t = e.colModel.isPivotMode() ? dy(e) : Fr(e), i = e.visibleCols.allCols.filter((r) => r.isAutoHeaderHeight()).map((r) => r.getAutoHeaderHeight() || 0);
  return Math.max(t, ...i);
}
function Fr(e) {
  return e.gos.get("headerHeight") ?? e.environment.getDefaultHeaderHeight();
}
function Pl(e) {
  return e.gos.get("floatingFiltersHeight") ?? Fr(e);
}
function Zu(e) {
  return e.gos.get("groupHeaderHeight") ?? Fr(e);
}
function dy(e) {
  return e.gos.get("pivotHeaderHeight") ?? Fr(e);
}
function cy(e) {
  return e.gos.get("pivotGroupHeaderHeight") ?? Zu(e);
}
var hy = class extends P {
  setComp(e, t, s) {
    this.comp = e, this.eGui = t;
    const { beans: i } = this, { headerNavigation: r, touchSvc: o, ctrlsSvc: n } = i;
    r && this.createManagedBean(
      new Ps(s, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this, i),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, i)
    }), this.onPivotModeChanged(i), this.setupHeaderHeight();
    const a = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: a }), o == null || o.mockHeaderContextMenu(this, a), n.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    ), this.addManagedEventListeners({
      displayedColumnsChanged: e,
      columnHeaderHeightChanged: e,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => pt(this.beans, () => e()),
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  setHeaderHeight() {
    var o;
    const { beans: e } = this;
    let t = 0;
    const s = Fl(e).reduce((n, a) => n + a, 0), i = Rl(e);
    if ((o = e.filterManager) != null && o.hasFloatingFilters() && (t += Pl(e)), t += s, t += i, this.headerHeight === t)
      return;
    this.headerHeight = t;
    const r = `${t + 1}px`;
    this.comp.setHeightAndMinHeight(r), this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged(e) {
    const t = e.colModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", t), this.comp.addOrRemoveCssClass("ag-pivot-off", !t);
  }
  onDisplayedColumnsChanged(e) {
    const s = e.visibleCols.allCols.some((i) => i.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", s);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), s = e.shiftKey, i = s !== t ? "LEFT" : "RIGHT", { beans: r } = this, { headerNavigation: o, focusSvc: n } = r;
    (o.navigateHorizontally(i, !0, e) || !s && n.focusOverlay(!1) || Xt(r, s, !0)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    const { headerNavigation: s } = this.beans;
    switch (e.key) {
      case w.LEFT:
        t = "LEFT";
      case w.RIGHT: {
        A(t) || (t = "RIGHT"), s.navigateHorizontally(t, !1, e) && e.preventDefault();
        break;
      }
      case w.UP:
        t = "UP";
      case w.DOWN: {
        A(t) || (t = "DOWN"), s.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e, { eGui: s, beans: i } = this;
    !t && s.contains(q(i)) || s.contains(t) || (i.focusSvc.focusedHeader = null);
  }
  onHeaderContextMenu(e, t, s) {
    var n;
    const { menuSvc: i, ctrlsSvc: r } = this.beans;
    if (!e && !s || !(i != null && i.isHeaderContextMenuEnabled()))
      return;
    const { target: o } = e ?? t;
    (o === this.eGui || o === ((n = r.getHeaderRowContainerCtrl()) == null ? void 0 : n.eViewport)) && i.showHeaderContextMenu(void 0, e, s);
  }
}, Tl = class extends L {
  constructor(e, t) {
    super(e), this.ctrl = t;
  }
  getCtrl() {
    return this.ctrl;
  }
}, uy = class extends Tl {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-header-cell" role="columnheader">
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div data-ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`,
      e
    ), this.eResize = S, this.eHeaderCompWrapper = S, this.headerCompVersion = 0;
  }
  postConstruct() {
    const e = this.getGui();
    ((r, o) => {
      o != null && o != "" ? e.setAttribute(r, o) : e.removeAttribute(r);
    })("col-id", this.ctrl.column.getColId());
    const s = {
      setWidth: (r) => e.style.width = r,
      addOrRemoveCssClass: (r, o) => this.addOrRemoveCssClass(r, o),
      setAriaSort: (r) => r ? uC(e, r) : pC(e),
      setUserCompDetails: (r) => this.setUserCompDetails(r),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(s, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0);
    const i = this.ctrl.getSelectAllGui();
    i && this.eResize.insertAdjacentElement("afterend", i);
  }
  destroy() {
    this.destroyHeaderComp(), super.destroy();
  }
  destroyHeaderComp() {
    this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
  }
  setUserCompDetails(e) {
    this.headerCompVersion++;
    const t = this.headerCompVersion;
    e.newAgStackInstance().then((s) => this.afterCompCreated(t, s));
  }
  afterCompCreated(e, t) {
    if (e != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(t);
      return;
    }
    this.destroyHeaderComp(), this.headerComp = t, this.headerCompGui = t.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui());
  }
}, py = class extends Tl {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-header-group-cell" role="columnheader">
            <div data-ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`,
      e
    ), this.eResize = S, this.eHeaderCompWrapper = S;
  }
  postConstruct() {
    const e = this.getGui(), t = (i, r) => r != null ? e.setAttribute(i, r) : e.removeAttribute(i);
    e.setAttribute("col-id", this.ctrl.column.getUniqueId());
    const s = {
      addOrRemoveCssClass: (i, r) => this.addOrRemoveCssClass(i, r),
      setHeaderWrapperHidden: (i) => {
        i ? this.eHeaderCompWrapper.style.setProperty("display", "none") : this.eHeaderCompWrapper.style.removeProperty("display");
      },
      setHeaderWrapperMaxHeight: (i) => {
        i != null ? this.eHeaderCompWrapper.style.setProperty("max-height", `${i}px`) : this.eHeaderCompWrapper.style.removeProperty("max-height"), this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", i != null);
      },
      setResizableDisplayed: (i) => O(this.eResize, i),
      setWidth: (i) => e.style.width = i,
      setAriaExpanded: (i) => t("aria-expanded", i),
      setUserCompDetails: (i) => this.setUserCompDetails(i),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(s, e, this.eResize, this.eHeaderCompWrapper, void 0);
  }
  setUserCompDetails(e) {
    e.newAgStackInstance().then((t) => this.afterHeaderCompCreated(t));
  }
  afterHeaderCompCreated(e) {
    const t = () => this.destroyBean(e);
    if (!this.isAlive()) {
      t();
      return;
    }
    const s = this.getGui(), i = e.getGui();
    this.eHeaderCompWrapper.appendChild(i), this.addDestroyFunc(t), this.headerGroupComp = e, this.ctrl.setDragSource(s);
  }
  addOrRemoveHeaderWrapperStyle(e, t) {
    const { eHeaderCompWrapper: s } = this;
    t ? s.style.setProperty(e, t) : s.style.removeProperty(e);
  }
}, gy = class extends Tl {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-header-cell ag-floating-filter" role="gridcell">
            <div data-ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" data-ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" data-ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`,
      e
    ), this.eFloatingFilterBody = S, this.eButtonWrapper = S, this.eButtonShowMainFilter = S;
  }
  postConstruct() {
    const e = this.getGui(), t = {
      addOrRemoveCssClass: (s, i) => this.addOrRemoveCssClass(s, i),
      addOrRemoveBodyCssClass: (s, i) => this.eFloatingFilterBody.classList.toggle(s, i),
      setButtonWrapperDisplayed: (s) => O(this.eButtonWrapper, s),
      setCompDetails: (s) => this.setCompDetails(s),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (s) => e.style.width = s,
      setMenuIcon: (s) => this.eButtonShowMainFilter.appendChild(s)
    };
    this.ctrl.setComp(t, e, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
  }
  setCompDetails(e) {
    if (!e) {
      this.destroyFloatingFilterComp(), this.compPromise = null;
      return;
    }
    this.compPromise = e.newAgStackInstance(), this.compPromise.then((t) => this.afterCompCreated(t));
  }
  destroy() {
    this.destroyFloatingFilterComp(), super.destroy();
  }
  destroyFloatingFilterComp() {
    this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp));
  }
  afterCompCreated(e) {
    if (e) {
      if (!this.isAlive()) {
        this.destroyBean(e);
        return;
      }
      this.destroyFloatingFilterComp(), this.floatingFilterComp = e, this.eFloatingFilterBody.appendChild(e.getGui()), e.afterGuiAttached && e.afterGuiAttached();
    }
  }
}, fy = class extends L {
  constructor(e) {
    super(), this.headerComps = {}, this.ctrl = e, this.setTemplate(
      /* html */
      `<div class="${this.ctrl.headerRowClass}" role="row"></div>`
    );
  }
  postConstruct() {
    Qa(this.getGui(), this.ctrl.getAriaRowIndex());
    const e = {
      setHeight: (t) => this.getGui().style.height = t,
      setTop: (t) => this.getGui().style.top = t,
      setHeaderCtrls: (t, s) => this.setHeaderCtrls(t, s),
      setWidth: (t) => this.getGui().style.width = t
    };
    this.ctrl.setComp(e, void 0);
  }
  destroy() {
    this.setHeaderCtrls([], !1), super.destroy();
  }
  setHeaderCtrls(e, t) {
    if (!this.isAlive())
      return;
    const s = this.headerComps;
    if (this.headerComps = {}, e.forEach((i) => {
      const r = i.instanceId;
      let o = s[r];
      delete s[r], o == null && (o = this.createHeaderComp(i), this.getGui().appendChild(o.getGui())), this.headerComps[r] = o;
    }), Object.values(s).forEach((i) => {
      this.getGui().removeChild(i.getGui()), this.destroyBean(i);
    }), t) {
      const i = Object.values(this.headerComps);
      i.sort(
        (o, n) => {
          const a = o.getCtrl().column.getLeft(), l = n.getCtrl().column.getLeft();
          return a - l;
        }
      );
      const r = i.map((o) => o.getGui());
      Eh(this.getGui(), r);
    }
  }
  createHeaderComp(e) {
    let t;
    switch (this.ctrl.type) {
      case "group":
        t = new py(e);
        break;
      case "filter":
        t = new gy(e);
        break;
      default:
        t = new uy(e);
        break;
    }
    return this.createBean(t), t.setParentComponent(this), t;
  }
}, Dl = class extends P {
  constructor(e, t, s, i) {
    super(), this.columnOrGroup = e, this.eCell = t, this.colsSpanning = i, this.columnOrGroup = e, this.ariaEl = t.querySelector("[role=columnheader]") || t, this.beans = s;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    const { beans: e, colsSpanning: t } = this;
    return e.gos.get("enableRtl") && t ? V(t) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const { gos: e, colAnimation: t } = this.beans, s = e.get("suppressColumnMoveAnimation"), i = A(this.columnOrGroup.getOldLeft());
    (t == null ? void 0 : t.isActive()) && i && !s ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = this.modifyLeftForPrintLayout(e, e.getOldLeft()), s = this.modifyLeftForPrintLayout(e, e.getLeft());
    this.setLeft(t), this.actualLeft = s, this.beans.colAnimation.executeNextVMTurn(() => {
      this.actualLeft === s && this.setLeft(s);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    const { gos: s, visibleCols: i } = this.beans;
    if (!ye(s, "print") || e.getPinned() === "left")
      return t;
    const o = i.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const n = i.bodyWidth;
      return o + n + t;
    }
    return o + t;
  }
  setLeft(e) {
    if (A(e) && (this.eCell.style.left = `${e}px`), de(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && Ch(this.ariaEl, t.length);
    }
  }
}, my = 0, Qu = "headerCtrl", El = class extends P {
  constructor(e, t) {
    super(), this.column = e, this.rowCtrl = t, this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.instanceId = e.getUniqueId() + "-" + my++;
  }
  postConstruct() {
    const e = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], e), this.addManagedEventListeners({
      overlayExclusiveChanged: e
    });
  }
  shouldStopEventPropagation(e) {
    const { headerRowIndex: t, column: s } = this.beans.focusSvc.focusedHeader, i = s.getDefinition(), r = i && i.suppressHeaderKeyboardEvent;
    if (!A(r))
      return !1;
    const o = this.gos.addGridCommonParams({
      colDef: i,
      column: s,
      headerRowIndex: t,
      event: e
    });
    return !!r(o);
  }
  getWrapperHasFocus() {
    return q(this.beans) === this.eGui;
  }
  setGui(e, t) {
    this.eGui = e, this.addDomData(t), t.addManagedListeners(this.beans.eventSvc, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), t.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onGuiFocus() {
    this.eventSvc.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(e) {
    const { wrapperElement: t, checkMeasuringCallback: s, compBean: i } = e, { beans: r } = this, o = (h) => {
      if (!this.isAlive() || !i.isAlive())
        return;
      const { paddingTop: u, paddingBottom: p, borderBottomWidth: g, borderTopWidth: f } = ii(this.eGui), m = u + p + g + f, v = t.offsetHeight + m;
      if (h < 5) {
        const b = Z(r), y = !b || !b.contains(t), F = v == 0;
        if (y || F) {
          pt(r, () => o(h + 1));
          return;
        }
      }
      this.setColHeaderHeight(this.column, v);
    };
    let n = !1, a;
    const l = () => {
      const h = this.column.isAutoHeaderHeight();
      h && !n && d(), !h && n && c();
    }, d = () => {
      n = !0, o(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), a = Rt(this.beans, t, () => o(0));
    }, c = () => {
      n = !1, a && a(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), a = void 0;
    };
    l(), i.addDestroyFunc(() => c()), i.addManagedListeners(this.column, { widthChanged: () => n && o(0) }), i.addManagedEventListeners({
      sortChanged: () => {
        n && window.setTimeout(() => o(0));
      }
    }), s && s(l);
  }
  onDisplayedColumnsChanged() {
    const { comp: e, column: t, beans: s, eGui: i } = this;
    !e || !t || !i || (Pu(e, t, s.visibleCols), Ja(i, s.visibleCols.getAriaColIndex(t)));
  }
  addResizeAndMoveKeyboardListeners(e) {
    e.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const e = mi(this.beans);
    this.eGui && ht(this.eGui, "tabindex", e ? null : "-1");
  }
  onGuiKeyDown(e) {
    var o;
    const t = q(this.beans), s = e.key === w.LEFT || e.key === w.RIGHT;
    if (this.isResizing && (e.preventDefault(), e.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    t !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !e.shiftKey && !e.altKey || ((this.isResizing || s) && (e.preventDefault(), e.stopImmediatePropagation()), !s))
      return;
    const r = e.key === w.LEFT !== this.gos.get("enableRtl") ? "left" : "right";
    if (e.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const n = this.getViewportAdjustedResizeDiff(e);
      this.resizeHeader(n, e.shiftKey), (o = this.resizeFeature) == null || o.toggleColumnResizing(!0);
    } else
      this.moveHeader(r);
  }
  moveHeader(e) {
    var t;
    (t = this.beans.colMoves) == null || t.moveHeader(e, this.eGui, this.column, this.rowCtrl.pinned, this);
  }
  getViewportAdjustedResizeDiff(e) {
    const t = this.getResizeDiff(e), { pinnedCols: s } = this.beans;
    return s ? s.getHeaderResizeDiff(t, this.column) : t;
  }
  getResizeDiff(e) {
    const { gos: t, column: s } = this;
    let i = e.key === w.LEFT !== t.get("enableRtl");
    const r = s.getPinned(), o = t.get("enableRtl");
    return r && o !== (r === "right") && (i = !i), (i ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var e;
      (e = this.resizeFeature) == null || e.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(e) {
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case w.PAGE_DOWN:
      case w.PAGE_UP:
      case w.PAGE_HOME:
      case w.PAGE_END:
        t && e.preventDefault();
    }
  }
  addDomData(e) {
    const t = Qu, { eGui: s, gos: i } = this;
    js(i, s, t, this), e.addDestroyFunc(() => js(i, s, t, null));
  }
  focus(e) {
    const { eGui: t } = this;
    return t ? (this.lastFocusEvent = e || null, t.focus(), !0) : !1;
  }
  focusThis() {
    this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
  }
  removeDragSource() {
    var e;
    this.dragSource && ((e = this.beans.dragAndDrop) == null || e.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(e, t, s) {
    const i = e ?? t, { menuSvc: r, gos: o } = this.beans;
    o.get("preventDefaultOnContextMenu") && i.preventDefault(), r != null && r.isHeaderContextMenuEnabled(s) && r.showHeaderContextMenu(s, e, t), this.dispatchColumnMouseEvent("columnHeaderContextMenu", s);
  }
  dispatchColumnMouseEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: e,
      column: t
    });
  }
  setColHeaderHeight(e, t) {
    if (!e.setAutoHeaderHeight(t))
      return;
    const { eventSvc: s } = this;
    e.isColumn ? s.dispatchEvent({
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    }) : s.dispatchEvent({
      type: "columnGroupHeaderHeightChanged",
      columnGroup: e,
      source: "autosizeColumnGroupHeaderHeight"
    });
  }
  clearComponent() {
    this.removeDragSource(), this.resizeFeature = null, this.comp = null, this.eGui = null;
  }
  destroy() {
    super.destroy(), this.column = null, this.lastFocusEvent = null, this.rowCtrl = null;
  }
}, Cy = class extends El {
  constructor() {
    super(...arguments), this.refreshFunctions = {}, this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
  }
  setComp(e, t, s, i, r) {
    this.comp = e;
    const { colResize: o, context: n, colHover: a } = this.beans, l = xr(this, n, r);
    this.setGui(t, l), this.updateState(), this.setupWidth(l), this.setupMovingCss(l), this.setupMenuClass(l), this.setupSortableClass(l), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight({
      wrapperElement: i,
      checkMeasuringCallback: (c) => this.setRefreshFunction("measuring", c),
      compBean: l
    }), this.addColumnHoverListener(l), this.setupFilterClass(l), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(l), this.setupSelectAll(l), this.setupUserComp(), this.refreshAria(), o ? this.resizeFeature = l.createManagedBean(
      o.createResizeFeature(this.rowCtrl.pinned, this.column, s, e, this)
    ) : O(s, !1), a == null || a.createHoverFeature(l, [this.column], t), l.createManagedBean(new Dl(this.column, t, this.beans)), l.createManagedBean(
      new Ps(t, {
        shouldStopEventPropagation: (c) => this.shouldStopEventPropagation(c),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(l), l.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"],
      () => this.refresh()
    ), l.addManagedListeners(this.column, { colDefChanged: () => this.refresh() }), l.addManagedListeners(this.column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const d = () => this.checkDisplayName();
    l.addManagedEventListeners({
      columnValueChanged: d,
      columnRowGroupChanged: d,
      columnPivotChanged: d,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    }), l.addDestroyFunc(() => {
      this.refreshFunctions = {}, this.selectAllFeature = null, this.dragSourceElement = void 0, this.userCompDetails = null, this.userHeaderClasses.clear(), this.ariaDescriptionProperties.clear(), this.clearComponent();
    });
  }
  resizeHeader(e, t) {
    var s;
    (s = this.beans.colResize) == null || s.resizeHeader(this.column, e, t);
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return kv(this.beans.userCompFactory, t, e);
  }
  createParams() {
    const { menuSvc: e, sortSvc: t, colFilter: s, gos: i } = this.beans;
    return i.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && !!(e != null && e.isHeaderFilterButtonEnabled(this.column)),
      enableFilterIcon: !!s && (!this.openFilterEnabled || we(this.gos)),
      showColumnMenu: (o) => {
        e == null || e.showColumnMenu({
          column: this.column,
          buttonElement: o,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (o) => {
        e == null || e.showColumnMenu({
          column: this.column,
          mouseEvent: o,
          positionBy: "mouse"
        });
      },
      showFilter: (o) => {
        e == null || e.showFilterMenu({
          column: this.column,
          buttonElement: o,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (o) => {
        t == null || t.progressSort(this.column, !!o, "uiColumnSorted");
      },
      setSort: (o, n) => {
        t == null || t.setSortForColumn(this.column, o, !!n, "uiColumnSorted");
      },
      eGridHeader: this.eGui,
      setTooltip: (o, n) => {
        i.assertModuleRegistered("Tooltip", 3), this.setupTooltip(o, n);
      }
    });
  }
  setupSelectAll(e) {
    const { selectionSvc: t } = this.beans;
    t && (this.selectAllFeature = e.createManagedBean(t.createSelectAllFeature(this.column)), this.selectAllFeature.setComp(this));
  }
  getSelectAllGui() {
    var e;
    return (e = this.selectAllFeature) == null ? void 0 : e.getCheckboxGui();
  }
  handleKeyDown(e) {
    var t;
    super.handleKeyDown(e), e.key === w.SPACE && ((t = this.selectAllFeature) == null || t.onSpaceKeyDown(e)), e.key === w.ENTER && this.onEnterKeyDown(e), e.key === w.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    var t;
    e.ctrlKey || e.metaKey ? this.showMenuOnKeyPress(e, !0) : this.sortable && ((t = this.beans.sortSvc) == null || t.progressSort(this.column, e.shiftKey, "uiColumnSorted"));
  }
  showMenuOnKeyPress(e, t) {
    const s = this.comp.getUserCompInstance();
    Bd(s) && s.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || (this.focusThis(), this.announceAriaDescription()), tn() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.eGui.contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.setupHeaderTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), s = fl(t, this.gos, this.column, null), i = this.userHeaderClasses;
      this.userHeaderClasses = new Set(s), s.forEach((r) => {
        i.has(r) ? i.delete(r) : this.comp.addOrRemoveCssClass(r, !0);
      }), i.forEach((r) => this.comp.addOrRemoveCssClass(r, !1));
    };
    this.setRefreshFunction("headerClasses", e), e();
  }
  setDragSource(e) {
    var t;
    this.dragSourceElement = e, this.removeDragSource(), !(!e || !this.draggable) && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null);
  }
  updateState() {
    const { menuSvc: e } = this.beans;
    this.menuEnabled = !!(e != null && e.isColumnMenuInHeaderEnabled(this.column)), this.openFilterEnabled = !!(e != null && e.isFilterMenuInHeaderEnabled(this.column)), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(e, t) {
    this.refreshFunctions[e] = t;
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), Object.values(this.refreshFunctions).forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    if (!e)
      return;
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  setupWidth(e) {
    const t = () => {
      const s = this.column.getActualWidth();
      this.comp.setWidth(`${s}px`);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupMovingCss(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    e.addManagedListeners(this.column, { movingChanged: t }), t();
  }
  setupMenuClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    e.addManagedListeners(this.column, { menuVisibleChanged: t }), t();
  }
  setupSortableClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    t(), this.setRefreshFunction("updateSortable", t), e.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(e) {
    const t = () => {
      const s = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", s), this.refreshAria();
    };
    e.addManagedListeners(this.column, { filterActiveChanged: t }), t();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.setRefreshFunction("wrapText", e);
  }
  onHeaderHighlightChanged() {
    const e = this.column.getHighlighted(), t = e === 0, s = e === 1;
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", t), this.comp.addOrRemoveCssClass("ag-header-highlight-after", s);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: s, beans: i } = this, r = Fl(this.beans), o = r.reduce((c, h) => c += h, 0) === 0;
    if (s.addOrRemoveCssClass("ag-header-parent-hidden", o), !t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), s.addOrRemoveCssClass("ag-header-span-height", !1), s.addOrRemoveCssClass("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: n, isSpanningTotal: a } = this.column.getColumnGroupPaddingInfo();
    s.addOrRemoveCssClass("ag-header-span-height", n > 0);
    const l = Rl(i);
    if (n === 0) {
      s.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${l}px`);
      return;
    }
    s.addOrRemoveCssClass("ag-header-span-total", a);
    let d = 0;
    for (let c = 0; c < n; c++)
      d += r[r.length - 1 - c];
    e.style.setProperty("top", `${-d}px`), e.style.setProperty("height", `${l + d}px`);
  }
  refreshAriaSort() {
    var e;
    if (this.sortable) {
      const t = this.getLocaleTextFunc(), s = ((e = this.beans.sortSvc) == null ? void 0 : e.getDisplaySortForColumn(this.column)) || null;
      this.comp.setAriaSort(rC(s)), this.setAriaDescriptionProperty("sort", t("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !we(this.gos)) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    var t;
    if (!this.eGui.contains(q(this.beans)))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((s, i) => s === "filter" ? -1 : i.charCodeAt(0) - s.charCodeAt(0)).map((s) => this.ariaDescriptionProperties.get(s)).join(". ");
    (t = this.beans.ariaAnnounce) == null || t.announceValue(e, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderColumnHoverListener(e, this.comp, this.column);
  }
  addActiveHeaderMouseListeners(e) {
    const t = (r) => this.handleMouseOverChange(r.type === "mouseenter"), s = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column), i = (r) => this.handleContextMenuMouseEvent(r, void 0, this.column);
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: s,
      contextmenu: i
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e), this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return Bd(t) ? t.getAnchorElementForMenu(e) : this.eGui;
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function Bd(e) {
  return typeof e.getAnchorElementForMenu == "function" && typeof e.onMenuKeyboardShortcut == "function";
}
var vy = 0, Bn = class extends P {
  constructor(e, t, s) {
    super(), this.rowIndex = e, this.pinned = t, this.type = s, this.instanceId = vy++;
    const i = s == "group" ? "ag-header-row-column-group" : s == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${i}`;
  }
  postConstruct() {
    this.isPrintLayout = ye(this.gos, "print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.getHeaderCellCtrls().every((e) => e.eGui != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t, s = !0) {
    this.comp = e, t = xr(this, this.beans.context, t), s && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners(t);
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(e) {
    const t = this.onRowHeightChanged.bind(this);
    e.addManagedEventListeners({
      columnResized: this.setWidth.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: (s) => this.onVirtualColumnsChanged(s.afterScroll),
      columnGroupHeaderHeightChanged: t,
      columnHeaderHeightChanged: t,
      gridStylesChanged: t,
      advancedFilterEnabledChanged: t
    }), e.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), e.addManagedPropertyListener("ensureDomOrder", (s) => this.isEnsureDomOrder = s.currentValue), e.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      t
    );
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls) {
      for (const t of this.headerCellCtrls.values())
        if (t.column === e)
          return t;
    }
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = ye(this.gos, "print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleCols: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { filterManager: e } = this.beans, t = [], s = Fl(this.beans), i = Rl(this.beans);
    t.push(...s), t.push(i), e != null && e.hasFloatingFilters() && t.push(Pl(this.beans));
    let r = 0;
    for (let n = 0; n < this.rowIndex; n++)
      r += t[n];
    const o = t[this.rowIndex];
    return { topOffset: r, rowHeight: o };
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getHeaderCtrls(), s = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, s, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const i of t)
      this.recycleAndCreateHeaderCtrls(i, e);
    const s = (i) => {
      const { focusSvc: r, visibleCols: o } = this.beans;
      return r.isHeaderWrapperFocused(i) ? o.isVisible(i.column) : !1;
    };
    if (e)
      for (const [i, r] of e)
        s(r) ? this.headerCellCtrls.set(i, r) : this.destroyBean(r);
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    var e;
    return Array.from(((e = this.headerCellCtrls) == null ? void 0 : e.values()) ?? []);
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup())
      return;
    const s = e.getUniqueId();
    let i;
    if (t && (i = t.get(s), t.delete(s)), i && i.column != e && (this.destroyBean(i), i = void 0), i == null)
      switch (this.type) {
        case "filter": {
          i = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerFilterCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        }
        case "group":
          i = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerGroupCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        default:
          i = this.createBean(new Cy(e, this));
          break;
      }
    this.headerCellCtrls.set(s, i);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { colViewport: s } = this.beans;
    return ["left", null, "right"].forEach((i) => {
      const r = s.getHeadersToRender(i, t);
      e = e.concat(r);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.colViewport.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(e) {
    if (!this.headerCellCtrls)
      return;
    const t = this.getHeaderCellCtrls();
    let s;
    return typeof e == "function" ? s = t.find(e) : s = t.find((i) => i.column == e), s;
  }
  focusHeader(e, t) {
    const s = this.findHeaderCellCtrl(e);
    return s ? s.focus(t) : !1;
  }
  destroy() {
    var e;
    (e = this.headerCellCtrls) == null || e.forEach((t) => {
      this.destroyBean(t);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
}, wy = class extends P {
  constructor(e) {
    super(), this.pinned = e, this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [];
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t;
    const { pinnedCols: s, ctrlsSvc: i, colModel: r, colMoves: o, filterManager: n } = this.beans;
    this.setupCenterWidth(), s == null || s.setupHeaderPinnedWidth(this), this.setupDragAndDrop(o, this.eViewport);
    const a = this.onDisplayedColumnsChanged.bind(this, n);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: a,
      advancedFilterEnabledChanged: a
    });
    const l = `${typeof this.pinned == "string" ? this.pinned : "center"}Header`;
    i.register(l, this), r.ready && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const { focusSvc: t, colModel: s, filterManager: i } = this.beans;
    let r = 0;
    const o = t.getFocusHeaderToUseAfterRefresh(), n = () => {
      const c = Xu(s) - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let h = 0; h < c; h++) {
        const u = this.createBean(new Bn(r++, this.pinned, "group"));
        this.groupsRowCtrls.push(u);
      }
    }, a = () => {
      const c = r++, h = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.rowIndex !== c);
      (h || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), h && (this.columnsRowCtrl = this.createBean(new Bn(c, this.pinned, "column")));
    }, l = () => {
      this.includeFloatingFilter = !!(i != null && i.hasFloatingFilters()) && !this.hidden;
      const c = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        c();
        return;
      }
      const h = r++;
      if (this.filtersRowCtrl) {
        const u = this.filtersRowCtrl.rowIndex !== h;
        (!e || u) && c();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new Bn(h, this.pinned, "filter")));
    };
    n(), a(), l();
    const d = this.getAllCtrls();
    this.comp.setCtrls(d), this.restoreFocusOnHeader(t, o);
  }
  getHeaderCtrlForColumn(e) {
    var t;
    if (Bt(e))
      return (t = this.columnsRowCtrl) == null ? void 0 : t.getHeaderCellCtrl(e);
    if (this.groupsRowCtrls.length !== 0)
      for (let s = 0; s < this.groupsRowCtrls.length; s++) {
        const i = this.groupsRowCtrls[s].getHeaderCellCtrl(e);
        if (i)
          return i;
      }
  }
  getHtmlElementForColumnHeader(e) {
    var t;
    return ((t = this.getHeaderCtrlForColumn(e)) == null ? void 0 : t.eGui) ?? null;
  }
  getRowType(e) {
    var t;
    return (t = this.getAllCtrls()[e]) == null ? void 0 : t.type;
  }
  focusHeader(e, t, s) {
    const r = this.getAllCtrls()[e];
    return r ? r.focusHeader(t, s) : !1;
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(e) {
    return this.groupsRowCtrls[e];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  destroy() {
    this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl), this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl), this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls), super.destroy();
  }
  setupDragAndDrop(e, t) {
    const s = e == null ? void 0 : e.createBodyDropTarget(this.pinned, t);
    s && this.createManagedBean(s);
  }
  restoreFocusOnHeader(e, t) {
    if (!t)
      return;
    const { column: s } = t;
    s.getPinned() == this.pinned && e.focusHeaderPosition({ headerPosition: t });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged(e) {
    const t = !!(e != null && e.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== t && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new bl((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
}, yy = class extends P {
  constructor() {
    super(...arguments), this.beanName = "menuSvc";
  }
  postConstruct() {
    const { enterpriseMenuFactory: e, filterMenuFactory: t } = this.beans;
    this.activeMenuFactory = e ?? t;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const { enterpriseMenuFactory: t, filterMenuFactory: s } = this.beans, i = t && we(this.gos) ? t : s;
    this.showColumnMenuCommon(i, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, s) {
    var i;
    (i = this.activeMenuFactory) == null || i.showMenuAfterContextMenuEvent(e, t, s);
  }
  hidePopupMenu() {
    var e, t;
    (e = this.beans.contextMenuSvc) == null || e.hideActiveMenu(), (t = this.activeMenuFactory) == null || t.hideActiveMenu();
  }
  isColumnMenuInHeaderEnabled(e) {
    var s;
    const { suppressHeaderMenuButton: t } = e.getColDef();
    return !t && !!((s = this.activeMenuFactory) != null && s.isMenuEnabled(e)) && (we(this.gos) || !!this.beans.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    const t = e && Bt(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef();
    return !(t != null && t.suppressHeaderContextMenu) && this.gos.get("columnMenu") === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(fs() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !we(this.gos) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e)) && !we(this.gos) && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFloatingFilterButtonEnabled(e) {
    return !e.getColDef().suppressFloatingFilterButton;
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos, t = e.get("suppressMenuHide");
    return we(e) ? e.exists("suppressMenuHide") ? t : !1 : t;
  }
  showColumnMenuCommon(e, t, s, i) {
    const { positionBy: r } = t, o = t.column;
    if (r === "button") {
      const { buttonElement: n } = t;
      e == null || e.showMenuAfterButtonClick(o, n, s, i);
    } else if (r === "mouse") {
      const { mouseEvent: n } = t;
      e == null || e.showMenuAfterMouseEvent(o, n, s, i);
    } else if (o) {
      const n = this.beans, a = n.ctrlsSvc;
      a.getScrollFeature().ensureColumnVisible(o, "auto"), pt(n, () => {
        var d;
        const l = (d = a.getHeaderRowContainerCtrl(o.getPinned())) == null ? void 0 : d.getHeaderCtrlForColumn(o);
        l && (e == null || e.showMenuAfterButtonClick(
          o,
          l.getAnchorElementForMenu(i),
          s,
          !0
        ));
      });
    }
  }
};
function Eo(e, t, s) {
  e.menuVisible !== t && (e.menuVisible = t, e.dispatchColEvent("menuVisibleChanged", s));
}
var Ju = class extends L {
  constructor() {
    super();
  }
}, by = class extends Ju {
  init() {
    var t;
    const e = ge((t = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(
      e ?? /* html */
      '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>'
    ), !e) {
      const s = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = s("loadingOoo", "Loading...");
      });
    }
  }
}, Sy = class extends Ju {
  init() {
    var t;
    const e = ge((t = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? /* html */
    '<span class="ag-overlay-no-rows-center"></span>'), !e) {
      const s = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = s("noRowsToShow", "No Rows To Show");
      });
    }
  }
};
function ms(e, t, s) {
  const i = B(e, t, s);
  if (i) {
    const { className: o } = i;
    if (typeof o == "string" && o.indexOf("ag-icon") > -1 || typeof o == "object" && o["ag-icon"])
      return i;
  }
  const r = document.createElement("span");
  return r.appendChild(i), r;
}
function B(e, t, s) {
  var o;
  let i = null;
  e === "smallDown" ? R(262) : e === "smallLeft" ? R(263) : e === "smallRight" && R(264);
  const r = s && s.getColDef().icons;
  if (r && (i = r[e]), t.gos && !i) {
    const n = t.gos.get("icons");
    n && (i = n[e]);
  }
  if (i) {
    let n;
    if (typeof i == "function")
      n = i();
    else if (typeof i == "string")
      n = i;
    else {
      R(38, { iconName: e });
      return;
    }
    if (typeof n == "string")
      return Be(n);
    if (qo(n))
      return n;
    R(133, { iconName: e });
    return;
  } else {
    const n = document.createElement("span"), a = t.registry.getIcon(e);
    a || (o = t.validation) == null || o.validateIcon(e);
    const l = a ?? e;
    return n.setAttribute("class", `ag-icon ag-icon-${l}`), n.setAttribute("unselectable", "on"), re(n, "presentation"), n;
  }
}
var xy = (
  /*css*/
  ".ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}"
), Fy = class extends L {
  constructor() {
    super(), this.dragSource = null, this.eIcon = S, this.eLabel = S, this.registerCSS(xy);
  }
  postConstruct() {
    const e = (t) => ms(t, this.beans, null);
    this.dropIconMap = {
      pinned: e("columnMovePin"),
      hide: e("columnMoveHide"),
      move: e("columnMoveMove"),
      left: e("columnMoveLeft"),
      right: e("columnMoveRight"),
      group: e("columnMoveGroup"),
      aggregate: e("columnMoveValue"),
      pivot: e("columnMovePivot"),
      notAllowed: e("dropNotAllowed")
    };
  }
  init(e) {
    this.dragSource = e.dragSource, this.setTemplate(
      /* html */
      `<div class="ag-dnd-ghost ag-unselectable">
                <span data-ref="eIcon" class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
                <div data-ref="eLabel" class="ag-dnd-ghost-label"></div>
            </div>`
    );
  }
  destroy() {
    this.dragSource = null, super.destroy();
  }
  setIcon(e, t) {
    const { eIcon: s, dragSource: i, dropIconMap: r, gos: o } = this;
    X(s);
    let n = null;
    e || (e = i != null && i.getDefaultIconName ? i.getDefaultIconName() : "notAllowed"), n = r[e], s.classList.toggle("ag-shake-left-to-right", t), !(n === r.hide && o.get("suppressDragLeaveHidesColumns")) && n && s.appendChild(n);
  }
  setLabel(e) {
    this.eLabel.textContent = Q(e);
  }
}, Ry = (
  /*css*/
  ".ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}"
), Ml = class extends L {
  constructor(e, t, s) {
    super(t, s), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {}, this.registerCSS(Ry);
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: s, labelAlignment: i, disabled: r } = this.config;
    r != null && this.setDisabled(r), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), s != null && this.setLabelWidth(s), this.setLabelAlignment(i || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    const { label: e, eLabel: t } = this;
    X(t), typeof e == "string" ? t.innerText = e + this.labelSeparator : e && t.appendChild(e), e === "" ? (O(t, !1), re(t, "presentation")) : (O(t, !0), re(t, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    const e = this.eLabel;
    return e.id = e.id || `ag-${this.getCompId()}-label`, e.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const s = this.getGui().classList;
    return s.toggle("ag-label-align-left", e === "left"), s.toggle("ag-label-align-right", e === "right"), s.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (fo(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return lt(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, ep = class extends Ml {
  constructor(e, t, s, i) {
    super(e, t, s), this.className = i;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: s } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), s != null && this.onValueChange(s), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), s = this.getLabel();
    s == null || s == "" || nC(e) !== null ? vs(e, "") : vs(e, t ?? "");
  }
  setAriaLabel(e) {
    return oe(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return yt(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
}, us = class extends ep {
  constructor(e, t, s = "text", i = "input") {
    super(
      e,
      (e == null ? void 0 : e.template) ?? /* html */
      `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${i} data-ref="eInput" class="ag-input-field-input"></${i}>
                </div>
            </div>`,
      [],
      t
    ), this.inputType = s, this.displayFieldTag = i, this.eLabel = S, this.eWrapper = S, this.eInput = S;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType();
    const { eLabel: e, eWrapper: t, eInput: s, className: i } = this;
    e.classList.add(`${i}-label`), t.classList.add(`${i}-input-wrapper`), s.classList.add(`${i}-input`), this.addCssClass("ag-input-field"), s.id = s.id || `ag-${this.getCompId()}-input`;
    const { inputName: r, inputWidth: o } = this.config;
    r != null && this.setInputName(r), o != null && this.setInputWidth(o), this.addInputListeners(), this.activateTabIndex([s]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return fo(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return ht(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return oe(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return lt(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      ht(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      ht(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, ri = class extends us {
  constructor(e, t = "ag-checkbox", s = "checkbox") {
    super(e, t, s), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    if (this.isSelected() === e)
      return;
    this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0;
    const s = this.eInput;
    s.checked = e, s.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue);
  }
  dispatchChange(e, t, s) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: s });
    const i = this.getInputElement();
    this.eventSvc.dispatchEvent({
      type: "checkboxChanged",
      id: i.id,
      name: i.name,
      selected: e,
      previousValue: t
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), s = this.selected = e.target.checked;
    this.refreshSelectedClass(s), this.dispatchChange(s, t, e);
  }
  refreshSelectedClass(e) {
    const t = this.eWrapper.classList;
    t.toggle("ag-checked", e === !0), t.toggle("ag-indeterminate", e == null);
  }
}, Pt = {
  selector: "AG-CHECKBOX",
  component: ri
}, Py = (
  /*css*/
  ".ag-checkbox-cell{height:100%}"
), Ty = class extends L {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [Pt]
    ), this.eCheckbox = S, this.registerCSS(Py);
  }
  init(e) {
    this.refresh(e);
    const { eCheckbox: t, beans: s } = this, i = t.getInputElement();
    i.setAttribute("tabindex", "-1"), gh(i, "polite"), this.addManagedListeners(i, {
      click: (r) => {
        if (he(r), t.isDisabled())
          return;
        const o = t.getValue();
        this.onCheckboxChanged(o);
      },
      dblclick: (r) => {
        he(r);
      }
    }), this.addManagedElementListeners(e.eGridCell, {
      keydown: (r) => {
        if (r.key === w.SPACE && !t.isDisabled()) {
          e.eGridCell === q(s) && t.toggle();
          const o = t.getValue();
          this.onCheckboxChanged(o), r.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    let t, s = !0;
    const { value: i, column: r, node: o } = e;
    if (o.group && r)
      if (typeof i == "boolean")
        t = i;
      else {
        const h = r.getColId();
        h.startsWith(Ss) ? t = i == null || i === "" ? void 0 : i === "true" : o.aggData && o.aggData[h] !== void 0 ? t = i ?? void 0 : s = !1;
      }
    else
      t = i ?? void 0;
    const { eCheckbox: n } = this;
    if (!s) {
      n.setDisplayed(!1);
      return;
    }
    n.setValue(t);
    const a = e.disabled ?? !(r != null && r.isCellEditable(o));
    n.setDisabled(a);
    const l = this.getLocaleTextFunc(), d = tl(l, t), c = a ? d : `${l("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${d})`;
    n.setInputAriaLabel(c);
  }
  onCheckboxChanged(e) {
    const { eventSvc: t, params: s } = this, { column: i, node: r, value: o } = s, n = {
      column: i,
      colDef: i.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: o
    };
    t.dispatchEvent({
      type: "cellEditingStarted",
      ...n
    });
    const a = r.setDataValue(i, e, "edit");
    t.dispatchEvent({
      type: "cellEditingStopped",
      ...n,
      oldValue: o,
      newValue: e,
      valueChanged: a
    }), a || this.updateCheckbox(s);
  }
}, Dy = "ROOT_NODE_ID", tp = class extends P {
  constructor() {
    super(...arguments), this.nextId = 0, this.allNodesMap = {}, this.rootNode = null;
  }
  get treeData() {
    return !1;
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  extractRowData() {
    var e, t;
    return (t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) == null ? void 0 : t.map((s) => s.data);
  }
  activate(e) {
    this.rootNode = e, e.group = !0, e.level = -1, e.id = Dy, e.allLeafChildren = [], e.childrenAfterGroup = [], e.childrenAfterSort = [], e.childrenAfterAggFilter = [], e.childrenAfterFilter = [], this.updateRootSiblingArrays(e);
  }
  deactivate() {
    this.rootNode && (this.allNodesMap = {}, this.rootNode = null);
  }
  destroy() {
    super.destroy(), this.allNodesMap = {}, this.rootNode = null;
  }
  setNewRowData(e) {
    const t = this.rootNode;
    t && (this.dispatchRowDataUpdateStartedEvent(e), t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.allNodesMap = {}, this.nextId = 0, this.loadNewRowData(e), this.updateRootSiblingArrays(t));
  }
  updateRootSiblingArrays(e) {
    const t = e.sibling;
    t && (t.childrenAfterFilter = e.childrenAfterFilter, t.childrenAfterGroup = e.childrenAfterGroup, t.childrenAfterAggFilter = e.childrenAfterAggFilter, t.childrenAfterSort = e.childrenAfterSort, t.childrenMapped = e.childrenMapped, t.allLeafChildren = e.allLeafChildren);
  }
  loadNewRowData(e) {
    this.rootNode.allLeafChildren = (e == null ? void 0 : e.map((t, s) => this.createRowNode(t, s))) ?? [];
  }
  setImmutableRowData(e, t) {
    const s = this.createTransactionForRowData(t), i = this.updateRowData(s, e.changedRowNodes);
    let r = !1;
    this.gos.get("suppressMaintainUnsortedOrder") || (r = this.updateRowOrderFromRowData(t));
    const { rowNodeTransaction: o, rowsInserted: n } = i, { add: a, remove: l, update: d } = o;
    (n || r || a.length || l.length || d.length) && (e.step = "group", e.rowDataUpdated = !0, e.rowNodeTransactions = [o], e.rowNodesOrderChanged = n || r);
  }
  updateRowData(e, t) {
    this.dispatchRowDataUpdateStartedEvent(e.add);
    const s = {
      changedRowNodes: t,
      rowNodeTransaction: { remove: [], update: [], add: [] },
      rowsInserted: !1
    }, i = [], r = Yt(this.gos);
    return this.executeRemove(r, e, s, i), this.executeUpdate(r, e, s, i), this.executeAdd(e, s), this.deselectNodes(i), s;
  }
  /** Converts the setRowData() command to a transaction */
  createTransactionForRowData(e) {
    const t = Yt(this.gos), s = { ...this.allNodesMap }, i = [], r = [], o = [];
    A(e) && e.forEach((n) => {
      const a = t({ data: n, level: 0 }), l = s[a];
      l ? (l.data !== n && r.push(n), s[a] = void 0) : o.push(n);
    });
    for (const n of Object.values(s))
      n && i.push(n.data);
    return { remove: i, update: r, add: o };
  }
  /**
   * Used by setImmutableRowData, after updateRowData, after updating with a generated transaction to
   * apply the order as specified by the the new data. We use sourceRowIndex to determine the order of the rows.
   * Time complexity is O(n) where n is the number of rows/rowData
   * @returns true if the order changed, otherwise false
   */
  updateRowOrderFromRowData(e) {
    var n;
    const t = (n = this.rootNode) == null ? void 0 : n.allLeafChildren, s = (t == null ? void 0 : t.length) ?? 0, i = /* @__PURE__ */ new Map();
    let r = -1, o = -1;
    for (let a = 0; a < s; ++a) {
      const l = t[a], d = l.data;
      d !== e[a] && (o < 0 && (r = a), o = a, i.set(d, l));
    }
    if (r < 0)
      return !1;
    for (let a = r; a <= o; ++a) {
      const l = i.get(e[a]);
      l !== void 0 && (t[a] = l, l.sourceRowIndex = a);
    }
    return !0;
  }
  executeAdd(e, t) {
    const s = e.add;
    if (!(s != null && s.length))
      return;
    let i = this.rootNode.allLeafChildren, r = i.length;
    if (typeof e.addIndex == "number" && (r = this.sanitizeAddIndex(e.addIndex), r > 0 && this.gos.get("treeData") && this.gos.get("getDataPath")))
      for (let h = 0; h < i.length; h++) {
        const u = i[h];
        if ((u == null ? void 0 : u.rowIndex) == r - 1) {
          r = h + 1;
          break;
        }
      }
    const o = s.length, n = t.changedRowNodes, a = new Array(o);
    for (let c = 0; c < o; c++) {
      const h = this.createRowNode(s[c], r + c);
      n.add(h), a[c] = h;
    }
    const l = this.rootNode;
    if (r < i.length) {
      const c = i.slice(0, r), h = i.slice(r, i.length), u = c.length + a.length;
      for (let p = 0, g = h.length; p < g; ++p)
        h[p].sourceRowIndex = u + p;
      i = [...c, ...a, ...h], t.rowsInserted = !0;
    } else
      i = i.concat(a);
    l.allLeafChildren = i;
    const d = l.sibling;
    d && (d.allLeafChildren = i), t.rowNodeTransaction.add = a;
  }
  executeRemove(e, t, { changedRowNodes: s, rowNodeTransaction: i }, r) {
    var d, c;
    const { remove: o } = t;
    if (!(o != null && o.length))
      return;
    const n = {};
    o.forEach((h) => {
      const u = this.lookupRowNode(e, h);
      u && (u.isSelected() && r.push(u), u.clearRowTopAndRowIndex(), n[u.id] = !0, delete this.allNodesMap[u.id], i.remove.push(u), s.remove(u));
    });
    const a = this.rootNode;
    a.allLeafChildren = ((d = a.allLeafChildren) == null ? void 0 : d.filter((h) => !n[h.id])) ?? null, (c = a.allLeafChildren) == null || c.forEach((h, u) => {
      h.sourceRowIndex = u;
    });
    const l = a.sibling;
    l && (l.allLeafChildren = a.allLeafChildren);
  }
  executeUpdate(e, t, { changedRowNodes: s, rowNodeTransaction: i }, r) {
    const { update: o } = t;
    o != null && o.length && o.forEach((n) => {
      const a = this.lookupRowNode(e, n);
      a && (a.updateData(n), !a.selectable && a.isSelected() && r.push(a), i.update.push(a), s.update(a));
    });
  }
  dispatchRowDataUpdateStartedEvent(e) {
    this.eventSvc.dispatchEvent({
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    });
  }
  deselectNodes(e) {
    var r;
    const t = "rowDataChanged", s = this.beans.selectionSvc, i = e.length > 0;
    i && (s == null || s.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    })), (r = s == null ? void 0 : s.updateGroupsFromChildrenSelections) == null || r.call(s, t), i && this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: t
    });
  }
  sanitizeAddIndex(e) {
    var s;
    const t = ((s = this.rootNode.allLeafChildren) == null ? void 0 : s.length) ?? 0;
    return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e);
  }
  createRowNode(e, t) {
    const s = new Qe(this.beans);
    return s.parent = this.rootNode, s.level = 0, s.group = !1, s.expanded = !1, s.sourceRowIndex = t, s.setDataAndId(e, String(this.nextId)), this.allNodesMap[s.id] && R(2, { nodeId: s.id }), this.allNodesMap[s.id] = s, this.nextId++, s;
  }
  lookupRowNode(e, t) {
    var i, r;
    let s;
    if (e) {
      const o = e({ data: t, level: 0 });
      if (s = this.allNodesMap[o], !s)
        return z(4, { id: o }), null;
    } else if (s = (r = (i = this.rootNode) == null ? void 0 : i.allLeafChildren) == null ? void 0 : r.find((o) => o.data === t), !s)
      return z(5, { data: t }), null;
    return s || null;
  }
}, Mt = /* @__PURE__ */ ((e) => (e.Applied = "Applied", e.StoreNotFound = "StoreNotFound", e.StoreLoading = "StoreLoading", e.StoreWaitingToLoad = "StoreWaitingToLoad", e.StoreLoadingFailed = "StoreLoadingFailed", e.StoreWrongType = "StoreWrongType", e.Cancelled = "Cancelled", e.StoreNotStarted = "StoreNotStarted", e))(Mt || {}), Ey = class extends L {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [Pt]
    ), this.eCheckbox = S;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.getLocaleTextFunc(), { rowNode: t, eCheckbox: s } = this, i = t.isSelected(), r = tl(e, i), [o, n] = t.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], a = e(o, n);
    s.setValue(i, !0), s.setInputAriaLabel(`${a} (${r})`);
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: he,
      click: (i) => {
        var r;
        he(i), (r = this.beans.selectionSvc) == null || r.handleSelectionEvent(i, this.rowNode, "checkboxSelected");
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), this.addManagedPropertyListener("rowSelection", ({ currentValue: i, previousValue: r }) => {
      const o = typeof i == "object" ? In(i) : void 0, n = typeof r == "object" ? In(r) : void 0;
      o !== n && this.onSelectableChanged();
    }), va(this.gos) || typeof this.getIsVisible() == "function") {
      const i = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: i }), this.addManagedListeners(this.rowNode, {
        dataChanged: i,
        cellChanged: i
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  showOrHideSelect() {
    const { column: e, rowNode: t, overrides: s, gos: i } = this;
    let r = t.selectable;
    const o = this.getIsVisible();
    if (r)
      if (typeof o == "function") {
        const l = s == null ? void 0 : s.callbackParams;
        if (!e)
          r = o({ ...l, node: t, data: t.data });
        else {
          const d = e.createColumnFunctionCallbackParams(t);
          r = o({ ...l, ...d });
        }
      } else
        r = o ?? !1;
    const n = i.get("rowSelection");
    if (n && typeof n != "string" ? !In(n) : e == null ? void 0 : e.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!r), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if (s != null && s.removeHidden) {
      this.setDisplayed(r);
      return;
    }
    this.setVisible(r);
  }
  getIsVisible() {
    var s, i;
    const e = this.overrides;
    if (e)
      return e.isVisible;
    const t = this.gos.get("rowSelection");
    return t && typeof t != "string" ? zs(t) : (i = (s = this.column) == null ? void 0 : s.getColDef()) == null ? void 0 : i.checkboxSelection;
  }
}, My = class {
  constructor(e) {
    this.rootId = null, this.endId = null, this.cachedRange = [], this.rowModel = e;
  }
  reset() {
    this.rootId = null, this.endId = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.rootId = e.id, this.endId = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.endId = e.id, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t) ?? [];
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.rootId === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot() {
    return this.rootId ? this.rowModel.getRowNode(this.rootId) ?? null : null;
  }
  getEnd() {
    return this.endId ? this.rowModel.getRowNode(this.endId) ?? null : null;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const s = t[0].id === this.rootId, i = t.findIndex((r) => r.id === e.id);
    if (i > -1) {
      const r = t.slice(0, i), o = t.slice(i + 1);
      return this.setEndRange(e), s ? { keep: r, discard: o } : { keep: o, discard: r };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const s = this.getRoot();
    if (s == null) {
      const r = this.getRange().slice();
      return t && e.depthFirstSearch((o) => !o.group && r.push(o)), r.push(e), this.setRoot(e), { keep: r, discard: [] };
    }
    const i = this.rowModel.getNodesInRangeForSelection(s, e);
    if (!i)
      return this.setRoot(e), { keep: [e], discard: [] };
    if (i.find((r) => r.id === this.endId))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const r = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: r };
    }
  }
}, Ay = class extends P {
  constructor(e) {
    super(), this.column = e, this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(q(this.beans)) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e;
    const t = this.createManagedBean(new ri());
    this.cbSelectAll = t, t.addCssClass("ag-header-select-all"), re(t.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedEventListeners({
      newColumnsLoaded: this.showOrHideSelectAll.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: this.onSelectionChanged.bind(this),
      paginationChanged: this.onSelectionChanged.bind(this),
      modelUpdated: this.onModelChanged.bind(this)
    }), this.addManagedListeners(t, { fieldValueChanged: this.onCbSelectAll.bind(this) }), t.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    const e = this.isCheckboxSelection();
    this.cbSelectAllVisible = e, this.cbSelectAll.setDisplayed(e), e && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.getSelectAllMode(), t = this.beans.selectionSvc, s = this.cbSelectAll, i = t.getSelectAllState(e);
    s.setValue(i);
    const r = t.hasNodesToSelect(e);
    s.setDisabled(!r), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.getLocaleTextFunc(), { headerCellCtrl: t, cbSelectAll: s, cbSelectAllVisible: i } = this, o = s.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), n = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    t.setAriaDescriptionProperty(
      "selectAll",
      i ? `${n} (${o})` : null
    ), s.setInputAriaLabel(e("ariaHeaderSelection", "Column with Header Selection")), t.announceAriaDescription();
  }
  checkSelectionType(e) {
    return bs(this.gos) ? !0 : (R(128, { feature: e }), !1);
  }
  checkRightRowModelType(e) {
    const { gos: t, rowModel: s } = this.beans;
    return J(t) || Te(t) ? !0 : (R(129, { feature: e, rowModel: s.getType() }), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.getSelectAllMode();
    let s = "uiSelectAll";
    t === "currentPage" ? s = "uiSelectAllCurrentPage" : t === "filtered" && (s = "uiSelectAllFiltered");
    const i = { source: s, selectAll: t }, r = this.beans.selectionSvc;
    e ? r.selectAllRowNodes(i) : r.deselectAllRowNodes(i);
  }
  /**
   * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
   * or `headerCheckboxSelection` is enabled in the legacy API.
   */
  isCheckboxSelection() {
    var d;
    const { column: e, gos: t, beans: s } = this, i = t.get("rowSelection"), r = e.getColDef(), { headerCheckboxSelection: o } = r;
    let n = !1;
    const a = typeof i == "object";
    if (a) {
      const c = Ot(e), h = en(e);
      (vo(i) === "autoGroupColumn" && h || c && ((d = s.selectionColSvc) != null && d.isSelectionColumnEnabled())) && (n = eo(i));
    } else
      typeof o == "function" ? n = o(t.addGridCommonParams({ column: e, colDef: r })) : n = !!o;
    const l = a ? "headerCheckbox" : "headerCheckboxSelection";
    return n && this.checkRightRowModelType(l) && this.checkSelectionType(l);
  }
  getSelectAllMode() {
    const e = Kh(this.gos, !1);
    if (e)
      return e;
    const { headerCheckboxSelectionCurrentPageOnly: t, headerCheckboxSelectionFilteredOnly: s } = this.column.getColDef();
    return t ? "currentPage" : s ? "filtered" : "all";
  }
}, sp = class extends P {
  postConstruct() {
    const { gos: e, beans: t } = this;
    this.selectionCtx = new My(t.rowModel), this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => {
      const s = va(e);
      s !== this.isRowSelectable && (this.isRowSelectable = s, this.updateSelectable());
    }), this.isRowSelectable = va(e);
  }
  destroy() {
    super.destroy(), this.selectionCtx.reset();
  }
  createCheckboxSelectionComponent() {
    return new Ey();
  }
  createSelectAllFeature(e) {
    return new Ay(e);
  }
  isMultiSelect() {
    return bs(this.gos);
  }
  onRowCtrlSelected(e, t, s) {
    const i = !!e.rowNode.isSelected();
    e.forEachGui(s, (r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-selected", i);
      const o = r.element;
      hr(o, i), o.contains(q(this.beans)) && t(r);
    });
  }
  announceAriaRowSelection(e) {
    var r;
    if (this.isRowSelectionBlocked(e))
      return;
    const t = e.isSelected();
    if (t && !Ed(this.gos))
      return;
    const i = this.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row`
    );
    (r = this.beans.ariaAnnounce) == null || r.announceValue(i, "rowSelection");
  }
  dispatchSelectionChanged(e) {
    this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: e
    });
  }
  isRowSelectionBlocked(e) {
    return !e.selectable || !!e.rowPinned || !ot(this.gos);
  }
  updateRowSelectable(e, t) {
    var i;
    const s = ((i = this.isRowSelectable) == null ? void 0 : i.call(this, e)) ?? !0;
    return this.setRowSelectable(e, s, t), s;
  }
  setRowSelectable(e, t, s) {
    if (e.selectable !== t) {
      if (e.selectable = t, e.dispatchRowEvent("selectableChanged"), s)
        return;
      if (qs(this.gos)) {
        const r = this.calculateSelectedFromChildren(e);
        this.setNodesSelected({ nodes: [e], newValue: r ?? !1, source: "selectableChanged" });
        return;
      }
      e.isSelected() && !e.selectable && this.setNodesSelected({ nodes: [e], newValue: !1, source: "selectableChanged" });
    }
  }
  calculateSelectedFromChildren(e) {
    var i;
    let t = !1, s = !1;
    if (!((i = e.childrenAfterGroup) != null && i.length))
      return e.selectable ? e.__selected : null;
    for (let r = 0; r < e.childrenAfterGroup.length; r++) {
      const o = e.childrenAfterGroup[r];
      let n = o.isSelected();
      if (!o.selectable) {
        const a = this.calculateSelectedFromChildren(o);
        if (a === null)
          continue;
        n = a;
      }
      switch (n) {
        case !0:
          t = !0;
          break;
        case !1:
          s = !0;
          break;
        default:
          return;
      }
    }
    if (!(t && s))
      return t ? !0 : s ? !1 : e.selectable ? e.__selected : null;
  }
  selectRowNode(e, t, s, i = "api") {
    const r = !e.selectable && t, o = e.__selected === t;
    if (r || o)
      return !1;
    e.__selected = t, e.dispatchRowEvent("rowSelected");
    const n = e.sibling;
    return n && n.footer && n.__localEventService && n.dispatchRowEvent("rowSelected"), this.eventSvc.dispatchEvent({
      ...Hu(e, this.gos, "rowSelected"),
      event: s || null,
      source: i
    }), !0;
  }
  isCellCheckboxSelection(e, t) {
    const s = this.gos.get("rowSelection");
    if (s && typeof s != "string") {
      const i = Ot(e) && zs(s);
      return e.isColumnFunc(t, i);
    } else
      return e.isColumnFunc(t, e.colDef.checkboxSelection);
  }
  inferNodeSelections(e, t, s, i) {
    const { gos: r, selectionCtx: o } = this, n = e.isSelected(), a = qs(r), l = OC(r), d = Ed(r), c = i === "rowClicked";
    if (c && a && e.group || c && !(l || d))
      return null;
    if (t && s && this.isMultiSelect()) {
      const h = o.getRoot();
      if (h)
        if (h.isSelected()) {
          const u = o.isInRange(e) ? o.truncate(e) : o.extend(e, a);
          return {
            deselect: u.discard,
            select: u.keep,
            reset: !1
          };
        } else {
          const u = o.extend(e, a);
          return {
            select: [],
            deselect: u.keep,
            reset: !1
          };
        }
      else return null;
    } else if (t && this.isMultiSelect()) {
      const h = o.getRoot(), u = o.isInRange(e) ? o.truncate(e) : o.extend(e, a);
      return {
        select: u.keep,
        deselect: u.discard,
        reset: !!(h && !h.isSelected())
      };
    } else {
      if (s)
        return o.setRoot(e), c && n && !d ? null : {
          node: e,
          newValue: !n,
          clearSelection: !this.isMultiSelect()
        };
      {
        o.setRoot(e);
        const h = GC(r), u = wo(r) === "filteredDescendants", p = c && (!h || !l);
        if (u && n === void 0 && J(r))
          return {
            node: e,
            newValue: !1,
            clearSelection: !this.isMultiSelect() || p
          };
        if (c) {
          const g = n ? !h : l;
          return g === n ? null : {
            node: e,
            newValue: g,
            clearSelection: !this.isMultiSelect() || p
          };
        }
        return {
          node: e,
          newValue: !n,
          clearSelection: !this.isMultiSelect() || p
        };
      }
    }
  }
}, Iy = class extends ri {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    const t = this.eInput;
    e.selected && e.name && t.name && t.name === e.name && e.id && t.id !== e.id && this.setValue(!1, !0);
  }
}, Ly = (
  /*css*/
  '.ag-toggle-button{flex:none;min-width:unset;width:unset}.ag-toggle-button-input-wrapper{background-color:var(--ag-toggle-button-off-background-color);border-radius:calc(var(--ag-toggle-button-height)*.5);flex:none;height:var(--ag-toggle-button-height);max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);position:relative;transition:background-color .1s;:where(.ag-toggle-button-input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-toggle-button-height);margin:0;max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);opacity:0}&:before{background-color:var(--ag-toggle-button-switch-background-color);border-radius:100%;content:"";display:block;height:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2);left:var(--ag-toggle-button-switch-inset);pointer-events:none;position:absolute;top:var(--ag-toggle-button-switch-inset);transition:left .1s;width:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2)}&.ag-checked{background-color:var(--ag-toggle-button-on-background-color);&:before{left:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-switch-inset))}}&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{opacity:.5}}'
), Ii = class extends ri {
  constructor(e) {
    super(e, "ag-toggle-button"), this.registerCSS(Ly);
  }
  setValue(e, t) {
    return super.setValue(e, t), this.addOrRemoveCssClass("ag-selected", this.getValue()), this;
  }
}, ky = {
  selector: "AG-TOGGLE-BUTTON",
  component: Ii
}, Tt = class extends us {
  constructor(e, t = "ag-text-field", s = "text") {
    super(e, t, s);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    const s = this.eInput;
    return s.value !== e && (s.value = A(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (s) => {
      xl(s) && s.key && !e.test(s.key) && s.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (s) => {
        var r;
        const i = (r = s.clipboardData) == null ? void 0 : r.getData("text");
        i && i.split("").some((o) => !e.test(o)) && s.preventDefault();
      }
    });
  }
}, mt = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: Tt
}, Oy = class extends us {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const s = super.setValue(e, t);
    return this.eInput.value = e, s;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, Gy = {
  selector: "AG-INPUT-TEXT-AREA",
  component: Oy
}, nn = class extends Tt {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct();
    const e = this.eInput;
    this.addManagedListeners(e, {
      blur: () => {
        const o = parseFloat(e.value), n = isNaN(o) ? "" : this.normalizeValue(o.toString());
        this.value !== n && this.setValue(n);
      },
      wheel: this.onWheel.bind(this)
    }), e.step = "any";
    const { precision: t, min: s, max: i, step: r } = this.config;
    typeof t == "number" && this.setPrecision(t), typeof s == "number" && this.setMin(s), typeof i == "number" && this.setMax(i), typeof r == "number" && this.setStep(r);
  }
  onWheel(e) {
    q(this.beans) === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e), { min: s, max: i } = this;
    return s != null && t < s ? e = s.toString() : i != null && t > i && (e = i.toString()), e;
  }
  adjustPrecision(e, t) {
    const s = this.precision;
    if (s == null)
      return e;
    if (t) {
      const r = parseFloat(e).toFixed(s);
      return parseFloat(r).toString();
    }
    const i = String(e).split(".");
    if (i.length > 1) {
      if (i[1].length <= s)
        return e;
      if (s > 0)
        return `${i[0]}.${i[1].slice(0, s)}`;
    }
    return i[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, ht(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, ht(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, ht(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue(
      (s) => super.setValue(s, t),
      () => this,
      e
    );
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, s) {
    if (A(s)) {
      let i = this.isScientificNotation(s);
      if (i && this.eInput.validity.valid)
        return e(s);
      if (!i) {
        s = this.adjustPrecision(s);
        const r = this.normalizeValue(s);
        i = s != r;
      }
      if (i)
        return t(s);
    }
    return e(s);
  }
  getValue() {
    const e = this.eInput;
    if (!e.validity.valid)
      return;
    const t = e.value;
    return this.isScientificNotation(t) ? this.adjustPrecision(t, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, an = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: nn
};
function sr(e, t) {
  return e.toString().padStart(t, "0");
}
function Ze(e, t = !0, s = "-") {
  if (!e)
    return null;
  let i = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((r) => sr(r, 2)).join(s);
  return t && (i += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((r) => sr(r, 2)).join(":")), i;
}
var Vn = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function ir(e, t = "YYYY-MM-DD") {
  const s = sr(e.getFullYear(), 4), i = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], r = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], o = {
    YYYY: () => s.slice(s.length - 4, s.length),
    YY: () => s.slice(s.length - 2, s.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => i[e.getMonth()],
    MMM: () => i[e.getMonth()].slice(0, 3),
    MM: () => sr(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${Vn(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${Vn(e.getDate())}`,
    DD: () => sr(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => r[e.getDay()],
    ddd: () => r[e.getDay()].slice(0, 3),
    dd: () => r[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${Vn(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, n = new RegExp(Object.keys(o).join("|"), "g");
  return t.replace(n, (a) => a in o ? o[a]() : a);
}
function Le(e) {
  if (!e)
    return null;
  const [t, s] = e.split(" ");
  if (!t)
    return null;
  const i = t.split("-").map((h) => parseInt(h, 10));
  if (i.filter((h) => !isNaN(h)).length !== 3)
    return null;
  const [r, o, n] = i, a = new Date(r, o - 1, n);
  if (a.getFullYear() !== r || a.getMonth() !== o - 1 || a.getDate() !== n)
    return null;
  if (!s || s === "00:00:00")
    return a;
  const [l, d, c] = s.split(":").map((h) => parseInt(h, 10));
  return l >= 0 && l < 24 && a.setHours(l), d >= 0 && d < 60 && a.setMinutes(d), c >= 0 && c < 60 && a.setSeconds(c), a;
}
var ip = class extends Tt {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = si();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        this.isDisabled() || e || this.eInput.focus();
      }
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    q(this.beans) === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Ze(e ?? null, !1) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, ht(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Ze(e ?? null, !1) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, ht(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, ht(this.eInput, "step", e), this);
  }
  getDate() {
    if (this.eInput.validity.valid)
      return Le(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Ze(e ?? null, !1), t);
  }
}, rp = {
  selector: "AG-INPUT-DATE-FIELD",
  component: ip
}, By = 1e3, Vy = 1e3, Vd = 100, Nd, Wr = !1, Ny = class extends P {
  constructor(e, t) {
    super(), this.tooltipCtrl = e, this.getTooltipValue = t, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.userCompFactory = e.userCompFactory;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const e = this.tooltipCtrl.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(e, {
      mouseenter: this.onMouseEnter.bind(this),
      mouseleave: this.onMouseLeave.bind(this)
    }), this.tooltipTrigger === 1 && this.addManagedListeners(e, {
      focusin: this.onFocusIn.bind(this),
      focusout: this.onFocusOut.bind(this)
    }), this.addManagedListeners(e, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(e, {
      mousedown: this.onMouseDown.bind(this),
      keydown: this.onKeyDown.bind(this)
    });
  }
  getGridOptionsTooltipDelay(e) {
    const t = this.gos.get(e);
    return Math.max(200, t);
  }
  getTooltipDelay(e) {
    var t, s, i, r;
    return e === "show" ? ((s = (t = this.tooltipCtrl).getTooltipShowDelayOverride) == null ? void 0 : s.call(t)) ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : ((r = (i = this.tooltipCtrl).getTooltipHideDelayOverride) == null ? void 0 : r.call(i)) ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const e = this.gos.get("tooltipTrigger");
    return !e || e === "hover" ? 0 : 1;
  }
  onMouseEnter(e) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !fs() && (Wr ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(e);
    }, Vd) : this.prepareToShowTooltip(e));
  }
  onMouseMove(e) {
    this.lastMouseEvent && (this.lastMouseEvent = e), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(e) {
    var r;
    const t = e.relatedTarget, s = this.tooltipCtrl.getGui(), i = (r = this.tooltipComp) == null ? void 0 : r.getGui();
    this.isInteractingWithTooltip || s.contains(t) || this.interactionEnabled && (i != null && i.contains(t)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.isInteractingWithTooltip && (this.isInteractingWithTooltip = !1), this.setToDoNothing();
  }
  prepareToShowTooltip(e) {
    if (this.state != 0 || Wr)
      return;
    let t = 0;
    e && (t = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = e || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), t), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    return (/* @__PURE__ */ new Date()).getTime() - Nd < By;
  }
  setToDoNothing(e) {
    !e && this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.onDocumentKeyDownCallback && (this.onDocumentKeyDownCallback(), this.onDocumentKeyDownCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    var n, a, l, d, c, h, u;
    const e = this.getTooltipValue(), t = this.tooltipCtrl;
    if (!A(e) || t.shouldDisplayTooltip && !t.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    const s = (n = t.getRowNode) == null ? void 0 : n.call(t), i = {
      location: ((a = t.getLocation) == null ? void 0 : a.call(t)) ?? "UNKNOWN",
      //'cell',
      colDef: (l = t.getColDef) == null ? void 0 : l.call(t),
      column: (d = t.getColumn) == null ? void 0 : d.call(t),
      rowIndex: (c = t.getRowIndex) == null ? void 0 : c.call(t),
      node: s,
      data: s == null ? void 0 : s.data,
      value: e,
      valueFormatted: (h = t.getValueFormatted) == null ? void 0 : h.call(t),
      hideTooltipCallback: () => this.hideTooltip(!0),
      ...((u = t.getAdditionalParams) == null ? void 0 : u.call(t)) ?? {}
    };
    this.state = 2, this.tooltipInstanceCount++;
    const r = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount), o = $v(this.userCompFactory, i);
    o == null || o.newAgStackInstance().then(r);
  }
  hideTooltip(e) {
    !e && this.isInteractingWithTooltip || (this.tooltipComp && (this.destroyTooltipComp(), Nd = (/* @__PURE__ */ new Date()).getTime()), this.eventSvc.dispatchEvent({
      type: "tooltipHide",
      parentGui: this.tooltipCtrl.getGui()
    }), e && (this.isInteractingWithTooltip = !1), this.setToDoNothing(!0));
  }
  newTooltipComponentCallback(e, t) {
    var n;
    if (this.state !== 2 || this.tooltipInstanceCount !== e) {
      this.destroyBean(t);
      return;
    }
    const i = t.getGui();
    this.tooltipComp = t, i.classList.contains("ag-tooltip") || i.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && i.classList.add("ag-tooltip-animate"), this.interactionEnabled && i.classList.add("ag-tooltip-interactive");
    const r = this.getLocaleTextFunc(), o = (n = this.popupSvc) == null ? void 0 : n.addPopup({
      eChild: i,
      ariaLabel: r("ariaLabelTooltip", "Tooltip")
    });
    if (o && (this.tooltipPopupDestroyFunc = o.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const a = () => this.setToDoNothing();
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
        bodyScroll: a,
        columnMoved: a
      });
    }
    this.interactionEnabled && ([this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(i, {
      mouseenter: this.onTooltipMouseEnter.bind(this),
      mouseleave: this.onTooltipMouseLeave.bind(this)
    }), [this.onDocumentKeyDownCallback] = this.addManagedElementListeners(Z(this.beans), {
      keydown: (a) => {
        i.contains(a == null ? void 0 : a.target) || this.onKeyDown();
      }
    }), this.tooltipTrigger === 1 && ([this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(i, {
      focusin: this.onTooltipFocusIn.bind(this),
      focusout: this.onTooltipFocusOut.bind(this)
    }))), this.eventSvc.dispatchEvent({
      type: "tooltipShow",
      tooltipGui: i,
      parentGui: this.tooltipCtrl.getGui()
    }), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, this.lockService());
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  isTooltipFocused() {
    var s;
    const e = (s = this.tooltipComp) == null ? void 0 : s.getGui(), t = q(this.beans);
    return !!e && e.contains(t);
  }
  onTooltipFocusOut(e) {
    const t = this.tooltipCtrl.getGui();
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, t.contains(e.relatedTarget) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    var t, s;
    const e = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? (t = this.popupSvc) == null || t.positionPopupUnderMouseEvent({
      ...e,
      mouseEvent: this.lastMouseEvent
    }) : (s = this.popupSvc) == null || s.positionPopupByComponent({
      ...e,
      eventSource: this.tooltipCtrl.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const e = this.tooltipPopupDestroyFunc, t = this.tooltipComp, s = this.tooltipTrigger === 0 ? Vy : 0;
    window.setTimeout(() => {
      e(), this.destroyBean(t);
    }, s), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((e) => {
      e && e();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    Wr = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, Vd);
  }
  unlockService() {
    Wr = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
function rr(e) {
  return e.get("tooltipShowMode") === "whenTruncated";
}
function ln(e, t) {
  return rr(e) ? Us(t) : void 0;
}
function Us(e) {
  return () => {
    const t = e();
    return t ? t.scrollWidth > t.clientWidth : !0;
  };
}
var Hy = class extends P {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  postConstruct() {
    this.refreshTooltip();
  }
  setBrowserTooltip(e) {
    const t = "title", s = this.ctrl.getGui();
    s && (e != null && e != "" ? s.setAttribute(t, e) : s.removeAttribute(t));
  }
  updateTooltipText() {
    const { getTooltipValue: e } = this.ctrl;
    e && (this.tooltip = e());
  }
  createTooltipFeatureIfNeeded() {
    this.tooltipManager == null && (this.tooltipManager = this.createBean(
      new Ny(this.ctrl, () => this.tooltip),
      this.beans.context
    ));
  }
  setTooltipAndRefresh(e) {
    this.tooltip = e, this.refreshTooltip();
  }
  refreshTooltip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  destroy() {
    this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context), super.destroy();
  }
}, zy = class extends L {
  constructor(e = "default", t = !1) {
    super(
      /* html */
      `<div class="ag-list ag-${e}-list" role="listbox"></div>`
    ), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case w.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const s = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(s);
        }
        break;
      case w.DOWN:
      case w.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case w.PAGE_DOWN:
      case w.PAGE_UP:
      case w.PAGE_HOME:
      case w.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === w.DOWN;
    let s;
    const { itemEls: i, highlightedEl: r } = this;
    if (!r)
      s = i[t ? 0 : i.length - 1];
    else {
      let n = i.indexOf(r) + (t ? 1 : -1);
      n = Math.min(Math.max(n, 0), i.length - 1), s = i[n];
    }
    this.highlightItem(s);
  }
  navigateToPage(e) {
    const { itemEls: t, highlightedEl: s } = this;
    if (!s || t.length === 0)
      return;
    const i = t.indexOf(s), r = this.options.length - 1, o = t[0].clientHeight, n = Math.floor(this.getGui().clientHeight / o);
    let a = -1;
    e === w.PAGE_HOME ? a = 0 : e === w.PAGE_END ? a = r : e === w.PAGE_DOWN ? a = Math.min(i + n, r) : e === w.PAGE_UP && (a = Math.max(i - n, 0)), a !== -1 && this.highlightItem(t[a]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: s } = e, i = s || t;
    return this.options.push({ value: t, text: i }), this.renderOption(t, i), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((e) => {
      ce(e);
    }), this.itemEls = [];
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, s) => {
      Ko(t, s + 1), Uo(t, e.length);
    });
  }
  renderOption(e, t) {
    const s = Z(this.beans), i = s.createElement("div");
    re(i, "option"), i.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const r = s.createElement("span");
    i.appendChild(r), r.textContent = t, this.unFocusable || (i.tabIndex = -1), this.itemEls.push(i), this.addManagedListeners(i, {
      mouseover: () => this.highlightItem(i),
      mousedown: (o) => {
        o.preventDefault(), o.stopPropagation(), this.setValue(e);
      }
    }), this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getTooltipValue: () => t,
        getGui: () => i,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => r.scrollWidth > r.clientWidth
      })
    ), this.getGui().appendChild(i);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const s = this.options.findIndex((i) => i.value === e);
    if (s !== -1) {
      const i = this.options[s];
      this.value = i.value, this.displayValue = i.text, this.highlightItem(this.itemEls[s]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!ke(e))
      return;
    this.clearHighlighted(), this.highlightedEl = e, e.classList.add(this.activeClass), hr(e, !0);
    const t = this.getGui(), { scrollTop: s, clientHeight: i } = t, { offsetTop: r, offsetHeight: o } = e;
    (r + o > s + i || r < s) && e.scrollIntoView({ block: "nearest" }), this.unFocusable || e.focus();
  }
  clearHighlighted() {
    const e = this.highlightedEl;
    !e || !ke(e) || (e.classList.remove(this.activeClass), hr(e, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, Wy = (
  /*css*/
  ".ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:disabled{opacity:.5}&.ag-picker-has-focus,&:focus-within{border:var(--ag-input-focus-border);box-shadow:var(--ag-focus-shadow)}}.ag-picker-field-button{background-color:var(--ag-background-color)}"
), Al = class extends ep {
  constructor(e) {
    if (super(
      e,
      (e == null ? void 0 : e.template) || /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      (e == null ? void 0 : e.agComponents) || [],
      e == null ? void 0 : e.className
    ), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = S, this.eWrapper = S, this.eDisplayField = S, this.eIcon = S, this.registerCSS(Wy), this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: s, variableWidth: i, minPickerWidth: r, maxPickerWidth: o } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!i, s != null && this.setPickerMaxHeight(s), r != null && this.setPickerMinWidth(r), o != null && this.setPickerMaxWidth(o);
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: s, inputWidth: i } = this.config;
    if (s) {
      const r = B(s, this.beans);
      r && this.eIcon.appendChild(r);
    }
    i != null && this.setInputWidth(i);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), He(e, !1), this.ariaRole && re(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case w.UP:
      case w.DOWN:
      case w.ENTER:
      case w.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case w.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const t = this.getLocaleTextFunc(), {
      config: { pickerAriaLabelKey: s, pickerAriaLabelValue: i, modalPicker: r = !0 },
      maxPickerHeight: o,
      minPickerWidth: n,
      maxPickerWidth: a,
      variableWidth: l,
      beans: d,
      eWrapper: c
    } = this, h = {
      modal: r,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = ys(d);
        this.beforeHidePicker(), f && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: t(s, i),
      anchorToElement: c
    };
    e.style.position = "absolute";
    const u = d.popupSvc, p = u.addPopup(h);
    l ? (n && (e.style.minWidth = n), e.style.width = il($s(c)), a && (e.style.maxWidth = a)) : fo(e, a ?? $s(c));
    const g = o ?? `${$o(u.getPopupParent())}px`;
    return e.style.setProperty("max-height", g), this.alignPickerToComponent(), p.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const {
      pickerGap: e,
      config: { pickerType: t },
      beans: { popupSvc: s, gos: i },
      eWrapper: r,
      pickerComponent: o
    } = this, n = i.get("enableRtl") ? "right" : "left";
    s.positionPopupByComponent({
      type: t,
      eventSource: r,
      ePopup: o.getGui(),
      position: "under",
      alignSide: n,
      keepWithinBounds: !0,
      nudgeY: e
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    He(t, e);
    const s = this.eWrapper.classList;
    s.toggle("ag-picker-expanded", e), s.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    var e;
    (e = this.hideCurrentPicker) == null || e.call(this);
  }
  setInputWidth(e) {
    return fo(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, _y = (
  /*css*/
  ".ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}"
), Ne = class extends Al {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "selectOpen",
      ariaRole: "combobox",
      ...e
    }), this.registerCSS(_y);
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        shouldDisplayTooltip: Us(() => this.eDisplayField),
        getGui: () => this.getGui()
      })
    ), super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: s } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), s && t == null && (this.eDisplayField.textContent = s), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    const e = this.createBean(new zy("select", !0));
    this.listComponent = e, e.setParentComponent(this);
    const t = e.getAriaElement(), s = `ag-select-list-${e.getCompId()}`;
    t.setAttribute("id", s), el(this.getAriaElement(), t), e.addManagedListeners(e, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      }
    }), e.addManagedListeners(e, {
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var s;
    const { key: t } = e;
    switch (t === w.TAB && this.hidePicker(), t) {
      case w.ENTER:
      case w.UP:
      case w.DOWN:
      case w.PAGE_UP:
      case w.PAGE_DOWN:
      case w.PAGE_HOME:
      case w.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (s = this.listComponent) == null || s.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case w.ESCAPE:
        super.onKeyDown(e);
        break;
      case w.SPACE:
        this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    const e = this.listComponent;
    e && (super.showPicker(), e.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this;
  }
  setValue(e, t, s) {
    const {
      listComponent: i,
      config: { placeholder: r },
      eDisplayField: o,
      tooltipFeature: n
    } = this;
    if (this.value === e || !i)
      return this;
    if (s || i.setValue(e, !0), i.getValue() === this.getValue())
      return this;
    let l = i.getDisplayValue();
    return l == null && r && (l = r), o.textContent = l, n == null || n.setTooltipAndRefresh(l ?? null), super.setValue(e, t);
  }
  destroy() {
    this.listComponent = this.destroyBean(this.listComponent), super.destroy();
  }
}, Rr = {
  selector: "AG-SELECT",
  component: Ne
}, io = {
  TAB_GUARD: "ag-tab-guard",
  TAB_GUARD_TOP: "ag-tab-guard-top",
  TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
}, Uy = class extends P {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: s,
      eBottomGuard: i,
      focusTrapActive: r,
      forceFocusOutWhenTabGuardsAreEmpty: o,
      isFocusableContainer: n,
      focusInnerElement: a,
      onFocusIn: l,
      onFocusOut: d,
      shouldStopEventPropagation: c,
      onTabKeyDown: h,
      handleKeyDown: u,
      eFocusableElement: p
    } = e;
    this.comp = t, this.eTopGuard = s, this.eBottomGuard = i, this.providedFocusInnerElement = a, this.eFocusableElement = p, this.focusTrapActive = !!r, this.forceFocusOutWhenTabGuardsAreEmpty = !!o, this.isFocusableContainer = !!n, this.providedFocusIn = l, this.providedFocusOut = d, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = h, this.providedHandleKeyDown = u;
  }
  postConstruct() {
    this.createManagedBean(
      new Ps(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && bt(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    var l;
    const t = Z(this.beans), s = bt(t.body, null, !0), i = s.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (i === -1)
      return;
    let r, o;
    e ? (r = 0, o = i) : (r = i + 1, o = s.length);
    const n = s.slice(r, o), a = this.gos.get("tabIndex");
    n.sort((d, c) => {
      const h = parseInt(d.getAttribute("tabindex") || "0"), u = parseInt(c.getAttribute("tabindex") || "0");
      return u === a ? 1 : h === a ? -1 : h === 0 ? 1 : u === 0 ? -1 : h - u;
    }), (l = n[e ? n.length - 1 : 0]) == null || l.focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const s = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), s && (s.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = bt(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return Pe(this.beans, this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, op = class extends P {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: s, eFocusableElement: i } = this, r = [t, s], o = {
      setTabIndex: (f) => {
        r.forEach(
          (m) => f != null ? m.setAttribute("tabindex", f) : m.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, s);
    const {
      focusTrapActive: n = !1,
      onFocusIn: a,
      onFocusOut: l,
      focusInnerElement: d,
      handleKeyDown: c,
      onTabKeyDown: h,
      shouldStopEventPropagation: u,
      forceFocusOutWhenTabGuardsAreEmpty: p,
      isFocusableContainer: g
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new Uy({
        comp: o,
        focusTrapActive: n,
        eTopGuard: t,
        eBottomGuard: s,
        eFocusableElement: i,
        onFocusIn: a,
        onFocusOut: l,
        focusInnerElement: d,
        handleKeyDown: c,
        onTabKeyDown: h,
        shouldStopEventPropagation: u,
        forceFocusOutWhenTabGuardsAreEmpty: p,
        isFocusableContainer: g
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = Z(this.beans).createElement("div"), s = e === "top" ? io.TAB_GUARD_TOP : io.TAB_GUARD_BOTTOM;
    return t.classList.add(io.TAB_GUARD, s), re(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    const s = this.eFocusableElement;
    s.insertAdjacentElement("afterbegin", e), s.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    X(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, s) {
    qo(t) || (t = t.getGui());
    const { eBottomGuard: i } = this;
    i ? i.insertAdjacentElement("beforebegin", t) : e(t, s);
  }
}, Nt = class extends L {
  initialiseTabGuard(e) {
    this.tabGuardFeature = this.createManagedBean(new op(this)), this.tabGuardFeature.initialiseTabGuard(e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(e);
  }
  appendChild(e, t) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), e, t);
  }
}, Ts = class extends L {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, hs = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new Rs(), this.preventMouseClick = t;
    const s = this.onTouchStart.bind(this), i = this.onTouchMove.bind(this), r = this.onTouchEnd.bind(this);
    e.addEventListener("touchstart", s, { passive: !0 }), e.addEventListener("touchmove", i, { passive: !0 }), e.addEventListener("touchend", r, { passive: !1 }), this.destroyFuncs.push(() => {
      e.removeEventListener("touchstart", s, { passive: !0 }), e.removeEventListener("touchmove", i, { passive: !0 }), e.removeEventListener("touchend", r, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const s = this.touchStart === t;
      if (this.touching && s && !this.moved) {
        this.moved = !0;
        const i = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(i);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !Ou(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const s = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(s), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}, dt = /* @__PURE__ */ ((e) => (e[e.VALUE = 0] = "VALUE", e[e.DIMENSION = 1] = "DIMENSION", e))(dt || {}), np = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t(), this.baseDocLink = `${Lh}/${this.frameworkName}-data-grid`, FC(this.baseDocLink);
  }
  setInterval(e, t) {
    return new U((s) => {
      s(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, s, i) {
    let r = {};
    if (typeof i == "object" ? r = i : typeof i == "boolean" && (r = { capture: i }), r.passive == null) {
      const o = Xh(t);
      o != null && (r.passive = o);
    }
    e.addEventListener(t, s, r);
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `${this.baseDocLink}${e ? `/${e}` : ""}`;
  }
};
function Ky(e) {
  return {
    beanName: "gridApi",
    bean: e.getBean("apiFunctionSvc").api
  };
}
var $y = [
  // Validate license first
  "licenseManager",
  // core beans only
  "environment",
  "eventSvc",
  "gos",
  "paginationAutoPageSizeSvc",
  "apiFunctionSvc",
  "gridApi",
  "registry",
  "agCompUtils",
  "userCompFactory",
  "rowContainerHeight",
  "horizontalResizeSvc",
  "localeSvc",
  "pinnedRowModel",
  "dragSvc",
  "colGroupSvc",
  "visibleCols",
  "popupSvc",
  "selectionSvc",
  "colFilter",
  "quickFilter",
  "filterManager",
  "colModel",
  "headerNavigation",
  "pageBounds",
  "pagination",
  "pageBoundsListener",
  "stickyRowSvc",
  "rowRenderer",
  "expressionSvc",
  "alignedGridsSvc",
  "navigation",
  "valueCache",
  "valueSvc",
  "autoWidthCalc",
  "filterMenuFactory",
  "dragAndDrop",
  "focusSvc",
  "cellNavigation",
  "cellStyles",
  "scrollVisibleSvc",
  "sortSvc",
  "colHover",
  "colAnimation",
  "autoColSvc",
  "selectionColSvc",
  "changeDetectionSvc",
  "animationFrameSvc",
  "undoRedo",
  "colDefFactory",
  "rowStyleSvc",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsSvc",
  "pinnedCols",
  "dataTypeSvc",
  "syncSvc",
  "overlays",
  "stateSvc",
  "expansionSvc",
  "apiEventSvc",
  "ariaAnnounce",
  "menuSvc",
  "colMoves",
  "colAutosize",
  "colFlex",
  "colResize",
  "pivotColsSvc",
  "valueColsSvc",
  "rowGroupColsSvc",
  "funcColsSvc",
  "colNames",
  "colViewport",
  "pivotResultCols",
  "showRowGroupCols",
  "validation"
  // Have validations run last
], Hd = Object.fromEntries(
  $y.map((e, t) => [e, t])
);
function jy(e, t) {
  const s = (e.beanName ? Hd[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, i = (t.beanName ? Hd[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return s - i;
}
function qy(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroySvc" ? -1 : 0;
}
var Yy = (
  /* html */
  '<div class="ag-pinned-left-header" role="rowgroup"></div>'
), Xy = (
  /* html */
  '<div class="ag-pinned-right-header" role="rowgroup"></div>'
), Zy = (
  /* html */
  `<div class="ag-header-viewport" role="presentation">
        <div class="ag-header-container" data-ref="eCenterContainer" role="rowgroup"></div>
    </div>`
), Nn = class extends L {
  constructor(e) {
    super(), this.eCenterContainer = S, this.headerRowComps = {}, this.rowCompsList = [], this.pinned = e;
  }
  postConstruct() {
    this.selectAndSetTemplate();
    const e = {
      setDisplayed: (s) => this.setDisplayed(s),
      setCtrls: (s) => this.setCtrls(s),
      // only gets called for center section
      setCenterWidth: (s) => this.eCenterContainer.style.width = s,
      setViewportScrollLeft: (s) => this.getGui().scrollLeft = s,
      // only gets called for pinned sections
      setPinnedContainerWidth: (s) => {
        const i = this.getGui();
        i.style.width = s, i.style.maxWidth = s, i.style.minWidth = s;
      }
    };
    this.createManagedBean(new wy(this.pinned)).setComp(e, this.getGui());
  }
  selectAndSetTemplate() {
    const e = this.pinned == "left", t = this.pinned == "right", s = e ? Yy : t ? Xy : Zy;
    this.setTemplate(s), this.eRowContainer = this.eCenterContainer !== S ? this.eCenterContainer : this.getGui();
  }
  destroy() {
    this.setCtrls([]), super.destroy();
  }
  destroyRowComp(e) {
    this.destroyBean(e), this.eRowContainer.removeChild(e.getGui());
  }
  setCtrls(e) {
    const t = this.headerRowComps;
    this.headerRowComps = {}, this.rowCompsList = [];
    let s;
    const i = (r) => {
      const o = r.getGui();
      o.parentElement != this.eRowContainer && this.eRowContainer.appendChild(o), s && Dh(this.eRowContainer, o, s), s = o;
    };
    e.forEach((r) => {
      const o = r.instanceId, n = t[o];
      delete t[o];
      const a = n || this.createBean(new fy(r));
      this.headerRowComps[o] = a, this.rowCompsList.push(a), i(a);
    }), Object.values(t).forEach((r) => this.destroyRowComp(r));
  }
}, Qy = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-header" role="presentation"/>'
    );
  }
  postConstruct() {
    const e = {
      addOrRemoveCssClass: (i, r) => this.addOrRemoveCssClass(i, r),
      setHeightAndMinHeight: (i) => {
        this.getGui().style.height = i, this.getGui().style.minHeight = i;
      }
    };
    this.createManagedBean(new hy()).setComp(e, this.getGui(), this.getFocusableElement());
    const s = (i) => {
      this.createManagedBean(i), this.appendChild(i);
    };
    s(new Nn("left")), s(new Nn(null)), s(new Nn("right"));
  }
}, Jy = {
  selector: "AG-HEADER-ROOT",
  component: Qy
}, eb = class extends L {
  constructor(e, t, s, i, r) {
    super(), this.cellCtrl = t, this.rendererVersion = 0, this.editorVersion = 0, this.beans = e, this.column = t.column, this.rowNode = t.rowNode, this.eRow = i;
    const o = document.createElement("div");
    o.setAttribute("comp-id", `${this.getCompId()}`), this.setTemplateFromElement(o);
    const n = this.getGui();
    this.forceWrapper = t.isForceWrapper(), this.refreshWrapper(!1), re(n, t.getCellAriaRole()), n.setAttribute("col-id", t.colIdSanitised);
    const a = {
      addOrRemoveCssClass: (l, d) => this.addOrRemoveCssClass(l, d),
      setUserStyles: (l) => Mh(n, l),
      getFocusableElement: () => this.getFocusableElement(),
      setIncludeSelection: (l) => this.includeSelection = l,
      setIncludeRowDrag: (l) => this.includeRowDrag = l,
      setIncludeDndSource: (l) => this.includeDndSource = l,
      setRenderDetails: (l, d, c) => this.setRenderDetails(l, d, c),
      setEditDetails: (l, d, c) => this.setEditDetails(l, d, c),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    t.setComp(a, this.getGui(), this.eCellWrapper, s, r, void 0);
  }
  getParentOfValue() {
    return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui();
  }
  setRenderDetails(e, t, s) {
    if (this.cellEditor && !this.cellEditorPopupWrapper)
      return;
    this.firstRender = this.firstRender == null;
    const r = this.refreshWrapper(!1);
    this.refreshEditStyles(!1), e ? !(s || r) && this.refreshCellRenderer(e) || (this.destroyRenderer(), this.createCellRendererInstance(e)) : (this.destroyRenderer(), this.insertValueWithoutCellRenderer(t));
  }
  setEditDetails(e, t, s) {
    e ? this.createCellEditorInstance(e, t, s) : this.destroyEditor();
  }
  removeControls() {
    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(e) {
    const t = this.includeRowDrag || this.includeDndSource || this.includeSelection, s = t || this.forceWrapper, i = s && this.eCellWrapper == null;
    if (i) {
      const d = document.createElement("div");
      d.setAttribute("role", "presentation"), d.setAttribute("class", "ag-cell-wrapper"), this.eCellWrapper = d, this.getGui().appendChild(this.eCellWrapper);
    }
    const r = !s && this.eCellWrapper != null;
    r && (ce(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !s);
    const o = !e && s, n = o && this.eCellValue == null;
    if (n) {
      const d = document.createElement("span");
      d.setAttribute("role", "presentation"), d.setAttribute("class", "ag-cell-value"), this.eCellValue = d, this.eCellWrapper.appendChild(this.eCellValue);
    }
    const a = !o && this.eCellValue != null;
    a && (ce(this.eCellValue), this.eCellValue = void 0);
    const l = i || r || n || a;
    return l && this.removeControls(), e || t && this.addControls(), l;
  }
  addControls() {
    this.includeRowDrag && this.rowDraggingComp == null && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && this.dndSourceComp == null && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.dndSourceComp && this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && this.checkboxSelectionComp == null && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.checkboxSelectionComp && this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue));
  }
  createCellEditorInstance(e, t, s) {
    const i = this.editorVersion, r = e.newAgStackInstance(), { params: o } = e;
    r.then((a) => this.afterCellEditorCreated(i, a, o, t, s)), Y(this.cellEditor) && o.cellStartedEdit && this.cellCtrl.focusCell(!0);
  }
  insertValueWithoutCellRenderer(e) {
    const t = this.getParentOfValue();
    X(t);
    const s = e != null ? Q(e, !0) : null;
    s != null && (t.textContent = s);
  }
  destroyEditorAndRenderer() {
    this.destroyRenderer(), this.destroyEditor();
  }
  destroyRenderer() {
    const { context: e } = this.beans;
    this.cellRenderer = e.destroyBean(this.cellRenderer), ce(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
  }
  destroyEditor() {
    const { context: e } = this.beans;
    this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = e.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = e.destroyBean(this.cellEditorPopupWrapper), ce(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
  }
  refreshCellRenderer(e) {
    if (this.cellRenderer == null || this.cellRenderer.refresh == null || this.cellRendererClass !== e.componentClass)
      return !1;
    const t = this.cellRenderer.refresh(e.params);
    return t === !0 || t === void 0;
  }
  createCellRendererInstance(e) {
    const s = !this.beans.gos.get("suppressAnimationFrame") && this.beans.animationFrameSvc, i = this.rendererVersion, { componentClass: r } = e, o = () => {
      if (this.rendererVersion !== i || !this.isAlive())
        return;
      const a = e.newAgStackInstance(), l = this.afterCellRendererCreated.bind(this, i, r);
      a && a.then(l);
    };
    s && this.firstRender ? this.beans.animationFrameSvc.createTask(o, this.rowNode.rowIndex, "createTasksP2") : o();
  }
  afterCellRendererCreated(e, t, s) {
    if (!this.isAlive() || e !== this.rendererVersion) {
      this.beans.context.destroyBean(s);
      return;
    }
    if (this.cellRenderer = s, this.cellRendererClass = t, this.cellRendererGui = this.cellRenderer.getGui(), this.cellRendererGui != null) {
      const r = this.getParentOfValue();
      X(r), r.appendChild(this.cellRendererGui);
    }
  }
  afterCellEditorCreated(e, t, s, i, r) {
    if (e !== this.editorVersion) {
      this.beans.context.destroyBean(t);
      return;
    }
    if (t.isCancelBeforeStart && t.isCancelBeforeStart()) {
      this.beans.context.destroyBean(t), this.cellCtrl.stopEditing(!0);
      return;
    }
    if (!t.getGui) {
      R(97, { colId: this.column.getId() }), this.beans.context.destroyBean(t);
      return;
    }
    this.cellEditor = t, this.cellEditorGui = t.getGui();
    const a = i || t.isPopup !== void 0 && t.isPopup();
    a ? this.addPopupCellEditor(s, r) : this.addInCellEditor(), this.refreshEditStyles(!0, a), t.afterGuiAttached && t.afterGuiAttached(), this.cellCtrl.cellEditorAttached();
  }
  refreshEditStyles(e, t) {
    this.addOrRemoveCssClass("ag-cell-inline-editing", e && !t), this.addOrRemoveCssClass("ag-cell-popup-editing", e && !!t), this.addOrRemoveCssClass("ag-cell-not-inline-editing", !e || !!t), this.cellCtrl.setInlineEditingCss();
  }
  addInCellEditor() {
    const e = this.getGui();
    e.contains(q(this.beans)) && e.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui && this.getParentOfValue().appendChild(this.cellEditorGui);
  }
  addPopupCellEditor(e, t) {
    var u;
    this.beans.gos.get("editType") === "fullRow" && R(98);
    const s = this.cellEditor;
    this.cellEditorPopupWrapper = this.beans.context.createBean(
      this.beans.editSvc.createPopupEditorWrapper(e)
    );
    const i = this.cellEditorPopupWrapper.getGui();
    this.cellEditorGui && i.appendChild(this.cellEditorGui);
    const r = this.beans.popupSvc, o = this.beans.gos.get("stopEditingWhenCellsLoseFocus"), n = t ?? ((u = s.getPopupPosition) == null ? void 0 : u.call(s)) ?? "over", a = this.beans.gos.get("enableRtl"), l = {
      ePopup: i,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.getGui(),
      position: n,
      alignSide: a ? "right" : "left",
      keepWithinBounds: !0
    }, d = r.positionPopupByComponent.bind(r, l), c = uh(this.beans.localeSvc), h = r.addPopup({
      modal: o,
      eChild: i,
      closeOnEsc: !0,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.getGui(),
      positionCallback: d,
      ariaLabel: c("ariaLabelCellEditor", "Cell Editor")
    });
    h && (this.hideEditorPopup = h.hideFunc);
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), super.destroy();
  }
  clearParentOfValue() {
    const e = this.getGui();
    e.contains(q(this.beans)) && e.focus({ preventScroll: !0 }), X(this.getParentOfValue());
  }
}, tb = class extends L {
  constructor(e, t, s) {
    super(), this.cellComps = {}, this.beans = t, this.rowCtrl = e;
    const i = document.createElement("div");
    i.setAttribute("comp-id", `${this.getCompId()}`), i.setAttribute("style", this.getInitialStyle(s)), this.setTemplateFromElement(i);
    const r = this.getGui(), o = r.style;
    this.domOrder = this.rowCtrl.getDomOrder(), re(r, "row");
    const n = {
      setDomOrder: (a) => this.domOrder = a,
      setCellCtrls: (a) => this.setCellCtrls(a),
      showFullWidth: (a) => this.showFullWidth(a),
      getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
      addOrRemoveCssClass: (a, l) => this.addOrRemoveCssClass(a, l),
      setUserStyles: (a) => Mh(r, a),
      setTop: (a) => o.top = a,
      setTransform: (a) => o.transform = a,
      setRowIndex: (a) => r.setAttribute("row-index", a),
      setRowId: (a) => r.setAttribute("row-id", a),
      setRowBusinessKey: (a) => r.setAttribute("row-business-key", a),
      refreshFullWidth: (a) => {
        var l, d;
        return ((d = (l = this.fullWidthCellRenderer) == null ? void 0 : l.refresh) == null ? void 0 : d.call(l, a())) ?? !1;
      }
    };
    e.setComp(n, this.getGui(), s, void 0), this.addDestroyFunc(() => {
      e.unsetComp(s);
    });
  }
  getInitialStyle(e) {
    const t = this.rowCtrl.getInitialTransform(e);
    return t ? `transform: ${t}` : `top: ${this.rowCtrl.getInitialRowTop(e)}`;
  }
  showFullWidth(e) {
    const t = (i) => {
      if (this.isAlive()) {
        const r = i.getGui();
        this.getGui().appendChild(r), this.rowCtrl.setupDetailRowAutoHeight(r), this.setFullWidthRowComp(i);
      } else
        this.beans.context.destroyBean(i);
    };
    e.newAgStackInstance().then(t);
  }
  setCellCtrls(e) {
    const t = Object.assign({}, this.cellComps);
    e.forEach((i) => {
      const r = i.instanceId;
      this.cellComps[r] == null ? this.newCellComp(i) : t[r] = null;
    });
    const s = Object.values(t).filter((i) => i != null);
    this.destroyCells(s), this.ensureDomOrder(e);
  }
  ensureDomOrder(e) {
    if (!this.domOrder)
      return;
    const t = [];
    e.forEach((s) => {
      const i = this.cellComps[s.instanceId];
      i && t.push(i.getGui());
    }), Eh(this.getGui(), t);
  }
  newCellComp(e) {
    const t = new eb(
      this.beans,
      e,
      this.rowCtrl.printLayout,
      this.getGui(),
      this.rowCtrl.editing
    );
    this.cellComps[e.instanceId] = t, this.getGui().appendChild(t.getGui());
  }
  destroy() {
    super.destroy(), this.destroyAllCells();
  }
  destroyAllCells() {
    const e = Object.values(this.cellComps).filter((t) => t != null);
    this.destroyCells(e);
  }
  setFullWidthRowComp(e) {
    this.fullWidthCellRenderer = e, this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  destroyCells(e) {
    e.forEach((t) => {
      if (!t)
        return;
      const s = t.cellCtrl.instanceId;
      this.cellComps[s] === t && (t.detach(), t.destroy(), this.cellComps[s] = null);
    });
  }
};
function sb(e) {
  let t;
  return e.type === "center" ? t = /* html */
  `<div class="${e.viewport}" data-ref="eViewport" role="presentation">
                <div class="${e.container}" data-ref="eContainer"></div>
            </div>` : t = /* html */
  `<div class="${e.container}" data-ref="eContainer"></div>`, t;
}
var ib = class extends L {
  constructor(e) {
    super(), this.eViewport = S, this.eContainer = S, this.rowComps = {}, this.name = e == null ? void 0 : e.name, this.options = di(this.name), this.setTemplate(sb(this.options));
  }
  postConstruct() {
    const e = {
      setHorizontalScroll: (s) => this.eViewport.scrollLeft = s,
      setViewportHeight: (s) => this.eViewport.style.height = s,
      setRowCtrls: ({ rowCtrls: s }) => this.setRowCtrls(s),
      setDomOrder: (s) => {
        this.domOrder = s;
      },
      setContainerWidth: (s) => this.eContainer.style.width = s,
      setOffsetTop: (s) => this.eContainer.style.transform = `translateY(${s})`
    };
    this.createManagedBean(new ey(this.name)).setComp(e, this.eContainer, this.eViewport);
  }
  destroy() {
    this.setRowCtrls([]), super.destroy();
  }
  setRowCtrls(e) {
    const t = { ...this.rowComps };
    this.rowComps = {}, this.lastPlacedElement = null;
    const s = (i) => {
      const r = i.instanceId, o = t[r];
      if (o)
        this.rowComps[r] = o, delete t[r], this.ensureDomOrder(o.getGui());
      else {
        if (!i.rowNode.displayed)
          return;
        const n = new tb(i, this.beans, this.options.type);
        this.rowComps[r] = n, this.appendRow(n.getGui());
      }
    };
    e.forEach(s), Object.values(t).forEach((i) => {
      this.eContainer.removeChild(i.getGui()), i.destroy();
    }), re(this.eContainer, "rowgroup");
  }
  appendRow(e) {
    this.domOrder ? CC(this.eContainer, e, this.lastPlacedElement) : this.eContainer.appendChild(e), this.lastPlacedElement = e;
  }
  ensureDomOrder(e) {
    this.domOrder && (Dh(this.eContainer, e, this.lastPlacedElement), this.lastPlacedElement = e);
  }
}, rb = {
  selector: "AG-ROW-CONTAINER",
  component: ib
};
function Hi(e, t) {
  return t.map((s) => {
    const i = `e${s[0].toUpperCase() + s.substring(1)}RowContainer`;
    return e[i] = { name: s }, /* html */
    `<ag-row-container name="${s}" data-ref="${i}"></ag-row-container>`;
  }).join("");
}
function ob(e) {
  const t = {}, s = (
    /* html */
    `<div class="ag-root ag-unselectable" data-ref="eGridRoot">
        <ag-header-root></ag-header-root>
        <div class="ag-floating-top" data-ref="eTop" role="presentation">
            ${Hi(t, ["topLeft", "topCenter", "topRight", "topFullWidth"])}
        </div>
        <div class="ag-body" data-ref="eBody" role="presentation">
            <div class="ag-body-viewport" data-ref="eBodyViewport" role="presentation">
            ${Hi(t, ["left", "center", "right", "fullWidth"])}
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" data-ref="eStickyTop" role="presentation">
            ${Hi(t, ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}
        </div>
        <div class="ag-sticky-bottom" data-ref="eStickyBottom" role="presentation">
            ${Hi(t, ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}
        </div>
        <div class="ag-floating-bottom" data-ref="eBottom" role="presentation">
            ${Hi(t, ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        ${e ? (
      /* html */
      "<ag-overlay-wrapper></ag-overlay-wrapper>"
    ) : ""}
    </div>`
  );
  return { paramsMap: t, template: s };
}
var nb = class extends L {
  constructor() {
    super(...arguments), this.eGridRoot = S, this.eBodyViewport = S, this.eStickyTop = S, this.eStickyBottom = S, this.eTop = S, this.eBottom = S, this.eBody = S;
  }
  postConstruct() {
    const { overlays: e, rangeSvc: t } = this.beans, s = e == null ? void 0 : e.getOverlayWrapperSelector(), { paramsMap: i, template: r } = ob(!!s);
    this.setTemplate(
      r,
      [
        ...s ? [s] : [],
        oy,
        ay,
        Jy,
        rb
      ],
      i
    );
    const o = (a, l) => {
      const d = `${a}px`;
      l.style.minHeight = d, l.style.height = d;
    }, n = {
      setRowAnimationCssOnBodyViewport: (a, l) => this.setRowAnimationCssOnBodyViewport(a, l),
      setColumnCount: (a) => hC(this.getGui(), a),
      setRowCount: (a) => cC(this.getGui(), a),
      setTopHeight: (a) => o(a, this.eTop),
      setBottomHeight: (a) => o(a, this.eBottom),
      setTopDisplay: (a) => this.eTop.style.display = a,
      setBottomDisplay: (a) => this.eBottom.style.display = a,
      setStickyTopHeight: (a) => this.eStickyTop.style.height = a,
      setStickyTopTop: (a) => this.eStickyTop.style.top = a,
      setStickyTopWidth: (a) => this.eStickyTop.style.width = a,
      setStickyBottomHeight: (a) => {
        this.eStickyBottom.style.height = a, this.eStickyBottom.classList.toggle("ag-hidden", a === "0px");
      },
      setStickyBottomBottom: (a) => this.eStickyBottom.style.bottom = a,
      setStickyBottomWidth: (a) => this.eStickyBottom.style.width = a,
      setColumnMovingCss: (a, l) => this.addOrRemoveCssClass(a, l),
      updateLayoutClasses: (a, l) => {
        [this.eBodyViewport.classList, this.eBody.classList].forEach((c) => {
          c.toggle(vt.AUTO_HEIGHT, l.autoHeight), c.toggle(vt.NORMAL, l.normal), c.toggle(vt.PRINT, l.print);
        }), this.addOrRemoveCssClass(vt.AUTO_HEIGHT, l.autoHeight), this.addOrRemoveCssClass(vt.NORMAL, l.normal), this.addOrRemoveCssClass(vt.PRINT, l.print);
      },
      setAlwaysVerticalScrollClass: (a, l) => this.eBodyViewport.classList.toggle(qu, l),
      registerBodyViewportResizeListener: (a) => {
        const l = Rt(this.beans, this.eBodyViewport, a);
        this.addDestroyFunc(() => l());
      },
      setPinnedTopBottomOverflowY: (a) => this.eTop.style.overflowY = this.eBottom.style.overflowY = a,
      setCellSelectableCss: (a, l) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach(
          (d) => d.classList.toggle(a, l)
        );
      },
      setBodyViewportWidth: (a) => this.eBodyViewport.style.width = a,
      setGridRootRole: (a) => re(this.eGridRoot, a)
    };
    this.ctrl = this.createManagedBean(new iy()), this.ctrl.setComp(
      n,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    ), (t && Ve(this.gos) || bs(this.gos)) && dC(this.getGui(), !0);
  }
  setRowAnimationCssOnBodyViewport(e, t) {
    const s = this.eBodyViewport.classList;
    s.toggle("ag-row-animation", t), s.toggle("ag-row-no-animation", !t);
  }
}, ab = {
  selector: "AG-GRID-BODY",
  component: nb
}, lb = class extends P {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  setComp(e, t, s) {
    this.view = e, this.eGridHostDiv = t, this.eGui = s, this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
    const { dragAndDrop: i, ctrlsSvc: r } = this.beans;
    i == null || i.registerGridDropTarget(() => this.eGui, this), Iu(this.gos, t), this.createManagedBean(new yl(this.view)), this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
    const o = Rt(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => o()), r.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = ml(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, s, i, r;
    const e = this.beans;
    return {
      paginationSelector: (t = e.pagination) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: e.registry.getSelector("AG-GRID-HEADER-DROP-ZONES"),
      sideBarSelector: (s = e.sideBar) == null ? void 0 : s.getSelector(),
      statusBarSelector: (i = e.registry) == null ? void 0 : i.getSelector("AG-STATUS-BAR"),
      watermarkSelector: (r = e.licenseManager) == null ? void 0 : r.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventSvc.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), { indexWithFocus: s, nextIndex: i } = this.getNextFocusableIndex(t, e);
    if (i < 0 || i >= t.length)
      return !1;
    if (i === 0) {
      if (s > 0) {
        const { visibleCols: r, focusSvc: o } = this.beans, n = r.allCols, a = V(n);
        if (o.focusGridView(a, !0))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[i], e);
  }
  focusInnerElement(e) {
    const t = this.gos.getCallback("focusGridInnerElement");
    if (t && t({ fromBottom: !!e }))
      return !0;
    const s = this.getFocusableContainers(), { focusSvc: i, visibleCols: r } = this.beans, o = r.allCols;
    if (e) {
      if (s.length > 1)
        return this.focusContainer(V(s), !0);
      const n = V(o);
      if (i.focusGridView(n, !0))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || mi(this.beans)) {
      if (i.focusGridView(o[0]))
        return !0;
      for (let n = 1; n < s.length; n++)
        if (ve(s[n].getGui()))
          return !0;
      return !1;
    }
    return i.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  allowFocusForNextCoreContainer(e) {
    var o;
    const t = this.view.getFocusableContainers(), { nextIndex: s, indexWithFocus: i } = this.getNextFocusableIndex(t, e);
    if (i === -1 || s < 0 || s >= t.length)
      return;
    const r = t[s];
    (o = r.setAllowFocus) == null || o.call(r, !0), setTimeout(() => {
      var n;
      (n = r.setAllowFocus) == null || n.call(r, !1);
    });
  }
  getNextFocusableIndex(e, t) {
    const s = q(this.beans), i = e.findIndex((o) => o.getGui().contains(s)), r = i + (t ? -1 : 1);
    return {
      indexWithFocus: i,
      nextIndex: r
    };
  }
  focusContainer(e, t) {
    var i, r;
    (i = e.setAllowFocus) == null || i.call(e, !0);
    const s = ve(e.getGui(), t);
    return (r = e.setAllowFocus) == null || r.call(e, !1), s;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, db = class extends Nt {
  constructor(e) {
    super(), this.gridBody = S, this.sideBar = S, this.pagination = S, this.rootWrapperBody = S, this.eGridDiv = e;
  }
  postConstruct() {
    const e = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (o) => this.addCssClass(o),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (o) => {
        this.getGui().style.userSelect = o ?? "", this.getGui().style.webkitUserSelect = o ?? "";
      },
      setCursor: (o) => {
        this.getGui().style.cursor = o ?? "";
      }
    }, t = this.createManagedBean(new lb()), s = t.getOptionalSelectors(), i = this.createTemplate(s), r = [ab, ...Object.values(s).filter((o) => !!o)];
    this.setTemplate(i, r), t.setComp(e, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => {
      },
      focusInnerElement: (o) => t.focusInnerElement(o),
      forceFocusOutWhenTabGuardsAreEmpty: !0
    });
  }
  insertGridIntoDom() {
    const e = this.getGui();
    this.eGridDiv.appendChild(e), this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(e), ws(this.gos, "Grid removed from DOM");
    });
  }
  updateLayoutClasses(e, t) {
    const s = this.rootWrapperBody.classList, { AUTO_HEIGHT: i, NORMAL: r, PRINT: o } = vt, { autoHeight: n, normal: a, print: l } = t;
    s.toggle(i, n), s.toggle(r, a), s.toggle(o, l), this.addOrRemoveCssClass(i, n), this.addOrRemoveCssClass(r, a), this.addOrRemoveCssClass(o, l);
  }
  createTemplate(e) {
    const t = e.gridHeaderDropZonesSelector ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "", s = e.sideBarSelector ? '<ag-side-bar data-ref="sideBar"></ag-side-bar>' : "", i = e.statusBarSelector ? "<ag-status-bar></ag-status-bar>" : "", r = e.watermarkSelector ? "<ag-watermark></ag-watermark>" : "", o = e.paginationSelector ? '<ag-pagination data-ref="pagination"></ag-pagination>' : "";
    return (
      /* html */
      `<div class="ag-root-wrapper" role="presentation">
                ${t}
                <div class="ag-root-wrapper-body" data-ref="rootWrapperBody" role="presentation">
                    <ag-grid-body data-ref="gridBody"></ag-grid-body>
                    ${s}
                </div>
                ${i}
                ${o}
                ${r}
            </div>`
    );
  }
  getFocusableElement() {
    return this.rootWrapperBody;
  }
  forceFocusOutOfContainer(e = !1) {
    var t;
    if (!e && ((t = this.pagination) != null && t.isDisplayed())) {
      this.pagination.forceFocusOutOfContainer(e);
      return;
    }
    super.forceFocusOutOfContainer(e);
  }
  getFocusableContainers() {
    const e = [this.gridBody];
    return [this.sideBar, this.pagination].forEach((t) => {
      t && e.push(t);
    }), e.filter((t) => ke(t.getGui()));
  }
}, $ = (e, t) => {
  for (const s of Object.keys(t))
    t[s] = e;
  return t;
}, zd = {
  dispatchEvent: "CommunityCore",
  // this is always registered
  ...$("CommunityCore", {
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0
  }),
  ...$("GridState", {
    getState: 0
  }),
  ...$("SharedRowSelection", {
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0
  }),
  ...$("RowApi", {
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0
  }),
  ...$("ScrollApi", {
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0
  }),
  ...$("KeyboardNavigation", {
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0
  }),
  ...$("EventApi", {
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0
  }),
  ...$("ValueCache", {
    expireValueCache: 0
  }),
  ...$("CellApi", {
    getCellValue: 0
  }),
  ...$("SharedMenu", {
    showColumnMenu: 0,
    hidePopupMenu: 0
  }),
  ...$("Sort", {
    onSortChanged: 0
  }),
  ...$("PinnedRow", {
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0
  }),
  ...$("Overlay", {
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0
  }),
  ...$("RenderApi", {
    setGridAriaProperty: 0,
    refreshCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0
  }),
  ...$("HighlightChanges", {
    flashCells: 0
  }),
  ...$("RowDrag", {
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0
  }),
  ...$("ColumnApi", {
    getColumnDefs: 0,
    getColumnDef: 0,
    getDisplayNameForColumn: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnsVisible: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0
  }),
  ...$("ColumnAutoSize", {
    sizeColumnsToFit: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0
  }),
  ...$("ColumnGroup", {
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumnGroup: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0
  }),
  ...$("ColumnMove", {
    moveColumnByIndex: 0,
    moveColumns: 0
  }),
  ...$("ColumnResize", {
    setColumnWidths: 0
  }),
  ...$("ColumnHover", {
    isColumnHovered: 0
  }),
  ...$("EditCore", {
    getCellEditorInstances: 0,
    getEditingCells: 0,
    stopEditing: 0,
    startEditingCell: 0
  }),
  ...$("UndoRedoEdit", {
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0
  }),
  ...$("FilterCore", {
    isAnyFilterPresent: 0,
    onFilterChanged: 0
  }),
  ...$("ColumnFilter", {
    isColumnFilterPresent: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0
  }),
  ...$("QuickFilter", {
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0
  }),
  ...$("Pagination", {
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0
  }),
  ...$("CsrmSsrmSharedApi", {
    expandAll: 0,
    collapseAll: 0,
    onRowHeightChanged: 0
  }),
  ...$("SsrmInfiniteSharedApi", {
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...$("ClientSideRowModelApi", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    resetRowHeights: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0
  }),
  ...$("CsvExport", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...$("InfiniteRowModel", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...$("AdvancedFilter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...$("IntegratedCharts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...$("Clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...$("ExcelExport", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...$("SharedMasterDetail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...$("ContextMenu", {
    showContextMenu: 0
  }),
  ...$("ColumnMenu", {
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...$("CellSelection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...$("SharedRowGrouping", {
    setRowGroupColumns: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0
  }),
  ...$("SharedAggregation", {
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0
  }),
  ...$("SharedPivot", {
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumns: 0,
    addValueColumns: 0,
    setPivotColumns: 0,
    removePivotColumns: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...$("ServerSideRowModelApi", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0
  }),
  ...$("SideBar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...$("StatusBar", {
    getStatusPanel: 0
  })
}, Hn = {
  isDestroyed: () => !0,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
}, cb = (e, t) => e.eventSvc.dispatchEvent(t), ap = class {
};
Reflect.defineProperty(ap, "name", { value: "GridApi" });
var hb = class extends P {
  constructor() {
    super(), this.beanName = "apiFunctionSvc", this.api = new ap(), this.fns = {
      ...Hn,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent: cb
    }, this.preDestroyLink = "";
    const { api: e } = this;
    for (const t of Object.keys(zd))
      e[t] = this.makeApi(t)[t];
  }
  postConstruct() {
    this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(e, t) {
    var r;
    const { fns: s, beans: i } = this;
    s !== Hn && (s[e] = ((r = i == null ? void 0 : i.validation) == null ? void 0 : r.validateApiFunction(e, t)) ?? t);
  }
  makeApi(e) {
    return {
      [e]: (...t) => {
        const {
          beans: s,
          fns: { [e]: i }
        } = this;
        return i ? i(s, ...t) : this.apiNotFound(e);
      }
    };
  }
  apiNotFound(e) {
    const { beans: t, gos: s, preDestroyLink: i } = this;
    if (!t)
      R(26, { fnName: e, preDestroyLink: i });
    else {
      const r = zd[e];
      s.assertModuleRegistered(r, `api.${e}`) && R(27, { fnName: e, module: r });
    }
  }
  destroy() {
    super.destroy(), this.fns = Hn, this.beans = null;
  }
};
function ub(e) {
  return e.context.getGridId();
}
function pb(e) {
  e.gridDestroySvc.destroy();
}
function gb(e) {
  return e.gridDestroySvc.destroyCalled;
}
function fb(e, t) {
  return e.gos.get(t);
}
function mb(e, t, s) {
  lp(e, { [t]: s });
}
function lp(e, t) {
  e.gos.updateGridOptions({ options: t });
}
var Cb = class extends L {
  constructor(e, t, s) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = s;
  }
  postConstruct() {
    this.getGui().appendChild(B("rowDrag", this.beans, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const { rowNode: t, column: s, eCell: i, gos: r } = this, o = s.getColDef().dndSourceOnRowDrag, n = e.dataTransfer;
    if (n.setDragImage(i, 0, 0), o) {
      const a = r.addGridCommonParams({
        rowNode: t,
        dragEvent: e
      });
      o(a);
    } else
      try {
        const a = JSON.stringify(t.data);
        n.setData("application/json", a), n.setData("text/plain", a);
      } catch {
      }
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
};
function vb(e, t) {
  var s, i;
  (i = (s = e.rowDragSvc) == null ? void 0 : s.rowDragFeature) == null || i.addRowDropZone(t);
}
function wb(e, t) {
  var i, r;
  const s = (i = e.dragAndDrop) == null ? void 0 : i.findExternalZone(t);
  s && ((r = e.dragAndDrop) == null || r.removeDropTarget(s));
}
function yb(e, t) {
  var s, i;
  return (i = (s = e.rowDragSvc) == null ? void 0 : s.rowDragFeature) == null ? void 0 : i.getRowDropZone(t);
}
var bb = class extends P {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeSvc";
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      onDragCancel: this.onDragStop.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    }, { dragSvc: s } = this.beans;
    return s.addDragSource(t), () => s.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const s = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(s);
  }
  setResizeIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, Sb = class extends L {
  constructor(e, t, s, i, r, o) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = s, this.customGui = i, this.dragStartPixels = r, this.suppressVisibilityChange = o, this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    const { beans: e, rowNode: t, column: s, gos: i } = this;
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(B("rowDrag", e, null)), this.addDragSource()), !this.suppressVisibilityChange) {
      const r = i.get("rowDragManaged") ? new Fb(this, t, s) : new xb(this, t, s);
      this.createManagedBean(r, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e, void 0, void 0, !0), this.addDragSource(t);
  }
  getSelectedNodes() {
    var i;
    const e = this.rowNode;
    if (!this.gos.get("rowDragMultiRow"))
      return [e];
    const s = ((i = this.beans.selectionSvc) == null ? void 0 : i.getSelectedNodes()) ?? [];
    return s.indexOf(e) !== -1 ? s : [e];
  }
  getDragItem() {
    const { column: e, rowNode: t } = this;
    return {
      rowNode: t,
      rowNodes: this.getSelectedNodes(),
      columns: e ? [e] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, {
      mousedown: (i) => {
        i == null || i.preventDefault();
      }
    })[0]);
    const s = this.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: t,
      dragItemName: () => {
        var n;
        const i = this.getDragItem(), r = ((n = i.rowNodes) == null ? void 0 : n.length) || 1, o = this.getRowDragText(this.column);
        return o ? o(i, r) : r === 1 ? this.cellValueFn() : `${r} ${s("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDrop.addDragSource(this.dragSource, !0);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDrop.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
}, dp = class extends P {
  constructor(e, t, s) {
    super(), this.parent = e, this.rowNode = t, this.column = s;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let s = !0, i = !1;
      const { column: r, rowNode: o, parent: n } = this;
      r && (s = r.isRowDrag(o) || n.isCustomGui(), i = typeof r.getColDef().rowDrag == "function"), i ? (n.setDisplayed(!0, t), n.setVisible(s, t)) : (n.setDisplayed(s, t), n.setVisible(!0, t));
    }
  }
}, xb = class extends dp {
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: e }), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}, Fb = class extends dp {
  postConstruct() {
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventSvc, {
      sortChanged: e,
      filterChanged: e,
      columnRowGroupChanged: e,
      newColumnsLoaded: e
    }), this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const { rowDragSvc: e, dragAndDrop: t, gos: s } = this.beans, i = e.rowDragFeature, r = i && i.shouldPreventRowMove(), o = s.get("suppressRowDrag"), n = t.hasExternalDropZones(), a = r && !n || o;
    this.setDisplayedOrVisible(a);
  }
}, Rb = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowDragSvc";
  }
  setupRowDrag(e, t) {
    const s = t.createManagedBean(new Dw(e)), i = this.beans.dragAndDrop;
    i.addDropTarget(s), t.addDestroyFunc(() => i.removeDropTarget(s)), this.rowDragFeature = s;
  }
  createRowDragComp(e, t, s, i, r, o) {
    return new Sb(e, t, s, i, r, o);
  }
  createRowDragCompForRow(e, t) {
    if (Ve(this.gos))
      return;
    const s = this.getLocaleTextFunc();
    return this.createRowDragComp(
      () => `1 ${s("rowDragRow", "row")}`,
      e,
      void 0,
      t,
      void 0,
      !0
    );
  }
  createRowDragCompForCell(e, t, s, i, r, o) {
    const n = this.gos;
    return n.get("rowDragManaged") && (!J(n) || n.get("pagination")) ? void 0 : this.createRowDragComp(
      s,
      e,
      t,
      i,
      r,
      o
    );
  }
}, Il = {
  moduleName: "Drag",
  version: G,
  beans: [Ew]
}, Pb = {
  moduleName: "DragAndDrop",
  version: G,
  dynamicBeans: {
    dndSourceComp: Cb
  },
  icons: {
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
}, Li = {
  moduleName: "SharedDragAndDrop",
  version: G,
  beans: [Rw],
  dependsOn: [Il],
  userComponents: {
    agDragAndDropImage: Fy
  },
  icons: {
    // shown on drag and drop image component icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on drag and drop image component icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on drag and drop image component icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on drag and drop image component icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on drag and drop image component icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
    // string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
}, Tb = {
  moduleName: "RowDrag",
  version: G,
  beans: [Rb],
  apiFunctions: {
    addRowDropZone: vb,
    removeRowDropZone: wb,
    getRowDropZoneParams: yb
  },
  dependsOn: [Li]
}, cp = {
  moduleName: "HorizontalResize",
  version: G,
  beans: [bb],
  dependsOn: [Il]
}, Db = (
  /*css*/
  ":where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}"
), Eb = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colAnimation", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.activeNext = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    if (this.active)
      return;
    const { gos: e } = this;
    e.get("suppressColumnMoveAnimation") || e.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0, this.activeNext = !0);
  }
  finish() {
    this.active && this.flush(
      () => this.activeNext = !1,
      () => this.active = !1
    );
  }
  executeNextVMTurn(e) {
    this.activeNext ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount, { gridBodyCtrl: t } = this;
    t.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && t.setColumnMovingCss(!1);
    });
  }
  flush(e, t) {
    const { executeNextFuncs: s, executeLaterFuncs: i } = this;
    if (s.length === 0 && i.length === 0) {
      e(), t();
      return;
    }
    const r = (o) => {
      for (; o.length; ) {
        const n = o.pop();
        n && n();
      }
    };
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e(), r(s);
      }, 0), window.setTimeout(() => {
        t(), r(i);
      }, 200);
    });
  }
};
function Mb(e, t, s) {
  var i;
  (i = e.colMoves) == null || i.moveColumnByIndex(t, s, "api");
}
function Ab(e, t, s) {
  var i;
  (i = e.colMoves) == null || i.moveColumns(t, s, "api");
}
var Ib = class extends P {
  constructor(e) {
    super(), this.pinned = e, this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [];
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((s) => {
      s.isPrimary() && (s.isAnyFunctionActive() || (s.isAllowValue() ? this.columnsToAggregate.push(s) : s.isAllowRowGroup() ? this.columnsToGroup.push(s) : s.isAllowPivot() && this.columnsToPivot.push(s)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    const { valueColsSvc: t, rowGroupColsSvc: s, pivotColsSvc: i } = this.beans;
    this.columnsToAggregate.length > 0 && (t == null || t.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop")), this.columnsToGroup.length > 0 && (s == null || s.addColumns(this.columnsToGroup, "toolPanelDragAndDrop")), this.columnsToPivot.length > 0 && (i == null || i.addColumns(this.columnsToPivot, "toolPanelDragAndDrop"));
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function Lb(e, t) {
  !t || t.length <= 1 || t.filter((i) => e.indexOf(i) < 0).length > 0 || t.sort((i, r) => {
    const o = e.indexOf(i), n = e.indexOf(r);
    return o - n;
  });
}
function hp(e) {
  const { isFromHeader: t, fromLeft: s, xPosition: i, fromEnter: r, fakeEvent: o, pinned: n, gos: a, colModel: l, colMoves: d, visibleCols: c } = e;
  let { allMovingColumns: h } = e;
  if (t) {
    const F = [];
    h.forEach((D) => {
      var I;
      let x = null, T = D.getParent();
      for (; T != null && T.getDisplayedLeafColumns().length === 1; )
        x = T, T = T.getParent();
      x != null ? (!!((I = x.getColGroupDef()) != null && I.marryChildren) ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        x.getProvidedColumnGroup().getLeafColumns()
      ) : x.getLeafColumns()).forEach((N) => {
        F.includes(N) || F.push(N);
      }) : F.includes(D) || F.push(D);
    }), h = F;
  }
  const u = h.slice();
  Lb(l.getCols(), u);
  const p = Bb({
    movingCols: u,
    draggingRight: s,
    xPosition: i,
    pinned: n,
    gos: a,
    colModel: l,
    visibleCols: c
  }), g = kb(u, l);
  if (p.length === 0)
    return;
  const f = p[0];
  let m = g !== null && !r;
  if (t && (m = g !== null), m && !o && (!s && f >= g || s && f <= g))
    return;
  const C = c.allCols, v = [];
  let b = null;
  for (let F = 0; F < p.length; F++) {
    const D = p[F], x = d.getProposedColumnOrder(u, D);
    if (!d.doesOrderPassRules(x))
      continue;
    const T = x.filter((E) => C.includes(E));
    if (b === null)
      b = T;
    else if (!Re(T, b))
      break;
    const I = Ob(x);
    v.push({ move: D, fragCount: I });
  }
  if (v.length === 0)
    return;
  v.sort((F, D) => F.fragCount - D.fragCount);
  const y = v[0].move;
  if (!(y > l.getCols().length - h.length))
    return { columns: h, toIndex: y };
}
function up(e) {
  const { columns: t, toIndex: s } = hp(e) || {}, { finished: i, colMoves: r } = e;
  return !t || s == null ? null : (r.moveColumns(t, s, "uiColumnMoved", i), i ? null : { columns: t, toIndex: s });
}
function kb(e, t) {
  const s = t.getCols(), i = YC(e.map((l) => s.indexOf(l))), r = i[0];
  return V(i) - r !== i.length - 1 ? null : r;
}
function Ob(e) {
  function t(i) {
    const r = [];
    let o = i.getOriginalParent();
    for (; o != null; )
      r.push(o), o = o.getOriginalParent();
    return r;
  }
  let s = 0;
  for (let i = 0; i < e.length - 1; i++) {
    let r = t(e[i]), o = t(e[i + 1]);
    [r, o] = r.length > o.length ? [r, o] : [o, r], r.forEach((n) => {
      o.indexOf(n) === -1 && s++;
    });
  }
  return s;
}
function Gb(e, t) {
  switch (t) {
    case "left":
      return e.leftCols;
    case "right":
      return e.rightCols;
    default:
      return e.centerCols;
  }
}
function Bb(e) {
  const { movingCols: t, draggingRight: s, xPosition: i, pinned: r, gos: o, colModel: n, visibleCols: a } = e;
  if (o.get("suppressMovableColumns") || t.some((b) => b.getColDef().suppressMovable))
    return [];
  const d = Gb(a, r), c = n.getCols(), h = d.filter((b) => t.includes(b)), u = d.filter((b) => !t.includes(b)), p = c.filter((b) => !t.includes(b));
  let g = 0, f = i;
  if (s) {
    let b = 0;
    h.forEach((y) => b += y.getActualWidth()), f -= b;
  }
  if (f > 0) {
    for (let b = 0; b < u.length; b++) {
      const y = u[b];
      if (f -= y.getActualWidth(), f < 0)
        break;
      g++;
    }
    s && g++;
  }
  let m;
  if (g > 0) {
    const b = u[g - 1];
    m = p.indexOf(b) + 1;
  } else
    m = p.indexOf(u[0]), m === -1 && (m = 0);
  const C = [m], v = (b, y) => b - y;
  if (s) {
    let b = m + 1;
    const y = c.length - 1;
    for (; b <= y; )
      C.push(b), b++;
    C.sort(v);
  } else {
    let b = m;
    const y = c.length - 1;
    let F = c[b];
    for (; b <= y && d.indexOf(F) < 0; )
      b++, C.push(b), F = c[b];
    b = m - 1;
    const D = 0;
    for (; b >= D; )
      C.push(b), b--;
    C.sort(v).reverse();
  }
  return C;
}
function xa(e) {
  var d;
  const { pinned: t, fromKeyboard: s, gos: i, ctrlsSvc: r, useHeaderRow: o, skipScrollPadding: n } = e;
  let a = (d = r.getHeaderRowContainerCtrl(t)) == null ? void 0 : d.eViewport, { x: l } = e;
  return a ? (s && (l -= a.getBoundingClientRect().left), i.get("enableRtl") && (o && (a = a.querySelector(".ag-header-row")), l = a.clientWidth - l), t == null && !n && (l += r.get("center").getCenterViewportScrollLeft()), l) : 0;
}
function zn(e, t) {
  for (const s of e)
    s.moving = t, s.dispatchColEvent("movingChanged", "uiColumnMoved");
}
var Wd = 7, Fa = 100, _r = Fa / 2, Vb = 5, Nb = 100, Hb = class extends P {
  constructor(e) {
    super(), this.pinned = e, this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.isCenterContainer = !A(e);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    const { pinned: e, lastDraggingEvent: t } = this, s = (t == null ? void 0 : t.dragItem.columns) ?? [];
    for (const i of s) {
      const r = i.getPinned();
      if (i.getColDef().lockPinned) {
        if (r == e)
          return "move";
        continue;
      }
      if (r === e || !e)
        return "move";
      if (!r && e)
        return "pinned";
    }
    return "notAllowed";
  }
  onDragEnter(e) {
    const t = e.dragItem, s = t.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(s, !0, "uiColumnDragged");
    else {
      const r = t.visibleState, o = (s || []).filter((n) => r[n.getId()]);
      this.setColumnsVisible(o, !0, "uiColumnDragged");
    }
    this.gos.get("suppressMoveWhenColumnDragging") || this.attemptToPinColumns(s, this.pinned), this.onDragging(e, !0, !0);
  }
  onDragging(e = this.lastDraggingEvent, t = !1, s = !1, i = !1) {
    const { gos: r, ctrlsSvc: o } = this.beans, n = r.get("suppressMoveWhenColumnDragging");
    if (i && !n) {
      this.finishColumnMoving();
      return;
    }
    if (this.lastDraggingEvent = e, !e || !i && Y(e.hDirection))
      return;
    const a = xa({
      x: e.x,
      pinned: this.pinned,
      gos: r,
      ctrlsSvc: o
    });
    t || this.checkCenterForScrolling(a), n ? this.handleColumnDragWhileSuppressingMovement(e, t, s, a, i) : this.handleColumnDragWhileAllowingMovement(e, t, s, a, i);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.clearHighlighted(), this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted(), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, s) {
    if (!e)
      return;
    const i = e.filter((r) => !r.getColDef().lockVisible);
    this.beans.colModel.setColsVisible(i, t, s);
  }
  finishColumnMoving() {
    this.clearHighlighted();
    const e = this.lastMovedInfo;
    if (!e)
      return;
    const { columns: t, toIndex: s } = e;
    this.beans.colMoves.moveColumns(t, s, "uiColumnMoved", !0);
  }
  handleColumnDragWhileSuppressingMovement(e, t, s, i, r) {
    const o = this.getAllMovingColumns(e, !0);
    if (r) {
      const n = this.isAttemptingToPin(o);
      n && this.attemptToPinColumns(o, void 0, !0);
      const { fromLeft: a, xPosition: l } = this.getNormalisedXPositionInfo(o, n) || {};
      if (a == null || l == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns: o,
        xPosition: l,
        fromEnter: t,
        fakeEvent: s,
        fromLeft: a
      });
    } else {
      if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(e))
        return;
      this.highlightHoveredColumn(o, i);
    }
  }
  handleColumnDragWhileAllowingMovement(e, t, s, i, r) {
    const o = this.getAllMovingColumns(e), n = this.normaliseDirection(e.hDirection) === "right", a = e.dragSource.type === 1, l = this.getMoveColumnParams({
      allMovingColumns: o,
      isFromHeader: a,
      xPosition: i,
      fromLeft: n,
      fromEnter: t,
      fakeEvent: s
    }), d = up({ ...l, finished: r });
    d && (this.lastMovedInfo = d);
  }
  getAllMovingColumns(e, t = !1) {
    const s = e.dragSource.getDragItem();
    let i = null;
    t ? (i = s.columnsInSplit, i || (i = s.columns)) : i = s.columns;
    const r = (o) => o.getColDef().lockPinned ? o.getPinned() == this.pinned : !0;
    return i ? i.filter(r) : [];
  }
  getMoveColumnParams(e) {
    const { allMovingColumns: t, isFromHeader: s, xPosition: i, fromLeft: r, fromEnter: o, fakeEvent: n } = e, { gos: a, colModel: l, colMoves: d, visibleCols: c } = this.beans;
    return {
      allMovingColumns: t,
      isFromHeader: s,
      fromLeft: r,
      xPosition: i,
      pinned: this.pinned,
      fromEnter: o,
      fakeEvent: n,
      gos: a,
      colModel: l,
      colMoves: d,
      visibleCols: c
    };
  }
  highlightHoveredColumn(e, t) {
    var c;
    const { gos: s, colModel: i } = this.beans, r = s.get("enableRtl"), o = i.getCols().filter((h) => h.isVisible() && h.getPinned() === this.pinned);
    let n = null, a = null, l = null;
    for (const h of o) {
      if (a = h.getActualWidth(), n = this.getNormalisedColumnLeft(h, 0, r), n != null) {
        const u = n + a;
        if (n <= t && u >= t) {
          l = h;
          break;
        }
      }
      n = null, a = null;
    }
    if (l)
      e.indexOf(l) !== -1 && (l = null);
    else {
      for (let h = o.length - 1; h >= 0; h--) {
        const u = o[h], p = o[h].getParent();
        if (!p) {
          l = u;
          break;
        }
        const g = p == null ? void 0 : p.getDisplayedLeafColumns();
        if (g.length) {
          l = V(g);
          break;
        }
      }
      if (!l)
        return;
      n = this.getNormalisedColumnLeft(l, 0, r), a = l.getActualWidth();
    }
    if (((c = this.lastHighlightedColumn) == null ? void 0 : c.column) !== l && this.clearHighlighted(), l == null || n == null || a == null)
      return;
    let d;
    t - n < a / 2 !== r ? d = 0 : d = 1, _d(l, d), this.lastHighlightedColumn = { column: l, position: d };
  }
  getNormalisedXPositionInfo(e, t) {
    const { gos: s, visibleCols: i } = this.beans, r = s.get("enableRtl"), { firstMovingCol: o, column: n, position: a } = this.getColumnMoveAndTargetInfo(
      e,
      t,
      r
    );
    if (!o || !n || a == null)
      return;
    const l = i.allCols, d = l.indexOf(o), c = l.indexOf(n), h = a === 0 !== r, u = d < c || d === c && !h;
    let p = 0;
    if (h ? u && (p -= 1) : u || (p += 1), c + p === d)
      return;
    const g = l[c + p];
    if (!g)
      return;
    const f = this.getNormalisedColumnLeft(g, 20, r);
    return { fromLeft: u, xPosition: f };
  }
  getColumnMoveAndTargetInfo(e, t, s) {
    const i = this.lastHighlightedColumn || {}, { firstMovingCol: r, lastMovingCol: o } = zb(e);
    if (!r || !o || i.column || !t)
      return {
        firstMovingCol: r,
        ...i
      };
    const a = this.getPinDirection() === "left";
    return {
      firstMovingCol: r,
      position: a ? 1 : 0,
      column: a !== s ? r : o
    };
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case "left":
          return "right";
        case "right":
          return "left";
      }
    return e;
  }
  getNormalisedColumnLeft(e, t, s) {
    const { gos: i, ctrlsSvc: r } = this.beans, o = e.getLeft();
    if (o == null)
      return null;
    const n = e.getActualWidth();
    return xa({
      x: s ? o + n - t : o + t,
      pinned: e.getPinned(),
      useHeaderRow: s,
      skipScrollPadding: !0,
      gos: i,
      ctrlsSvc: r
    });
  }
  isAttemptingToPin(e) {
    const t = this.needToMoveLeft || this.needToMoveRight, s = this.failedMoveAttempts > Wd;
    return t && s || e.some((i) => i.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(e) {
    const { allMovingColumns: t, xPosition: s, fromEnter: i, fakeEvent: r, fromLeft: o } = e, n = this.getMoveColumnParams({
      allMovingColumns: t,
      isFromHeader: !0,
      xPosition: s,
      fromLeft: o,
      fromEnter: i,
      fakeEvent: r
    }), { columns: a, toIndex: l } = hp(n) || {};
    a && l != null && (this.lastMovedInfo = {
      columns: a,
      toIndex: l
    }), this.finishColumnMoving();
  }
  clearHighlighted() {
    const { lastHighlightedColumn: e } = this;
    e && (_d(e.column, null), this.lastHighlightedColumn = null);
  }
  checkCenterForScrolling(e) {
    if (!this.isCenterContainer)
      return;
    const t = this.beans.ctrlsSvc.get("center"), s = t.getCenterViewportScrollLeft(), i = s + t.getCenterWidth();
    let r, o;
    this.gos.get("enableRtl") ? (r = e < s + _r, o = e > i - _r) : (o = e < s + _r, r = e > i - _r), this.needToMoveRight = r, this.needToMoveLeft = o, o || r ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
  }
  ensureIntervalStarted() {
    var e;
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), Nb), (e = this.beans.dragAndDrop.getDragAndDropImageComponent()) == null || e.setIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    var e;
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.failedMoveAttempts = 0, (e = this.beans.dragAndDrop.getDragAndDropImageComponent()) == null || e.setIcon(this.getIconName(), !1));
  }
  moveInterval() {
    var i, r;
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * Vb, e > Fa && (e = Fa);
    let t = null;
    const s = this.gridBodyCon.scrollFeature;
    if (this.needToMoveLeft ? t = s.scrollHorizontally(-e) : this.needToMoveRight && (t = s.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const { pinnedCols: o, dragAndDrop: n, gos: a } = this.beans;
      if (this.failedMoveAttempts <= Wd + 1 || !o)
        return;
      if ((i = n.getDragAndDropImageComponent()) == null || i.setIcon("pinned", !1), !a.get("suppressMoveWhenColumnDragging")) {
        const l = (r = this.lastDraggingEvent) == null ? void 0 : r.dragItem.columns;
        this.attemptToPinColumns(l, void 0, !0);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left")
      return "left";
    if (this.needToMoveRight || this.pinned === "right")
      return "right";
  }
  attemptToPinColumns(e, t, s = !1) {
    const i = (e || []).filter((n) => !n.getColDef().lockPinned);
    if (!i.length)
      return 0;
    s && (t = this.getPinDirection());
    const { pinnedCols: r, dragAndDrop: o } = this.beans;
    return r == null || r.setColsPinned(i, t, "uiColumnDragged"), s && o.nudge(), i.length;
  }
  destroy() {
    super.destroy(), this.lastDraggingEvent = null, this.clearHighlighted(), this.lastMovedInfo = null;
  }
};
function _d(e, t) {
  e.highlighted !== t && (e.highlighted = t, e.dispatchColEvent("headerHighlightChanged", "uiColumnMoved"));
}
function zb(e) {
  const t = e.length;
  let s, i;
  for (let r = 0; r <= t; r++) {
    if (!s) {
      const o = e[r];
      o.getLeft() != null && (s = o);
    }
    if (!i) {
      const o = e[t - 1 - r];
      o.getLeft() != null && (i = o);
    }
    if (s && i)
      break;
  }
  return { firstMovingCol: s, lastMovingCol: i };
}
var Wb = class extends P {
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    const { ctrlsSvc: e, dragAndDrop: t } = this.beans, s = this.pinned;
    e.whenReady(this, (i) => {
      let r;
      const o = i.gridBodyCtrl.eBodyViewport;
      switch (s) {
        case "left":
          r = [
            [o, i.left.eContainer],
            [i.bottomLeft.eContainer],
            [i.topLeft.eContainer]
          ];
          break;
        case "right":
          r = [
            [o, i.right.eContainer],
            [i.bottomRight.eContainer],
            [i.topRight.eContainer]
          ];
          break;
        default:
          r = [
            [o, i.center.eViewport],
            [i.bottomCenter.eViewport],
            [i.topCenter.eViewport]
          ];
          break;
      }
      this.eSecondaryContainers = r;
    }), this.moveColumnFeature = this.createManagedBean(new Hb(s)), this.bodyDropPivotTarget = this.createManagedBean(new Ib(s)), t.addDropTarget(this), this.addDestroyFunc(() => t.removeDropTarget(this));
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.beans.colModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
}, _b = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colMoves";
  }
  moveColumnByIndex(e, t, s) {
    const i = this.beans.colModel.getCols();
    if (!i)
      return;
    const r = i[e];
    this.moveColumns([r], t, s);
  }
  moveColumns(e, t, s, i = !0) {
    const { colModel: r, colAnimation: o, visibleCols: n, eventSvc: a } = this.beans, l = r.getCols();
    if (!l)
      return;
    if (t > l.length - e.length) {
      R(30, { toIndex: t });
      return;
    }
    o == null || o.start();
    const d = r.getColsForKeys(e);
    this.doesMovePassRules(d, t) && (Ad(r.getCols(), d, t), n.refresh(s), a.dispatchEvent({
      type: "columnMoved",
      columns: d,
      column: d.length === 1 ? d[0] : null,
      toIndex: t,
      finished: i,
      source: s
    })), o == null || o.finish();
  }
  doesMovePassRules(e, t) {
    const s = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(s);
  }
  doesOrderPassRules(e) {
    const { colModel: t, gos: s } = this.beans;
    return !(!eu(e, t.getColTree()) || !((r) => {
      const o = (d) => d ? d === "left" || d === !0 ? -1 : 1 : 0, n = s.get("enableRtl");
      let a = n ? 1 : -1, l = !0;
      return r.forEach((d) => {
        const c = o(d.getColDef().lockPosition);
        n ? c > a && (l = !1) : c < a && (l = !1), a = c;
      }), l;
    })(e));
  }
  getProposedColumnOrder(e, t) {
    const i = this.beans.colModel.getCols().slice();
    return Ad(i, e, t), i;
  }
  createBodyDropTarget(e, t) {
    return new Wb(e, t);
  }
  moveHeader(e, t, s, i, r) {
    const { ctrlsSvc: o, gos: n, colModel: a, visibleCols: l, focusSvc: d } = this.beans, c = t.getBoundingClientRect(), h = c.left, u = de(s), p = u ? c.width : s.getActualWidth(), g = e === "left" !== n.get("enableRtl"), f = xa({
      x: g ? h - 20 : h + p + 20,
      pinned: i,
      fromKeyboard: !0,
      gos: n,
      ctrlsSvc: o
    }), m = d.focusedHeader;
    up({
      allMovingColumns: u ? s.getLeafColumns() : [s],
      isFromHeader: !0,
      fromLeft: e === "right",
      xPosition: f,
      pinned: i,
      fromEnter: !1,
      fakeEvent: !1,
      gos: n,
      colModel: a,
      colMoves: this,
      visibleCols: l,
      finished: !0
    });
    let C;
    if (u) {
      const v = s.getDisplayedLeafColumns();
      C = g ? v[0] : V(v);
    } else
      C = s;
    if (o.getScrollFeature().ensureColumnVisible(C, "auto"), (!r.isAlive() || n.get("ensureDomOrder")) && m) {
      let v;
      if (u) {
        const b = s.getGroupId(), y = s.getLeafColumns();
        if (!y.length)
          return;
        const F = y[0].getParent();
        if (!F)
          return;
        v = Ub(F, b);
      } else
        v = s;
      v && d.focusHeaderPosition({
        headerPosition: {
          ...m,
          column: v
        }
      });
    }
  }
  setDragSourceForHeader(e, t, s) {
    const { gos: i, colModel: r, dragAndDrop: o, visibleCols: n } = this.beans;
    let a = !i.get("suppressDragLeaveHidesColumns");
    const l = de(t), d = l ? t.getProvidedColumnGroup().getLeafColumns() : [t], h = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => a ? "hide" : "notAllowed",
      getDragItem: l ? () => $b(t, n.allCols) : () => Kb(t),
      dragItemName: s,
      onDragStarted: () => {
        a = !i.get("suppressDragLeaveHidesColumns"), zn(d, !0);
      },
      onDragStopped: () => zn(d, !1),
      onDragCancelled: () => zn(d, !1),
      onGridEnter: (u) => {
        if (a) {
          const { columns: p = [], visibleState: g } = u ?? {}, f = l ? (C) => !g || g[C.getColId()] : () => !0, m = p.filter(
            (C) => !C.getColDef().lockVisible && f(C)
          );
          r.setColsVisible(m, !0, "uiColumnMoved");
        }
      },
      onGridExit: (u) => {
        var p;
        if (a) {
          const g = ((p = u == null ? void 0 : u.columns) == null ? void 0 : p.filter((f) => !f.getColDef().lockVisible)) || [];
          r.setColsVisible(g, !1, "uiColumnMoved");
        }
      }
    };
    return o.addDragSource(h, !0), h;
  }
};
function Ub(e, t) {
  for (; e; ) {
    if (e.getGroupId() === t)
      return e;
    e = e.getParent();
  }
}
function Kb(e) {
  const t = {};
  return t[e.getId()] = e.isVisible(), {
    columns: [e],
    visibleState: t
  };
}
function $b(e, t) {
  const s = e.getProvidedColumnGroup().getLeafColumns(), i = {};
  s.forEach((a) => i[a.getId()] = a.isVisible());
  const r = [];
  t.forEach((a) => {
    s.indexOf(a) >= 0 && (r.push(a), be(s, a));
  }), s.forEach((a) => r.push(a));
  const o = [], n = e.getLeafColumns();
  for (const a of r)
    n.indexOf(a) !== -1 && o.push(a);
  return {
    columns: r,
    columnsInSplit: o,
    visibleState: i
  };
}
var Ll = {
  moduleName: "ColumnMove",
  version: G,
  beans: [_b, Eb],
  apiFunctions: {
    moveColumnByIndex: Mb,
    moveColumns: Ab
  },
  dependsOn: [Li],
  css: [Db]
}, jb = class extends P {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const s = this.getHeaderCellForColumn(e);
    if (!s)
      return -1;
    const i = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(e);
    return t || i.push(s), this.addElementsToContainerAndGetWidth(i);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const s = this.centerRowContainerCtrl.eContainer;
    e.forEach((o) => this.cloneItemIntoDummy(o, t)), s.appendChild(t);
    const i = t.offsetWidth;
    s.removeChild(t);
    const r = this.gos.get("autoSizePadding");
    return i + r;
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((s) => {
      const i = s.getHtmlElementForColumnHeader(e);
      i != null && (t = i);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const s = e.cloneNode(!0);
    s.style.width = "", s.style.position = "static", s.style.left = "";
    const i = document.createElement("div"), r = i.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((a) => s.classList.contains(a)) ? (r.add("ag-header", "ag-header-row"), i.style.position = "static") : r.add("ag-row");
    let n = e.parentElement;
    for (; n; ) {
      if (["ag-header-row", "ag-row"].some((l) => n.classList.contains(l))) {
        for (let l = 0; l < n.classList.length; l++) {
          const d = n.classList[l];
          d != "ag-row-position-absolute" && r.add(d);
        }
        break;
      }
      n = n.parentElement;
    }
    i.appendChild(s), t.appendChild(i);
  }
}, pp = {
  moduleName: "AutoWidth",
  version: G,
  beans: [jb]
};
function qb(e, t, s = !0, i = "api") {
  var r;
  (r = e.colResize) == null || r.setColumnWidths(t, !1, s, i);
}
var Yb = class extends P {
  constructor(e, t, s, i) {
    super(), this.comp = e, this.eResize = t, this.pinned = s, this.columnGroup = i;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const { horizontalResizeSvc: e, gos: t, colAutosize: s } = this.beans, i = e.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    this.addDestroyFunc(i), !t.get("suppressAutoSize") && s && this.addDestroyFunc(
      s.addColumnGroupResize(
        this.eResize,
        this.columnGroup,
        () => this.resizeLeafColumnsToFit("uiColumnResized")
      )
    );
  }
  onResizeStart(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: s,
      resizeRatios: i,
      groupAfterColumns: r,
      groupAfterStartWidth: o,
      groupAfterRatios: n
    } = this.getInitialValues(e);
    this.resizeCols = t, this.resizeStartWidth = s, this.resizeRatios = i, this.resizeTakeFromCols = r, this.resizeTakeFromStartWidth = o, this.resizeTakeFromRatios = n, this.toggleColumnResizing(!0);
  }
  onResizing(e, t, s = "uiColumnResized") {
    const i = this.normaliseDragChange(t), r = this.resizeStartWidth + i;
    this.resizeColumnsFromLocalValues(r, s, e);
  }
  getInitialValues(e) {
    var l;
    const t = (d) => d.reduce((c, h) => c + h.getActualWidth(), 0), s = (d, c) => d.map((h) => h.getActualWidth() / c), i = this.getColumnsToResize(), r = t(i), o = s(i, r), n = {
      columnsToResize: i,
      resizeStartWidth: r,
      resizeRatios: o
    };
    let a = null;
    if (e && (a = ((l = this.beans.colGroupSvc) == null ? void 0 : l.getGroupAtDirection(this.columnGroup, "After")) ?? null), a) {
      const d = a.getDisplayedLeafColumns(), c = n.groupAfterColumns = d.filter(
        (u) => u.isResizable()
      ), h = n.groupAfterStartWidth = t(c);
      n.groupAfterRatios = s(c, h);
    } else
      n.groupAfterColumns = void 0, n.groupAfterStartWidth = void 0, n.groupAfterRatios = void 0;
    return n;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup), s = this.getInitialValues();
    t > s.resizeStartWidth && this.resizeColumns(s, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, s = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const i = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols,
      groupAfterStartWidth: this.resizeTakeFromStartWidth,
      groupAfterRatios: this.resizeTakeFromRatios
    };
    this.resizeColumns(i, e, t, s);
  }
  resizeColumns(e, t, s, i = !0) {
    var h;
    const {
      columnsToResize: r,
      resizeStartWidth: o,
      resizeRatios: n,
      groupAfterColumns: a,
      groupAfterStartWidth: l,
      groupAfterRatios: d
    } = e, c = [];
    if (c.push({
      columns: r,
      ratios: n,
      width: t
    }), a) {
      const u = t - o;
      c.push({
        columns: a,
        ratios: d,
        width: l - u
      });
    }
    (h = this.beans.colResize) == null || h.resizeColumnSets({
      resizeSets: c,
      finished: i,
      source: s
    }), i && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
}, Xb = class extends P {
  constructor(e, t, s, i, r) {
    super(), this.pinned = e, this.column = t, this.eResize = s, this.comp = i, this.ctrl = r;
  }
  postConstruct() {
    const e = [];
    let t, s;
    const i = () => {
      if (O(this.eResize, t), !t)
        return;
      const { horizontalResizeSvc: n, colAutosize: a } = this.beans, l = n.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      e.push(l), s && a && e.push(a.addColumnAutosize(this.eResize, this.column));
    }, r = () => {
      e.forEach((n) => n()), e.length = 0;
    }, o = () => {
      const n = this.column.isResizable(), a = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (n !== t || a !== s) && (t = n, s = a, r(), i());
    };
    o(), this.addDestroyFunc(r), this.ctrl.setRefreshFunction("resize", o);
  }
  onResizing(e, t) {
    const { column: s, lastResizeAmount: i, resizeStartWidth: r, beans: o } = this, n = this.normaliseResizeAmount(t), a = r + n, l = [{ key: s, newWidth: a }], { pinnedCols: d, ctrlsSvc: c, colResize: h } = o;
    if (this.column.getPinned()) {
      const u = (d == null ? void 0 : d.leftWidth) ?? 0, p = (d == null ? void 0 : d.rightWidth) ?? 0, g = yi(c.getGridBodyCtrl().eBodyViewport) - 50;
      if (u + p + (n - i) > g)
        return;
    }
    this.lastResizeAmount = n, h == null || h.setColumnWidths(l, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const s = this.pinned !== "left", i = this.pinned === "right";
    return this.gos.get("enableRtl") ? s && (t *= -1) : i && (t *= -1), t;
  }
}, Zb = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colResize";
  }
  setColumnWidths(e, t, s, i) {
    const r = [], { colModel: o, gos: n, visibleCols: a } = this.beans;
    e.forEach((l) => {
      const d = o.getColDefCol(l.key) || o.getCol(l.key);
      if (!d)
        return;
      if (r.push({
        width: l.newWidth,
        ratios: [1],
        columns: [d]
      }), n.get("colResizeDefault") === "shift" && (t = !t), t) {
        const h = a.getColAfter(d);
        if (!h)
          return;
        const u = d.getActualWidth() - l.newWidth, p = h.getActualWidth() + u;
        r.push({
          width: p,
          ratios: [1],
          columns: [h]
        });
      }
    }), r.length !== 0 && this.resizeColumnSets({
      resizeSets: r,
      finished: s,
      source: i
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: s, source: i } = e;
    if (!(!t || t.every((c) => Qb(c)))) {
      if (s) {
        const c = t && t.length > 0 ? t[0].columns : null;
        Pi(this.eventSvc, c, s, i);
      }
      return;
    }
    const o = [], n = [];
    t.forEach((c) => {
      const { width: h, columns: u, ratios: p } = c, g = {}, f = {};
      u.forEach((v) => n.push(v));
      let m = !0, C = 0;
      for (; m; ) {
        if (C++, C > 1e3) {
          z(31);
          break;
        }
        m = !1;
        const v = [];
        let b = 0, y = h;
        u.forEach((D, x) => {
          if (f[D.getId()])
            y -= g[D.getId()];
          else {
            v.push(D);
            const I = p[x];
            b += I;
          }
        });
        const F = 1 / b;
        v.forEach((D, x) => {
          const T = x === v.length - 1;
          let I;
          T ? I = y : (I = Math.round(p[x] * h * F), y -= I);
          const E = D.getMinWidth(), M = D.getMaxWidth();
          I < E ? (I = E, f[D.getId()] = !0, m = !0) : M > 0 && I > M && (I = M, f[D.getId()] = !0, m = !0), g[D.getId()] = I;
        });
      }
      u.forEach((v) => {
        const b = g[v.getId()];
        v.getActualWidth() !== b && (v.setActualWidth(b, i), o.push(v));
      });
    });
    const a = o.length > 0;
    let l = [];
    if (a) {
      const { colFlex: c, visibleCols: h, colViewport: u } = this.beans;
      l = (c == null ? void 0 : c.refreshFlexedColumns({
        resizingCols: n,
        skipSetLeft: !0
      })) ?? [], h.setLeftValues(i), h.updateBodyWidths(), u.checkViewportColumns();
    }
    const d = n.concat(l);
    (a || s) && Pi(this.eventSvc, d, s, i, l);
  }
  resizeHeader(e, t, s) {
    if (!e.isResizable())
      return;
    const i = e.getActualWidth(), r = e.getMinWidth(), o = e.getMaxWidth(), n = Math.min(Math.max(i + t, r), o);
    this.setColumnWidths([{ key: e, newWidth: n }], s, !0, "uiColumnResized");
  }
  createResizeFeature(e, t, s, i, r) {
    return new Xb(e, t, s, i, r);
  }
  createGroupResizeFeature(e, t, s, i) {
    return new Yb(e, t, s, i);
  }
};
function Qb(e) {
  const { columns: t, width: s } = e;
  let i = 0, r = 0, o = !0;
  t.forEach((l) => {
    const d = l.getMinWidth();
    i += d || 0;
    const c = l.getMaxWidth();
    c > 0 ? r += c : o = !1;
  });
  const n = s >= i, a = !o || s <= r;
  return n && a;
}
var Jb = {
  moduleName: "ColumnResize",
  version: G,
  beans: [Zb],
  apiFunctions: {
    setColumnWidths: qb
  },
  dependsOn: [cp, pp]
}, eS = class extends P {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}, tS = class extends El {
  constructor() {
    super(...arguments), this.onSuppressColMoveChange = () => {
      !this.isAlive() || this.isSuppressMoving() ? this.removeDragSource() : this.dragSource || this.setDragSource(this.eGui);
    };
  }
  setComp(e, t, s, i, r) {
    const { column: o, beans: n } = this, { context: a, colNames: l, colHover: d, colResize: c } = n;
    this.comp = e, r = xr(this, a, r), this.setGui(t, r), this.displayName = l.getDisplayNameForColumnGroup(o, "header"), this.addClasses(), this.setupMovingCss(r), this.setupExpandable(r), this.setupTooltip(), this.setupAutoHeight({
      wrapperElement: i,
      compBean: r
    }), this.setupUserComp(), this.addHeaderMouseListeners(r), this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this)), this.refreshMaxHeaderHeight();
    const h = this.rowCtrl.pinned, u = o.getProvidedColumnGroup().getLeafColumns();
    d == null || d.createHoverFeature(r, u, t), r.createManagedBean(new Dl(o, t, n)), r.createManagedBean(new eS(e, o)), c ? this.resizeFeature = r.createManagedBean(
      c.createGroupResizeFeature(e, s, h, o)
    ) : e.setResizableDisplayed(!1), r.createManagedBean(
      new Ps(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addHighlightListeners(r, u), r.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners(r), r.addDestroyFunc(() => this.clearComponent());
  }
  refreshMaxHeaderHeight() {
    const { gos: e, comp: t } = this, s = e.get("groupHeaderHeight");
    s != null ? s === 0 ? t.setHeaderWrapperHidden(!0) : t.setHeaderWrapperMaxHeight(s) : (t.setHeaderWrapperHidden(!1), t.setHeaderWrapperMaxHeight(null));
  }
  addHighlightListeners(e, t) {
    if (this.beans.gos.get("suppressMoveWhenColumnDragging"))
      for (const s of t)
        e.addManagedListeners(s, {
          headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, s)
        });
  }
  onLeafColumnHighlightChanged(e) {
    const t = this.column.getDisplayedLeafColumns(), s = t[0] === e, i = V(t) === e;
    if (!s && !i)
      return;
    const r = e.getHighlighted(), o = !!this.rowCtrl.findHeaderCellCtrl((l) => l.column.isMoving());
    let n = !1, a = !1;
    if (o) {
      const l = this.beans.gos.get("enableRtl"), d = r === 1, c = r === 0;
      s && (l ? a = d : n = c), i && (l ? n = c : a = d);
    }
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", n), this.comp.addOrRemoveCssClass("ag-header-highlight-after", a);
  }
  resizeHeader(e, t) {
    const { resizeFeature: s } = this;
    if (!s)
      return;
    const i = s.getInitialValues(t);
    s.resizeColumns(i, i.resizeStartWidth + e, "uiColumnResized", !0);
  }
  resizeLeafColumnsToFit(e) {
    var t;
    (t = this.resizeFeature) == null || t.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const { colGroupSvc: e, userCompFactory: t, gos: s } = this.beans, i = s.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (o) => {
        e.setColumnGroupOpened(this.column.getProvidedColumnGroup(), o, "gridInitializing");
      },
      setTooltip: (o, n) => {
        s.assertModuleRegistered("Tooltip", 3), this.setupTooltip(o, n);
      }
    }), r = Gv(t, i);
    r && this.comp.setUserCompDetails(r);
  }
  addHeaderMouseListeners(e) {
    const t = (r) => this.handleMouseOverChange(r.type === "mouseenter"), s = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), i = (r) => this.handleContextMenuMouseEvent(r, void 0, this.column.getProvidedColumnGroup());
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: s,
      contextmenu: i
    });
  }
  handleMouseOverChange(e) {
    this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.setupHeaderGroupTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupExpandable(e) {
    const t = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const s = this.refreshExpanded.bind(this);
    e.addManagedListeners(t, {
      expandedChanged: s,
      expandableChanged: s
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  addClasses() {
    const { column: e } = this, t = e.getColGroupDef(), s = fl(t, this.gos, null, e);
    e.isPadding() ? (s.push("ag-header-group-cell-no-group"), e.getLeafColumns().every((r) => r.isSpanHeaderHeight()) && s.push("ag-header-span-height")) : (s.push("ag-header-group-cell-with-group"), t != null && t.wrapHeaderText && s.push("ag-header-cell-wrap-text")), s.forEach((i) => this.comp.addOrRemoveCssClass(i, !0));
  }
  setupMovingCss(e) {
    const { column: t } = this, i = t.getProvidedColumnGroup().getLeafColumns(), r = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", t.isMoving());
    i.forEach((o) => {
      e.addManagedListeners(o, { movingChanged: r });
    }), r();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || this.focusThis();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === w.ENTER) {
      const s = this.column, i = !s.isExpanded();
      this.beans.colGroupSvc.setColumnGroupOpened(
        s.getProvidedColumnGroup(),
        i,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    var t;
    !this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), e && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null));
  }
  isSuppressMoving() {
    return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((e) => e.getColDef().suppressMovable || e.getColDef().lockPosition);
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function sS(e, t, s) {
  var i;
  (i = e.colGroupSvc) == null || i.setColumnGroupOpened(t, s, "api");
}
function iS(e, t, s) {
  var i;
  return ((i = e.colGroupSvc) == null ? void 0 : i.getColumnGroup(t, s)) ?? null;
}
function rS(e, t) {
  var s;
  return ((s = e.colGroupSvc) == null ? void 0 : s.getProvidedColGroup(t)) ?? null;
}
function oS(e, t, s) {
  return e.colNames.getDisplayNameForColumnGroup(t, s) || "";
}
function nS(e) {
  var t;
  return ((t = e.colGroupSvc) == null ? void 0 : t.getColumnGroupState()) ?? [];
}
function aS(e, t) {
  var s;
  (s = e.colGroupSvc) == null || s.setColumnGroupState(t, "api");
}
function lS(e) {
  var t;
  (t = e.colGroupSvc) == null || t.resetColumnGroupState("api");
}
function dS(e) {
  return e.visibleCols.treeLeft;
}
function cS(e) {
  return e.visibleCols.treeCenter;
}
function hS(e) {
  return e.visibleCols.treeRight;
}
function uS(e) {
  return e.visibleCols.getAllTrees();
}
function pS(e, t) {
  for (let s = 0; s < t.length; s++) {
    const i = e.indexOf(t[s]);
    i >= 0 && (e[i] = e[e.length - 1], e.pop());
  }
}
var gS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "visibleCols", this.colsAndGroupsMap = {}, this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.isBodyWidthDirty = !0;
  }
  refresh(e, t = !1) {
    var a;
    const { colModel: s, colGroupSvc: i, colViewport: r } = this.beans;
    t || this.buildTrees(s, i), i == null || i.updateOpenClosedVisibility();
    const o = Wn(this.treeLeft);
    this.leftCols = o, this.centerCols = Wn(this.treeCenter);
    const n = Wn(this.treeRight);
    this.rightCols = n, this.joinColsAriaOrder(s), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.allCols.filter((l) => l.isAutoHeight()), (a = this.beans.colFlex) == null || a.refreshFlexedColumns(), this.updateBodyWidths(), r.checkViewportColumns(!1), this.setFirstRightAndLastLeftPinned(s, o, n, e), this.eventSvc.dispatchEvent({
      type: "displayedColumnsChanged",
      source: e
    });
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = _t(this.centerCols), t = _t(this.leftCols), s = _t(this.rightCols);
    this.isBodyWidthDirty = this.bodyWidth !== e, (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== s) && (this.bodyWidth = e, this.leftWidth = t, this.rightWidth = s, this.eventSvc.dispatchEvent({
      type: "columnContainerWidthChanged"
    }), this.eventSvc.dispatchEvent({
      type: "displayedColumnsWidthChanged"
    }));
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e, t, s, i) {
    let r, o;
    this.gos.get("enableRtl") ? (r = t ? t[0] : null, o = s ? V(s) : null) : (r = t ? V(t) : null, o = s ? s[0] : null), e.getCols().forEach((n) => {
      n.setLastLeftPinned(n === r, i), n.setFirstRightPinned(n === o, i);
    });
  }
  buildTrees(e, t) {
    const s = e.getColsToShow(), i = s.filter((l) => l.getPinned() == "left"), r = s.filter((l) => l.getPinned() == "right"), o = s.filter((l) => l.getPinned() != "left" && l.getPinned() != "right"), n = new mu(), a = (l) => t ? t.createColumnGroups(l) : l.columns;
    this.treeLeft = a({
      columns: i,
      idCreator: n,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = a({
      columns: r,
      idCreator: n,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = a({
      columns: o,
      idCreator: n,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder(e) {
    const t = e.getCols(), s = [], i = [], r = [];
    for (const o of t) {
      const n = o.getPinned();
      n ? n === !0 || n === "left" ? s.push(o) : r.push(o) : i.push(o);
    }
    this.ariaOrderColumns = s.concat(i).concat(r);
  }
  getAriaColIndex(e) {
    let t;
    return de(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        de(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    const { colModel: t } = this.beans;
    if (!t.getColDefCols())
      return;
    const i = t.getCols().slice(0), r = this.gos.get("enableRtl");
    [this.leftCols, this.rightCols, this.centerCols].forEach((o) => {
      if (r) {
        let n = _t(o);
        o.forEach((a) => {
          n -= a.getActualWidth(), a.setLeft(n, e);
        });
      } else {
        let n = 0;
        o.forEach((a) => {
          a.setLeft(n, e), n += a.getActualWidth();
        });
      }
      pS(i, o);
    }), i.forEach((o) => {
      o.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols) : this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.allCols.indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    const {
      leftCols: t,
      beans: { colModel: s }
    } = this;
    return s.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getRightColsForRow(e) {
    const {
      rightCols: t,
      beans: { colModel: s }
    } = this;
    return s.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getColsForRow(e, t, s, i) {
    const r = [];
    let o = null;
    for (let n = 0; n < t.length; n++) {
      const a = t[n], l = t.length - n, d = Math.min(a.getColSpan(e), l), c = [a];
      if (d > 1) {
        const u = d - 1;
        for (let p = 1; p <= u; p++)
          c.push(t[n + p]);
        n += u;
      }
      let h;
      s ? (h = !1, c.forEach((u) => {
        s(u) && (h = !0);
      })) : h = !0, h && (r.length === 0 && o && (i && i(a)) && r.push(o), r.push(a)), o = a;
    }
    return r;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getColBefore(e) {
    const t = this.allCols, s = t.indexOf(e);
    return s > 0 ? t[s - 1] : null;
  }
  isPinningLeft() {
    return this.leftCols.length > 0;
  }
  isPinningRight() {
    return this.rightCols.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    Ks(this.treeCenter, !1, e), Ks(this.treeLeft, !1, e), Ks(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = ["leftCols", "centerCols", "rightCols"];
    e && t.reverse();
    for (let s = 0; s < t.length; s++) {
      const i = this[t[s]];
      if (i.length)
        return e ? V(i) : i[0];
    }
    return null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.allCols, s = t.indexOf(e);
    return s < t.length - 1 ? t[s + 1] : null;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return _t(this.leftCols);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return _t(this.rightCols);
  }
  isColAtEdge(e, t) {
    const s = this.allCols;
    if (!s.length)
      return !1;
    const i = t === "first";
    let r;
    if (de(e)) {
      const o = e.getDisplayedLeafColumns();
      if (!o.length)
        return !1;
      r = i ? o[0] : V(o);
    } else
      r = e;
    return (i ? s[0] : V(s)) === r;
  }
};
function Ks(e, t, s) {
  if (e)
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (de(r)) {
        const o = t ? r.getDisplayedChildren() : r.getChildren();
        Ks(o, t, s);
      }
      s(r);
    }
}
function Wn(e) {
  const t = [];
  return Ks(e, !0, (s) => {
    Bt(s) && t.push(s);
  }), t;
}
var fS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colGroupSvc";
  }
  getColumnGroupState() {
    const e = [], t = this.beans.colModel.getColTree();
    return jt(null, t, (s) => {
      ae(s) && e.push({
        groupId: s.getGroupId(),
        open: s.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.beans.colModel.getColDefColTree();
    if (!t)
      return;
    const s = [];
    jt(null, t, (i) => {
      if (ae(i)) {
        const r = i.getColGroupDef(), o = {
          groupId: i.getGroupId(),
          open: r ? r.openByDefault : void 0
        };
        s.push(o);
      }
    }), this.setColumnGroupState(s, e);
  }
  setColumnGroupState(e, t) {
    const { colModel: s, colAnimation: i, visibleCols: r, eventSvc: o } = this.beans;
    if (!s.getColTree())
      return;
    i == null || i.start();
    const a = [];
    e.forEach((l) => {
      const d = l.groupId, c = l.open, h = this.getProvidedColGroup(d);
      h && h.isExpanded() !== c && (h.setExpanded(c), a.push(h));
    }), r.refresh(t, !0), a.length && o.dispatchEvent({
      type: "columnGroupOpened",
      columnGroup: a.length === 1 ? a[0] : void 0,
      columnGroups: a
    }), i == null || i.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, s) {
    let i;
    ae(e) ? i = e.getId() : i = e || "", this.setColumnGroupState([{ groupId: i, open: t }], s);
  }
  getProvidedColGroup(e) {
    let t = null;
    return jt(null, this.beans.colModel.getColTree(), (s) => {
      ae(s) && s.getId() === e && (t = s);
    }), t;
  }
  getGroupAtDirection(e, t) {
    const s = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), i = e.getDisplayedLeafColumns(), r = t === "After" ? V(i) : i[0], o = `getCol${t}`;
    for (; ; ) {
      const n = this.beans.visibleCols[o](r);
      if (!n)
        return null;
      const a = this.getColGroupAtLevel(n, s);
      if (a !== e)
        return a;
    }
  }
  getColGroupAtLevel(e, t) {
    let s = e.getParent(), i, r;
    for (; i = s.getProvidedColumnGroup().getLevel(), r = s.getPaddingLevel(), !(i + r <= t); )
      s = s.getParent();
    return s;
  }
  updateOpenClosedVisibility() {
    const e = this.beans.visibleCols.getAllTrees();
    Ks(e, !1, (t) => {
      de(t) && t.calculateDisplayedColumns();
    });
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (de(e))
      return e;
    const s = this.beans.visibleCols.getAllTrees(), i = typeof t == "number";
    let r = null;
    return Ks(s, !1, (o) => {
      if (de(o)) {
        const n = o;
        let a;
        i ? a = e === n.getGroupId() && t === n.getPartId() : a = e === n.getGroupId(), a && (r = n);
      }
    }), r;
  }
  createColumnGroups(e) {
    const { columns: t, idCreator: s, pinned: i, oldDisplayedGroups: r, isStandaloneStructure: o } = e, n = this.mapOldGroupsById(r), a = [];
    let l = t;
    for (; l.length; ) {
      const d = l;
      l = [];
      let c = 0;
      const h = (u) => {
        const p = c;
        c = u;
        const g = d[p], m = (de(g) ? g.getProvidedColumnGroup() : g).getOriginalParent();
        if (m == null) {
          for (let v = p; v < u; v++)
            a.push(d[v]);
          return;
        }
        const C = this.createColumnGroup(
          m,
          s,
          n,
          i,
          o
        );
        for (let v = p; v < u; v++)
          C.addChild(d[v]);
        l.push(C);
      };
      for (let u = 1; u < d.length; u++) {
        const p = d[u], f = (de(p) ? p.getProvidedColumnGroup() : p).getOriginalParent(), m = d[c], v = (de(m) ? m.getProvidedColumnGroup() : m).getOriginalParent();
        f !== v && h(u);
      }
      c < d.length && h(d.length);
    }
    return o || this.setupParentsIntoCols(a, null), a;
  }
  createProvidedColumnGroup(e, t, s, i, r, o, n) {
    const a = r.getUniqueKey(t.groupId || null, null), l = this.createMergedColGroupDef(t, a), d = new er(l, a, !1, s);
    this.createBean(d);
    const c = this.findExistingGroup(t, o);
    c && o.splice(c.idx, 1);
    const h = c == null ? void 0 : c.group;
    h && d.setExpanded(h.isExpanded());
    const u = pu(
      this.beans,
      l.children,
      s + 1,
      e,
      i,
      r,
      o,
      n
    );
    return d.setChildren(u), d;
  }
  balanceColumnTree(e, t, s, i) {
    const r = [];
    for (let o = 0; o < e.length; o++) {
      const n = e[o];
      if (ae(n)) {
        const a = n, l = this.balanceColumnTree(
          a.getChildren(),
          t + 1,
          s,
          i
        );
        a.setChildren(l), r.push(a);
      } else {
        let a, l;
        for (let d = s - 1; d >= t; d--) {
          const c = i.getUniqueKey(null, null), h = this.createMergedColGroupDef(null, c), u = new er(h, c, !0, t);
          this.createBean(u), l && l.setChildren([u]), l = u, a || (a = l);
        }
        if (a && l)
          if (r.push(a), e.some((c) => ae(c))) {
            l.setChildren([n]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        r.push(n);
      }
    }
    return r;
  }
  findDepth(e) {
    let t = 0, s = e;
    for (; s && s[0] && ae(s[0]); )
      t++, s = s[0].getChildren();
    return t;
  }
  findMaxDepth(e, t) {
    let s = t;
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (ae(r)) {
        const o = r, n = this.findMaxDepth(o.getChildren(), t + 1);
        s < n && (s = n);
      }
    }
    return s;
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(e, t) {
    const s = [];
    return e.forEach((i) => {
      let r = i;
      for (let o = t - 1; o >= 0; o--) {
        const n = new er(null, `FAKE_PATH_${i.getId()}}_${o}`, !0, o);
        this.createBean(n), n.setChildren([r]), r.originalParent = n, r = n;
      }
      t === 0 && (i.originalParent = null), s.push(r);
    }), s;
  }
  createMergedColGroupDef(e, t) {
    const s = {}, { gos: i, validation: r } = this.beans;
    return Object.assign(s, i.get("defaultColGroupDef")), Object.assign(s, e), r == null || r.validateColDef(s, t), s;
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let i = 0; i < t.length; i++) {
        const r = t[i];
        if (r.getColGroupDef() && r.getId() === e.groupId)
          return { idx: i, group: r };
      }
  }
  createColumnGroup(e, t, s, i, r) {
    const o = e.getGroupId(), n = t.getInstanceIdForKey(o), a = Gu(o, n);
    let l = s[a];
    return l && l.getProvidedColumnGroup() !== e && (l = null), A(l) ? l.reset() : (l = new Bu(e, o, n, i), r || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, s = (i) => {
      i.forEach((r) => {
        if (de(r)) {
          const o = r;
          t[r.getUniqueId()] = o, s(o.getChildren());
        }
      });
    };
    return e && s(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((s) => {
      if (s.parent = t, de(s)) {
        const i = s;
        this.setupParentsIntoCols(i.getChildren(), i);
      }
    });
  }
}, gp = {
  moduleName: "ColumnGroup",
  version: G,
  dynamicBeans: { headerGroupCellCtrl: tS },
  beans: [fS],
  apiFunctions: {
    getAllDisplayedColumnGroups: uS,
    getCenterDisplayedColumnGroups: cS,
    getColumnGroup: iS,
    getColumnGroupState: nS,
    getDisplayNameForColumnGroup: oS,
    getLeftDisplayedColumnGroups: dS,
    getProvidedColumnGroup: rS,
    getRightDisplayedColumnGroups: hS,
    resetColumnGroupState: lS,
    setColumnGroupOpened: sS,
    setColumnGroupState: aS
  }
}, mS = {
  moduleName: "CheckboxCellRenderer",
  version: G,
  userComponents: {
    agCheckboxCellRenderer: Ty
  }
};
function CS(e, t) {
  const s = e.colModel.getColDefCol(t);
  return s ? s.getColDef() : null;
}
function vS(e) {
  return e.colModel.getColumnDefs();
}
function wS(e, t, s) {
  return e.colNames.getDisplayNameForColumn(t, s) || "";
}
function yS(e, t) {
  return e.colModel.getColDefCol(t);
}
function bS(e) {
  return e.colModel.getColDefCols();
}
function SS(e, t) {
  return Xe(e, t, "api");
}
function xS(e) {
  return pr(e);
}
function FS(e) {
  ru(e, "api");
}
function RS(e) {
  return e.visibleCols.isPinningLeft() || e.visibleCols.isPinningRight();
}
function PS(e) {
  return e.visibleCols.isPinningLeft();
}
function TS(e) {
  return e.visibleCols.isPinningRight();
}
function DS(e, t) {
  return e.visibleCols.getColAfter(t);
}
function ES(e, t) {
  return e.visibleCols.getColBefore(t);
}
function MS(e, t, s) {
  e.colModel.setColsVisible(t, s, "api");
}
function AS(e, t, s) {
  var i;
  (i = e.pinnedCols) == null || i.setColsPinned(t, s, "api");
}
function IS(e) {
  return e.colModel.getCols();
}
function LS(e) {
  return e.visibleCols.leftCols;
}
function kS(e) {
  return e.visibleCols.centerCols;
}
function OS(e) {
  return e.visibleCols.rightCols;
}
function GS(e) {
  return e.visibleCols.allCols;
}
function BS(e) {
  return e.colViewport.getViewportColumns();
}
function Ra(e, t) {
  if (!e)
    return;
  const s = e, i = {};
  return Object.keys(s).forEach((r) => {
    if (t && t.indexOf(r) >= 0 || Zh.has(r))
      return;
    const o = s[r];
    typeof o == "object" && o !== null && o.constructor === Object ? i[r] = Ra(o) : i[r] = o;
  }), i;
}
var VS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colDefFactory";
  }
  wireBeans(e) {
    this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc;
  }
  getColumnDefs(e, t, s, i) {
    var a, l;
    const r = e.slice();
    t ? r.sort((d, c) => s.indexOf(d) - s.indexOf(c)) : s && r.sort((d, c) => i.indexOf(d) - i.indexOf(c));
    const o = (a = this.rowGroupColsSvc) == null ? void 0 : a.columns, n = (l = this.pivotColsSvc) == null ? void 0 : l.columns;
    return this.buildColumnDefs(r, o, n);
  }
  buildColumnDefs(e, t = [], s = []) {
    const i = [], r = {};
    return e.forEach((o) => {
      const n = this.createDefFromColumn(o, t, s);
      let a = !0, l = n, d = o.getOriginalParent(), c = null;
      for (; d; ) {
        let h = null;
        if (d.isPadding()) {
          d = d.getOriginalParent();
          continue;
        }
        const u = r[d.getGroupId()];
        if (u) {
          u.children.push(l), a = !1;
          break;
        }
        if (h = this.createDefFromGroup(d), h && (h.children = [l], r[h.groupId] = h, l = h, d = d.getOriginalParent()), d != null && c === d) {
          a = !1;
          break;
        }
        c = d;
      }
      a && i.push(l);
    }), i;
  }
  createDefFromGroup(e) {
    const t = Ra(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, s) {
    const i = Ra(e.getColDef());
    return i.colId = e.getColId(), i.width = e.getActualWidth(), i.rowGroup = e.isRowGroupActive(), i.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, i.pivot = e.isPivotActive(), i.pivotIndex = e.isPivotActive() ? s.indexOf(e) : null, i.aggFunc = e.isValueActive() ? e.getAggFunc() : null, i.hide = e.isVisible() ? void 0 : !0, i.pinned = e.isPinned() ? e.getPinned() : null, i.sort = e.getSort() ? e.getSort() : null, i.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, i;
  }
}, NS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colFlex";
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth);
    const s = this.flexViewportWidth;
    if (!s)
      return [];
    const { visibleCols: i } = this.beans, r = i.centerCols;
    let o = -1;
    if (e.resizingCols) {
      const g = new Set(e.resizingCols);
      for (let f = r.length - 1; f >= 0; f--)
        if (g.has(r[f])) {
          o = f;
          break;
        }
    }
    let n = !1;
    const a = r.map((g, f) => {
      const m = g.getFlex(), C = m != null && m > 0 && f > o;
      return n || (n = C), {
        col: g,
        isFlex: C,
        flex: Math.max(0, m ?? 0),
        initialSize: g.getActualWidth(),
        min: g.getMinWidth(),
        max: g.getMaxWidth(),
        targetSize: 0
      };
    });
    if (!n)
      return [];
    let l = a.length, d = a.reduce((g, f) => g + f.flex, 0), c = s;
    const h = (g, f) => {
      g.frozenSize = f, g.col.setActualWidth(f, t), c -= f, d -= g.flex, l -= 1;
    }, u = (g) => g.frozenSize != null;
    for (const g of a)
      g.isFlex || h(g, g.initialSize);
    for (; l > 0; ) {
      const g = Math.round(d < 1 ? c * d : c);
      let f, m = 0, C = 0;
      for (const y of a) {
        if (u(y))
          continue;
        f = y, C += g * (y.flex / d);
        const F = C - m, D = Math.round(F);
        y.targetSize = D, m += D;
      }
      f && (f.targetSize += g - m);
      let v = 0;
      for (const y of a) {
        if (u(y))
          continue;
        const F = y.targetSize, D = Math.min(Math.max(F, y.min), y.max);
        v += D - F, y.violationType = D === F ? void 0 : D < F ? "max" : "min", y.targetSize = D;
      }
      const b = v === 0 ? "all" : v > 0 ? "min" : "max";
      for (const y of a)
        u(y) || (b === "all" || y.violationType === b) && h(y, y.targetSize);
    }
    e.skipSetLeft || i.setLeftValues(t), e.updateBodyWidths && i.updateBodyWidths();
    const p = a.filter((g) => g.isFlex && !g.violationType).map((g) => g.col);
    if (e.fireResizedEvent) {
      const g = a.filter((m) => m.initialSize !== m.frozenSize).map((m) => m.col), f = a.filter((m) => m.flex).map((m) => m.col);
      Pi(this.eventSvc, g, !0, t, f);
    }
    return p;
  }
  initCol(e) {
    const { flex: t, initialFlex: s } = e.colDef;
    t !== void 0 ? e.flex = t : s !== void 0 && (e.flex = s);
  }
  // this method should only be used by the colModel to
  // change flex when required by the applyColumnState method.
  setColFlex(e, t) {
    e.flex = t ?? null, e.dispatchStateUpdatedEvent("flex");
  }
}, HS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "dataTypeSvc", this.dataTypeDefinitions = {}, this.isPendingInference = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  postConstruct() {
    this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.colModel.recreateColumnDefs(Ws(e.source));
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes(), t = {};
    this.dataTypeDefinitions = t;
    const s = {};
    this.formatValueFuncs = s;
    const i = (n) => (a) => {
      const { column: l, node: d, value: c } = a;
      let h = l.getColDef().valueFormatter;
      return h === n.groupSafeValueFormatter && (h = n.valueFormatter), this.beans.valueSvc.formatValue(l, d, c, h);
    };
    Object.entries(e).forEach(([n, a]) => {
      const l = {
        ...a,
        groupSafeValueFormatter: $d(a, this.gos)
      };
      t[n] = l, s[n] = i(l);
    });
    const r = this.gos.get("dataTypeDefinitions") ?? {}, o = {};
    this.dataTypeMatchers = o, Object.entries(r).forEach(([n, a]) => {
      const l = this.processDataTypeDefinition(
        a,
        r,
        [n],
        e
      );
      l && (t[n] = l, a.dataTypeMatcher && (o[n] = a.dataTypeMatcher), s[n] = i(l));
    }), this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((n) => {
      const a = o[n];
      a && delete o[n], o[n] = a ?? e[n].dataTypeMatcher;
    });
  }
  processDataTypeDefinition(e, t, s, i) {
    let r;
    const o = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let n = i[o];
      const a = t[o];
      if (n && a && (n = a), !Kd(e, n, o))
        return;
      r = Ud(n, e);
    } else {
      if (s.includes(o)) {
        R(44);
        return;
      }
      const n = t[o];
      if (!Kd(e, n, o))
        return;
      const a = this.processDataTypeDefinition(
        n,
        t,
        [...s, o],
        i
      );
      if (!a)
        return;
      r = Ud(a, e);
    }
    return {
      ...r,
      groupSafeValueFormatter: $d(r, this.gos)
    };
  }
  updateColDefAndGetColumnType(e, t, s) {
    let { cellDataType: i } = t;
    const { field: r } = t;
    if (i === void 0 && (i = e.cellDataType), (i == null || i === !0) && (i = this.canInferCellDataType(e, t) ? this.inferCellDataType(r, s) : !1), !i) {
      e.cellDataType = !1;
      return;
    }
    const o = this.dataTypeDefinitions[i];
    if (!o) {
      R(47, { cellDataType: i });
      return;
    }
    return e.cellDataType = i, o.groupSafeValueFormatter && (e.valueFormatter = o.groupSafeValueFormatter), o.valueParser && (e.valueParser = o.valueParser), o.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, i, o, s), o.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isPendingInference)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const s = (i) => {
      t.add(i.key);
    };
    e.addEventListener("columnStateUpdated", s), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.removeEventListener("columnStateUpdated", s)
    );
  }
  canInferCellDataType(e, t) {
    const { gos: s } = this;
    if (!J(s))
      return !1;
    const i = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (_n(t, i))
      return !1;
    const r = t.type === null ? e.type : t.type;
    if (r) {
      const o = s.get("columnTypes") ?? {};
      if (yo(r).some((a) => {
        const l = o[a.trim()];
        return l && _n(l, i);
      }))
        return !1;
    }
    return !_n(e, i);
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let s;
    const i = this.getInitialData();
    if (i) {
      const o = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      s = Ji(i, e, o);
    } else
      this.initWaitForRowData(t);
    if (s == null)
      return;
    const [r] = Object.entries(this.dataTypeMatchers).find(
      ([o, n]) => n(s)
    ) ?? ["object"];
    return r;
  }
  getInitialData() {
    var t;
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const s = (t = this.beans.rowModel.rootNode) == null ? void 0 : t.allLeafChildren;
      if (s != null && s.length)
        return s[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isPendingInference)
      return;
    this.isPendingInference = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions, { colAutosize: s, eventSvc: i } = this.beans;
    t && s && (s.shouldQueueResizeOperations = !0);
    const [r] = this.addManagedEventListeners({
      rowDataUpdateStarted: (o) => {
        const { firstRowData: n } = o;
        n && (r == null || r(), this.isPendingInference = !1, this.processColumnsPendingInference(n, t), this.columnStateUpdatesPendingInference = {}, t && (s == null || s.processResizeOperations()), i.dispatchEvent({
          type: "dataTypesInferred"
        }));
      }
    });
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const s = [];
    this.destroyColumnStateUpdateListeners();
    const i = {}, r = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([o, n]) => {
      const a = this.colModel.getCol(o);
      if (!a)
        return;
      const l = a.getColDef();
      if (!this.resetColDefIntoCol(a, "cellDataTypeInferred"))
        return;
      const d = a.getColDef();
      if (t && d.type && d.type !== l.type) {
        const c = WS(a, n);
        c.rowGroup && c.rowGroupIndex == null && (i[o] = c), c.pivot && c.pivotIndex == null && (r[o] = c), s.push(c);
      }
    }), t && s.push(
      ...this.generateColumnStateForRowGroupAndPivotIndexes(
        i,
        r
      )
    ), s.length && Xe(this.beans, { state: s }, "cellDataTypeInferred"), this.initialData = null;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const s = {}, { rowGroupColsSvc: i, pivotColsSvc: r } = this.beans;
    return i == null || i.restoreColumnOrder(s, e), r == null || r.restoreColumnOrder(s, t), Object.values(s);
  }
  resetColDefIntoCol(e, t) {
    const s = e.getUserProvidedColDef();
    if (!s)
      return !1;
    const i = bo(this.beans, s, e.getColId());
    return e.setColDef(i, s, t), !0;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, s = e.object;
    this.hasObjectValueParser = t.valueParser !== s.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== s.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    const { dateString: t } = this.dataTypeDefinitions;
    return e ? this.getDataTypeDefinition(e) ?? t : t;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var i;
    if (t == null)
      return !0;
    const s = (i = this.getDataTypeDefinition(e)) == null ? void 0 : i.dataTypeMatcher;
    return s ? s(t) : !0;
  }
  validateColDef(e) {
    const t = (s) => R(48, { property: s });
    if (e.cellDataType === "object") {
      const { object: s } = this.dataTypeDefinitions;
      e.valueFormatter === s.groupSafeValueFormatter && !this.hasObjectValueFormatter && t("Formatter"), e.editable && e.valueParser === s.valueParser && !this.hasObjectValueParser && t("Parser");
    }
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  isColPendingInference(e) {
    return this.isPendingInference && !!this.columnStateUpdatesPendingInference[e];
  }
  setColDefPropertiesForBaseDataType(e, t, s, i) {
    var o;
    const r = this.formatValueFuncs[t];
    switch (s.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor";
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (n) => !!n.colDef.editable && n.event.key === w.SPACE;
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = r;
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = r;
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (n, a) => {
          const l = this.colModel.getColDefCol(i), d = l == null ? void 0 : l.getColDef();
          if (!l || !d)
            return 0;
          const c = n == null ? "" : r({ column: l, node: null, value: n }), h = a == null ? "" : r({ column: l, node: null, value: a });
          return c === h ? 0 : c > h ? 1 : -1;
        }, e.keyCreator = r;
        break;
      }
    }
    (o = this.beans.filterManager) == null || o.setColDefPropertiesForDataType(e, s, r);
  }
  getDefaultDataTypes() {
    const e = (s) => !!s.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (s) => {
          var i, r;
          return ((r = (i = s.newValue) == null ? void 0 : i.trim) == null ? void 0 : r.call(i)) === "" ? null : Number(s.newValue);
        },
        valueFormatter: (s) => s.value == null ? "" : typeof s.value != "number" || isNaN(s.value) ? t("invalidNumber", "Invalid Number") : String(s.value),
        dataTypeMatcher: (s) => typeof s == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (s) => s.newValue === "" ? null : qe(s.newValue),
        dataTypeMatcher: (s) => typeof s == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (s) => {
          var i, r;
          return s.newValue == null ? s.newValue : ((r = (i = s.newValue) == null ? void 0 : i.trim) == null ? void 0 : r.call(i)) === "" ? null : String(s.newValue).toLowerCase() === "true";
        },
        valueFormatter: (s) => s.value == null ? "" : String(s.value),
        dataTypeMatcher: (s) => typeof s == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (s) => Le(s.newValue == null ? null : String(s.newValue)),
        valueFormatter: (s) => s.value == null ? "" : !(s.value instanceof Date) || isNaN(s.value.getTime()) ? t("invalidDate", "Invalid Date") : Ze(s.value, !1) ?? "",
        dataTypeMatcher: (s) => s instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (s) => Le(s) ?? void 0,
        dateFormatter: (s) => Ze(s ?? null, !1) ?? void 0,
        valueParser: (s) => e(String(s.newValue)) ? s.newValue : null,
        valueFormatter: (s) => e(String(s.value)) ? s.value : "",
        dataTypeMatcher: (s) => typeof s == "string" && e(s)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (s) => qe(s.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
};
function Ud(e, t) {
  const s = {
    ...e,
    ...t
  };
  return e.columnTypes && t.columnTypes && t.appendColumnTypes && (s.columnTypes = [
    ...yo(e.columnTypes),
    ...yo(t.columnTypes)
  ]), s;
}
function Kd(e, t, s) {
  return t ? t.baseDataType !== e.baseDataType ? (R(46), !1) : !0 : (R(45, { parentCellDataType: s }), !1);
}
function $d(e, t) {
  if (e.valueFormatter)
    return (s) => {
      var i, r;
      if ((i = s.node) != null && i.group) {
        const o = (s.colDef.pivotValueColumn ?? s.column).getAggFunc();
        if (o) {
          if (o === "first" || o === "last")
            return e.valueFormatter(s);
          if (e.baseDataType === "number" && o !== "count") {
            if (typeof s.value == "number")
              return e.valueFormatter(s);
            if (typeof s.value == "object") {
              if (!s.value)
                return;
              if ("toNumber" in s.value)
                return e.valueFormatter({
                  ...s,
                  value: s.value.toNumber()
                });
              if ("value" in s.value)
                return e.valueFormatter({
                  ...s,
                  value: s.value.value
                });
            }
          }
          return;
        }
        if (t.get("groupDisplayType") === "groupRows" && !t.get("treeData"))
          return;
      } else if (t.get("groupHideOpenParents") && s.column.isRowGroupActive() && typeof s.value == "string" && !((r = e.dataTypeMatcher) != null && r.call(e, s.value)))
        return;
      return e.valueFormatter(s);
    };
}
function zS(e, t, s, i) {
  if (!t[s])
    return !1;
  const r = e[s];
  return r === null ? (t[s] = !1, !1) : i === void 0 ? !!r : r === i;
}
function _n(e, t) {
  return [
    ["cellRenderer", "agSparklineCellRenderer"],
    ["valueGetter", void 0],
    ["valueParser", void 0],
    ["refData", void 0]
  ].some(
    ([s, i]) => zS(e, t, s, i)
  );
}
function WS(e, t) {
  const s = nu(e);
  return t.forEach((i) => {
    delete s[i], i === "rowGroup" ? delete s.rowGroupIndex : i === "pivot" && delete s.pivotIndex;
  }), s;
}
var _S = {
  moduleName: "DataType",
  version: G,
  beans: [HS],
  dependsOn: [mS]
}, US = {
  moduleName: "ColumnFlex",
  version: G,
  beans: [NS]
}, KS = {
  moduleName: "ColumnApi",
  version: G,
  beans: [VS],
  apiFunctions: {
    getColumnDef: CS,
    getDisplayNameForColumn: wS,
    getColumn: yS,
    getColumns: bS,
    applyColumnState: SS,
    getColumnState: xS,
    resetColumnState: FS,
    isPinning: RS,
    isPinningLeft: PS,
    isPinningRight: TS,
    getDisplayedColAfter: DS,
    getDisplayedColBefore: ES,
    setColumnsVisible: MS,
    setColumnsPinned: AS,
    getAllGridColumns: IS,
    getDisplayedLeftColumns: LS,
    getDisplayedCenterColumns: kS,
    getDisplayedRightColumns: OS,
    getAllDisplayedColumns: GS,
    getAllDisplayedVirtualColumns: BS,
    getColumnDefs: vS
  }
};
function $S(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, s = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(s, "$1 $2$3").replace(/\./g, " ").split(" ").map((r) => r.substring(0, 1).toUpperCase() + (r.length > 1 ? r.substring(1, r.length) : "")).join(" ");
}
var jS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colNames";
  }
  getDisplayNameForColumn(e, t, s = !1) {
    if (!e)
      return null;
    const i = this.getHeaderName(e.getColDef(), e, null, null, t), { aggColNameSvc: r } = this.beans;
    return s && r ? r.getHeaderName(e, i) : i;
  }
  getDisplayNameForProvidedColumnGroup(e, t, s) {
    const i = t == null ? void 0 : t.getColGroupDef();
    return i ? this.getHeaderName(i, null, e, t, s) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, s, i, r) {
    var n;
    const o = e.headerValueGetter;
    if (o) {
      const a = this.gos.addGridCommonParams({
        colDef: e,
        column: t,
        columnGroup: s,
        providedColumnGroup: i,
        location: r
      });
      return typeof o == "function" ? o(a) : typeof o == "string" ? ((n = this.beans.expressionSvc) == null ? void 0 : n.evaluate(o, a)) ?? null : "";
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return $S(e.field);
    }
    return "";
  }
}, qS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colViewport", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.colModel = e.colModel;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, s = !1) {
    const { visibleCols: i } = this, r = i.isBodyWidthDirty;
    if (!(e === this.scrollWidth && t === this.scrollPosition && !r)) {
      if (this.scrollWidth = e, this.scrollPosition = t, i.isBodyWidthDirty = !0, this.gos.get("enableRtl")) {
        const n = i.bodyWidth;
        this.viewportLeft = n - t - e, this.viewportRight = n - t;
      } else
        this.viewportLeft = t, this.viewportRight = e + t;
      this.colModel.ready && this.checkViewportColumns(s);
    }
  }
  getHeadersToRender(e, t) {
    let s;
    switch (e) {
      case "left":
        s = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        s = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        s = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return s || [];
  }
  extractViewportColumns() {
    const e = this.visibleCols.centerCols;
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear(e) {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, e || (this.colsWithinViewportHash = "");
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() || YS(e) ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, s = t + e.getActualWidth(), i = this.viewportLeft - 200, r = this.viewportRight + 200, o = t < i && s < i, n = t > r && s > r;
    return !o && !n;
  }
  // used by Grid API only
  getViewportColumns() {
    const { leftCols: e, rightCols: t } = this.visibleCols;
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.colModel.colSpanActive)
      return this.colsWithinViewport;
    const t = (o) => {
      const n = o.getLeft();
      return A(n) && n > this.viewportLeft;
    }, s = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this), { visibleCols: i } = this, r = i.centerCols;
    return i.getColsForRow(e, r, s, t);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventSvc.dispatchEvent({
      type: "virtualColumnsChanged",
      afterScroll: e
    });
  }
  calculateHeaderRows() {
    this.clear(!0);
    const e = {}, { leftCols: t, rightCols: s, treeLeft: i, treeRight: r, treeCenter: o } = this.visibleCols;
    this.headerColsWithinViewport.concat(t).concat(s).forEach((l) => e[l.getId()] = !0);
    const a = (l, d, c) => {
      let h = !1;
      for (let u = 0; u < l.length; u++) {
        const p = l[u];
        let g = !1;
        if (Bt(p))
          g = e[p.getId()] === !0;
        else {
          const m = p.getDisplayedChildren();
          m && (g = a(m, d, c + 1));
        }
        g && (h = !0, d[c] || (d[c] = []), d[c].push(p));
      }
      return h;
    };
    a(i, this.rowsOfHeadersToRenderLeft, 0), a(r, this.rowsOfHeadersToRenderRight, 0), a(o, this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (i) => `${i.getId()}-${i.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), s = this.colsWithinViewportHash !== t;
    return s && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), s;
  }
};
function YS(e) {
  for (; e; ) {
    if (e.isAutoHeaderHeight())
      return !0;
    e = e.getParent();
  }
  return !1;
}
var XS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "agCompUtils";
  }
  adaptFunction(e, t) {
    if (!e.cellRenderer)
      return null;
    class s {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(r) {
        const o = t(r), n = typeof o;
        if (n === "string" || n === "number" || n === "boolean") {
          this.eGui = Be("<span>" + o + "</span>");
          return;
        }
        if (o == null) {
          this.eGui = Be("<span></span>");
          return;
        }
        this.eGui = o;
      }
    }
    return s;
  }
}, ZS = {
  moduleName: "CellRendererFunction",
  version: G,
  beans: [XS]
}, QS = class extends P {
  constructor() {
    super(...arguments), this.beanName = "registry", this.agGridDefaults = {}, this.agGridDefaultParams = {}, this.jsComps = {}, this.dynamicBeans = {}, this.selectors = {}, this.icons = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    e != null && Object.entries(e).forEach(([t, s]) => {
      this.jsComps[t] = s;
    });
  }
  registerModule(e) {
    const { icons: t, userComponents: s, dynamicBeans: i, selectors: r } = e;
    if (s) {
      const o = (n, a, l) => {
        this.agGridDefaults[n] = a, l && (this.agGridDefaultParams[n] = l);
      };
      for (const n of Object.keys(s)) {
        const a = s[n];
        typeof a == "object" ? o(n, a.classImp, a.params) : o(n, a);
      }
    }
    if (i)
      for (const o of Object.keys(i))
        this.dynamicBeans[o] = i[o];
    if (r == null || r.forEach((o) => {
      this.selectors[o.selector] = o;
    }), t)
      for (const o of Object.keys(t))
        this.icons[o] = t[o];
  }
  getUserComponent(e, t) {
    var a;
    const s = (l, d, c) => ({
      componentFromFramework: d,
      component: l,
      params: c
    }), { frameworkOverrides: i } = this.beans, r = i.frameworkComponent(t, this.gos.get("components"));
    if (r != null)
      return s(r, !0);
    const o = this.jsComps[t];
    if (o) {
      const l = i.isFrameworkComponent(o);
      return s(o, l);
    }
    const n = this.agGridDefaults[t];
    return n ? s(n, !1, this.agGridDefaultParams[t]) : ((a = this.beans.validation) == null || a.missingUserComponent(e, t, this.agGridDefaults, this.jsComps), null);
  }
  createDynamicBean(e, t, ...s) {
    const i = this.dynamicBeans[e];
    if (i == null) {
      if (t)
        throw new Error(ut(256));
      return;
    }
    return new i(...s);
  }
  getSelector(e) {
    return this.selectors[e];
  }
  getIcon(e) {
    return this.icons[e];
  }
}, JS = 23, ex = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ctrlsSvc", this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  postConstruct() {
    var e, t;
    this.addEventListener(
      "ready",
      () => {
        this.updateReady(), this.ready && (this.readyCallbacks.forEach((s) => s(this.params)), this.readyCallbacks.length = 0);
      },
      ((t = (e = this.beans.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : t.call(e)) ?? !1
    );
  }
  updateReady() {
    const e = Object.values(this.params);
    this.ready = e.length === JS && e.every((t) => (t == null ? void 0 : t.isAlive()) ?? !1);
  }
  whenReady(e, t) {
    this.ready ? t(this.params) : this.readyCallbacks.push(t), e.addDestroyFunc(() => {
      const s = this.readyCallbacks.indexOf(t);
      s >= 0 && this.readyCallbacks.splice(s, 1);
    });
  }
  register(e, t) {
    this.params[e] = t, this.updateReady(), this.ready && this.dispatchLocalEvent({ type: "ready" }), t.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(e) {
    return this.params[e];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: s } = this.params;
    return [e, s, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
  getScrollFeature() {
    return this.getGridBodyCtrl().scrollFeature;
  }
}, tx = (
  /*css*/
  ':where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none}}:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom,.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}.ag-floating-bottom{border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);height:var(--ag-row-height);white-space:nowrap;width:100%;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px))}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row-hover.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{opacity:1}50%{opacity:.4}to{opacity:1}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-chart,.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}:where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);cursor:pointer;font-family:inherit;padding:var(--ag-spacing) calc(var(--ag-spacing)*2);&:hover{background-color:var(--ag-row-hover-color)}&:active{border-color:var(--ag-accent-color)}&:disabled{background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-background-color);border:var(--ag-input-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-column-select-column-readonly{&.ag-icon-grip,.ag-icon-grip{opacity:.35}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{&:hover{background-color:var(--ag-icon-button-hover-color);border-radius:1px;box-shadow:0 0 0 4px var(--ag-icon-button-hover-color)}}.ag-filter-active{--ag-icon-button-hover-color:color-mix(in srgb,transparent,var(--ag-accent-color) 28%);background-color:color-mix(in srgb,transparent,var(--ag-accent-color) 14%);border-radius:1px;outline:solid 4px color-mix(in srgb,transparent,var(--ag-accent-color) 14%);position:relative;&:after{background-color:var(--ag-accent-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z")}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto}.ag-menu,.ag-resizer{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-resizer{pointer-events:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}:where(.ag-ltr) :where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize}&.ag-resizer-topRight{cursor:nesw-resize}&.ag-resizer-bottomRight{cursor:nwse-resize}&.ag-resizer-bottomLeft{cursor:nesw-resize}}:where(.ag-rtl) :where(.ag-resizer){&.ag-resizer-topLeft{cursor:nesw-resize}&.ag-resizer-topRight{cursor:nwse-resize}&.ag-resizer-bottomRight{cursor:nesw-resize}&.ag-resizer-bottomLeft{cursor:nwse-resize}}'
), ah, lh, kl = typeof window != "object" || !((lh = (ah = window == null ? void 0 : window.document) == null ? void 0 : ah.fonts) != null && lh.forEach), Pa = /* @__PURE__ */ new WeakMap(), Di = (e, t, s) => {
  if (kl)
    return;
  const i = t.getRootNode() === document ? document.head : t;
  let r = Pa.get(i);
  if (r || (r = { css: /* @__PURE__ */ new Set() }, Pa.set(i, r)), r.css.has(e))
    return;
  const o = document.createElement("style");
  o.dataset.agGlobalCss = s, o.textContent = e, r.last ? r.last.insertAdjacentElement("afterend", o) : i.insertBefore(o, i.querySelector(":not(title, meta)")), r.css.add(e), r.last = o;
}, fp = (e) => {
  Di(tx, e, "core"), Array.from(Jv()).sort((t, s) => t.moduleName.localeCompare(s.moduleName)).forEach(
    (t) => {
      var s;
      return (s = t.css) == null ? void 0 : s.forEach((i) => Di(i, e, `module-${t.moduleName}`));
    }
  );
}, Ta = /* @__PURE__ */ new Set(), sx = (e) => {
  Ta.add(e);
}, ix = (e) => {
  if (Ta.delete(e), Ta.size === 0) {
    Pa = /* @__PURE__ */ new WeakMap();
    for (const t of document.head.querySelectorAll("style[data-ag-global-css]"))
      t.remove();
  }
}, Oe = (e) => new mp(e), as = "$default", rx = 0, mp = class {
  constructor({ feature: e, params: t, modeParams: s = {}, css: i, cssImports: r }) {
    this.feature = e, this.css = i, this.cssImports = r, this.modeParams = {
      // NOTE: it's important that default is defined first, putting it
      // first in iteration order, because when merging params the default
      // params override any prior modal params, so modal params in this
      // part need to come after default params to prevent them from being
      // immediately overridden.
      [as]: {
        ...s[as] ?? {},
        ...t ?? {}
      },
      ...s
    };
  }
  use(e) {
    let t = this._inject;
    if (t == null) {
      let { css: s } = this;
      if (s) {
        const i = `ag-theme-${this.feature ?? "part"}-${++rx}`;
        typeof s == "function" && (s = s()), s = `:where(.${i}) {
${s}
}
`;
        for (const r of this.cssImports ?? [])
          s = `@import url(${JSON.stringify(r)});
${s}`;
        t = { css: s, class: i };
      } else
        t = !1;
      this._inject = t;
    }
    return t && e && Di(t.css, e, t.class), t ? t.class : !1;
  }
}, ox = (e) => e.replace(/[A-Z]/g, (t) => `-${t}`).toLowerCase(), Cp = (e) => `--ag-${ox(e)}`, Zt = (e) => `var(${Cp(e)})`, nx = (e, t, s) => Math.max(t, Math.min(s, e)), ax = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (s) => {
    const i = s;
    return t.has(i) || t.set(i, e(s)), t.get(i);
  };
}, At = (e) => ({ ref: "accentColor", mix: e }), je = (e) => ({ ref: "foregroundColor", mix: e }), ct = (e) => ({
  ref: "foregroundColor",
  mix: e,
  onto: "backgroundColor"
}), lx = { ref: "foregroundColor" }, Gt = { ref: "accentColor" }, Ei = {
  backgroundColor: "#fff",
  foregroundColor: "#181d1f",
  borderColor: je(0.15),
  chromeBackgroundColor: ct(0.02),
  browserColorScheme: "light"
}, dx = {
  ...Ei,
  textColor: lx,
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  wrapperBorder: !0,
  rowBorder: !0,
  headerRowBorder: !0,
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: !1,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: !0,
  pinnedRowBorder: !0,
  sidePanelBorder: !0,
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  sideButtonBarBackgroundColor: {
    ref: "sideBarBackgroundColor"
  },
  sideButtonBarTopPadding: 0,
  sideButtonSelectedUnderlineWidth: 2,
  sideButtonSelectedUnderlineColor: "transparent",
  sideButtonSelectedUnderlineTransitionDuration: 0,
  sideButtonBackgroundColor: "transparent",
  sideButtonTextColor: { ref: "textColor" },
  sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
  sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBackgroundColor: { ref: "backgroundColor" },
  sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBorder: !0,
  sideButtonLeftPadding: { ref: "spacing" },
  sideButtonRightPadding: { ref: "spacing" },
  sideButtonVerticalPadding: { calc: "spacing * 3" },
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  cellFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "backgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: Gt,
  rangeSelectionBackgroundColor: At(0.2),
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: At(0.5),
  rowHoverColor: At(0.08),
  columnHoverColor: At(0.05),
  selectedRowBackgroundColor: At(0.12),
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: {
    ref: "backgroundColor"
  },
  borderRadius: 4,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  spacing: 8,
  fontSize: 14,
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  popupShadow: "0 0 16px #00000026",
  cardShadow: "0 1px 4px 1px #00000018",
  dropdownShadow: { ref: "cardShadow" },
  dragAndDropImageBackgroundColor: {
    ref: "backgroundColor"
  },
  dragAndDropImageBorder: !0,
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  dragHandleColor: je(0.7),
  focusShadow: {
    spread: 3,
    color: At(0.5)
  },
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  listItemHeight: {
    calc: "iconSize + widgetVerticalSpacing"
  },
  iconSize: 16,
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonOnBackgroundColor: Gt,
  toggleButtonOffBackgroundColor: ct(0.3),
  toggleButtonSwitchBackgroundColor: {
    ref: "backgroundColor"
  },
  toggleButtonSwitchInset: 2,
  menuBorder: {
    color: je(0.2)
  },
  menuBackgroundColor: ct(0.03),
  menuTextColor: ct(0.95),
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: je(0.8),
  iconButtonHoverColor: je(0.1),
  dialogShadow: {
    ref: "popupShadow"
  },
  cellEditingBorder: {
    color: Gt
  },
  cellEditingShadow: { ref: "cardShadow" },
  dialogBorder: {
    color: je(0.2)
  },
  panelBackgroundColor: {
    ref: "backgroundColor"
  },
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarBorder: !0,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: !0,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipBorder: !0,
  columnDropCellBackgroundColor: je(0.07),
  columnDropCellTextColor: {
    ref: "textColor"
  },
  columnDropCellDragHandleColor: {
    ref: "textColor"
  },
  columnDropCellBorder: {
    color: je(0.13)
  },
  selectCellBackgroundColor: je(0.07),
  selectCellBorder: {
    color: je(0.13)
  },
  advancedFilterBuilderButtonBarBorder: !0,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  iconButtonHoverBackgroundColor: je(0.1),
  rowLoadingSkeletonEffectColor: je(0.15)
}, cx = [
  "colorScheme",
  "color",
  "length",
  "scale",
  "borderStyle",
  "border",
  "shadow",
  "image",
  "fontFamily",
  "fontWeight",
  "duration"
], hx = ax((e) => (e = e.toLowerCase(), cx.find((t) => e.endsWith(t.toLowerCase())) ?? "length")), dn = (e) => typeof e == "string" ? e : typeof e == "number" ? String(e) : !1, Ol = (e) => {
  if (typeof e == "string")
    return e;
  if (e && "ref" in e) {
    const t = Zt(e.ref);
    return e.mix == null ? t : `color-mix(in srgb, ${e.onto ? Zt(e.onto) : "transparent"}, ${t} ${nx(e.mix * 100, 0, 100)}%)`;
  }
  return !1;
}, ux = dn, ci = (e) => typeof e == "string" ? e : typeof e == "number" ? `${e}px` : e && "calc" in e ? `calc(${e.calc.replace(/ ?[*/+] ?/g, " $& ").replace(/-?[a-z][a-z0-9]*\b(?![-(])/gi, (s) => s[0] === "-" ? s : ` ${Zt(s)} `)})` : e && "ref" in e ? Zt(e.ref) : !1, px = dn, gx = (e, t) => typeof e == "string" ? e : e === !0 ? "solid 1px var(--ag-border-color)" : e === !1 ? t === "columnBorder" ? "solid 1px transparent" : "none" : e && "ref" in e ? Zt(e.ref) : vp(e.style ?? "solid") + " " + ci(e.width ?? 1) + " " + Ol(e.color ?? { ref: "borderColor" }), fx = (e) => typeof e == "string" ? e : e === !1 ? "none" : e && "ref" in e ? Zt(e.ref) : [
  ci(e.offsetX ?? 0),
  ci(e.offsetY ?? 0),
  ci(e.radius ?? 0),
  ci(e.spread ?? 0),
  Ol(e.color ?? { ref: "foregroundColor" })
].join(" "), vp = dn, wp = (e) => typeof e == "string" ? jd(e) : e && "googleFont" in e ? wp(e.googleFont) : e && "ref" in e ? Zt(e.ref) : Array.isArray(e) ? e.map((t) => (typeof t == "object" && "googleFont" in t && (t = t.googleFont), jd(t))).join(", ") : !1, jd = (e) => (
  // don't quote safe identifier names, so that people can specify fonts
  // like sans-serif which are keywords not strings
  /^[\w-]+$/.test(e) ? e : JSON.stringify(e)
), mx = dn, yp = (e) => typeof e == "string" ? e : e && "url" in e ? `url(${JSON.stringify(e.url)})` : e && "svg" in e ? yp({ url: `data:image/svg+xml,${encodeURIComponent(e.svg)}` }) : e && "ref" in e ? Zt(e.ref) : !1, Cx = (e, t) => typeof e == "string" ? e : typeof e == "number" ? (e >= 10 && z(104, { value: e, param: t }), `${e}s`) : e && "ref" in e ? Zt(e.ref) : !1, vx = {
  color: Ol,
  colorScheme: ux,
  length: ci,
  scale: px,
  border: gx,
  borderStyle: vp,
  shadow: fx,
  image: yp,
  fontFamily: wp,
  fontWeight: mx,
  duration: Cx
}, wx = (e, t) => {
  const s = hx(e);
  return vx[s](t, e);
}, bp = () => new Sp(), Sp = class xp {
  constructor(t = []) {
    this.parts = t;
  }
  withPart(t) {
    return typeof t == "function" && (t = t()), t instanceof mp ? new xp([...this.parts, t]) : (fa(259, { part: t }, "Invalid part"), this);
  }
  withoutPart(t) {
    return this.withPart(Oe({ feature: t }));
  }
  withParams(t, s = as) {
    return this.withPart(
      Oe({
        modeParams: { [s]: t }
      })
    );
  }
  /**
   * Called by a grid instance when it starts using the theme. This installs
   * the theme's parts into document head, or the shadow DOM if the provided
   * container is within a shadow root.
   */
  _startUse({ container: t, loadThemeGoogleFonts: s }) {
    if (kl)
      return;
    bx(), fp(t);
    const i = yx(this);
    if (i.length > 0)
      for (const r of i)
        s && xx(r);
    for (const r of this.parts)
      r.use(t);
  }
  /**
   * Return CSS that that applies the params of this theme to elements with
   * the provided class name
   */
  _getCssClass() {
    return this._cssClassCache ?? (this._cssClassCache = qd(this.parts).map((t) => t.use()).filter(Boolean).join(" "));
  }
  _getModeParams() {
    let t = this._paramsCache;
    if (!t) {
      const s = {
        // NOTE: defining the default mode here is important, it ensures
        // that the default mode is first in iteration order, which puts
        // it first in outputted CSS, allowing other modes to override it
        [as]: { ...dx }
      };
      for (const i of qd(this.parts))
        for (const [r, o] of Object.entries(i.modeParams))
          if (o) {
            const n = s[r] ?? (s[r] = {}), a = /* @__PURE__ */ new Set();
            for (const [l, d] of Object.entries(o))
              d !== void 0 && (n[l] = d, a.add(l));
            if (r === as) {
              for (const [l, d] of Object.entries(s))
                if (l !== as)
                  for (const c of a)
                    delete d[c];
            }
          }
      this._paramsCache = t = s;
    }
    return t;
  }
  /**
   * Return the CSS chunk that is inserted into the grid DOM, and will
   * therefore be removed automatically when the grid is destroyed or it
   * starts to use a new theme.
   *
   * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
   */
  _getPerGridCss(t) {
    const s = "##SELECTOR##";
    let i = this._paramsCssCache;
    if (!i) {
      let r = "", o = "";
      for (const [a, l] of Object.entries(this._getModeParams())) {
        if (a !== as) {
          const c = `:where([data-ag-theme-mode="${typeof CSS == "object" ? CSS.escape(a) : a}"]) & {
`;
          r += c, o += c;
        }
        for (const [d, c] of Object.entries(l)) {
          const h = wx(d, c);
          if (h === !1)
            z(107, { key: d, value: c });
          else {
            const u = Cp(d), p = u.replace("--ag-", "--ag-inherited-");
            r += `	${u}: var(${p}, ${h});
`, o += `	${p}: var(${u});
`;
          }
        }
        a !== as && (r += `}
`, o += `}
`);
      }
      let n = `${s} {
${r}}
`;
      n += `:has(> ${s}):not(${s}) {
${o}}
`, this._paramsCssCache = i = n;
    }
    return i.replaceAll(s, `:where(.${t})`);
  }
}, qd = (e) => {
  const t = /* @__PURE__ */ new Map();
  for (const i of e)
    t.set(i.feature, i);
  const s = [];
  for (const i of e)
    (!i.feature || t.get(i.feature) === i) && s.push(i);
  return s;
}, yx = (e) => {
  const t = /* @__PURE__ */ new Set(), s = (o) => {
    if (Array.isArray(o))
      o.forEach(s);
    else {
      const n = o == null ? void 0 : o.googleFont;
      typeof n == "string" && t.add(n);
    }
  };
  return Object.values(e._getModeParams()).flatMap((o) => Object.values(o)).forEach(s), Array.from(t).sort();
}, Yd = !1, bx = () => {
  if (!Yd) {
    Yd = !0;
    for (const e of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]')))
      e.remove();
  }
}, Sx = /* @__PURE__ */ new Set(), xx = async (e) => {
  Sx.add(e);
  const t = `@import url('https://${Fx}/css2?family=${encodeURIComponent(e)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  Di(t, document.head, `googleFont:${e}`);
}, Fx = "fonts.googleapis.com", Rx = (
  /*css*/
  '.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}'
), Fp = Oe({
  feature: "checkboxStyle",
  params: {
    checkboxBorderWidth: 1,
    checkboxBorderRadius: {
      ref: "borderRadius"
    },
    checkboxUncheckedBackgroundColor: {
      ref: "backgroundColor"
    },
    checkboxUncheckedBorderColor: ct(0.3),
    checkboxCheckedBackgroundColor: Gt,
    checkboxCheckedBorderColor: Gt,
    checkboxCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
    },
    checkboxCheckedShapeColor: {
      ref: "backgroundColor"
    },
    checkboxIndeterminateBackgroundColor: ct(0.3),
    checkboxIndeterminateBorderColor: ct(0.3),
    checkboxIndeterminateShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
    },
    checkboxIndeterminateShapeColor: {
      ref: "backgroundColor"
    },
    radioCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
    }
  },
  css: Rx
});
({
  ...Ei
});
({
  ...Ei
});
var Rp = {
  ...Ei,
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: ct(0.05),
  rowHoverColor: At(0.15),
  selectedRowBackgroundColor: At(0.2),
  menuBackgroundColor: ct(0.1),
  browserColorScheme: "dark",
  popupShadow: "0 0px 20px #000A",
  cardShadow: "0 1px 4px 1px #000A",
  advancedFilterBuilderJoinPillColor: "#7a3a37",
  advancedFilterBuilderColumnPillColor: "#355f2d",
  advancedFilterBuilderOptionPillColor: "#5a3168",
  advancedFilterBuilderValuePillColor: "#374c86",
  checkboxUncheckedBorderColor: ct(0.4),
  toggleButtonOffBackgroundColor: ct(0.4)
}, Px = {
  ...Rp,
  backgroundColor: "#1f2836"
}, Pp = /* @__PURE__ */ Oe({
  feature: "colorScheme",
  params: Ei,
  modeParams: {
    light: Ei,
    dark: Rp,
    "dark-blue": Px
  }
}), Tp = (
  /*css*/
  ':where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}'
), Tx = (
  /*css*/
  `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}`
), Dx = /* @__PURE__ */ Oe({
  feature: "iconSet",
  css: () => Tp + Tx
}), Dp = {
  aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
  arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
  asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
  chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
  "color-picker": '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
  columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
  contracted: '<path d="m9 18 6-6-6-6"/>',
  copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
  cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
  csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
  desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  expanded: '<path d="m15 18-6-6 6-6"/>',
  "eye-slash": '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
  eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
  filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
  first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
  group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
  last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
  left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
  linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
  loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
  maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
  menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
  "menu-alt": '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
  minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
  minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
  next: '<path d="m9 18 6-6-6-6"/>',
  none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
  "not-allowed": '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
  paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
  pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
  pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
  plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
  previous: '<path d="m15 18-6-6 6-6"/>',
  right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
  save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
  "small-left": '<path d="m15 18-6-6 6-6"/>',
  "small-right": '<path d="m9 18 6-6-6-6"/>',
  tick: '<path d="M20 6 9 17l-5-5"/>',
  "tree-closed": '<path d="m9 18 6-6-6-6"/>',
  "tree-indeterminate": '<path d="M5 12h14"/>',
  "tree-open": '<path d="m6 9 6 6 6-6"/>',
  unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
  up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/><g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
  settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>'
}, Ep = {
  "small-down": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
  "small-up": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>'
}, Ex = (e = {}) => {
  let t = Tp;
  for (const s of [...Object.keys(Dp), ...Object.keys(Ep)]) {
    const i = Mx(s, e.strokeWidth);
    t += `.ag-icon-${s}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(i)}'); }
`;
  }
  return t;
}, Mx = (e, t = 1.5) => {
  const s = Ep[e];
  if (s)
    return s;
  const i = Dp[e];
  if (!i)
    throw new Error(`Missing icon data for ${e}`);
  return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${t}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + i + "</svg>";
}, Ax = (e = {}) => Oe({
  feature: "iconSet",
  css: () => Ex(e)
}), Ix = /* @__PURE__ */ Ax(), Gl = (
  /*css*/
  ':where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}:where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) :where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) :where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}'
), Lx = (
  /*css*/
  ":where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){&:focus{box-shadow:var(--ag-focus-shadow)}}"
), kx = (
  /*css*/
  ":where(input.ag-input-field-input:not([type]),input.ag-input-field-input[type=text],input.ag-input-field-input[type=number],input.ag-input-field-input[type=tel],input.ag-input-field-input[type=date],input.ag-input-field-input[type=datetime-local],textarea.ag-input-field-input){border-left:none;border-right:none;border-top:none}"
), Bl = {
  inputBackgroundColor: "transparent",
  inputBorder: !1,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPlaceholderTextColor: {
    ref: "inputTextColor",
    mix: 0.5
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  },
  inputIconColor: {
    ref: "inputTextColor"
  }
};
Oe({
  feature: "inputStyle",
  params: Bl,
  css: Gl
});
var Mp = /* @__PURE__ */ Oe({
  feature: "inputStyle",
  params: {
    ...Bl,
    inputBackgroundColor: {
      ref: "backgroundColor"
    },
    inputBorder: !0,
    inputBorderRadius: {
      ref: "borderRadius"
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: {
      color: Gt
    },
    inputFocusShadow: {
      ref: "focusShadow"
    },
    inputDisabledBackgroundColor: ct(0.06),
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputInvalidBorder: {
      color: { ref: "invalidColor" }
    }
  },
  css: () => Gl + Lx
});
({
  ...Bl,
  inputBorder: je(0.3)
});
var Pr = (
  /*css*/
  '.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:1px solid var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}'
), Ox = (
  /*css*/
  ".ag-tab{border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;border-top:var(--ag-tab-selected-border-width) solid transparent;flex:0;&.ag-tab-selected{border-left-color:var(--ag-tab-selected-border-color);border-right-color:var(--ag-tab-selected-border-color);border-top-color:var(--ag-tab-selected-border-color);margin-bottom:-1px;padding-bottom:calc(var(--ag-tab-bottom-padding) + 1px)}}"
), Tr = {
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: 1,
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: 0,
  tabSelectedUnderlineTransitionDuration: 0,
  tabBarBorder: !1
};
Oe({
  feature: "tabStyle",
  params: Tr,
  css: Pr
});
var Gx = /* @__PURE__ */ Oe({
  feature: "tabStyle",
  params: {
    ...Tr,
    tabBarBorder: !0,
    tabBarBackgroundColor: je(0.05),
    tabTextColor: {
      ref: "textColor",
      mix: 0.7
    },
    tabSelectedTextColor: {
      ref: "textColor"
    },
    tabHoverTextColor: {
      ref: "textColor"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: {
      ref: "backgroundColor"
    }
  },
  css: Pr
});
({
  ...Tr
});
var Bx = /* @__PURE__ */ Oe({
  feature: "tabStyle",
  params: {
    ...Tr,
    tabBarBorder: !0,
    tabBarBackgroundColor: {
      ref: "chromeBackgroundColor"
    },
    tabHoverTextColor: Gt,
    tabSelectedTextColor: Gt,
    tabSelectedUnderlineColor: Gt,
    tabSelectedUnderlineWidth: 2,
    tabSelectedUnderlineTransitionDuration: "0.3s"
  },
  css: Pr
});
({
  ...Tr
});
var Vx = /* @__PURE__ */ bp().withPart(Fp).withPart(Pp).withPart(Ix).withPart(Gx).withPart(() => Mp).withParams({
  fontFamily: [
    { googleFont: "IBM Plex Sans" },
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu"
  ]
}), Nx = /* @__PURE__ */ bp().withPart(Fp).withPart(Pp).withPart(Dx).withPart(Bx).withPart(Mp).withParams({
  accentColor: "#2196f3",
  selectedRowBackgroundColor: At(0.3),
  inputFocusBorder: {
    color: At(0.4)
  },
  fontSize: 13,
  dataFontSize: 14,
  headerFontWeight: 700,
  borderRadius: 3,
  wrapperBorderRadius: 3,
  tabSelectedUnderlineColor: Gt,
  tabSelectedBorderWidth: 2,
  tabSelectedUnderlineTransitionDuration: 0.3
}), Xd = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, Zd = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, Qd = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, Un = {
  cssName: "--ag-row-border",
  changeKey: "rowBorderWidthChanged",
  defaultValue: 1,
  border: !0
}, Hx = 0, zx = class extends P {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.sizesMeasured = !1, this.paramsClass = `ag-theme-params-${++Hx}`, this.globalCSS = [];
  }
  wireBeans(e) {
    this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange()), this.handleThemeGridOptionChange(), this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.getSizeEl(Xd), this.getSizeEl(Zd), this.getSizeEl(Qd), this.getSizeEl(Un), this.refreshRowBorderWidthVariable(), this.addDestroyFunc(() => ix(this));
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(Xd);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(Zd);
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(Qd);
  }
  getRowBorderWidth() {
    return this.getCSSVariablePixelValue(Un);
  }
  applyThemeClasses(e) {
    const { gridTheme: t } = this;
    let s = "";
    if (t)
      s = `${this.paramsClass} ${t._getCssClass()}`;
    else {
      let i = this.eGridDiv;
      for (; i; ) {
        for (const r of Array.from(i.classList))
          r.startsWith("ag-theme-") && (s = s ? `${s} ${r}` : r);
        i = i.parentElement;
      }
    }
    for (const i of Array.from(e.classList))
      i.startsWith("ag-theme-") && e.classList.remove(i);
    if (s) {
      const i = e.className;
      e.className = i + (i ? " " : "") + s;
    }
  }
  refreshRowHeightVariable() {
    const { eGridDiv: e } = this, t = e.style.getPropertyValue("--ag-line-height").trim(), s = this.gos.get("rowHeight");
    if (s == null || isNaN(s) || !isFinite(s))
      return t !== null && e.style.setProperty("--ag-line-height", null), -1;
    const i = `${s}px`;
    return t != i ? (e.style.setProperty("--ag-line-height", i), s) : t != "" ? parseFloat(t) : -1;
  }
  addGlobalCSS(e, t) {
    this.gridTheme ? Di(e, this.eGridDiv, t) : this.globalCSS.push([e, t]);
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const s = this.measureSizeEl(e);
    return s === "detached" || s === "no-styles" ? e.defaultValue : (this.lastKnownValues.set(e, s), s);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const s = t.offsetWidth;
    return s === Kn ? "no-styles" : (this.sizesMeasured = !0, s);
  }
  getMeasurementContainer() {
    let e = this.eMeasurementContainer;
    return e || (e = this.eMeasurementContainer = document.createElement("div"), e.className = "ag-measurement-container", this.eGridDiv.appendChild(e)), e;
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    const s = this.getMeasurementContainer();
    t = document.createElement("div");
    const { border: i } = e;
    i ? (t.className = "ag-measurement-element-border", t.style.setProperty(
      "--ag-internal-measurement-border",
      `var(${e.cssName}, solid ${Kn}px`
    )) : t.style.width = `var(${e.cssName}, ${Kn}px)`, s.appendChild(t), this.sizeEls.set(e, t);
    let r = this.measureSizeEl(e);
    r === "no-styles" && R(9, { variable: e });
    const o = Rt(this.beans, t, () => {
      const n = this.measureSizeEl(e);
      n === "detached" || n === "no-styles" || (this.lastKnownValues.set(e, n), n !== r && (r = n, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => o()), t;
  }
  fireGridStylesChangedEvent(e) {
    e === "rowBorderWidthChanged" && this.refreshRowBorderWidthVariable(), this.eventSvc.dispatchEvent({
      type: "gridStylesChanged",
      [e]: !0
    });
  }
  refreshRowBorderWidthVariable() {
    const e = this.getCSSVariablePixelValue(Un);
    this.eGridDiv.style.setProperty("--ag-internal-row-border-width", `${e}px`);
  }
  handleThemeGridOptionChange() {
    const { gos: e, eGridDiv: t, globalCSS: s, gridTheme: i } = this, r = e.get("theme");
    let o;
    if (r === "legacy")
      o = void 0;
    else {
      const n = r ?? Vx;
      n instanceof Sp ? o = n : z(240, { theme: n });
    }
    if (o !== i) {
      if (o) {
        sx(this), fp(t);
        for (const [a, l] of s)
          Di(a, t, l);
        s.length = 0;
      }
      this.gridTheme = o, o == null || o._startUse({
        loadThemeGoogleFonts: e.get("loadThemeGoogleFonts"),
        container: t
      });
      let n = this.eParamsStyle;
      n || (n = this.eParamsStyle = document.createElement("style"), t.appendChild(n)), kl || (n.textContent = (o == null ? void 0 : o._getPerGridCss(this.paramsClass)) || ""), this.applyThemeClasses(t), this.fireGridStylesChangedEvent("themeChanged");
    }
    o && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded") && z(r ? 106 : 239);
  }
}, Kn = 15538, Wx = class extends P {
  constructor() {
    super(...arguments), this.beanName = "eventSvc", this.globalEventService = new Rs();
  }
  postConstruct() {
    const { globalListener: e, globalSyncListener: t } = this.beans;
    e && this.addGlobalListener(e, !0), t && this.addGlobalListener(t, !1);
  }
  addEventListener(e, t, s) {
    this.globalEventService.addEventListener(e, t, s);
  }
  removeEventListener(e, t, s) {
    this.globalEventService.removeEventListener(e, t, s);
  }
  addGlobalListener(e, t = !1) {
    this.globalEventService.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalEventService.removeGlobalListener(e, t);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e));
  }
  dispatchEventOnce(e) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e));
  }
};
function Ap(e) {
  return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
}
function Da(e, t) {
  let s;
  if (de(e) && Ap(e) && e.isPadding()) {
    const i = e;
    s = i.getLeafColumns()[0];
    let r = s;
    for (; r !== i; )
      t++, r = r.getParent();
  }
  return {
    column: s || e,
    headerRowIndex: t
  };
}
var _x = class extends P {
  constructor() {
    super(...arguments), this.beanName = "headerNavigation", this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    const e = this.beans;
    e.ctrlsSvc.whenReady(this, (s) => {
      this.gridBodyCon = s.gridBodyCtrl;
    });
    const t = Z(e);
    this.addManagedElementListeners(t, {
      mousedown: () => {
        this.currentHeaderRowWithoutSpan = -1;
      }
    });
  }
  getHeaderPositionForColumn(e, t) {
    let s;
    const { colModel: i, colGroupSvc: r, ctrlsSvc: o } = this.beans;
    if (typeof e == "string" ? (s = i.getCol(e), s || (s = (r == null ? void 0 : r.getColumnGroup(e)) ?? null)) : s = e, !s)
      return null;
    const n = o.getHeaderRowContainerCtrl(), a = n == null ? void 0 : n.getAllCtrls(), l = V(a || []).type === "filter", d = Kt(this.beans) - 1;
    let c = -1, h = s;
    for (; h; )
      c++, h = h.getParent();
    let u = c;
    return t && l && u === d - 1 && u++, u === -1 ? null : {
      headerRowIndex: u,
      column: s
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, s) {
    const i = this.beans.focusSvc;
    if (t || (t = i.focusedHeader), !t)
      return !1;
    const { headerRowIndex: r } = t, o = t.column, n = Kt(this.beans), a = e === "UP", l = this.getHeaderRowType(r);
    let {
      headerRowIndex: d,
      column: c,
      headerRowIndexWithoutSpan: h
    } = a ? Ux(l, o, r) : Kx(l, o, r), u = !1;
    return d < 0 && (d = 0, c = o, u = !0), d >= n ? (d = -1, this.currentHeaderRowWithoutSpan = -1) : h !== void 0 && (this.currentHeaderRowWithoutSpan = h), !u && !c ? !1 : i.focusHeaderPosition({
      headerPosition: { headerRowIndex: d, column: c },
      allowUserOverride: !0,
      event: s
    });
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, s) {
    const { focusSvc: i, gos: r } = this.beans, o = i.focusedHeader;
    let n, a;
    if (this.currentHeaderRowWithoutSpan !== -1 ? o.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = o.headerRowIndex, e === "LEFT" !== r.get("enableRtl") ? (a = "Before", n = this.findHeader(o, a)) : (a = "After", n = this.findHeader(o, a)), n || !t)
      return i.focusHeaderPosition({
        headerPosition: n,
        direction: a,
        fromTab: t,
        allowUserOverride: !0,
        event: s
      });
    if (t) {
      const l = r.getCallback("tabToNextHeader");
      if (l)
        return i.focusHeaderPositionFromUserFunc({
          userFunc: l,
          headerPosition: n,
          direction: a
        });
    }
    return this.focusNextHeaderRow(o, a, s);
  }
  focusNextHeaderRow(e, t, s) {
    const i = e.headerRowIndex;
    let r = null, o;
    const n = this.beans;
    if (t === "Before" ? i > 0 && (o = i - 1, this.currentHeaderRowWithoutSpan -= 1, r = this.findColAtEdgeForHeaderRow(o, "end")) : (o = i + 1, this.currentHeaderRowWithoutSpan < Kt(n) ? this.currentHeaderRowWithoutSpan += 1 : this.currentHeaderRowWithoutSpan = -1, r = this.findColAtEdgeForHeaderRow(o, "start")), !r)
      return !1;
    const { column: a, headerRowIndex: l } = Da(
      r.column,
      r == null ? void 0 : r.headerRowIndex
    );
    return n.focusSvc.focusHeaderPosition({
      headerPosition: { column: a, headerRowIndex: l },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: s
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let s;
    if (de(e)) {
      const i = e.getDisplayedLeafColumns();
      s = t === "Before" ? V(i) : i[0];
    } else
      s = e;
    this.gridBodyCon.scrollFeature.ensureColumnVisible(s);
  }
  findHeader(e, t) {
    let s, i;
    const { colGroupSvc: r, visibleCols: o } = this.beans;
    if (de(e.column) ? s = (r == null ? void 0 : r.getGroupAtDirection(e.column, t)) ?? void 0 : (i = `getCol${t}`, s = o[i](e.column)), !s)
      return;
    const { headerRowIndex: n } = e;
    if (this.getHeaderRowType(n) !== "filter") {
      const d = [s];
      for (; s.getParent(); )
        s = s.getParent(), d.push(s);
      s = d[Math.max(0, d.length - 1 - n)];
    }
    const { column: a, headerRowIndex: l } = Da(s, n);
    return {
      column: a,
      headerRowIndex: l
    };
  }
  getHeaderRowType(e) {
    const t = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const { visibleCols: s, ctrlsSvc: i, colGroupSvc: r } = this.beans, o = s.allCols, n = o[t === "start" ? 0 : o.length - 1];
    if (!n)
      return;
    const a = i.getHeaderRowContainerCtrl(n.getPinned()), l = a == null ? void 0 : a.getRowType(e);
    if (l == "group") {
      const d = r == null ? void 0 : r.getColGroupAtLevel(n, e);
      return {
        headerRowIndex: e,
        column: d
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: l == null ? -1 : e,
      column: n
    };
  }
};
function Ux(e, t, s) {
  const i = e === "filter", r = e === "column";
  let o = i ? t : t.getParent(), n = s - 1, a = n;
  if (r && Ap(t.getParent())) {
    for (; o && o.isPadding(); )
      o = o.getParent(), n--;
    a = n, n < 0 && (o = t, n = s, a = void 0);
  }
  return { column: o, headerRowIndex: n, headerRowIndexWithoutSpan: a };
}
function Kx(e, t, s, i = "After") {
  let r = t, o = s + 1;
  const n = o;
  if (e === "group") {
    const a = t.getDisplayedLeafColumns(), l = i === "After" ? a[0] : V(a), d = [];
    let c = l;
    for (; c.getParent() !== t; )
      c = c.getParent(), d.push(c);
    if (r = l, l.isSpanHeaderHeight())
      for (let h = d.length - 1; h >= 0; h--) {
        const u = d[h];
        if (!u.isPadding()) {
          r = u;
          break;
        }
        o++;
      }
    else
      r = V(d), r || (r = l);
  }
  return { column: r, headerRowIndex: o, headerRowIndexWithoutSpan: n };
}
var $x = class extends P {
  constructor() {
    super(...arguments), this.beanName = "focusSvc";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.visibleCols = e.visibleCols, this.rowRenderer = e.rowRenderer, this.navigation = e.navigation, this.filterManager = e.filterManager, this.overlays = e.overlays;
  }
  postConstruct() {
    const e = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: e,
      columnRowGroupChanged: e
    }), this.addDestroyFunc(dw(this.beans));
  }
  onColumnEverythingChanged() {
    if (!this.focusedCell)
      return;
    const e = this.focusedCell.column, t = this.colModel.getCol(e.getId());
    e !== t && this.clearFocusedCell();
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCell || this.isDomDataMissingInHierarchy(q(this.beans), mr) ? null : this.focusedCell;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader || this.isDomDataMissingInHierarchy(q(this.beans), Qu) ? null : this.focusedHeader;
  }
  isDomDataMissingInHierarchy(e, t) {
    let s = e;
    for (; s; ) {
      if (Co(this.gos, s, t))
        return !1;
      s = s.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCell;
  }
  shouldRestoreFocus(e) {
    return this.isCellRestoreFocused(e) ? (setTimeout(() => {
      this.restoredFocusedCell = null;
    }, 0), !0) : !1;
  }
  clearRestoreFocus() {
    this.restoredFocusedCell = null, this.awaitRestoreFocusedCell = !1;
  }
  restoreFocusedCell(e, t) {
    this.awaitRestoreFocusedCell = !0, setTimeout(() => {
      this.awaitRestoreFocusedCell && (this.setRestoreFocusedCell(e), t());
    });
  }
  isCellRestoreFocused(e) {
    return this.restoredFocusedCell == null ? !1 : Ti(e, this.restoredFocusedCell);
  }
  setRestoreFocusedCell(e) {
    this.beans.frameworkOverrides.renderingEngine === "react" && (this.restoredFocusedCell = e);
  }
  getFocusEventParams(e) {
    const { rowIndex: t, rowPinned: s, column: i } = e, r = {
      rowIndex: t,
      rowPinned: s,
      column: i,
      isFullWidthCell: !1
    }, o = this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: s });
    return o && (r.isFullWidthCell = o.isFullWidth()), r;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCell = null, this.focusedCell == null)
      return;
    const e = this.getFocusEventParams(this.focusedCell);
    this.focusedCell = null, this.eventSvc.dispatchEvent({
      type: "cellFocusCleared",
      ...e
    });
  }
  setFocusedCell(e) {
    const { column: t, rowIndex: s, rowPinned: i, forceBrowserFocus: r = !1, preventScrollOnBrowserFocus: o = !1 } = e, n = this.colModel.getCol(t);
    if (!n) {
      this.focusedCell = null;
      return;
    }
    this.focusedCell = {
      rowIndex: s,
      rowPinned: ge(i),
      column: n
    }, this.eventSvc.dispatchEvent({
      type: "cellFocused",
      ...this.getFocusEventParams(this.focusedCell),
      forceBrowserFocus: r,
      preventScrollOnBrowserFocus: o
    });
  }
  isCellFocused(e) {
    return this.focusedCell == null ? !1 : Ti(e, this.focusedCell);
  }
  isRowNodeFocused(e) {
    return this.isRowFocused(e.rowIndex, e.rowPinned);
  }
  isHeaderWrapperFocused(e) {
    if (this.focusedHeader == null)
      return !1;
    const {
      column: t,
      rowCtrl: { rowIndex: s, pinned: i }
    } = e, { column: r, headerRowIndex: o } = this.focusedHeader;
    return t === r && s === o && i == r.getPinned();
  }
  focusHeaderPosition(e) {
    var l;
    if (mi(this.beans))
      return !1;
    const { direction: t, fromTab: s, allowUserOverride: i, event: r, fromCell: o, rowWithoutSpanValue: n } = e;
    let { headerPosition: a } = e;
    if (o && ((l = this.filterManager) != null && l.isAdvFilterHeaderActive()))
      return this.focusAdvancedFilter(a);
    if (i) {
      const d = this.focusedHeader, c = Kt(this.beans);
      if (s) {
        const h = this.gos.getCallback("tabToNextHeader");
        h && (a = this.getHeaderPositionFromUserFunc({
          userFunc: h,
          direction: t,
          currentPosition: d,
          headerPosition: a,
          headerRowCount: c
        }));
      } else {
        const h = this.gos.getCallback("navigateToNextHeader");
        if (h && r) {
          const u = {
            key: r.key,
            previousHeaderPosition: d,
            nextHeaderPosition: a,
            headerRowCount: c,
            event: r
          };
          a = h(u);
        }
      }
    }
    return a ? this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: t,
      event: r,
      fromCell: o,
      rowWithoutSpanValue: n
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(e) {
    if (mi(this.beans))
      return !1;
    const { userFunc: t, headerPosition: s, direction: i, event: r } = e, o = this.focusedHeader, n = Kt(this.beans), a = this.getHeaderPositionFromUserFunc({
      userFunc: t,
      direction: i,
      currentPosition: o,
      headerPosition: s,
      headerRowCount: n
    });
    return !!a && this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: i,
      event: r
    });
  }
  getHeaderPositionFromUserFunc(e) {
    const { userFunc: t, direction: s, currentPosition: i, headerPosition: r, headerRowCount: o } = e, a = t({
      backwards: s === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: r,
      headerRowCount: o
    });
    return a === !0 ? i : a === !1 ? null : a;
  }
  focusProvidedHeaderPosition(e) {
    const { headerPosition: t, direction: s, fromCell: i, rowWithoutSpanValue: r, event: o } = e, { column: n, headerRowIndex: a } = t, { filterManager: l, ctrlsSvc: d, headerNavigation: c } = this.beans;
    if (a === -1)
      return l != null && l.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(t) : this.focusGridView(n);
    c == null || c.scrollToColumn(n, s);
    const h = d.getHeaderRowContainerCtrl(n.getPinned()), u = (h == null ? void 0 : h.focusHeader(t.headerRowIndex, n, o)) || !1;
    return c && u && (r != null || i) && (c.currentHeaderRowWithoutSpan = r ?? -1), u;
  }
  focusFirstHeader() {
    var i;
    if ((i = this.overlays) != null && i.isExclusive() && this.focusOverlay())
      return !0;
    let e = this.visibleCols.allCols[0];
    if (!e)
      return !1;
    const { colGroupSvc: t } = this.beans;
    t && e.getParent() && (e = t.getColGroupAtLevel(e, 0));
    const s = Da(e, 0);
    return this.focusHeaderPosition({
      headerPosition: s,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(e) {
    var i;
    if ((i = this.overlays) != null && i.isExclusive() && this.focusOverlay(!0))
      return !0;
    const t = Kt(this.beans) - 1, s = V(this.visibleCols.allCols);
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: t, column: s },
      rowWithoutSpanValue: -1,
      event: e
    });
  }
  focusPreviousFromFirstCell(e) {
    var t;
    return (t = this.filterManager) != null && t.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(e);
  }
  isAnyCellFocused() {
    return !!this.focusedCell;
  }
  isRowFocused(e, t) {
    return this.focusedCell == null ? !1 : this.focusedCell.rowIndex === e && this.focusedCell.rowPinned === ge(t);
  }
  focusOverlay(e) {
    var s, i;
    const t = ((s = this.overlays) == null ? void 0 : s.isVisible()) && ((i = this.overlays.eWrapper) == null ? void 0 : i.getGui());
    return !!t && ve(t, e);
  }
  focusGridView(e, t = !1, s = !0) {
    var r, o, n, a, l;
    if ((r = this.overlays) != null && r.isExclusive())
      return s && this.focusOverlay(t);
    if (Mu(this.beans))
      return t && !mi(this.beans) ? this.focusLastHeader() : s && this.focusOverlay(t) ? !0 : Xt(this.beans, !1);
    const i = t ? Tw(this.beans) : Pw(this.beans);
    if (i) {
      const { rowIndex: d, rowPinned: c } = i;
      if (e ?? (e = (o = this.focusedHeader) == null ? void 0 : o.column), e && d !== void 0 && d !== null) {
        if ((n = this.navigation) == null || n.ensureCellVisible({ rowIndex: d, column: e, rowPinned: c }), t) {
          const h = this.rowRenderer.getRowByPosition(i);
          if (h != null && h.isFullWidth() && ((a = this.navigation) != null && a.tryToFocusFullWidthRow(i, t)))
            return !0;
        }
        return this.setFocusedCell({
          rowIndex: d,
          column: e,
          rowPinned: ge(c),
          forceBrowserFocus: !0
        }), (l = this.beans.rangeSvc) == null || l.setRangeToCell({ rowIndex: d, rowPinned: c, column: e }), !0;
      }
    }
    return !!(s && this.focusOverlay(t) || t && this.focusLastHeader());
  }
  focusAdvancedFilter(e) {
    var t;
    return this.advFilterFocusColumn = e == null ? void 0 : e.column, ((t = this.beans.advancedFilter) == null ? void 0 : t.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(e, t) {
    var i;
    const s = (t ? void 0 : this.advFilterFocusColumn) ?? ((i = this.visibleCols.allCols) == null ? void 0 : i[0]);
    return e ? this.focusHeaderPosition({
      headerPosition: {
        column: s,
        headerRowIndex: Kt(this.beans) - 1
      }
    }) : this.focusGridView(s);
  }
  clearAdvancedFilterColumn() {
    this.advFilterFocusColumn = void 0;
  }
}, jx = class extends P {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleSvc";
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colAnimation = e.colAnimation;
  }
  postConstruct() {
    this.getScrollbarWidth(), this.addManagedEventListeners({
      displayedColumnsChanged: this.updateScrollVisible.bind(this),
      displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
    });
  }
  updateScrollVisible() {
    const { colAnimation: e } = this;
    e != null && e.isActive() ? e.executeLaterVMTurn(() => {
      e.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
    }) : this.updateScrollVisibleImpl();
  }
  updateScrollVisibleImpl() {
    var s;
    const e = this.ctrlsSvc.get("center");
    if (!e || (s = this.colAnimation) != null && s.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.verticalScrollShowing
    };
    this.setScrollsVisible(t), this.updateScrollGap();
  }
  updateScrollGap() {
    const e = this.ctrlsSvc.get("center"), t = e.hasHorizontalScrollGap(), s = e.hasVerticalScrollGap();
    (this.horizontalScrollGap !== t || this.verticalScrollGap !== s) && (this.horizontalScrollGap = t, this.verticalScrollGap = s, this.eventSvc.dispatchEvent({
      type: "scrollGapChanged"
    }));
  }
  setScrollsVisible(e) {
    (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) && (this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing, this.eventSvc.dispatchEvent({
      type: "scrollVisibilityChanged"
    }));
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const e = this.gos.get("scrollbarWidth"), s = typeof e == "number" && e >= 0 ? e : fC();
      s != null && (this.scrollbarWidth = s, this.eventSvc.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
}, qx = class extends P {
  constructor() {
    super(...arguments), this.beanName = "gridDestroySvc", this.destroyCalled = !1;
  }
  destroy() {
    var i;
    if (this.destroyCalled)
      return;
    const { stateSvc: e, ctrlsSvc: t, context: s } = this.beans;
    this.eventSvc.dispatchEvent({
      type: "gridPreDestroyed",
      state: (e == null ? void 0 : e.getState()) ?? {}
    }), this.destroyCalled = !0, (i = t.get("gridCtrl")) == null || i.destroyGridUi(), s.destroy(), super.destroy();
  }
}, or = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), Yx = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  enableStrictPivotColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressMoveWhenColumnDragging: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  cellFlashDuration: 500,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0,
  suppressSetFilterByDefault: !1
}, Xx = 0, Zx = 0, Qx = class extends P {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.gridInstanceId = Zx++, this.propEventSvc = new Rs(), this.globalEventHandlerFactory = (e) => (t, s) => {
      if (!this.isAlive())
        return;
      const i = or.has(t);
      if (i && !e || !i && e)
        return;
      const r = dl(t), o = this.gridOptions[r];
      typeof o == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => {
        o(s);
      });
    };
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, this.validation = e.validation, this.api = e.gridApi, this.gridId = e.context.getGridId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), !0), this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: e }) => {
        this.updateGridOptions({ options: e, force: !0, source: "gridOptionsUpdated" });
      }
    });
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(e) {
    return this.gridOptions[e] ?? Yx[e];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(e) {
    return this.mergeGridCommonParams(this.gridOptions[e]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(e) {
    return A(this.gridOptions[e]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(e) {
    return e && ((s) => e(this.addGridCommonParams(s)));
  }
  updateGridOptions({
    options: e,
    force: t,
    source: s = "api"
  }) {
    const i = { id: Xx++, properties: [] }, r = [], { gridOptions: o, validation: n } = this;
    Object.entries(e).forEach(([a, l]) => {
      n == null || n.warnOnInitialPropertyUpdate(s, a);
      const d = t || typeof l == "object" && s === "api", c = o[a];
      if (d || c !== l) {
        o[a] = l;
        const h = {
          type: a,
          currentValue: l,
          previousValue: c,
          changeSet: i,
          source: s
        };
        r.push(h);
      }
    }), n == null || n.processGridOptions(this.gridOptions), i.properties = r.map((a) => a.type), r.forEach((a) => {
      ws(this, `Updated property ${a.type} from`, a.previousValue, " to ", a.currentValue), this.propEventSvc.dispatchEvent(a);
    });
  }
  addPropertyEventListener(e, t) {
    this.propEventSvc.addEventListener(e, t);
  }
  removePropertyEventListener(e, t) {
    this.propEventSvc.removeEventListener(e, t);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  getGridCommonParams() {
    return {
      api: this.api,
      context: this.gridOptionsContext
    };
  }
  addGridCommonParams(e) {
    const t = e;
    return t.api = this.api, t.context = this.gridOptionsContext, t;
  }
  assertModuleRegistered(e, t) {
    const s = Array.isArray(e) ? e.some((i) => this.isModuleRegistered(i)) : this.isModuleRegistered(e);
    return s || z(200, {
      ...this.getModuleErrorParams(),
      moduleName: e,
      reasonOrId: t
    }), s;
  }
  getModuleErrorParams() {
    return {
      gridId: this.gridId,
      gridScoped: gl(),
      rowModelType: this.get("rowModelType")
    };
  }
  isModuleRegistered(e) {
    return xu(e, this.gridId, this.get("rowModelType"));
  }
};
function Jx(e) {
  return (
    /* html */
    `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            ${e ? '<ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>' : ""}
        </div>
    </div>`
  );
}
var e0 = class extends L {
  constructor() {
    super(...arguments), this.eFilter = S, this.eFilterButton = S, this.eSortIndicator = S, this.eMenu = S, this.eLabel = S, this.eText = S, this.eSortOrder = S, this.eSortAsc = S, this.eSortDesc = S, this.eSortMixed = S, this.eSortNone = S, this.isLoadingInnerComponent = !1;
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || e.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon ? !1 : (this.setDisplayName(e), !0);
  }
  workOutTemplate() {
    const { params: e, beans: t } = this, s = e.template ?? Jx(!!t.sortSvc);
    return s != null && s.trim ? s.trim() : s;
  }
  init(e) {
    this.params = e;
    const { sortSvc: t, touchSvc: s, userCompFactory: i } = this.beans;
    this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate, t ? [t.getSortIndicatorSelector()] : void 0), s == null || s.setupForHeader(this), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.workOutInnerHeaderComponent(i, e), this.setDisplayName(e);
  }
  workOutInnerHeaderComponent(e, t) {
    const s = Ov(e, t, t);
    s && (this.isLoadingInnerComponent = !0, s.newAgStackInstance().then((i) => {
      this.isLoadingInnerComponent = !1, i && (this.isAlive() ? (this.innerHeaderComponent = i, this.eText.appendChild(i.getGui())) : this.destroyBean(i));
    }));
  }
  setDisplayName(e) {
    const { displayName: t } = e, s = this.currentDisplayName;
    if (this.currentDisplayName = t, s === t || this.innerHeaderComponent || this.isLoadingInnerComponent)
      return;
    const i = Q(t, !0);
    this.eText.innerText = i;
  }
  addInIcon(e, t, s) {
    if (t == null)
      return;
    const i = B(e, this.beans, s);
    i && t.appendChild(i);
  }
  workOutShowMenu() {
    var e;
    return this.params.enableMenu && !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonEnabled());
  }
  shouldSuppressMenuHide() {
    var e;
    return !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonAlwaysShowEnabled());
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      ce(this.eMenu), this.eMenu = void 0;
      return;
    }
    const { gos: e, eMenu: t, params: s } = this, i = we(e);
    this.addInIcon(i ? "menu" : "menuAlt", t, s.column), t.classList.toggle("ag-header-menu-icon", !i);
    const r = this.shouldSuppressMenuHide();
    this.currentSuppressMenuHide = r, this.addManagedElementListeners(t, { click: () => s.showColumnMenu(t) }), t.classList.toggle("ag-header-menu-always-show", r);
  }
  onMenuKeyboardShortcut(e) {
    var l;
    const { params: t, gos: s, beans: i, eMenu: r, eFilterButton: o } = this, n = t.column, a = we(s);
    if (e && !a) {
      if ((l = i.menuSvc) != null && l.isFilterMenuInHeaderEnabled(n))
        return t.showFilter(o ?? r ?? this.getGui()), !0;
    } else if (t.enableMenu)
      return t.showColumnMenu(r ?? o ?? this.getGui()), !0;
    return !1;
  }
  setupSort() {
    const { sortSvc: e } = this.beans;
    if (!e)
      return;
    const { enableSorting: t, column: s } = this.params;
    if (this.currentSort = t, !this.eSortIndicator) {
      this.eSortIndicator = this.createBean(e.createSortIndicator(!0));
      const { eSortIndicator: i, eSortOrder: r, eSortAsc: o, eSortDesc: n, eSortMixed: a, eSortNone: l } = this;
      i.attachCustomElements(r, o, n, a, l);
    }
    this.eSortIndicator.setupSort(s), this.currentSort && e.setupHeader(this, s, this.eLabel);
  }
  setupFilterIcon() {
    const { eFilter: e, params: t } = this;
    e && this.configureFilter(t.enableFilterIcon, e, this.onFilterChangedIcon.bind(this), "filterActive");
  }
  setupFilterButton() {
    const { eFilterButton: e, params: t } = this;
    if (!e)
      return;
    this.configureFilter(
      t.enableFilterButton,
      e,
      this.onFilterChangedButton.bind(this),
      "filter"
    ) ? this.addManagedElementListeners(e, {
      click: () => t.showFilter(e)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, s, i) {
    if (!e)
      return ce(t), !1;
    const r = this.params.column;
    return this.addInIcon(i, t, r), this.addManagedListeners(r, { filterChanged: s }), s(), !0;
  }
  onFilterChangedIcon() {
    const e = this.params.column.isFilterActive();
    O(this.eFilter, e, { skipAriaHidden: !0 });
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    const { eFilterButton: t, eMenu: s } = this;
    return e ? t ?? s ?? this.getGui() : s ?? t ?? this.getGui();
  }
  destroy() {
    super.destroy(), this.innerHeaderComponent && (this.destroyBean(this.innerHeaderComponent), this.innerHeaderComponent = void 0);
  }
}, t0 = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`
    ), this.agOpened = S, this.agClosed = S, this.agLabel = S, this.isLoadingInnerComponent = !1;
  }
  init(e) {
    const { userCompFactory: t } = this.beans;
    this.params = e, this.checkWarnings(), this.workOutInnerHeaderGroupComponent(t, e), this.setupLabel(e), this.addGroupExpandIcon(e), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && R(89);
  }
  workOutInnerHeaderGroupComponent(e, t) {
    const s = Bv(e, t, t);
    s && (this.isLoadingInnerComponent = !0, s.newAgStackInstance().then((i) => {
      this.isLoadingInnerComponent = !1, i && (this.isAlive() ? (this.innerHeaderGroupComponent = i, this.agLabel.appendChild(i.getGui())) : this.destroyBean(i));
    }));
  }
  setupExpandIcons() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: s },
      beans: i
    } = this;
    this.addInIcon("columnGroupOpened", e), this.addInIcon("columnGroupClosed", t);
    const r = (l) => {
      if (nt(l))
        return;
      const d = !s.isExpanded();
      i.colGroupSvc.setColumnGroupOpened(
        s.getProvidedColumnGroup(),
        d,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(i, t, r), this.addTouchAndClickListeners(i, e, r);
    const o = (l) => {
      he(l);
    };
    this.addManagedElementListeners(t, { dblclick: o }), this.addManagedElementListeners(e, { dblclick: o }), this.addManagedElementListeners(this.getGui(), { dblclick: r }), this.updateIconVisibility();
    const n = s.getProvidedColumnGroup(), a = this.updateIconVisibility.bind(this);
    this.addManagedListeners(n, {
      expandedChanged: a,
      expandableChanged: a
    });
  }
  addTouchAndClickListeners(e, t, s) {
    var i;
    (i = e.touchSvc) == null || i.setupForHeaderGroup(this, t, s), this.addManagedElementListeners(t, { click: s });
  }
  updateIconVisibility() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: s }
    } = this;
    if (s.isExpandable()) {
      const i = s.isExpanded();
      O(e, i), O(t, !i);
    } else
      O(e, !1), O(t, !1);
  }
  addInIcon(e, t) {
    const s = B(e, this.beans, null);
    s && t.appendChild(s);
  }
  addGroupExpandIcon(e) {
    if (!e.columnGroup.isExpandable()) {
      const { agOpened: t, agClosed: s } = this;
      O(t, !1), O(s, !1);
      return;
    }
  }
  setupLabel(e) {
    var r;
    const { displayName: t, columnGroup: s } = e, i = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
    if (A(t) && !i) {
      const o = Q(t, !0);
      this.agLabel.textContent = o;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((r = s.getColGroupDef()) != null && r.suppressStickyLabel));
  }
  destroy() {
    super.destroy(), this.innerHeaderGroupComponent && (this.destroyBean(this.innerHeaderGroupComponent), this.innerHeaderGroupComponent = void 0);
  }
}, s0 = {
  moduleName: "ColumnHeaderComp",
  version: G,
  userComponents: {
    agColumnHeader: e0
  },
  icons: {
    // button to launch legacy column menu
    menu: "menu",
    // button to launch new enterprise column menu
    menuAlt: "menu-alt"
  }
}, i0 = {
  moduleName: "ColumnGroupHeaderComp",
  version: G,
  userComponents: {
    agColumnGroupHeader: t0
  },
  icons: {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted"
  }
}, r0 = {
  moduleName: "AnimationFrame",
  version: G,
  beans: [nw]
}, o0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "touchSvc";
  }
  mockBodyContextMenu(e, t) {
    this.mockContextMenu(e, e.eBodyViewport, t);
  }
  mockHeaderContextMenu(e, t) {
    this.mockContextMenu(e, e.eGui, t);
  }
  mockRowContextMenu(e) {
    if (!fs())
      return;
    const t = (s, i, r) => {
      var a;
      const { rowCtrl: o, cellCtrl: n } = e.getControlsForEventTarget((r == null ? void 0 : r.target) ?? null);
      (a = this.beans.contextMenuSvc) == null || a.handleContextMenuMouseEvent(void 0, r, o, n);
    };
    this.mockContextMenu(e, e.element, t);
  }
  handleCellDoubleClick(e, t) {
    return (() => {
      if (!fs() || qh("dblclick"))
        return !1;
      const i = (/* @__PURE__ */ new Date()).getTime(), r = i - e.lastIPadMouseClickEvent < 200;
      return e.lastIPadMouseClickEvent = i, r;
    })() ? (e.onCellDoubleClicked(t), t.preventDefault(), !0) : !1;
  }
  setupForHeader(e) {
    const { gos: t, sortSvc: s } = this.beans;
    if (t.get("suppressTouch"))
      return;
    const { params: i, eMenu: r, eFilterButton: o } = e, n = new hs(e.getGui(), !0), a = e.shouldSuppressMenuHide(), l = a && A(r), d = l ? new hs(r, !0) : n;
    if (i.enableMenu) {
      const c = l ? "tap" : "longTap", h = (u) => i.showColumnMenuAfterMouseClick(u.touchStart);
      e.addManagedListeners(d, { [c]: h });
    }
    if (i.enableSorting) {
      const c = (h) => {
        const u = h.touchStart.target;
        a && (r != null && r.contains(u) || o != null && o.contains(u)) || s == null || s.progressSort(i.column, !1, "uiColumnSorted");
      };
      e.addManagedListeners(n, { tap: c });
    }
    if (i.enableFilterButton && o) {
      const c = new hs(o, !0);
      e.addManagedListeners(c, {
        tap: () => i.showFilter(o)
      }), e.addDestroyFunc(() => c.destroy());
    }
    e.addDestroyFunc(() => n.destroy()), l && e.addDestroyFunc(() => d.destroy());
  }
  setupForHeaderGroup(e, t, s) {
    const i = new hs(t, !0);
    e.addManagedListeners(i, { tap: s }), e.addDestroyFunc(() => i.destroy());
  }
  mockContextMenu(e, t, s) {
    if (!fs())
      return;
    const i = new hs(t), r = (o) => {
      s(void 0, o.touchStart, o.touchEvent);
    };
    e.addManagedListeners(i, { longTap: r }), e.addDestroyFunc(() => i.destroy());
  }
}, n0 = {
  moduleName: "Touch",
  version: G,
  beans: [o0]
}, a0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "cellNavigation";
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, s = !1) {
    return s ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const s = e === w.UP, i = e === w.DOWN, r = e === w.LEFT;
    let o, n;
    const { pageBounds: a, gos: l, visibleCols: d } = this.beans;
    if (s || i)
      n = s ? a.getFirstRow() : a.getLastRow(), o = t.column;
    else {
      const c = d.allCols, h = l.get("enableRtl");
      n = t.rowIndex, o = r !== h ? c[0] : V(c);
    }
    return {
      rowIndex: n,
      rowPinned: null,
      column: o
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let s = t, i = !1;
    for (; !i; ) {
      switch (e) {
        case w.UP:
          s = this.getCellAbove(s);
          break;
        case w.DOWN:
          s = this.getCellBelow(s);
          break;
        case w.RIGHT:
          s = this.gos.get("enableRtl") ? this.getCellToLeft(s) : this.getCellToRight(s);
          break;
        case w.LEFT:
          s = this.gos.get("enableRtl") ? this.getCellToRight(s) : this.getCellToLeft(s);
          break;
        default:
          s = null, R(8, { key: e });
          break;
      }
      s ? i = this.isCellGoodToFocusOn(s) : i = !0;
    }
    return s;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let s;
    const { pinnedRowModel: i, rowModel: r } = this.beans;
    switch (e.rowPinned) {
      case "top":
        s = i == null ? void 0 : i.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        s = i == null ? void 0 : i.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        s = r.getRow(e.rowIndex);
        break;
    }
    return s ? !this.isSuppressNavigable(t, s) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, s = e.rowPinned;
    let i = !1;
    const { pageBounds: r, pinnedRowModel: o, rowModel: n } = this.beans;
    if (this.isLastRowInContainer(e))
      switch (s) {
        case "bottom":
          return null;
        case "top":
          return n.isRowsToRender() ? { rowIndex: r.getFirstRow(), rowPinned: null } : o != null && o.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return o != null && o.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    else s && (i = !0);
    const a = n.getRow(e.rowIndex), l = i ? void 0 : this.getNextStickyPosition(a);
    return l || { rowIndex: t + 1, rowPinned: s };
  }
  getNextStickyPosition(e, t) {
    const { gos: s, rowRenderer: i } = this.beans;
    if (!Xo(s) || !e || !e.sticky)
      return;
    const r = i.getStickyTopRowCtrls().some((d) => d.rowNode.rowIndex === e.rowIndex);
    let o = [];
    r ? o = [...i.getStickyTopRowCtrls()].sort(
      (d, c) => d.rowNode.rowIndex - c.rowNode.rowIndex
    ) : o = [...i.getStickyBottomRowCtrls()].sort(
      (d, c) => c.rowNode.rowIndex - d.rowNode.rowIndex
    );
    const n = t ? -1 : 1, a = o.findIndex((d) => d.rowNode.rowIndex === e.rowIndex), l = o[a + n];
    if (l)
      return { rowIndex: l.rowNode.rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, s = e.rowIndex, { pinnedRowModel: i, pageBounds: r } = this.beans;
    return t === "top" ? ((i == null ? void 0 : i.getPinnedTopRowCount()) ?? -1) <= s : t === "bottom" ? ((i == null ? void 0 : i.getPinnedBottomRowCount()) ?? -1) <= s : r.getLastRow() <= s;
  }
  getRowAbove(e) {
    const t = e.rowIndex, s = e.rowPinned, { pageBounds: i, pinnedRowModel: r, rowModel: o } = this.beans, n = s ? t === 0 : t === i.getFirstRow();
    let a = !1;
    const l = () => ({ rowIndex: (r == null ? void 0 : r.getPinnedTopRowCount()) ?? -1, rowPinned: "top" });
    if (n)
      return s === "top" ? null : s && o.isRowsToRender() ? { rowIndex: i.getLastRow(), rowPinned: null } : r != null && r.isRowsToRender("top") ? l() : null;
    s && (a = !0);
    const d = o.getRow(e.rowIndex), c = a ? void 0 : this.getNextStickyPosition(d, !0);
    return c || { rowIndex: t - 1, rowPinned: s };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    const { visibleCols: t, pagination: s } = this.beans, i = t.allCols;
    let r = e.rowIndex, o = e.rowPinned, n = t.getColAfter(e.column);
    if (!n) {
      n = i[0];
      const a = this.getRowBelow(e);
      if (Y(a) || !a.rowPinned && !((s == null ? void 0 : s.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: n, rowPinned: o };
  }
  getNextTabbedCellBackwards(e) {
    const { visibleCols: t, pagination: s } = this.beans, i = t.allCols;
    let r = e.rowIndex, o = e.rowPinned, n = t.getColBefore(e.column);
    if (!n) {
      n = V(i);
      const a = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (Y(a) || !a.rowPinned && !((s == null ? void 0 : s.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: n, rowPinned: o };
  }
  isSuppressNavigable(e, t) {
    const { suppressNavigable: s } = e.colDef;
    if (typeof s == "boolean")
      return s;
    if (typeof s == "function") {
      const i = e.createColumnFunctionCallbackParams(t);
      return s(i);
    }
    return !1;
  }
};
function l0(e) {
  return e.focusSvc.getFocusedCell();
}
function d0(e) {
  return e.focusSvc.clearFocusedCell();
}
function c0(e, t, s, i) {
  e.focusSvc.setFocusedCell({ rowIndex: t, column: s, rowPinned: i, forceBrowserFocus: !0 });
}
function h0(e, t) {
  var s;
  return ((s = e.navigation) == null ? void 0 : s.tabToNextCell(!1, t)) ?? !1;
}
function u0(e, t) {
  var s;
  return ((s = e.navigation) == null ? void 0 : s.tabToNextCell(!0, t)) ?? !1;
}
function p0(e, t, s = !1) {
  var r;
  const i = (r = e.headerNavigation) == null ? void 0 : r.getHeaderPositionForColumn(t, s);
  i && e.focusSvc.focusHeaderPosition({ headerPosition: i });
}
var g0 = class extends P {
  constructor() {
    super(), this.beanName = "navigation", this.onPageDown = Pd(this.onPageDown, 100), this.onPageUp = Pd(this.onPageUp, 100);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const s = e.key, i = e.altKey, r = e.ctrlKey || e.metaKey, o = !!this.beans.rangeSvc && e.shiftKey, n = ku(this.gos, e);
    let a = !1;
    switch (s) {
      case w.PAGE_HOME:
      case w.PAGE_END:
        !r && !i && (this.onHomeOrEndKey(s), a = !0);
        break;
      case w.LEFT:
      case w.RIGHT:
      case w.UP:
      case w.DOWN:
        if (!n)
          return !1;
        r && !i && !o && (this.onCtrlUpDownLeftRight(s, n), a = !0);
        break;
      case w.PAGE_DOWN:
      case w.PAGE_UP:
        !r && !i && (a = this.handlePageUpDown(s, n, t));
        break;
    }
    return a && e.preventDefault(), a;
  }
  handlePageUpDown(e, t, s) {
    return s && (t = this.beans.focusSvc.getFocusedCell()), t ? (e === w.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    const { scrollIndex: t, scrollType: s, scrollColumn: i, focusIndex: r, focusColumn: o } = e, { scrollFeature: n } = this.gridBodyCon;
    A(i) && !i.isPinned() && n.ensureColumnVisible(i), A(t) && n.ensureIndexVisible(t, s), e.isAsync || n.ensureIndexVisible(r);
    const { focusSvc: a, rangeSvc: l } = this.beans;
    a.setFocusedCell({
      rowIndex: r,
      column: o,
      rowPinned: null,
      forceBrowserFocus: !0
    }), l == null || l.setRangeToCell({ rowIndex: r, rowPinned: null, column: o });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const t = this.beans, s = $n(t), i = this.getViewportHeight(), { pageBounds: r, rowModel: o, rowAutoHeight: n } = t, a = r.getPixelOffset(), l = s.top + i, d = o.getRowIndexAtPixel(l + a);
    n != null && n.active ? this.navigateToNextPageWithAutoHeight(e, d) : this.navigateToNextPage(e, d);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const t = this.beans, s = $n(t), { pageBounds: i, rowModel: r, rowAutoHeight: o } = t, n = i.getPixelOffset(), a = s.top, l = r.getRowIndexAtPixel(a + n);
    o != null && o.active ? this.navigateToNextPageWithAutoHeight(e, l, !0) : this.navigateToNextPage(e, l, !0);
  }
  navigateToNextPage(e, t, s = !1) {
    const { pageBounds: i, rowModel: r } = this.beans, o = this.getViewportHeight(), n = i.getFirstRow(), a = i.getLastRow(), l = i.getPixelOffset(), d = r.getRow(e.rowIndex), c = s ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (d == null ? void 0 : d.rowHeight) - o - l
    ) : o - l, h = (d == null ? void 0 : d.rowTop) + c;
    let u = r.getRowIndexAtPixel(h + l);
    if (u === e.rowIndex) {
      const g = s ? -1 : 1;
      t = u = e.rowIndex + g;
    }
    let p;
    s ? (p = "bottom", u < n && (u = n), t < n && (t = n)) : (p = "top", u > a && (u = a), t > a && (t = a)), this.isRowTallerThanView(r.getRow(u)) && (t = u, p = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: p,
      scrollColumn: null,
      focusIndex: u,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, s = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: s ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const i = this.getNextFocusIndexForAutoHeight(e, s);
      this.navigateTo({
        scrollIndex: t,
        scrollType: s ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: i,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const s = t ? -1 : 1, i = this.getViewportHeight(), { pageBounds: r, rowModel: o } = this.beans, n = r.getLastRow();
    let a = 0, l = e.rowIndex;
    for (; l >= 0 && l <= n; ) {
      const d = o.getRow(l);
      if (d) {
        const c = d.rowHeight ?? 0;
        if (a + c > i)
          break;
        a += c;
      }
      l += s;
    }
    return Math.max(0, Math.min(l, n));
  }
  getViewportHeight() {
    const e = this.beans, t = $n(e), s = this.beans.scrollVisibleSvc.getScrollbarWidth();
    let i = t.bottom - t.top;
    return e.ctrlsSvc.get("center").isHorizontalScrollShowing() && (i -= s), i;
  }
  isRowTallerThanView(e) {
    if (!e)
      return !1;
    const t = e.rowHeight;
    return typeof t != "number" ? !1 : t > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const s = this.beans.cellNavigation.getNextCellToFocus(e, t, !0), { rowIndex: i } = s, r = s.column;
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: r,
      focusIndex: i,
      focusColumn: r
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === w.PAGE_HOME, { visibleCols: s, pageBounds: i } = this.beans, r = s.allCols, o = t ? r[0] : V(r), n = t ? i.getFirstRow() : i.getLastRow();
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: o,
      focusIndex: n,
      focusColumn: o
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const s = t.shiftKey, i = this.tabToNextCellCommon(e, s, t), r = this.beans, { ctrlsSvc: o, pageBounds: n, focusSvc: a, gos: l } = r;
    if (i !== !1) {
      i ? t.preventDefault() : i === null && o.get("gridCtrl").allowFocusForNextCoreContainer(s);
      return;
    }
    if (s) {
      const { rowIndex: d, rowPinned: c } = e.getRowPosition();
      (c ? d === 0 : d === n.getFirstRow()) && (l.get("headerHeight") === 0 || mi(r) ? Xt(r, !0, !0) : (t.preventDefault(), a.focusPreviousFromFirstCell(t)));
    } else
      e instanceof so && e.focusCell(!0), (!s && a.focusOverlay(!1) || Xt(r, s)) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const s = this.beans, { focusSvc: i, rowRenderer: r } = s, o = i.getFocusedCell();
    if (!o)
      return !1;
    let n = It(s, o);
    return !n && (n = r.getRowByPosition(o), !n || !n.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(n, e, t);
  }
  tabToNextCellCommon(e, t, s) {
    let i = e.editing;
    if (!i && e instanceof so) {
      const n = e.rowCtrl;
      n && (i = n.editing);
    }
    let r;
    return i ? this.gos.get("editType") === "fullRow" ? r = this.moveToNextEditingRow(e, t, s) : r = this.moveToNextEditingCell(e, t, s) : r = this.moveToNextCellNotEditing(e, t), r === null ? r : r || !!this.beans.focusSvc.focusedHeader;
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, s = null) {
    var o;
    const i = e.cellPosition;
    e.eGui.focus(), e.stopEditing();
    const r = this.findNextCellToFocusOn(i, t, !0);
    return r === !1 ? null : r == null ? !1 : ((o = this.beans.editSvc) == null || o.startEditing(r, null, !0, s), r.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, s = null) {
    const i = e.cellPosition, r = this.findNextCellToFocusOn(i, t, !0);
    if (r === !1)
      return null;
    if (r == null)
      return !1;
    const o = r.cellPosition, n = this.isCellEditable(i), a = this.isCellEditable(o), l = o && i.rowIndex === o.rowIndex && i.rowPinned === o.rowPinned, { editSvc: d, rowEditSvc: c } = this.beans;
    if (n && (d == null || d.setFocusOutOnEditor(e)), !l) {
      const h = e.rowCtrl;
      d == null || d.stopRowEditing(h);
      const u = r.rowCtrl;
      c == null || c.startEditing(u, void 0, void 0, s);
    }
    return a ? (d == null || d.setFocusInOnEditor(r), r.focusCell()) : r.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t) {
    const s = this.beans.visibleCols.allCols;
    let i;
    e instanceof ba ? i = {
      ...e.getRowPosition(),
      column: t ? s[0] : V(s)
    } : i = e.cellPosition;
    const r = this.findNextCellToFocusOn(i, t, !1);
    if (r === !1)
      return null;
    if (r instanceof so)
      r.focusCell(!0);
    else if (r)
      return this.tryToFocusFullWidthRow(r.getRowPosition(), t);
    return A(r);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, s) {
    let i = e;
    const r = this.beans, { cellNavigation: o, gos: n, focusSvc: a, rowRenderer: l, rangeSvc: d } = r;
    for (; ; ) {
      e !== i && (e = i), t || (i = this.getLastCellOfColSpan(i)), i = o.getNextTabbedCell(i, t);
      const c = n.getCallback("tabToNextCell");
      if (A(c)) {
        const g = c({
          backwards: t,
          editing: s,
          previousCellPosition: e,
          nextCellPosition: i || null
        });
        if (g === !0)
          i = e;
        else {
          if (g === !1)
            return !1;
          i = {
            rowIndex: g.rowIndex,
            column: g.column,
            rowPinned: g.rowPinned
          };
        }
      }
      if (!i)
        return null;
      if (i.rowIndex < 0) {
        const p = Kt(r);
        return a.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: p + i.rowIndex,
            column: i.column
          },
          fromCell: !0
        }), null;
      }
      const h = n.get("editType") === "fullRow";
      if (s && !h && !this.isCellEditable(i))
        continue;
      this.ensureCellVisible(i);
      const u = It(r, i);
      if (!u) {
        const p = l.getRowByPosition(i);
        if (!p || !p.isFullWidth() || s)
          continue;
        return p;
      }
      if (!o.isSuppressNavigable(u.column, u.rowNode))
        return d == null || d.setRangeToCell(i), u;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  lookupRowNodeForCell({ rowIndex: e, rowPinned: t }) {
    const { pinnedRowModel: s, rowModel: i } = this.beans;
    return t === "top" ? s == null ? void 0 : s.getPinnedTopRow(e) : t === "bottom" ? s == null ? void 0 : s.getPinnedBottomRow(e) : i.getRow(e);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, s, i) {
    let r = s, o = !1;
    const n = this.beans, { cellNavigation: a, focusSvc: l, gos: d } = n;
    for (; r && (r === s || !this.isValidNavigateCell(r)); )
      d.get("enableRtl") ? t === w.LEFT && (r = this.getLastCellOfColSpan(r)) : t === w.RIGHT && (r = this.getLastCellOfColSpan(r)), r = a.getNextCellToFocus(t, r), o = Y(r);
    if (o && e && e.key === w.UP && (r = {
      rowIndex: -1,
      rowPinned: null,
      column: s.column
    }), i) {
      const h = d.getCallback("navigateToNextCell");
      if (A(h)) {
        const p = h({
          key: t,
          previousCellPosition: s,
          nextCellPosition: r || null,
          event: e
        });
        A(p) ? r = {
          rowPinned: p.rowPinned,
          rowIndex: p.rowIndex,
          column: p.column
        } : r = null;
      }
    }
    if (!r)
      return;
    if (r.rowIndex < 0) {
      const h = Kt(n);
      l.focusHeaderPosition({
        headerPosition: { headerRowIndex: h + r.rowIndex, column: s.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const c = this.getNormalisedPosition(r);
    c ? this.focusPosition(c) : this.tryToFocusFullWidthRow(r);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = It(this.beans, e);
    return t ? (e = t.cellPosition, this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t) {
    const { visibleCols: s, rowRenderer: i, focusSvc: r, eventSvc: o } = this.beans, n = s.allCols, a = i.getRowByPosition(e);
    if (!a || !a.isFullWidth())
      return !1;
    const l = r.getFocusedCell(), d = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? V(n) : n[0])
    };
    this.focusPosition(d);
    const c = t ?? (l != null && Me(d, l));
    return o.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: d.rowIndex,
      rowPinned: d.rowPinned,
      column: d.column,
      isFullWidthCell: !0,
      fromBelow: c
    }), !0;
  }
  focusPosition(e) {
    const { focusSvc: t, rangeSvc: s } = this.beans;
    t.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), s == null || s.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!St(this.beans, e);
  }
  getLastCellOfColSpan(e) {
    const t = It(this.beans, e);
    if (!t)
      return e;
    const s = t.getColSpanningList();
    return s.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: V(s),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = Xo(this.gos), s = this.beans.rowModel.getRow(e.rowIndex), i = t && (s == null ? void 0 : s.sticky), { scrollFeature: r } = this.gridBodyCon;
    !i && Y(e.rowPinned) && r.ensureIndexVisible(e.rowIndex), e.column.isPinned() || r.ensureColumnVisible(e.column);
  }
};
function $n(e) {
  return e.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
var cn = {
  moduleName: "KeyboardNavigation",
  version: G,
  beans: [g0, a0, _x],
  apiFunctions: {
    getFocusedCell: l0,
    clearFocusedCell: d0,
    setFocusedCell: c0,
    setFocusedHeader: p0,
    tabToNextCell: h0,
    tabToPreviousCell: u0
  }
}, f0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages(), this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: (e == null ? void 0 : e.animate) ?? !1,
      newData: (e == null ? void 0 : e.newData) ?? !1,
      newPage: (e == null ? void 0 : e.newPage) ?? !1,
      newPageSize: (e == null ? void 0 : e.newPageSize) ?? !1,
      keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? !1
    });
  }
  calculatePages() {
    const { pageBounds: e, pagination: t, rowModel: s } = this.beans;
    t ? t.calculatePages() : e.calculateBounds(0, s.getRowCount() - 1);
  }
}, m0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pageBounds", this.pixelOffset = 0;
  }
  getFirstRow() {
    var e;
    return ((e = this.topRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getLastRow() {
    var e;
    return ((e = this.bottomRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getCurrentPageHeight() {
    const { topRowBounds: e, bottomRowBounds: t } = this;
    return !e || !t ? 0 : Math.max(t.rowTop + t.rowHeight - e.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const { topRowBounds: e, bottomRowBounds: t } = this, s = (e == null ? void 0 : e.rowTop) ?? 0, i = t ? t.rowTop + t.rowHeight : 0;
    return { pageFirstPixel: s, pageLastPixel: i };
  }
  calculateBounds(e, t) {
    const { rowModel: s } = this.beans, i = s.getRowBounds(e);
    i && (i.rowIndex = e), this.topRowBounds = i;
    const r = s.getRowBounds(t);
    r && (r.rowIndex = t), this.bottomRowBounds = r, this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    var t;
    const e = ((t = this.topRowBounds) == null ? void 0 : t.rowTop) ?? 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, C0 = (
  /*css*/
  ".ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{display:inline-block;min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}"
), v0 = class extends P {
  constructor(e, t) {
    super(), this.element = e, this.isLeft = t, this.getWidth = t ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
  }
  postConstruct() {
    this.addManagedEventListeners({
      [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this)
    });
  }
  onPinnedWidthChanged() {
    const e = this.getWidth(), t = e > 0;
    O(this.element, t), yt(this.element, e);
  }
}, w0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pinnedCols";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (t) => {
      this.gridBodyCtrl = t.gridBodyCtrl;
    });
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const { gos: e, visibleCols: t, eventSvc: s } = this.beans, i = ye(e, "print"), r = i ? 0 : t.getColsLeftWidth(), o = i ? 0 : t.getDisplayedColumnsRightWidth();
    r != this.leftWidth && (this.leftWidth = r, s.dispatchEvent({ type: "leftPinnedWidthChanged" })), o != this.rightWidth && (this.rightWidth = o, s.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.eBodyViewport, t = yi(e);
    if (t <= 50)
      return;
    let s = this.getPinnedColumnsOverflowingViewport(t - 50);
    const i = this.gos.getCallback("processUnpinnedColumns");
    s.length && (i && (s = i({
      columns: s,
      viewportWidth: t
    })), this.setColsPinned(s, null, "viewportSizeFeature"));
  }
  createPinnedWidthFeature(e, t) {
    return new v0(e, t);
  }
  setColsPinned(e, t, s) {
    const { colModel: i, colAnimation: r, visibleCols: o, gos: n } = this.beans;
    if (!i.cols || !(e != null && e.length))
      return;
    if (ye(n, "print")) {
      R(37);
      return;
    }
    r == null || r.start();
    let a;
    t === !0 || t === "left" ? a = "left" : t === "right" ? a = "right" : a = null;
    const l = [];
    e.forEach((d) => {
      if (!d)
        return;
      const c = i.getCol(d);
      c && c.getPinned() !== a && (this.setColPinned(c, a), l.push(c));
    }), l.length && (o.refresh(s), su(this.eventSvc, l, s)), r == null || r.finish();
  }
  initCol(e) {
    const { pinned: t, initialPinned: s } = e.colDef;
    t !== void 0 ? this.setColPinned(e, t) : this.setColPinned(e, s);
  }
  setColPinned(e, t) {
    t === !0 || t === "left" ? e.pinned = "left" : t === "right" ? e.pinned = "right" : e.pinned = null, e.dispatchStateUpdatedEvent("pinned");
  }
  setupHeaderPinnedWidth(e) {
    const { scrollVisibleSvc: t } = this.beans;
    if (e.pinned == null)
      return;
    const s = e.pinned === "left", i = e.pinned === "right";
    e.hidden = !0;
    const r = () => {
      const o = s ? this.leftWidth : this.rightWidth;
      if (o == null)
        return;
      const n = o == 0, a = e.hidden !== n, l = this.gos.get("enableRtl"), d = t.getScrollbarWidth(), h = t.verticalScrollShowing && (l && s || !l && i) ? o + d : o;
      e.comp.setPinnedContainerWidth(`${h}px`), e.comp.setDisplayed(!n), a && (e.hidden = n, e.refresh());
    };
    e.addManagedEventListeners({
      leftPinnedWidthChanged: r,
      rightPinnedWidthChanged: r,
      scrollVisibilityChanged: r,
      scrollbarWidthChanged: r
    });
  }
  getHeaderResizeDiff(e, t) {
    if (t.getPinned()) {
      const { leftWidth: i, rightWidth: r } = this, o = yi(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (i + r + e > o)
        if (o > i + r)
          e = o - i - r;
        else
          return 0;
    }
    return e;
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.rightWidth ?? 0, s = this.leftWidth ?? 0, i = t + s;
    if (i < e)
      return [];
    const { visibleCols: r } = this.beans, o = [...r.leftCols], n = [...r.rightCols];
    let a = 0, l = 0;
    const d = 0, c = [];
    let h = i - d - e;
    for (; (l < o.length || a < n.length) && h > 0; ) {
      if (a < n.length) {
        const u = n[a++];
        h -= u.getActualWidth(), c.push(u);
      }
      if (l < o.length && h > 0) {
        const u = o[l++];
        h -= u.getActualWidth(), c.push(u);
      }
    }
    return c;
  }
}, y0 = {
  moduleName: "PinnedColumn",
  version: G,
  beans: [w0],
  css: [C0]
}, b0 = class extends P {
  constructor() {
    super(), this.beanName = "ariaAnnounce", this.descriptionContainer = null, this.pendingAnnouncements = /* @__PURE__ */ new Map(), this.lastAnnouncement = "", this.updateAnnouncement = Ce(this, this.updateAnnouncement.bind(this), 200);
  }
  postConstruct() {
    const e = this.beans, t = Z(e), s = this.descriptionContainer = t.createElement("div");
    s.classList.add("ag-aria-description-container"), gh(s, "polite"), lC(s, "additions text"), aC(s, !0), e.eGridDiv.appendChild(s);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(e, t) {
    this.pendingAnnouncements.set(t, e), this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer)
      return;
    const e = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear(), this.descriptionContainer.textContent = "", setTimeout(() => {
      if (this.isAlive() && this.descriptionContainer) {
        let t = e;
        this.lastAnnouncement === t && (t = `${t}.`), this.lastAnnouncement = t, this.descriptionContainer.textContent = t;
      }
    }, 50);
  }
  destroy() {
    var t;
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (X(e), (t = e.parentElement) == null || t.removeChild(e)), this.descriptionContainer = null, this.pendingAnnouncements.clear();
  }
}, S0 = {
  moduleName: "Aria",
  version: G,
  beans: [b0]
};
function x0(e) {
  var t;
  (t = e.overlays) == null || t.showLoadingOverlay();
}
function F0(e) {
  var t;
  (t = e.overlays) == null || t.showNoRowsOverlay();
}
function R0(e) {
  var t;
  (t = e.overlays) == null || t.hideOverlay();
}
var P0 = (
  /*css*/
  ".ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}"
), Ip = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`
    ), this.eOverlayWrapper = S, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeCssClass = null, this.elToFocusAfter = null, this.registerCSS(P0);
  }
  handleKeyDown(e) {
    if (e.key !== w.TAB || e.defaultPrevented || nt(e))
      return;
    const t = this.beans;
    if (Pe(t, this.eOverlayWrapper, !1, e.shiftKey))
      return;
    let i = !1;
    e.shiftKey ? i = t.focusSvc.focusGridView(V(t.visibleCols.allCols), !0, !1) : i = Xt(t, !1), i && e.preventDefault();
  }
  updateLayoutClasses(e, t) {
    const s = this.eOverlayWrapper.classList, { AUTO_HEIGHT: i, NORMAL: r, PRINT: o } = vt;
    s.toggle(i, t.autoHeight), s.toggle(r, t.normal), s.toggle(o, t.print);
  }
  postConstruct() {
    this.createManagedBean(new yl(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.beans.overlays.setOverlayWrapperComp(this), this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeCssClass && t.toggle(this.activeCssClass, !1), this.activeCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, s, i) {
    if (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.elToFocusAfter = null, this.activePromise = e, !!e) {
      if (this.setDisplayed(!0, { skipAriaHidden: !0 }), s && this.isGridFocused()) {
        const r = q(this.beans);
        r && !ys(this.beans) && (this.elToFocusAfter = r);
      }
      e.then((r) => {
        if (this.activePromise !== e) {
          this.activeOverlay !== r && (this.destroyBean(r), r = null);
          return;
        }
        if (this.activePromise = null, !!r) {
          if (this.activeOverlay !== r && (this.eOverlayWrapper.appendChild(r.getGui()), this.activeOverlay = r, i)) {
            const o = r;
            this.updateListenerDestroyFunc = this.addManagedPropertyListener(i, ({ currentValue: n }) => {
              var a;
              (a = o.refresh) == null || a.call(o, this.gos.addGridCommonParams({ ...n ?? {} }));
            });
          }
          s && this.isGridFocused() && ve(this.eOverlayWrapper);
        }
      });
    }
  }
  updateOverlayWrapperPaddingTop(e) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${e}px`);
  }
  destroyActiveOverlay() {
    var i;
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    let t = this.elToFocusAfter;
    this.activeOverlay = null, this.elToFocusAfter = null, t && !this.isGridFocused() && (t = null);
    const s = this.updateListenerDestroyFunc;
    s && (s(), this.updateListenerDestroyFunc = null), this.destroyBean(e), X(this.eOverlayWrapper), (i = t == null ? void 0 : t.focus) == null || i.call(t, { preventScroll: !0 });
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  isGridFocused() {
    const e = q(this.beans);
    return !!e && this.beans.eGridDiv.contains(e);
  }
  destroy() {
    this.elToFocusAfter = null, this.destroyActiveOverlay(), this.beans.overlays.setOverlayWrapperComp(void 0), super.destroy();
  }
}, T0 = {
  selector: "AG-OVERLAY-WRAPPER",
  component: Ip
}, D0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "overlays", this.state = 0, this.showInitialOverlay = !0, this.wrapperPadding = 0;
  }
  postConstruct() {
    this.isClientSide = J(this.gos);
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e,
      gridSizeChanged: this.refreshWrapperPadding.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = !1, this.updateOverlayVisibility();
      }
    }), this.addManagedPropertyListener("loading", e);
  }
  setOverlayWrapperComp(e) {
    this.eWrapper = e, this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 && !!this.eWrapper;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 && !!this.eWrapper;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos, t = e.get("loading");
    !t && (t !== void 0 || e.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos;
    e.get("loading") || e.get("suppressNoRowsOverlay") || this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    if (this.showInitialOverlay = !1, this.gos.get("loading")) {
      R(99);
      return;
    }
    this.doHideOverlay();
  }
  getOverlayWrapperSelector() {
    return T0;
  }
  getOverlayWrapperCompClass() {
    return Ip;
  }
  updateOverlayVisibility() {
    if (!this.eWrapper) {
      this.state = 0;
      return;
    }
    const {
      state: e,
      isClientSide: t,
      beans: { gos: s, colModel: i, rowModel: r }
    } = this;
    let o = this.gos.get("loading");
    o !== void 0 && (this.showInitialOverlay = !1), this.showInitialOverlay && o === void 0 && !s.get("suppressLoadingOverlay") && (o = !s.get("columnDefs") || !i.ready || !s.get("rowData") && t), o ? e !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, r.isEmpty() && !s.get("suppressNoRowsOverlay") && t ? e !== 2 && this.doShowNoRowsOverlay() : e !== 0 && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.eWrapper && (this.state = 1, this.showOverlay(
      Uv(this.beans.userCompFactory, {}),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    ), this.updateExclusive());
  }
  doShowNoRowsOverlay() {
    this.eWrapper && (this.state = 2, this.showOverlay(
      Kv(this.beans.userCompFactory, {}),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    ), this.updateExclusive());
  }
  doHideOverlay() {
    this.eWrapper && (this.state = 0, this.eWrapper.hideOverlay(), this.updateExclusive());
  }
  showOverlay(e, t, s) {
    var r;
    const i = (e == null ? void 0 : e.newAgStackInstance()) ?? null;
    (r = this.eWrapper) == null || r.showOverlay(i, t, this.isExclusive(), s), this.refreshWrapperPadding();
  }
  updateExclusive() {
    const e = this.exclusive;
    this.exclusive = this.isExclusive(), this.exclusive !== e && this.eventSvc.dispatchEvent({
      type: "overlayExclusiveChanged"
    });
  }
  refreshWrapperPadding() {
    const e = this.eWrapper;
    if (!e)
      return;
    let t = 0;
    if (this.state === 2) {
      const s = this.beans.ctrlsSvc.get("gridHeaderCtrl");
      t = (s == null ? void 0 : s.headerHeight) || 0;
    } else this.wrapperPadding !== 0 && (t = 0);
    this.wrapperPadding !== t && (this.wrapperPadding = t, e.updateOverlayWrapperPaddingTop(t));
  }
}, E0 = {
  moduleName: "Overlay",
  version: G,
  userComponents: {
    agLoadingOverlay: by,
    agNoRowsOverlay: Sy
  },
  apiFunctions: {
    showLoadingOverlay: x0,
    showNoRowsOverlay: F0,
    hideOverlay: R0
  },
  beans: [D0]
}, M0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeight", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = gC(), ws(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top, t = this.getUiBodyHeight();
    (e !== this.scrollY || t !== this.uiBodyHeight) && (this.scrollY = e, this.uiBodyHeight = t, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    ws(
      this.gos,
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventSvc.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
    return e.bottom - e.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), s = e / t;
    return this.maxScrollY * s;
  }
}, A0 = 400, I0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((o) => o.onCellSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((o) => o.updateRangeBordersIfRangeCount());
      }, s = () => {
        this.eventSvc.addEventListener("cellSelectionChanged", e), this.eventSvc.addEventListener("columnMoved", t), this.eventSvc.addEventListener("columnPinned", t), this.eventSvc.addEventListener("columnVisible", t);
      }, i = () => {
        this.eventSvc.removeEventListener("cellSelectionChanged", e), this.eventSvc.removeEventListener("columnMoved", t), this.eventSvc.removeEventListener("columnPinned", t), this.eventSvc.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => i()), this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        Ve(this.gos) ? s() : i();
      }), Ve(this.gos) && s();
    };
  }
  wireBeans(e) {
    this.pageBounds = e.pageBounds, this.colModel = e.colModel, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusSvc = e.focusSvc, this.rowContainerHeight = e.rowContainerHeight, this.ctrlsSvc = e.ctrlsSvc;
  }
  postConstruct() {
    this.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListener("suppressCellFocus", (s) => this.onSuppressCellFocusChanged(s.currentValue)), this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    ), this.addManagedPropertyListener("cellSelection", ({ currentValue: s, previousValue: i }) => {
      (!i && s || i && !s) && this.redrawRows();
    });
    const { stickyRowSvc: e, gos: t } = this.beans;
    if (e)
      this.stickyRowFeature = e.createStickyRowFeature(
        this,
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      );
    else {
      const s = this.gridBodyCtrl;
      s.setStickyTopHeight(0), s.setStickyBottomHeight(0);
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = ye(t, "print"), this.embedFullWidthRows = this.printLayout || t.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new L0(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyTopRowCtrls) ?? [];
  }
  getStickyBottomRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyBottomRowCtrls) ?? [];
  }
  updateAllRowCtrls() {
    var i;
    const e = Object.values(this.rowCtrlsByRowIndex), t = Object.values(this.zombieRowCtrls), s = ((i = this.cachedRowCtrls) == null ? void 0 : i.getEntries()) ?? [];
    t.length > 0 || s.length > 0 ? this.allRowCtrls = [...e, ...t, ...s] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  onSuppressCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)), this.getFullWidthRowCtrls().forEach((t) => t.onSuppressCellFocusChanged(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => {
        this.onCellFocusChanged(e);
      },
      cellFocusCleared: () => this.onCellFocusChanged(),
      flashCells: (e) => {
        const { cellFlashSvc: t } = this.beans;
        t && this.getAllCellCtrls().forEach((s) => t.onFlashCells(s, e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.colModel.getCols().forEach((t) => {
      const s = (l) => {
        this.getAllCellCtrls().forEach((d) => {
          d.column === t && l(d);
        });
      }, i = () => {
        s((l) => l.onLeftChanged());
      }, r = () => {
        s((l) => l.onWidthChanged());
      }, o = () => {
        s((l) => l.onFirstRightPinnedChanged());
      }, n = () => {
        s((l) => l.onLastLeftPinnedChanged());
      }, a = () => {
        s((l) => l.onColDefChanged());
      };
      t.addEventListener("leftChanged", i), t.addEventListener("widthChanged", r), t.addEventListener("firstRightPinnedChanged", o), t.addEventListener("lastLeftPinnedChanged", n), t.addEventListener("colDefChanged", a), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", i), t.removeEventListener("widthChanged", r), t.removeEventListener("firstRightPinnedChanged", o), t.removeEventListener("lastLeftPinnedChanged", n), t.removeEventListener("colDefChanged", a);
      });
    });
  }
  onDomLayoutChanged() {
    const e = ye(this.gos, "print"), t = e || this.gos.get("embedFullWidthRows"), s = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, s && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  /**
   * @param column AgColumn
   * @returns An array with HTMLElement for every cell of the column passed as param.
   * If the cell is spanning across multiple columns, it only returns the html element
   * if the column passed is the first column of the span (used for auto width calculation).
   */
  getAllCellsNotSpanningForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((s) => {
      var r;
      const i = (r = s.getCellCtrl(e, !0)) == null ? void 0 : r.eGui;
      i && t.push(i);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, "top"), this.refreshFloatingRows(this.bottomRowCtrls, "bottom");
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t) {
    const { pinnedRowModel: s, beans: i, printLayout: r } = this, o = Object.fromEntries(e.map((a) => [a.rowNode.id, a]));
    s == null || s.forEachPinnedRow(t, (a, l) => {
      const d = e[l];
      d && s.getPinnedRowById(d.rowNode.id, t) === void 0 && (d.destroyFirstPass(), d.destroySecondPass()), a.id in o ? (e[l] = o[a.id], delete o[a.id]) : e[l] = new ba(a, i, !1, !1, r);
    });
    const n = (t === "top" ? s == null ? void 0 : s.getPinnedTopRowCount() : s == null ? void 0 : s.getPinnedBottomRowCount()) ?? 0;
    e.length = n;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = !1) {
    var s, i;
    if (e.sticky)
      (s = this.stickyRowFeature) == null || s.refreshStickyNode(e);
    else if ((i = this.cachedRowCtrls) != null && i.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const r = (o) => {
        const n = o[e.rowIndex];
        n && n.rowNode === e && (n.destroyFirstPass(), n.destroySecondPass(), o[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          r(this.topRowCtrls);
          break;
        case "bottom":
          r(this.bottomRowCtrls);
          break;
        default:
          r(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((s) => this.redrawRow(s, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusSvc.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const s = q(this.beans), i = Co(this.gos, s, Po), r = Co(this.gos, s, mr);
    return i || r ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const s = !e.domLayoutChanged && !!e.recycleRows, i = e.animate && fi(this.gos), r = s ? this.getRowsToRecycle() : null;
    s || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender();
    const { stickyRowFeature: o } = this;
    if (o) {
      o.checkStickyRows();
      const n = o.extraTopHeight + o.extraBottomHeight;
      n && this.updateContainerHeights(n);
    }
    this.recycleRows(r, i), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var i;
    const t = e.newData || e.newPage, s = this.gos.get("suppressScrollOnNewData");
    t && !s && (this.gridBodyCtrl.scrollFeature.scrollToTop(), (i = this.stickyRowFeature) == null || i.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    const { rowContainerHeight: t } = this;
    if (this.printLayout) {
      t.setModelHeight(null);
      return;
    }
    let s = this.pageBounds.getCurrentPageHeight();
    s === 0 && (s = 1), t.setModelHeight(s + e);
  }
  getLockOnRefresh() {
    var e, t;
    if (this.refreshInProgress)
      throw new Error(ut(252));
    this.refreshInProgress = !0, (t = (e = this.beans.frameworkOverrides).getLockOnRefresh) == null || t.call(e);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.beans.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && this.focusSvc.restoreFocusedCell(e, () => {
      this.onCellFocusChanged(
        this.gos.addGridCommonParams({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          type: "cellFocused"
        })
      );
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), s = t.length;
    for (let i = 0; i < s; i++) {
      const r = t[i].getAllCellCtrls(), o = r.length;
      for (let n = 0; n < o; n++)
        e.push(r[n]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.getStickyTopRowCtrls(), t = this.getStickyBottomRowCtrls();
    return [
      ...this.topRowCtrls,
      ...this.bottomRowCtrls,
      ...e,
      ...t,
      ...Object.values(this.rowCtrlsByRowIndex)
    ];
  }
  addRenderedRowListener(e, t, s) {
    const i = this.rowCtrlsByRowIndex[t];
    i && i.addEventListener(e, s);
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    for (const s of this.getCellCtrls(e.rowNodes, e.columns))
      s.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = null;
    this.stickyRowFeature && (t = this.getCellToRestoreFocusToAfterRefresh() || null);
    for (const s of this.getRowCtrls(e)) {
      if (!s.isFullWidth())
        continue;
      s.refreshFullWidth() || this.redrawRow(s.rowNode, !0);
    }
    this.dispatchDisplayedRowsChanged(!1), t && this.restoreFocusedCell(t);
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = Ea(e), s = this.getAllRowCtrls();
    return !e || !t ? s : s.filter((i) => {
      const r = i.rowNode;
      return Ma(r, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let s;
    A(t) && (s = {}, t.forEach((r) => {
      const o = this.colModel.getCol(r);
      A(o) && (s[o.getId()] = !0);
    }));
    const i = [];
    return this.getRowCtrls(e).forEach((r) => {
      r.getAllCellCtrls().forEach((o) => {
        const n = o.column.getId();
        s && !s[n] || i.push(o);
      });
    }), i;
  }
  destroy() {
    this.removeAllRowComps(!0), super.destroy();
  }
  removeAllRowComps(e = !1) {
    var s;
    const t = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(t, e), (s = this.stickyRowFeature) == null || s.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    for (const [s, i] of Object.entries(this.rowCtrlsByRowIndex))
      i.rowNode.id == null && e.push(s);
    this.removeRowCtrls(e);
    const t = {};
    for (const s of Object.values(this.rowCtrlsByRowIndex)) {
      const i = s.rowNode;
      t[i.id] = s;
    }
    return this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((s) => {
      const i = this.rowCtrlsByRowIndex[s];
      i && (i.destroyFirstPass(t), i.destroySecondPass()), delete this.rowCtrlsByRowIndex[s];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    var l;
    const { afterScroll: t } = e;
    let s;
    const i = this.stickyRowFeature;
    i && (s = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const r = this.firstRenderedRow, o = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let n = !1;
    if (i) {
      n = i.checkStickyRows();
      const d = i.extraTopHeight + i.extraBottomHeight;
      d && this.updateContainerHeights(d);
    }
    const a = this.firstRenderedRow !== r || this.lastRenderedRow !== o;
    if (!(t && !n && !a) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !n), s != null)) {
      const d = this.getCellToRestoreFocusToAfterRefresh();
      s != null && d == null && ((l = this.beans.animationFrameSvc) == null || l.flushAllFrames(), this.restoreFocusedCell(s));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const s = {};
    e.forEach((o) => s[o] = !0);
    const r = Object.keys(this.rowCtrlsByRowIndex).filter((o) => !s[o]);
    this.removeRowCtrls(r, t);
  }
  calculateIndexesToDraw(e) {
    const t = [];
    for (let r = this.firstRenderedRow; r <= this.lastRenderedRow; r++)
      t.push(r);
    const s = (r) => {
      const o = r.rowNode.rowIndex;
      o != null && (o < this.firstRenderedRow || o > this.lastRenderedRow) && this.doNotUnVirtualiseRow(r) && t.push(o);
    };
    for (const r of Object.values(this.rowCtrlsByRowIndex))
      s(r);
    if (e)
      for (const r of Object.values(e))
        s(r);
    t.sort((r, o) => r - o);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r], n = this.rowModel.getRow(o);
      n && !n.sticky && i.push(o);
    }
    return i;
  }
  recycleRows(e, t = !1, s = !1) {
    const i = this.calculateIndexesToDraw(e);
    if ((this.printLayout || s) && (t = !1), this.removeRowCompsNotToDraw(i, !t), i.forEach((r) => {
      this.createOrUpdateRowCtrl(r, e, t, s);
    }), e) {
      const { animationFrameSvc: r } = this.beans;
      r && s && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? r.addDestroyTask(() => {
        this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
      }) : this.destroyRowCtrls(e, t);
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    this.eventSvc.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll: e
    });
  }
  onDisplayedColumnsChanged() {
    const { visibleCols: e } = this.beans, t = e.isPinningLeft(), s = e.isPinningRight();
    (this.pinningLeft !== t || s !== this.pinningRight) && (this.pinningLeft = t, this.pinningRight = s, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const s = t.rowNode.rowIndex;
      e.push(s.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = Ea(e);
    return this.getAllRowCtrls().filter((s) => {
      if (!s.isFullWidth())
        return !1;
      const i = s.rowNode;
      return !(t != null && !Ma(i, t));
    });
  }
  createOrUpdateRowCtrl(e, t, s, i) {
    let r, o = this.rowCtrlsByRowIndex[e];
    if (o || (r = this.rowModel.getRow(e), A(r) && A(t) && t[r.id] && r.alreadyRendered && (o = t[r.id], t[r.id] = null)), !o)
      if (r || (r = this.rowModel.getRow(e)), A(r))
        o = this.createRowCon(r, s, i);
      else
        return;
    return r && (r.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = o, o;
  }
  destroyRowCtrls(e, t) {
    const s = [];
    if (e) {
      for (const i of Object.values(e))
        if (i) {
          if (this.cachedRowCtrls && i.isCacheable()) {
            this.cachedRowCtrls.addRow(i);
            continue;
          }
          if (i.destroyFirstPass(!t), t) {
            const r = i.instanceId;
            this.zombieRowCtrls[r] = i, s.push(() => {
              i.destroySecondPass(), delete this.zombieRowCtrls[r];
            });
          } else
            i.destroySecondPass();
        }
    }
    t && (s.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), window.setTimeout(() => s.forEach((i) => i()), A0));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = Ye(this.beans);
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    const { rowContainerHeight: e, pageBounds: t, rowModel: s } = this;
    e.updateOffset();
    let i, r;
    if (!s.isRowsToRender())
      i = 0, r = -1;
    else if (this.printLayout)
      this.beans.environment.refreshRowHeightVariable(), i = t.getFirstRow(), r = t.getLastRow();
    else {
      const c = this.getRowBufferInPixels(), h = this.ctrlsSvc.getScrollFeature(), u = this.gos.get("suppressRowVirtualisation");
      let p = !1, g, f;
      do {
        const y = t.getPixelOffset(), { pageFirstPixel: F, pageLastPixel: D } = t.getCurrentPagePixelRange(), x = e.divStretchOffset, T = h.getVScrollPosition(), I = T.top, E = T.bottom;
        u ? (g = F + x, f = D + x) : (g = Math.max(I + y - c, F) + x, f = Math.min(E + y + c, D) + x), this.firstVisibleVPixel = Math.max(I + y, F) + x, this.lastVisibleVPixel = Math.min(E + y, D) + x, p = this.ensureAllRowsInRangeHaveHeightsCalculated(g, f);
      } while (p);
      let m = s.getRowIndexAtPixel(g), C = s.getRowIndexAtPixel(f);
      const v = t.getFirstRow(), b = t.getLastRow();
      m < v && (m = v), C > b && (C = b), i = m, r = C;
    }
    const o = ye(this.gos, "normal"), n = this.gos.get("suppressMaxRenderedRowRestriction"), a = Math.max(this.getRowBuffer(), 500);
    o && !n && r - i > a && (r = i + a);
    const l = i !== this.firstRenderedRow, d = r !== this.lastRenderedRow;
    (l || d) && (this.firstRenderedRow = i, this.lastRenderedRow = r, this.eventSvc.dispatchEvent({
      type: "viewportChanged",
      firstRow: i,
      lastRow: r
    }));
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    this.dataFirstRenderedFired || (this.dataFirstRenderedFired = !0, window.requestAnimationFrame(() => {
      this.beans.eventSvc.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    }));
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var a, l;
    const s = (a = this.pinnedRowModel) == null ? void 0 : a.ensureRowHeightsValid(), i = (l = this.stickyRowFeature) == null ? void 0 : l.ensureRowHeightsValid(), { pageBounds: r, rowModel: o } = this, n = o.ensureRowHeightsValid(
      e,
      t,
      r.getFirstRow(),
      r.getLastRow()
    );
    return (n || i) && this.eventSvc.dispatchEvent({
      type: "recalculateRowBounds"
    }), i || n || s ? (this.updateContainerHeights(), !0) : !1;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const i = e.rowNode, r = this.focusSvc.isRowNodeFocused(i), o = e.editing, n = i.detail;
    return r || o || n ? !!this.isRowPresent(i) : !1;
  }
  isRowPresent(e) {
    var t;
    return this.rowModel.isRowPresent(e) ? ((t = this.beans.pagination) == null ? void 0 : t.isRowPresent(e)) ?? !0 : !1;
  }
  createRowCon(e, t, s) {
    var a;
    const i = ((a = this.cachedRowCtrls) == null ? void 0 : a.getRow(e)) ?? null;
    if (i)
      return i;
    const r = this.gos.get("suppressAnimationFrame"), o = s && !r && !this.printLayout && !!this.beans.animationFrameSvc;
    return new ba(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.rowNode);
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: s } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[s];
        break;
      case "bottom":
        t = this.bottomRowCtrls[s];
        break;
      default:
        t = this.rowCtrlsByRowIndex[s], t || (t = this.getStickyTopRowCtrls().find((i) => i.rowNode.rowIndex === s) || null, t || (t = this.getStickyBottomRowCtrls().find((i) => i.rowNode.rowIndex === s) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const i = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !i;
  }
}, L0 = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.rowNode.id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.rowNode != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, s = this.entriesMap[t];
    delete this.entriesMap[t], be(this.entriesList, s);
  }
  removeFromCache(e) {
    const t = e.rowNode.id;
    delete this.entriesMap[t], be(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
};
function Ea(e) {
  if (!e)
    return;
  const t = {
    top: {},
    bottom: {},
    normal: {}
  };
  return e.forEach((s) => {
    const i = s.id;
    switch (s.rowPinned) {
      case "top":
        t.top[i] = s;
        break;
      case "bottom":
        t.bottom[i] = s;
        break;
      default:
        t.normal[i] = s;
        break;
    }
  }), t;
}
function Ma(e, t) {
  const s = e.id;
  switch (e.rowPinned) {
    case "top":
      return t.top[s] != null;
    case "bottom":
      return t.bottom[s] != null;
    default:
      return t.normal[s] != null;
  }
}
var k0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  postConstruct() {
    const { gos: e } = this;
    this.isAccentedSort = e.get("accentedSort"), this.primaryColumnsSortGroups = wt(e), this.addManagedPropertyListener(
      "accentedSort",
      (t) => this.isAccentedSort = t.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = wt(e)
    );
  }
  doFullSort(e, t) {
    const s = e.map((i, r) => ({
      currentPos: r,
      rowNode: i
    }));
    return s.sort(this.compareRowNodes.bind(this, t)), s.map((i) => i.rowNode);
  }
  compareRowNodes(e, t, s) {
    const i = t.rowNode, r = s.rowNode;
    for (let o = 0, n = e.length; o < n; o++) {
      const a = e[o], l = a.sort === "desc", d = this.getValue(i, a.column), c = this.getValue(r, a.column);
      let h;
      const u = this.getComparator(a, i);
      if (u ? h = u(d, c, i, r, l) : h = Qr(d, c, this.isAccentedSort), !isNaN(h) && h !== 0)
        return a.sort === "asc" ? h : h * -1;
    }
    return t.currentPos - s.currentPos;
  }
  getComparator(e, t) {
    const s = e.column, i = s.getColDef().comparator;
    if (i != null)
      return i;
    if (!s.getColDef().showRowGroup)
      return;
    const r = !t.group && s.getColDef().field;
    if (!r)
      return;
    const o = this.beans.colModel.getColDefCol(r);
    if (o)
      return o.getColDef().comparator;
  }
  getValue(e, t) {
    var a, l;
    const { valueSvc: s, colModel: i, showRowGroupCols: r, gos: o } = this.beans;
    if (!this.primaryColumnsSortGroups)
      return s.getValue(t, e, !1);
    if (e.rowGroupColumn === t) {
      if (Qo(o, i.isPivotActive())) {
        const h = (a = e.allLeafChildren) == null ? void 0 : a[0];
        return h ? s.getValue(t, h, !1) : void 0;
      }
      const c = r == null ? void 0 : r.getShowRowGroupCol(t.getId());
      return c ? (l = e.groupData) == null ? void 0 : l[c.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return s.getValue(t, e, !1);
  }
};
function O0(e) {
  var t;
  (t = e.sortSvc) == null || t.onSortChanged("api");
}
function zi(e, t) {
  return (
    /* html */
    `<span data-ref="eSort${e}" class="ag-sort-indicator-icon ag-sort-${t} ag-hidden" aria-hidden="true"></span>`
  );
}
var G0 = (
  /* html */
  `<span class="ag-sort-indicator-container">
        ${zi("Order", "order")}
        ${zi("Asc", "ascending-icon")}
        ${zi("Desc", "descending-icon")}
        ${zi("Mixed", "mixed-icon")}
        ${zi("None", "none-icon")}
    </span>`
), Vl = class extends L {
  constructor(e) {
    super(), this.eSortOrder = S, this.eSortAsc = S, this.eSortDesc = S, this.eSortMixed = S, this.eSortNone = S, e || this.setTemplate(G0);
  }
  attachCustomElements(e, t, s, i, r) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = s, this.eSortMixed = i, this.eSortNone = r;
  }
  setupSort(e, t = !1) {
    if (this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !e.isSortable() && !e.getColDef().showRowGroup)
      return;
    this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e);
    const s = this.updateIcons.bind(this), i = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", s), this.addManagedEventListeners({
      newColumnsLoaded: s,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: i,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: i
    }), this.onSortChanged();
  }
  addInIcon(e, t, s) {
    if (t == null)
      return;
    const i = B(e, this.beans, s);
    i && t.appendChild(i);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const { eSortAsc: e, eSortDesc: t, eSortNone: s, column: i, gos: r, beans: o } = this, n = o.sortSvc.getDisplaySortForColumn(i);
    if (e && O(e, n === "asc", { skipAriaHidden: !0 }), t && O(t, n === "desc", { skipAriaHidden: !0 }), s) {
      const a = !i.getColDef().unSortIcon && !r.get("unSortIcon"), l = n == null;
      O(s, !a && l, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    const { eSortMixed: e, column: t, gos: s } = this;
    this.addInIcon("sortUnSort", e, t);
    const i = t.getColDef().showRowGroup;
    wt(s) && i && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    const { eSortMixed: e, beans: t, column: s } = this;
    if (e) {
      const i = t.sortSvc.getDisplaySortForColumn(s) === "mixed";
      O(e, i, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    const {
      eSortOrder: e,
      column: t,
      beans: { sortSvc: s }
    } = this;
    if (!e)
      return;
    const i = s.getColumnsWithSortingOrdered(), r = s.getDisplaySortIndexForColumn(t) ?? -1, o = i.some(
      (a) => s.getDisplaySortIndexForColumn(a) ?? !1
    ), n = r >= 0 && o;
    O(e, n, { skipAriaHidden: !0 }), r >= 0 ? e.textContent = (r + 1).toString() : X(e);
  }
}, B0 = {
  selector: "AG-SORT-INDICATOR",
  component: Vl
}, Cr = ["asc", "desc", null], V0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "sortSvc";
  }
  progressSort(e, t, s) {
    const i = this.getNextSortDirection(e);
    this.setSortForColumn(e, i, t, s);
  }
  progressSortFromEvent(e, t) {
    const i = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
    this.progressSort(e, i, "uiColumnSorted");
  }
  setSortForColumn(e, t, s, i) {
    var c;
    t !== "asc" && t !== "desc" && (t = null);
    const { gos: r, showRowGroupCols: o } = this.beans, n = wt(r);
    let a = [e];
    if (n && e.getColDef().showRowGroup) {
      const h = (c = o == null ? void 0 : o.getSourceColumnsForGroupColumn) == null ? void 0 : c.call(o, e), u = h == null ? void 0 : h.filter((p) => p.isSortable());
      u && (a = [e, ...u]);
    }
    a.forEach((h) => this.setColSort(h, t, i));
    const l = (s || r.get("alwaysMultiSort")) && !r.get("suppressMultiSort"), d = [];
    if (!l) {
      const h = this.clearSortBarTheseColumns(a, i);
      d.push(...h);
    }
    this.updateSortIndex(e), d.push(...a), this.dispatchSortChangedEvents(i, d);
  }
  updateSortIndex(e) {
    const { gos: t, colModel: s, showRowGroupCols: i } = this.beans, r = wt(t), o = i == null ? void 0 : i.getShowRowGroupCol(e.getId()), n = r && o || e, a = this.getColumnsWithSortingOrdered();
    s.getAllCols().forEach((c) => this.setColSortIndex(c, null));
    const l = a.filter((c) => r && c.getColDef().showRowGroup ? !1 : c !== n);
    (n.getSort() ? [...l, n] : l).forEach((c, h) => this.setColSortIndex(c, h));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.beans.colModel.getAllCols().filter((s) => !!s.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const s = {
      type: "sortChanged",
      source: e
    };
    t && (s.columns = t), this.eventSvc.dispatchEvent(s);
  }
  clearSortBarTheseColumns(e, t) {
    const s = [];
    return this.beans.colModel.getAllCols().forEach((i) => {
      e.includes(i) || (i.getSort() && s.push(i), this.setColSort(i, void 0, t));
    }), s;
  }
  getNextSortDirection(e) {
    const t = e.getColDef().sortingOrder ?? this.gos.get("sortingOrder") ?? Cr, s = t.indexOf(e.getSort()), i = s < 0, r = s == t.length - 1;
    return i || r ? t[0] : t[s + 1];
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    const { gos: e, colModel: t, showRowGroupCols: s, rowGroupColsSvc: i } = this.beans;
    let r = t.getAllCols().filter((d) => !!d.getSort());
    if (t.isPivotMode()) {
      const d = wt(e);
      r = r.filter((c) => {
        const h = !!c.getAggFunc(), u = !c.isPrimary(), p = d ? s == null ? void 0 : s.getShowRowGroupCol(c.getId()) : c.getColDef().showRowGroup;
        return h || u || p;
      });
    }
    const o = (i == null ? void 0 : i.columns.filter((d) => !!d.getSort())) ?? [], n = {};
    r.forEach((d, c) => n[d.getId()] = c), r.sort((d, c) => {
      const h = d.getSortIndex(), u = c.getSortIndex();
      if (h != null && u != null)
        return h - u;
      if (h == null && u == null) {
        const p = n[d.getId()], g = n[c.getId()];
        return p > g ? 1 : -1;
      } else return u == null ? -1 : 1;
    });
    const a = wt(e) && !!o.length;
    a && (r = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        r.map((d) => (s == null ? void 0 : s.getShowRowGroupCol(d.getId())) ?? d)
      )
    ]);
    const l = /* @__PURE__ */ new Map();
    return r.forEach((d, c) => l.set(d, c)), a && o.forEach((d) => {
      const c = s.getShowRowGroupCol(d.getId());
      l.set(d, l.get(c));
    }), l;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [s, i]) => t - i).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = wt(this.gos), s = !!e.getColDef().showRowGroup;
    return t && s;
  }
  getDisplaySortForColumn(e) {
    var n;
    const t = (n = this.beans.showRowGroupCols) == null ? void 0 : n.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const i = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, r = i[0].getSort();
    return i.every((a) => a.getSort() == r) ? r : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
  setupHeader(e, t, s) {
    let i = 0;
    e.addManagedListeners(t, {
      movingChanged: () => {
        i = (/* @__PURE__ */ new Date()).getTime();
      }
    }), s && e.addManagedElementListeners(s, {
      click: (o) => {
        const n = t.isMoving(), l = (/* @__PURE__ */ new Date()).getTime() - i < 50;
        n || l || this.progressSortFromEvent(t, o);
      }
    });
    const r = () => {
      var n;
      const o = t.getSort();
      if (e.addOrRemoveCssClass("ag-header-cell-sorted-asc", o === "asc"), e.addOrRemoveCssClass("ag-header-cell-sorted-desc", o === "desc"), e.addOrRemoveCssClass("ag-header-cell-sorted-none", !o), t.getColDef().showRowGroup) {
        const a = (n = this.beans.showRowGroupCols) == null ? void 0 : n.getSourceColumnsForGroupColumn(t), d = !(a == null ? void 0 : a.every(
          (c) => t.getSort() == c.getSort()
        ));
        e.addOrRemoveCssClass("ag-header-cell-sorted-mixed", d);
      }
    };
    e.addManagedEventListeners({
      sortChanged: r,
      columnRowGroupChanged: r
    });
  }
  initCol(e) {
    const { sort: t, initialSort: s, sortIndex: i, initialSortIndex: r } = e.colDef;
    t !== void 0 ? (t === "asc" || t === "desc") && (e.sort = t) : (s === "asc" || s === "desc") && (e.sort = s), i !== void 0 ? i !== null && (e.sortIndex = i) : r !== null && (e.sortIndex = r);
  }
  updateColSort(e, t, s) {
    t !== void 0 && (t === "desc" || t === "asc" ? this.setColSort(e, t, s) : this.setColSort(e, void 0, s));
  }
  setColSort(e, t, s) {
    e.sort !== t && (e.sort = t, e.dispatchColEvent("sortChanged", s)), e.dispatchStateUpdatedEvent("sort");
  }
  setColSortIndex(e, t) {
    e.sortIndex = t, e.dispatchStateUpdatedEvent("sortIndex");
  }
  createSortIndicator(e) {
    return new Vl(e);
  }
  getSortIndicatorSelector() {
    return B0;
  }
}, Nl = {
  moduleName: "Sort",
  version: G,
  beans: [V0, k0],
  apiFunctions: {
    onSortChanged: O0
  },
  userComponents: {
    agSortIndicator: Vl
  },
  icons: {
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none"
  }
}, N0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "syncSvc", this.waitingForColumns = !1;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.beans.ctrlsSvc.whenReady(this, () => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    const { colModel: t, rowModel: s } = this.beans;
    t.setColumnDefs(e ?? [], "gridInitializing"), s.start();
  }
  gridReady() {
    const { eventSvc: e, gos: t } = this;
    e.dispatchEvent({
      type: "gridReady"
    }), ws(t, `initialised successfully, enterprise = ${t.isModuleRegistered("EnterpriseCore")}`);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.beans.colModel.setColumnDefs(t, Ws(e.source));
    }
  }
};
function H0(e) {
  var t;
  (t = e.valueCache) == null || t.expire();
}
function z0(e, t) {
  const { colKey: s, rowNode: i, useFormatter: r } = t, o = e.colModel.getColDefCol(s) ?? e.colModel.getCol(s);
  if (Y(o))
    return null;
  const n = e.valueSvc.getValueForDisplay(o, i);
  return r ? e.valueSvc.formatValue(o, i, n) ?? Q(n, !0) : n;
}
var Mi = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  depthFirstSearchChangedPath(e, t) {
    const { rowNode: s, children: i } = e;
    if (i)
      for (let r = 0; r < i.length; ++r)
        this.depthFirstSearchChangedPath(i[r], t);
    t(s);
  }
  depthFirstSearchEverything(e, t, s) {
    const i = e.childrenAfterGroup;
    if (i)
      for (let r = 0, o = i.length; r < o; ++r) {
        const n = i[r];
        n.childrenAfterGroup ? this.depthFirstSearchEverything(n, t, s) : s && t(n);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, s = !1) {
    this.active && !s ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, s = 0;
    for (; !this.mapToItems[t.id]; ) {
      const i = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = i, s++, t = t.parent;
    }
    return s;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let s = e;
    for (; s; )
      this.nodeIdsToColumns[s.id] || (this.nodeIdsToColumns[s.id] = {}), t.forEach((i) => this.nodeIdsToColumns[s.id][i.getId()] = !0), s = s.parent;
  }
  linkPathItems(e, t) {
    let s = e;
    for (let i = 0; i < t; i++) {
      const r = this.mapToItems[s.id], o = this.mapToItems[s.parent.id];
      o.children || (o.children = []), o.children.push(r), s = s.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const s = this.createPathItems(e);
    this.linkPathItems(e, s), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const s = this.nodeIdsToColumns[e.id];
    return t.filter((r) => s[r.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const s = this.nodeIdsToColumns[e.id];
    return t.filter((r) => !s[r.getId()]);
  }
}, W0 = "paste", _0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionSvc", this.clientSideRowModel = null;
  }
  postConstruct() {
    const { gos: e, rowModel: t } = this.beans;
    J(e) && (this.clientSideRowModel = t), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    const { gos: t, rowRenderer: s } = this.beans;
    if (e.source === W0 || t.get("suppressChangeDetection"))
      return;
    const i = e.node, r = [i], o = this.clientSideRowModel, n = o == null ? void 0 : o.rootNode;
    if (n && !i.isRowPinned()) {
      const a = t.get("aggregateOnlyChangedColumns"), l = new Mi(a, n);
      l.addParentNode(i.parent, [e.column]), o.doAggregate(l), l.forEachChangedNodeDepthFirst((d) => {
        r.push(d);
      });
    }
    s.refreshCells({ rowNodes: r });
  }
}, U0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "expressionSvc", this.cache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    z(15, { expression: e });
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (s) {
      return z(16, { expression: e, params: t, e: s }), null;
    }
  }
  createExpressionFunction(e) {
    const t = this.cache;
    if (t[e])
      return t[e];
    const s = this.createFunctionBody(e), i = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      s
    );
    return t[e] = i, i;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, K0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    const e = this.gos;
    this.active = e.get("valueCache"), this.neverExpires = e.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, s) {
    if (this.active) {
      const i = this.cacheVersion;
      e.__cacheVersion !== i && (e.__cacheVersion = i, e.__cacheData = {}), e.__cacheData[t] = s;
    }
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
}, $0 = {
  moduleName: "ValueCache",
  version: G,
  beans: [K0],
  apiFunctions: {
    expireValueCache: H0
  }
}, j0 = {
  moduleName: "Expression",
  version: G,
  beans: [U0]
}, q0 = {
  moduleName: "ChangeDetection",
  version: G,
  beans: [_0]
}, Y0 = {
  moduleName: "CellApi",
  version: G,
  apiFunctions: {
    getCellValue: z0
  }
}, X0 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "valueSvc", this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionSvc = e.expressionSvc, this.colModel = e.colModel, this.valueCache = e.valueCache, this.dataTypeSvc = e.dataTypeSvc;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this), this.isSsrm = Te(this.gos), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (t) => this.callColumnCellValueChangedHandler(t);
    this.eventSvc.addEventListener("cellValueChanged", e, !0), this.addDestroyFunc(() => this.eventSvc.removeEventListener("cellValueChanged", e, !0)), this.addManagedPropertyListener("treeData", (t) => this.isTreeData = t.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * This hides values in expanded group rows which are instead displayed by the footer row.
   */
  getValueForDisplay(e, t) {
    const s = t.leafGroup && this.colModel.isPivotMode(), i = t.group && t.expanded && !t.footer && !s, r = this.gos.get("groupSuppressBlankHeader");
    if (!i || r)
      return this.getValue(e, t);
    let o = !1;
    const n = this.gos.get("groupTotalRow");
    typeof n != "function" ? o = !!n : o = !!this.gos.getCallback("groupTotalRow")({ node: this });
    const a = i && o;
    return this.getValue(e, t, a);
  }
  getValue(e, t, s = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const i = e.getColDef(), r = i.field, o = e.getColId(), n = t.data;
    let a;
    const l = t.groupData && t.groupData[o] !== void 0, d = !s && t.aggData && t.aggData[o] !== void 0, c = this.isSsrm && s && !!e.getColDef().aggFunc, h = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (this.isTreeData && d ? a = t.aggData[o] : this.isTreeData && i.valueGetter ? a = this.executeValueGetter(i.valueGetter, n, e, t) : this.isTreeData && r && n ? a = Ji(n, r, e.isFieldContainsDots()) : l ? a = t.groupData[o] : d ? a = t.aggData[o] : i.valueGetter ? a = this.executeValueGetter(i.valueGetter, n, e, t) : h ? a = Ji(n, t.field, e.isFieldContainsDots()) : r && n && !c && (a = Ji(n, r, e.isFieldContainsDots())), this.cellExpressions && typeof a == "string" && a.indexOf("=") === 0) {
      const u = a.substring(1);
      a = this.executeValueGetter(u, n, e, t);
    }
    if (a == null) {
      const u = this.getOpenedGroup(t, e);
      if (u != null)
        return u;
    }
    return a;
  }
  parseValue(e, t, s, i) {
    var n;
    const r = e.getColDef(), o = r.valueParser;
    if (A(o)) {
      const a = this.gos.addGridCommonParams({
        node: t,
        data: t == null ? void 0 : t.data,
        oldValue: i,
        newValue: s,
        colDef: r,
        column: e
      });
      return typeof o == "function" ? o(a) : (n = this.expressionSvc) == null ? void 0 : n.evaluate(o, a);
    }
    return s;
  }
  getDeleteValue(e, t) {
    return A(e.getColDef().valueParser) ? this.parseValue(e, t, "", this.getValueForDisplay(e, t)) ?? null : null;
  }
  formatValue(e, t, s, i, r = !0) {
    let o = null, n;
    const a = e.getColDef();
    if (i ? n = i : r && (n = a.valueFormatter), n) {
      const l = this.gos.addGridCommonParams({
        value: s,
        node: t,
        data: t ? t.data : null,
        colDef: a,
        column: e
      });
      typeof n == "function" ? o = n(l) : o = this.expressionSvc ? this.expressionSvc.evaluate(n, l) : null;
    } else if (a.refData)
      return a.refData[s] || "";
    return o == null && Array.isArray(s) && (o = s.join(", ")), o;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const i = t.getColDef().showRowGroup;
    let r = e.parent;
    for (; r != null; ) {
      if (r.rowGroupColumn && (i === !0 || i === r.rowGroupColumn.getColId()))
        return r.key;
      r = r.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, s, i) {
    var c, h;
    const r = this.colModel.getColDefCol(t);
    if (!e || !r)
      return !1;
    Y(e.data) && (e.data = {});
    const { field: o, valueSetter: n } = r.getColDef();
    if (Y(o) && Y(n))
      return R(17), !1;
    if (this.dataTypeSvc && !this.dataTypeSvc.checkType(r, s))
      return R(135), !1;
    const a = this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      oldValue: this.getValue(r, e),
      newValue: s,
      colDef: r.getColDef(),
      column: r
    });
    a.newValue = s;
    let l;
    if (A(n) ? typeof n == "function" ? l = n(a) : l = (c = this.expressionSvc) == null ? void 0 : c.evaluate(n, a) : l = this.setValueUsingField(e.data, o, s, r.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), (h = this.valueCache) == null || h.onDataChanged();
    const d = this.getValue(r, e);
    return this.eventSvc.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: a.column,
      colDef: a.colDef,
      data: e.data,
      node: e,
      oldValue: a.oldValue,
      newValue: d,
      value: d,
      source: i
    }), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, s, i) {
    if (!t)
      return !1;
    let r = !1;
    if (!i)
      r = e[t] === s, r || (e[t] = s);
    else {
      const o = t.split(".");
      let n = e;
      for (; o.length > 0 && n; ) {
        const a = o.shift();
        o.length === 0 ? (r = n[a] === s, r || (n[a] = s)) : n = n[a];
      }
    }
    return !r;
  }
  executeValueGetterWithValueCache(e, t, s, i) {
    const r = s.getColId(), o = this.valueCache.getValue(i, r);
    if (o !== void 0)
      return o;
    const n = this.executeValueGetterWithoutValueCache(e, t, s, i);
    return this.valueCache.setValue(i, r, n), n;
  }
  executeValueGetterWithoutValueCache(e, t, s, i) {
    var n;
    const r = this.gos.addGridCommonParams({
      data: t,
      node: i,
      column: s,
      colDef: s.getColDef(),
      getValue: this.getValueCallback.bind(this, i)
    });
    let o;
    return typeof e == "function" ? o = e(r) : o = (n = this.expressionSvc) == null ? void 0 : n.evaluate(e, r), o;
  }
  getValueCallback(e, t) {
    const s = this.colModel.getColDefCol(t);
    return s ? this.getValue(s, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const s = this.getValue(e, t), i = e.getColDef().keyCreator;
    let r = s;
    if (i) {
      const o = this.gos.addGridCommonParams({
        value: s,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      r = i(o);
    }
    return typeof r == "string" || r == null || (r = String(r), r === "[object Object]" && R(121)), r;
  }
}, Z0 = {
  moduleName: "CommunityCore",
  version: G,
  beans: [
    qx,
    hb,
    QS,
    pv,
    M0,
    gS,
    Wx,
    Qx,
    lv,
    m0,
    f0,
    I0,
    X0,
    $x,
    zx,
    jx,
    ex,
    N0,
    jS,
    qS
  ],
  icons: {
    // icon on select dropdowns (select cell editor, charts tool panels)
    selectOpen: "small-down",
    /** @deprecated v33 */
    smallDown: "small-down",
    /** @deprecated v33 */
    colorPicker: "color-picker",
    /** @deprecated v33 */
    smallUp: "small-up",
    /** @deprecated v33 */
    checkboxChecked: "small-up",
    /** @deprecated v33 */
    checkboxIndeterminate: "checkbox-indeterminate",
    /** @deprecated v33 */
    checkboxUnchecked: "checkbox-unchecked",
    /** @deprecated v33 */
    radioButtonOn: "radio-button-on",
    /** @deprecated v33 */
    radioButtonOff: "radio-button-off",
    /** @deprecated v33 */
    smallLeft: "small-left",
    /** @deprecated v33 */
    smallRight: "small-right"
  },
  apiFunctions: {
    getGridId: ub,
    destroy: pb,
    isDestroyed: gb,
    getGridOption: fb,
    setGridOption: mb,
    updateGridOptions: lp
  },
  dependsOn: [
    _S,
    Ll,
    Jb,
    Nl,
    s0,
    gp,
    i0,
    E0,
    q0,
    r0,
    cn,
    y0,
    S0,
    n0,
    ZS,
    US,
    j0
  ]
}, Hl = class Is {
  /**
   * @param providedOptions
   * @returns Shallow copy of the provided options with global options merged in.
   */
  static applyGlobalGridOptions(t) {
    if (!Is.gridOptions)
      return { ...t };
    let s = {};
    return pe(s, Is.gridOptions, !0, !0), Is.mergeStrategy === "deep" ? pe(s, t, !0, !0) : s = { ...s, ...t }, Is.gridOptions.context && (s.context = Is.gridOptions.context), t.context && (Is.mergeStrategy === "deep" && s.context && pe(t.context, s.context, !0, !0), s.context = t.context), s;
  }
};
Hl.gridOptions = void 0;
Hl.mergeStrategy = "shallow";
var Q0 = Hl;
function Lp(e, t, s) {
  if (!t)
    return z(11), {};
  const i = s;
  let r;
  if (!(i != null && i.setThemeOnGridDiv)) {
    const n = document.createElement("div");
    n.style.height = "100%", e.appendChild(n), e = n, r = () => e.remove();
  }
  return new eF().create(
    e,
    t,
    (n) => {
      const a = new db(e);
      n.createBean(a);
    },
    void 0,
    s,
    r
  );
}
var J0 = 1, eF = class {
  create(e, t, s, i, r, o) {
    const n = Q0.applyGlobalGridOptions(t), a = n.gridId ?? String(J0++), l = n.rowModelType ?? "clientSide", d = this.getRegisteredModules(r, a, l), c = this.createBeansList(l, d, a), h = this.createProvidedBeans(e, n, r);
    if (!c)
      return;
    const u = {
      providedBeanInstances: h,
      beanClasses: c,
      gridId: a,
      beanInitComparator: jy,
      beanDestroyComparator: qy,
      derivedBeans: [Ky],
      destroyCallback: o
    }, p = new sw(u);
    return this.registerModuleFeatures(p, d), s(p), p.getBean("syncSvc").start(), i && i(p), p.getBean("gridApi");
  }
  getRegisteredModules(e, t, s) {
    var i;
    return gr(Z0, void 0), (i = e == null ? void 0 : e.modules) == null || i.forEach((r) => gr(r, t)), Qv(t, s);
  }
  registerModuleFeatures(e, t) {
    const s = e.getBean("registry"), i = e.getBean("apiFunctionSvc");
    t.forEach((r) => {
      s.registerModule(r);
      const o = r.apiFunctions;
      o && Object.keys(o).forEach((a) => {
        i == null || i.addFunction(a, o[a]);
      });
    });
  }
  createProvidedBeans(e, t, s) {
    let i = s ? s.frameworkOverrides : null;
    Y(i) && (i = new np());
    const r = {
      gridOptions: t,
      eGridDiv: e,
      globalListener: s ? s.globalListener : null,
      globalSyncListener: s ? s.globalSyncListener : null,
      frameworkOverrides: i
    };
    return s && s.providedBeanInstances && Object.assign(r, s.providedBeanInstances), r;
  }
  createBeansList(e, t, s) {
    const r = {
      clientSide: "ClientSideRowModel",
      infinite: "InfiniteRowModel",
      serverSide: "ServerSideRowModel",
      viewport: "ViewportRowModel"
    }[e];
    if (!r) {
      fa(201, { rowModelType: e }, `Unknown rowModelType ${e}.`);
      return;
    }
    if (!xu(r, s, e)) {
      fa(
        200,
        {
          reasonOrId: `rowModelType = '${e}'`,
          moduleName: r,
          gridScoped: gl(),
          gridId: s,
          rowModelType: e
        },
        `Missing module ${r}Module for rowModelType ${e}. 
If upgrading from before v33, see ${Si}/upgrading-to-ag-grid-33/#changes-to-modules/`
      );
      return;
    }
    const o = /* @__PURE__ */ new Set();
    return t.forEach((n) => {
      var a;
      return (a = n.beans) == null ? void 0 : a.forEach((l) => o.add(l));
    }), Array.from(o);
  }
};
function Dt(e) {
  const t = e.rowModel;
  return t.getType() === "clientSide" ? t : void 0;
}
function hn(e) {
  const t = e.rowModel;
  return t.getType() === "infinite" ? t : void 0;
}
function ki(e) {
  const t = e.rowModel;
  return t.getType() === "serverSide" ? t : void 0;
}
var tF = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel"
], sF = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "scrollGapChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnGroupHeaderHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged",
  "overlayExclusiveChanged",
  "beforeRefreshModel"
], kp = [...tF, ...sF], iF = class extends P {
  constructor() {
    super(...arguments), this.beanName = "localeSvc";
  }
  getLocaleTextFunc() {
    const e = this.gos, t = e.getCallback("getLocaleText");
    if (t)
      return (i, r, o) => t({
        key: i,
        defaultValue: r,
        variableValues: o
      });
    const s = e.get("localeText");
    return (i, r, o) => {
      let n = s && s[i];
      if (n && o && o.length) {
        let a = 0;
        for (; !(a >= o.length || n.indexOf("${variable}") === -1); )
          n = n.replace("${variable}", o[a++]);
      }
      return n ?? r;
    };
  }
}, rF = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
  // 'treeDataChildrenField',
], oF = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy",
  "selectionColumnDef"
], nF = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
], Op = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
], aF = ["theme", "rowSelection"], lF = [
  "cellSelection",
  "sideBar",
  "suppressGroupChangesColumnVisibility",
  "groupAggFiltering",
  "suppressStickyTotalRow",
  "groupHideParentOfSingleChild"
], Gp = [
  "loadThemeGoogleFonts",
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault"
], dF = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "chartMenuItems",
  "groupTotalRow",
  "alwaysPassFilter"
], Aa = [
  ...nF,
  ...oF,
  ...rF,
  ...Op,
  ...dF,
  ...Gp,
  ...lF,
  ...aF
], cF = class {
  wrap(e, t, s, i) {
    const r = this.createWrapper(e, i);
    return t == null || t.forEach((o) => {
      this.createMethod(r, o, !0);
    }), s == null || s.forEach((o) => {
      this.createMethod(r, o, !1);
    }), r;
  }
  createMethod(e, t, s) {
    e.addMethod(t, this.createMethodProxy(e, t, s));
  }
  createMethodProxy(e, t, s) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (s && R(49, { methodName: t }), null);
    };
  }
}, hF = class extends Ts {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = Q(t, !0);
  }
};
function un(e) {
  const { inputValue: t, allSuggestions: s, hideIrrelevant: i, filterByPercentageOfBestMatch: r, addSequentialWeight: o } = e;
  let n = s.map((d, c) => ({
    value: d,
    relevance: pF(t.toLowerCase(), d.toLocaleLowerCase(), o),
    idx: c
  }));
  if (n.sort((d, c) => c.relevance - d.relevance), i && (n = n.filter((d) => d.relevance !== 0)), n.length > 0 && r && r > 0) {
    const c = n[0].relevance * r;
    n = n.filter((h) => c - h.relevance < 0);
  }
  const a = [], l = [];
  for (const d of n)
    a.push(d.value), l.push(d.idx);
  return { values: a, indices: l };
}
function uF(e) {
  const t = [], s = e.length;
  for (let i = 1; i <= s; i++)
    for (let r = 0; r <= s - i; r++) {
      const o = r + i - 1;
      t.push(e.slice(r, o + 1));
    }
  return t;
}
function pF(e, t, s = !1) {
  const i = e.replace(/\s/g, ""), r = t.replace(/\s/g, ""), o = i.length, n = r.length, a = new Array(o + 1).fill(null).map(() => new Array(n + 1).fill(0));
  for (let h = 0; h <= o; h += 1)
    a[h][0] = h;
  for (let h = 0; h <= n; h += 1)
    a[0][h] = h;
  for (let h = 1; h <= o; h++)
    for (let u = 1; u <= n; u++)
      i[h - 1] === r[u - 1] ? a[h][u] = a[h - 1][u - 1] : a[h][u] = 1 + Math.min(a[h][u - 1], Math.min(a[h - 1][u], a[h - 1][u - 1]));
  const l = a[o][n];
  let c = Math.max(o, n) - l;
  if (s) {
    const h = uF(i);
    for (let u = 0; u < h.length; u++) {
      const p = h[u];
      r.indexOf(p) !== -1 && (c += 1, c *= p.length);
    }
  }
  return c;
}
function Xs(e, t) {
  if (typeof e != "number")
    return "";
  const s = t(), i = s("thousandSeparator", ","), r = s("decimalSeparator", ".");
  return e.toString().replace(".", r).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${i}`);
}
var Bp = class extends P {
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, Vp = class {
  constructor(e) {
    this.groupColumns = [];
    const {
      colModel: t,
      rowGroupColsSvc: s,
      colNames: i,
      valueSvc: r,
      gos: o,
      processCellCallback: n,
      processHeaderCallback: a,
      processGroupHeaderCallback: l,
      processRowGroupCallback: d
    } = e;
    this.colModel = t, this.rowGroupColsSvc = s, this.colNames = i, this.valueSvc = r, this.gos = o, this.processCellCallback = n, this.processHeaderCallback = a, this.processGroupHeaderCallback = l, this.processRowGroupCallback = d;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    return this.getHeaderName(this.processHeaderCallback, e) ?? "";
  }
  extractRowCellValue(e, t, s, i, r) {
    const n = (!this.gos.get("groupHideOpenParents") || r.footer) && this.shouldRenderGroupSummaryCell(r, e, t) ? this.createValueForGroupNode(e, r) : this.valueSvc.getValue(e, r);
    return this.processCell({
      accumulatedRowIndex: s,
      rowNode: r,
      column: e,
      value: n,
      processCellCallback: this.processCellCallback,
      type: i
    });
  }
  shouldRenderGroupSummaryCell(e, t, s) {
    var n, a;
    if (!(e && e.group))
      return !1;
    if (this.groupColumns.indexOf(t) !== -1) {
      if (((n = e.groupData) == null ? void 0 : n[t.getId()]) !== void 0 || Te(this.gos) && e.group)
        return !0;
      if (e.footer && e.level === -1) {
        const l = t.getColDef();
        return l == null || l.showRowGroup === !0 || l.showRowGroup === ((a = this.rowGroupColsSvc) == null ? void 0 : a.columns[0].getId());
      }
    }
    const o = Qo(this.gos, this.colModel.isPivotMode());
    return s === 0 && o;
  }
  getHeaderName(e, t) {
    return e ? e(this.gos.addGridCommonParams({ column: t })) : this.colNames.getDisplayNameForColumn(t, "csv", !0);
  }
  createValueForGroupNode(e, t) {
    if (this.processRowGroupCallback)
      return this.processRowGroupCallback(this.gos.addGridCommonParams({ column: e, node: t }));
    const s = this.gos.get("treeData"), i = (a) => {
      var d;
      if (s)
        return a.key;
      const l = (d = a.groupData) == null ? void 0 : d[e.getId()];
      return !l || !a.rowGroupColumn || a.rowGroupColumn.getColDef().useValueFormatterForExport === !1 ? l : this.valueSvc.formatValue(a.rowGroupColumn, a, l) ?? l;
    }, r = t.footer, o = [i(t)];
    if (!al(this.gos))
      for (; t.parent; )
        t = t.parent, o.push(i(t));
    const n = o.reverse().join(" -> ");
    return r ? `Total ${n}` : n;
  }
  processCell(e) {
    const { accumulatedRowIndex: t, rowNode: s, column: i, value: r, processCellCallback: o, type: n } = e;
    return o ? {
      value: o(
        this.gos.addGridCommonParams({
          accumulatedRowIndex: t,
          column: i,
          node: s,
          value: r,
          type: n,
          parseValue: (a) => this.valueSvc.parseValue(
            i,
            s,
            a,
            this.valueSvc.getValue(i, s)
          ),
          formatValue: (a) => this.valueSvc.formatValue(i, s, a) ?? a
        })
      ) ?? ""
    } : i.getColDef().useValueFormatterForExport !== !1 ? {
      value: r ?? "",
      valueFormatted: this.valueSvc.formatValue(i, s, r)
    } : { value: r ?? "" };
  }
};
function zl(e, t) {
  const s = document.defaultView || window;
  if (!s) {
    R(52);
    return;
  }
  const i = document.createElement("a"), r = s.URL.createObjectURL(t);
  i.setAttribute("href", r), i.setAttribute("download", e), i.style.display = "none", document.body.appendChild(i), i.dispatchEvent(
    new MouseEvent("click", {
      bubbles: !1,
      cancelable: !0,
      view: s
    })
  ), document.body.removeChild(i), s.setTimeout(() => {
    s.URL.revokeObjectURL(r);
  }, 0);
}
var gF = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  dragAndDropImageComponent: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  groupLockGroupColumns: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0,
  suppressSetFilterByDefault: !0,
  getDataPath: !0
}, Ue = "clientSide", Ge = "serverSide", ni = "infinite", fF = {
  onGroupExpandedOrCollapsed: [Ue],
  refreshClientSideRowModel: [Ue],
  isRowDataEmpty: [Ue],
  forEachLeafNode: [Ue],
  forEachNodeAfterFilter: [Ue],
  forEachNodeAfterFilterAndSort: [Ue],
  resetRowHeights: [Ue],
  applyTransaction: [Ue],
  applyTransactionAsync: [Ue],
  flushAsyncTransactions: [Ue],
  getBestCostNodeSelection: [Ue],
  getServerSideSelectionState: [Ge],
  setServerSideSelectionState: [Ge],
  applyServerSideTransaction: [Ge],
  applyServerSideTransactionAsync: [Ge],
  applyServerSideRowData: [Ge],
  retryServerSideLoads: [Ge],
  flushServerSideAsyncTransactions: [Ge],
  refreshServerSide: [Ge],
  getServerSideGroupLevelState: [Ge],
  refreshInfiniteCache: [ni],
  purgeInfiniteCache: [ni],
  getInfiniteRowCount: [ni],
  isLastRowIndexKnown: [ni, Ge],
  expandAll: [Ue, Ge],
  collapseAll: [Ue, Ge],
  onRowHeightChanged: [Ue, Ge],
  setRowCount: [ni, Ge],
  getCacheBlockState: [ni, Ge]
}, mF = {
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  },
  clearRangeSelection: {
    version: "v32.2",
    message: "Use `clearCellSelection` instead."
  },
  getInfiniteRowCount: {
    version: "v32.2",
    old: "getInfiniteRowCount()",
    new: "getDisplayedRowCount()"
  },
  selectAllFiltered: {
    version: "v33",
    old: "selectAllFiltered()",
    new: 'selectAll("filtered")'
  },
  deselectAllFiltered: {
    version: "v33",
    old: "deselectAllFiltered()",
    new: 'deselectAll("filtered")'
  },
  selectAllOnCurrentPage: {
    version: "v33",
    old: "selectAllOnCurrentPage()",
    new: 'selectAll("currentPage")'
  },
  deselectAllOnCurrentPage: {
    version: "v33",
    old: "deselectAllOnCurrentPage()",
    new: 'deselectAll("currentPage")'
  }
};
function CF(e, t, s) {
  const i = mF[e];
  if (i) {
    const { version: o, new: n, old: a, message: l } = i, d = a ?? e;
    return (...c) => {
      const h = n ? `Please use ${n} instead. ` : "";
      return kt(`Since ${o} api.${d} is deprecated. ${h}${l ?? ""}`), t.apply(t, c);
    };
  }
  const r = fF[e];
  return r ? (...o) => {
    const n = s.rowModel.getType();
    if (!r.includes(n)) {
      gi(
        `api.${e} can only be called when gridOptions.rowModelType is ${r.join(" or ")}`
      );
      return;
    }
    return t.apply(t, o);
  } : t;
}
var vF = {
  AdvancedFilter: 1,
  AllEnterprise: 1,
  CellSelection: 1,
  Clipboard: 1,
  ColumnMenu: 1,
  ColumnsToolPanel: 1,
  ContextMenu: 1,
  ExcelExport: 1,
  FiltersToolPanel: 1,
  GridCharts: 1,
  IntegratedCharts: 1,
  GroupFilter: 1,
  MasterDetail: 1,
  Menu: 1,
  MultiFilter: 1,
  Pivot: 1,
  RangeSelection: 1,
  RichSelect: 1,
  RowGrouping: 1,
  RowGroupingPanel: 1,
  ServerSideRowModelApi: 1,
  ServerSideRowModel: 1,
  SetFilter: 1,
  SideBar: 1,
  Sparklines: 1,
  StatusBar: 1,
  TreeData: 1,
  ViewportRowModel: 1
}, jn = [
  "TextFilter",
  "NumberFilter",
  "DateFilter",
  "SetFilter",
  "MultiFilter",
  "GroupFilter",
  "CustomFilter"
], wF = {
  EditCore: [
    "TextEditor",
    "NumberEditor",
    "DateEditor",
    "CheckboxEditor",
    "LargeTextEditor",
    "SelectEditor",
    "RichSelect",
    "CustomEditor"
  ],
  CheckboxCellRenderer: ["AllCommunity"],
  ClientSideRowModelHierarchy: ["RowGrouping", "Pivot", "TreeData"],
  ColumnFilter: jn,
  ColumnGroupHeaderComp: ["AllCommunity"],
  ColumnGroup: ["AllCommunity"],
  ColumnHeaderComp: ["AllCommunity"],
  ColumnMove: ["AllCommunity"],
  ColumnResize: ["AllCommunity"],
  CommunityCore: ["AllCommunity"],
  CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  EnterpriseCore: ["AllEnterprise"],
  FilterCore: [...jn, "QuickFilter", "ExternalFilter", "AdvancedFilter"],
  GroupCellRenderer: ["RowGrouping", "Pivot", "TreeData", "MasterDetail", "ServerSideRowModel"],
  KeyboardNavigation: ["AllCommunity"],
  LoadingCellRenderer: ["ServerSideRowModel"],
  MenuCore: ["ColumnMenu", "ContextMenu"],
  MenuItem: ["ColumnMenu", "ContextMenu", "MultiFilter", "IntegratedCharts", "ColumnsToolPanel"],
  Overlay: ["AllCommunity"],
  PinnedColumn: ["AllCommunity"],
  SharedAggregation: ["RowGrouping", "Pivot", "TreeData", "ServerSideRowModel"],
  SharedDragAndDrop: ["AllCommunity"],
  SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
  SharedMenu: [...jn, "ColumnMenu", "ContextMenu"],
  SharedPivot: ["Pivot", "ServerSideRowModel"],
  SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
  SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
  SkeletonCellRenderer: ["ServerSideRowModel"],
  Sort: ["AllCommunity"],
  SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
  SharedTreeData: ["TreeData", "ServerSideRowModel"]
}, yF = {
  InfiniteRowModel: "infinite",
  ClientSideRowModelApi: "clientSide",
  ClientSideRowModel: "clientSide",
  ServerSideRowModelApi: "serverSide",
  ServerSideRowModel: "serverSide",
  ViewportRowModel: "viewport"
};
function bF(e, t) {
  const s = [];
  return (Array.isArray(e) ? e : [e]).forEach((i) => {
    const r = wF[i];
    r ? r.forEach((o) => {
      const n = yF[o];
      (!n || n === t) && s.push(o);
    }) : s.push(i);
  }), s;
}
var Ci = {
  agSetColumnFilter: "SetFilter",
  agSetColumnFloatingFilter: "SetFilter",
  agMultiColumnFilter: "MultiFilter",
  agMultiColumnFloatingFilter: "MultiFilter",
  agGroupColumnFilter: "GroupFilter",
  agGroupColumnFloatingFilter: "GroupFilter",
  agGroupCellRenderer: "GroupCellRenderer",
  agGroupRowRenderer: "GroupCellRenderer",
  agRichSelect: "RichSelect",
  agRichSelectCellEditor: "RichSelect",
  agDetailCellRenderer: "SharedMasterDetail",
  agSparklineCellRenderer: "Sparklines",
  agDragAndDropImage: "SharedDragAndDrop",
  agColumnHeader: "ColumnHeaderComp",
  agColumnGroupHeader: "ColumnGroupHeaderComp",
  agSortIndicator: "Sort",
  agAnimateShowChangeCellRenderer: "HighlightChanges",
  agAnimateSlideCellRenderer: "HighlightChanges",
  agLoadingCellRenderer: "LoadingCellRenderer",
  agSkeletonCellRenderer: "SkeletonCellRenderer",
  agCheckboxCellRenderer: "CheckboxCellRenderer",
  agLoadingOverlay: "Overlay",
  agNoRowsOverlay: "Overlay",
  agTooltipComponent: "Tooltip",
  agReadOnlyFloatingFilter: "CustomFilter",
  agTextColumnFilter: "TextFilter",
  agNumberColumnFilter: "NumberFilter",
  agDateColumnFilter: "DateFilter",
  agDateInput: "DateFilter",
  agTextColumnFloatingFilter: "TextFilter",
  agNumberColumnFloatingFilter: "NumberFilter",
  agDateColumnFloatingFilter: "DateFilter",
  agCellEditor: "TextEditor",
  agSelectCellEditor: "SelectEditor",
  agTextCellEditor: "TextEditor",
  agNumberCellEditor: "NumberEditor",
  agDateCellEditor: "DateEditor",
  agDateStringCellEditor: "DateEditor",
  agCheckboxCellEditor: "CheckboxEditor",
  agLargeTextCellEditor: "LargeTextEditor",
  agMenuItem: "MenuItem",
  agColumnsToolPanel: "ColumnsToolPanel",
  agFiltersToolPanel: "FiltersToolPanel",
  agAggregationComponent: "StatusBar",
  agSelectedRowCountComponent: "StatusBar",
  agTotalRowCountComponent: "StatusBar",
  agFilteredRowCountComponent: "StatusBar",
  agTotalAndFilteredRowCountComponent: "StatusBar"
}, SF = (e) => `import { ModuleRegistry } from 'ag-grid-community'; 
${e.map(
  (s) => `import { ${Mo(s)} } from '${vF[s] ? "ag-grid-enterprise" : "ag-grid-community"}';`
).join(` 
`)} 

ModuleRegistry.registerModules([ ${e.map(Mo).join(", ")} ]); 

For more info see: ${Si}/modules/`;
function Mo(e) {
  return `${e}Module`;
}
var Jd = ({
  reasonOrId: e,
  moduleName: t,
  gridScoped: s,
  gridId: i,
  rowModelType: r,
  additionalText: o
}) => {
  const n = bF(t, r);
  return `Unable to use ${typeof e == "string" ? e : PF[e]} as ${n.length > 1 ? "one of " + n.map(Mo).join(", ") : Mo(n[0])} is not registered${s ? " for gridId: " + i : ""}. Check if you have registered the module:
${SF(n)}` + (o ? ` 

${o}` : "");
}, ec = (e) => `${e} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${e} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${e}.with(AgChartsEnterpriseModule)]);
    `, xF = (e) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${e}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`, FF = {
  1: () => "`rowData` must be an array",
  2: ({ nodeId: e }) => `Duplicate node id '${e}' detected from getRowId callback, this could cause issues in your grid.`,
  3: () => "Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.",
  4: ({ id: e }) => `Could not find row id=${e}, data item was not found for this id`,
  5: ({ data: e }) => [
    "Could not find data item as object was not found.",
    e,
    " Consider using getRowId to help the Grid find matching row data"
  ],
  6: () => "'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'",
  7: () => "Pivoting is not supported with aligned grids as it may produce different columns in each grid.",
  8: ({ key: e }) => `Unknown key for navigation ${e}`,
  9: ({ variable: e }) => `No value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`,
  10: ({ eventType: e }) => `As of v33, the '${e}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
  11: () => "No gridOptions provided to createGrid",
  12: ({ colKey: e }) => ["column ", e, " not found"],
  13: () => "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.",
  14: ({ groupPrefix: e }) => `Row IDs cannot start with ${e}, this is a reserved prefix for AG Grid's row grouping feature.`,
  15: ({ expression: e }) => ["value should be either a string or a function", e],
  16: ({ expression: e, params: t, e: s }) => [
    "Processing of the expression failed",
    "Expression = ",
    e,
    "Params = ",
    t,
    "Exception = ",
    s
  ],
  17: () => "you need either field or valueSetter set on colDef for editing to work",
  18: () => "alignedGrids contains an undefined option.",
  19: () => "alignedGrids - No api found on the linked grid.",
  20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
  21: () => "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.",
  22: ({ key: e }) => `${e} is an initial property and cannot be updated.`,
  23: () => "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.",
  24: () => "row height must be a number if not using standard row model",
  25: ({ id: e }) => ["The getRowId callback must return a string. The ID ", e, " is being cast to a string."],
  26: ({ fnName: e, preDestroyLink: t }) => `Grid API function ${e}() cannot be called as the grid has been destroyed.
 Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
 To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${t}`,
  27: ({ fnName: e, module: t }) => `API function '${e}' not registered to module '${t}'`,
  28: () => "setRowCount cannot be used while using row grouping.",
  29: () => "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?",
  30: ({ toIndex: e }) => [
    "tried to insert columns in invalid location, toIndex = ",
    e,
    "remember that you should not count the moving columns when calculating the new index"
  ],
  31: () => "infinite loop in resizeColumnSets",
  32: () => "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.",
  33: () => "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.",
  34: ({ key: e }) => `the column type '${e}' is a default column type and cannot be overridden.`,
  35: () => "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.",
  36: ({ t: e }) => "colDef.type '" + e + "' does not correspond to defined gridOptions.columnTypes",
  37: () => "Changing the column pinning status is not allowed with domLayout='print'",
  38: ({ iconName: e }) => `provided icon '${e}' needs to be a string or a function`,
  39: () => "Applying column order broke a group where columns should be married together. Applying new order has been discarded.",
  40: ({ e, method: t }) => `${e}
${xF(t)}`,
  41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
  42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
  43: ({ iconName: e }) => `As of v33, icon '${e}' is deprecated. Use the icon CSS name instead.`,
  44: () => 'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
  45: ({ parentCellDataType: e }) => `The data type definition ${e} does not exist.`,
  46: () => 'The "baseDataType" property of a data type definition must match that of its parent.',
  47: ({ cellDataType: e }) => `Missing data type definition - "${e}"`,
  48: ({ property: e }) => `Cell data type is "object" but no Value ${e} has been provided. Please either provide an object data type definition with a Value ${e}, or set "colDef.value${e}"`,
  49: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  50: ({ compName: e }) => `Could not find component ${e}, did you forget to configure this component?`,
  51: () => "Export cancelled. Export is not allowed as per your configuration.",
  52: () => "There is no `window` associated with the current `document`",
  53: () => "unknown value type during csv conversion",
  54: () => "Could not find document body, it is needed for drag and drop and context menu.",
  55: () => "addRowDropZone - A container target needs to be provided",
  56: () => "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.",
  57: () => "unable to show popup filter, filter instantiation failed",
  58: () => "no values found for select cellEditor",
  59: () => "cannot select pinned rows",
  60: () => "cannot select node until it has finished loading",
  61: () => "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.",
  62: ({ colId: e }) => `setFilterModel() - no column found for colId: ${e}`,
  63: ({ colId: e }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${e}`,
  64: ({ colId: e }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${e}`,
  65: () => "filter missing setModel method, which is needed for setFilterModel",
  66: () => "filter API missing getModel method, which is needed for getFilterModel",
  67: () => "Filter is missing isFilterActive() method",
  68: () => "Column Filter API methods have been disabled as Advanced Filters are enabled.",
  69: ({ guiFromFilter: e }) => `getGui method from filter returned ${e}; it should be a DOM element.`,
  70: ({ newFilter: e }) => `Grid option quickFilterText only supports string inputs, received: ${typeof e}`,
  71: () => "debounceMs is ignored when apply button is present",
  72: ({ keys: e }) => ["ignoring FilterOptionDef as it doesn't contain one of ", e],
  73: () => "invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'",
  74: () => "no filter options for filter",
  75: () => "Unknown button type specified",
  76: ({ filterModelType: e }) => [
    'Unexpected type of filter "',
    e,
    '", it looks like the filter was configured with incorrect Filter Options'
  ],
  77: () => "Filter model is missing 'conditions'",
  78: () => 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
  79: () => '"filterParams.maxNumConditions" must be greater than or equal to zero.',
  80: () => '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
  81: () => '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
  82: ({ param: e }) => `DateFilter ${e} is not a number`,
  83: () => "DateFilter minValidYear should be <= maxValidYear",
  84: () => "DateFilter minValidDate should be <= maxValidDate",
  85: () => "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.",
  86: () => "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.",
  87: () => "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.",
  88: ({ index: e }) => `Invalid row index for ensureIndexVisible: ${e}`,
  89: () => "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)",
  90: () => "datasource is missing getRows method",
  91: () => "Filter is missing method doesFilterPass",
  92: ({ methodName: e }) => `AnimationFrameService.${e} called but animation frames are off`,
  93: () => "cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`",
  94: ({
    paginationPageSizeOption: e,
    pageSizeSet: t,
    pageSizesSet: s,
    pageSizeOptions: i
  }) => `'paginationPageSize=${e}'${t ? "" : " (default value)"}, but ${e} is not included in${s ? "" : " the default"} paginationPageSizeSelector=[${i.join(", ")}].`,
  95: ({
    paginationPageSizeOption: e,
    paginationPageSizeSelector: t
  }) => `Either set '${t}' to an array that includes ${e} or to 'false' to disable the page size selector.`,
  96: ({ id: e, data: t }) => [
    "Duplicate ID",
    e,
    "found for pinned row with data",
    t,
    "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
  ],
  97: ({ colId: e }) => `cellEditor for column ${e} is missing getGui() method`,
  98: () => "popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.",
  99: () => "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.",
  100: ({ rowModelType: e }) => `selectAll only available when rowModelType='clientSide', ie not ${e}`,
  101: ({
    propertyName: e,
    componentName: t,
    agGridDefaults: s,
    jsComps: i
  }) => {
    const r = [], o = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(s).filter(
        (a) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(a)
      ),
      ...Object.keys(i)
    ], n = un({
      inputValue: t,
      allSuggestions: o,
      hideIrrelevant: !0,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    return r.push(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.
`
    ), n.length > 0 && r.push(`         Did you mean: [${n.slice(0, 3)}]?
`), r.push("If using a custom component check it has been registered correctly."), r;
  },
  102: () => "selecting just filtered only works when gridOptions.rowModelType='clientSide'",
  103: () => "Invalid selection state. When using client-side row model, the state must conform to `string[]`.",
  104: ({ value: e, param: t }) => `Numeric value ${e} passed to ${t} param will be interpreted as ${e} seconds. If this is intentional use "${e}s" to silence this warning.`,
  105: ({ e }) => ["chart rendering failed", e],
  106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${Si}/theming-migration/`,
  107: ({ key: e, value: t }) => `Invalid value for theme param ${e} - ${t}`,
  108: ({ e }) => ["chart update failed", e],
  109: ({ aggFuncOrString: e }) => `unrecognised aggregation function ${e}`,
  110: () => "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup",
  111: () => "Invalid selection state. When `groupSelectsChildren` is enabled, the state must conform to `IServerSideGroupSelectionState`.",
  113: () => "Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values",
  114: ({ component: e }) => `Could not find component with name of ${e}. Is it in Vue.components?`,
  115: () => "The provided selection state should be an object.",
  116: () => "Invalid selection state. The state must conform to `IServerSideSelectionState`.",
  117: () => "selectAll must be of boolean type.",
  118: () => "Infinite scrolling must be enabled in order to set the row count.",
  119: () => "Unable to instantiate filter",
  120: () => "MultiFloatingFilterComp expects MultiFilter as its parent",
  121: () => "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key",
  122: () => "could not find the document, document is empty",
  123: () => "Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.",
  124: () => "No active charts to update.",
  125: ({ chartId: e }) => `Unable to update chart. No active chart found with ID: ${e}.`,
  126: () => "unable to restore chart as no chart model is provided",
  127: ({ allRange: e }) => `unable to create chart as ${e ? "there are no columns in the grid" : "no range is selected"}.`,
  128: ({ feature: e }) => `${e} is only available if using 'multiRow' selection mode.`,
  129: ({ feature: e, rowModel: t }) => `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`,
  130: () => 'cannot multi select unless selection mode is "multiRow"',
  131: () => "cannot range select while selecting multiple rows",
  132: () => "Row selection features are not available unless `rowSelection` is enabled.",
  133: ({ iconName: e }) => `icon '${e}' function should return back a string or a dom object`,
  134: ({ iconName: e }) => `Did not find icon '${e}'`,
  135: () => "Data type of the new value does not match the cell data type of the column",
  136: () => "Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.",
  137: ({ type: e, currentChartType: t }) => `Unable to update chart as a '${e}' update type is not permitted on a ${t}.`,
  138: ({ chartType: e }) => `invalid chart type supplied: ${e}`,
  139: ({ customThemeName: e }) => `a custom chart theme with the name ${e} has been supplied but not added to the 'chartThemes' list`,
  140: ({ name: e }) => `no stock theme exists with the name '${e}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
  141: () => "cross filtering with row grouping is not supported.",
  142: () => "cross filtering is only supported in the client side row model.",
  143: ({ panel: e }) => `'${e}' is not a valid Chart Tool Panel name`,
  144: ({ type: e }) => `Invalid charts data panel group name supplied: '${e}'`,
  145: ({ group: e }) => `As of v32, only one charts customize panel group can be expanded at a time. '${e}' will not be expanded.`,
  146: ({ comp: e }) => `Unable to instantiate component '${e}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
  147: ({ group: e }) => `Invalid charts customize panel group name supplied: '${e}'`,
  148: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  149: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  150: () => "'seriesChartTypes' are required when the 'customCombo' chart type is specified.",
  151: ({ chartType: e }) => `invalid chartType '${e}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
  152: ({ colId: e }) => `no 'seriesChartType' found for colId = '${e}', defaulting to 'line'.`,
  153: ({ chartDataType: e }) => `unexpected chartDataType value '${e}' supplied, instead use 'category', 'series' or 'excluded'`,
  154: ({ colId: e }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${e}`,
  155: ({ option: e }) => `'${e}' is not a valid Chart Toolbar Option`,
  156: ({ panel: e }) => `Invalid panel in chartToolPanelsDef.panels: '${e}'`,
  157: ({ unrecognisedGroupIds: e }) => ["unable to find group(s) for supplied groupIds:", e],
  158: () => "can not expand a column item that does not represent a column group header",
  159: () => "Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.",
  160: () => "Export cancelled. Export is not allowed as per your configuration.",
  161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
  162: ({ id: e, dataType: t }) => `Unrecognized data type for excel export [${e}.dataType=${t}]`,
  163: ({ featureName: e }) => `Excel table export does not work with ${e}. The exported Excel file will not contain any Excel tables.
 Please turn off ${e} to enable Excel table exports.`,
  164: () => "Unable to add data table to Excel sheet: A table already exists.",
  165: () => "Unable to add data table to Excel sheet: Missing required parameters.",
  166: ({ unrecognisedGroupIds: e }) => ["unable to find groups for these supplied groupIds:", e],
  167: ({ unrecognisedColIds: e }) => ["unable to find columns for these supplied colIds:", e],
  168: () => "detailCellRendererParams.template should be function or string",
  169: () => 'Reference to eDetailGrid was missing from the details template. Please add data-ref="eDetailGrid" to the template.',
  170: ({ providedStrategy: e }) => `invalid cellRendererParams.refreshStrategy = ${e} supplied, defaulting to refreshStrategy = 'rows'.`,
  171: () => "could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions",
  172: () => "could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData",
  173: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  174: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  175: ({ menuTabName: e, itemsToConsider: t }) => [
    `Trying to render an invalid menu item '${e}'. Check that your 'menuTabs' contains one of `,
    t
  ],
  176: ({ key: e }) => `unknown menu item type ${e}`,
  177: () => "valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.",
  178: ({ colId: e }) => `column ${e} is not visible`,
  179: () => "totalValueGetter should be either a function or a string (expression)",
  180: () => "agRichSelectCellEditor requires cellEditorParams.values to be set",
  181: () => "agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.",
  182: () => 'you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data',
  183: () => "Group Column Filter only works on group columns. Please use a different filter.",
  184: ({ parentGroupData: e, childNodeData: t }) => ["duplicate group keys for row data, keys should be unique", [e, t]],
  185: ({ data: e }) => ["getDataPath() should not return an empty path", [e]],
  186: ({
    rowId: e,
    rowData: t,
    duplicateRowsData: s
  }) => ["duplicate group keys for row data, keys should be unique", e, t, ...s],
  187: ({ rowId: e, firstData: t, secondData: s }) => [
    `Duplicate node id ${e}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
    "first instance",
    t,
    "second instance",
    s
  ],
  188: () => "getRowId callback must be provided for Server Side Row Model selection to work correctly.",
  189: ({ startRow: e }) => `invalid value ${e} for startRow, the value should be >= 0`,
  190: ({ rowGroupId: e, data: t }) => [
    "null and undefined values are not allowed for server side row model keys",
    e ? `column = ${e}` : "",
    "data is ",
    t
  ],
  191: () => "cannot multi select unless selection mode is 'multiRow'",
  192: () => "cannot use range selection when multi selecting rows",
  193: () => "cannot multi select unless selection mode is 'multiRow'",
  194: ({ method: e }) => `calling gridApi.${e}() is only possible when using rowModelType=\`clientSide\`.`,
  195: ({ justCurrentPage: e }) => `selecting just ${e ? "current page" : "filtered"} only works when gridOptions.rowModelType='clientSide'`,
  196: ({ key: e }) => `Provided ids must be of string type. Invalid id provided: ${e}`,
  197: () => "`toggledNodes` must be an array of string ids.",
  198: () => "cannot multi select unless selection mode is 'multiRow'",
  199: () => "getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  200: Jd,
  201: ({ rowModelType: e }) => `Could not find row model for rowModelType = ${e}`,
  202: () => "`getSelectedNodes` and `getSelectedRows` functions cannot be used with `groupSelectsChildren` and the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  203: () => "Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.",
  204: () => "Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.",
  205: ({ duplicateIdText: e }) => `Unable to display rows as duplicate row ids (${e}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
  206: () => "getRowId callback must be implemented for transactions to work. Transaction was ignored.",
  207: () => 'The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.',
  208: () => "Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.",
  209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${Si}/filter-set-filter-list/#filter-value-types`,
  210: () => "Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?",
  211: () => "property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.",
  212: () => "please review all your toolPanel components, it seems like at least one of them doesn't have an id",
  213: () => "Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.",
  214: ({ key: e }) => `unable to lookup Tool Panel as invalid key supplied: ${e}`,
  215: ({ key: e, defaultByKey: t }) => `the key ${e} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(t).join(",")}`,
  216: ({ name: e }) => `Missing component for '${e}'`,
  217: ({ invalidColIds: e }) => ["unable to find grid columns for the supplied colDef(s):", e],
  218: ({ property: e, defaultOffset: t }) => `${e} must be a number, the value you provided is not a valid number. Using the default of ${t}px.`,
  219: ({ property: e }) => `Property ${e} does not exist on the target object.`,
  220: ({ lineDash: e }) => `'${e}' is not a valid 'lineDash' option.`,
  221: () => "agAggregationComponent should only be used with the client and server side row model.",
  222: () => "agFilteredRowCountComponent should only be used with the client side row model.",
  223: () => "agSelectedRowCountComponent should only be used with the client and server side row model.",
  224: () => "agTotalAndFilteredRowCountComponent should only be used with the client side row model.",
  225: () => "agTotalRowCountComponent should only be used with the client side row model.",
  226: () => "viewport is missing init method.",
  227: () => "menu item icon must be DOM node or string",
  228: ({ menuItemOrString: e }) => `unrecognised menu item ${e}`,
  229: ({ index: e }) => ["invalid row index for ensureIndexVisible: ", e],
  230: () => "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/",
  // @deprecated v32 mark for removal as part of v32 deprecated features
  231: () => "As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.",
  232: () => "Using both rowData and v-model. rowData will be ignored.",
  233: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  234: () => 'Group Column Filter does not work with the colDef property "field". This property will be ignored.',
  235: () => 'Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.',
  236: () => 'Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.',
  237: () => "Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.",
  238: () => "setRowCount can only accept a positive row count.",
  239: () => 'Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string "legacy" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.',
  240: ({ theme: e }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${e}`,
  241: () => "cannot select multiple rows when rowSelection.mode is set to 'singleRow'",
  242: () => "cannot select multiple rows when using rangeSelect",
  243: () => "Failed to deserialize state - each provided state object must be an object.",
  244: () => "Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.",
  245: () => "Failed to deserialize state - `toggledNodes` must be an array.",
  246: () => "Failed to deserialize state - Every `toggledNode` requires an associated string id.",
  247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. 
Please rebuild the selection state and reapply it.`,
  248: () => "SetFloatingFilter expects SetFilter as its parent",
  249: () => "Must supply a Value Formatter in Set Filter params when using a Key Creator",
  250: () => "Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.",
  251: ({ chartType: e }) => `AG Grid: Unable to create chart as an invalid chartType = '${e}' was supplied.`,
  252: () => `cannot get grid to draw rows when it is in the middle of drawing rows. 
Your code probably called a grid API method while the grid was in the render stage. 
To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). 
To see what part of your code that caused the refresh check this stacktrace.`,
  253: ({ version: e }) => ["Illegal version string: ", e],
  254: () => "Cannot create chart: no chart themes available.",
  255: ({ point: e }) => `Lone surrogate U+${e.toString(16).toUpperCase()} is not a scalar value`,
  256: () => "Unable to initialise. See validation error, or load ValidationModule if missing.",
  257: () => ec("IntegratedChartsModule"),
  258: () => ec("SparklinesModule"),
  259: ({ part: e }) => `the argument to theme.withPart must be a Theming API part object, received: ${e}`,
  260: ({
    propName: e,
    compName: t,
    gridScoped: s,
    gridId: i,
    rowModelType: r
  }) => Jd({
    reasonOrId: `AG Grid '${e}' component: ${t}`,
    moduleName: Ci[t],
    gridId: i,
    gridScoped: s,
    rowModelType: r
  }),
  261: () => "As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.",
  262: () => 'As of v33, icon key "smallDown" is deprecated. Use "advancedFilterBuilderSelect" for Advanced Filter Builder dropdown, "selectOpen" for Select cell editor and dropdowns (e.g. Integrated Charts menu), "richSelectOpen" for Rich Select cell editor',
  263: () => 'As of v33, icon key "smallLeft" is deprecated. Use "panelDelimiterRtl" for Row Group Panel / Pivot Panel, "subMenuOpenRtl" for sub-menus.',
  264: () => 'As of v33, icon key "smallRight" is deprecated. Use "panelDelimiter" for Row Group Panel / Pivot Panel, "subMenuOpen" for sub-menus'
};
function RF(e, t) {
  const s = FF[e];
  if (!s)
    return [`Missing error text for error id ${e}!`];
  const i = s(t), o = `
See ${Bh(e, t)}`;
  return Array.isArray(i) ? i.concat(o) : [i, o];
}
var PF = {
  1: "Charting Aggregation",
  2: "pivotResultFields",
  3: "setTooltip"
}, TF = () => ({
  checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." },
  headerCheckboxSelection: {
    version: "32.2",
    message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
  },
  headerCheckboxSelectionFilteredOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.'
  },
  headerCheckboxSelectionCurrentPageOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.'
  },
  showDisabledCheckboxes: {
    version: "32.2",
    message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
  }
}), DF = () => ({
  aggFunc: { module: "SharedAggregation" },
  autoHeight: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "RowAutoHeight"
  },
  cellClass: { module: "CellStyle" },
  cellClassRules: { module: "CellStyle" },
  cellEditor: ({ cellEditor: e, editable: t }) => {
    if (!t)
      return null;
    if (typeof e == "string") {
      const s = Ci[e];
      if (s)
        return { module: s };
    }
    return { module: "CustomEditor" };
  },
  cellRenderer: ({ cellRenderer: e }) => {
    if (typeof e != "string")
      return null;
    const t = Ci[e];
    return t ? { module: t } : null;
  },
  cellRendererParams: {
    validate: (e) => (e.rowGroup != null || e.rowGroupIndex != null || e.cellRenderer === "agGroupCellRenderer") && "checkbox" in e.cellRendererParams ? 'Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = "autoGroupColumn"` instead.' : null
  },
  cellStyle: { module: "CellStyle" },
  children: () => Np(),
  columnChooserParams: {
    module: "ColumnMenu"
  },
  contextMenuItems: { module: "ContextMenu" },
  dndSource: { module: "DragAndDrop" },
  dndSourceOnRowDrag: { module: "DragAndDrop" },
  editable: ({ editable: e, cellEditor: t }) => e && !t ? {
    module: "TextEditor"
  } : null,
  enableCellChangeFlash: { module: "HighlightChanges" },
  enablePivot: { module: "SharedPivot" },
  enableRowGroup: { module: "SharedRowGrouping" },
  enableValue: { module: "SharedAggregation" },
  filter: ({ filter: e }) => {
    if (e && typeof e != "string" && typeof e != "boolean")
      return { module: "CustomFilter" };
    if (typeof e == "string") {
      const t = Ci[e];
      if (t)
        return { module: t };
    }
    return { module: "ColumnFilter" };
  },
  floatingFilter: { module: "ColumnFilter" },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerTooltip: { module: "Tooltip" },
  headerValueGetter: {
    validate: (e) => {
      const t = e.headerValueGetter;
      return typeof t == "function" || typeof t == "string" ? null : "headerValueGetter must be a function or a valid string expression";
    }
  },
  icons: {
    validate: ({ icons: e }) => {
      if (e) {
        if (e.smallDown)
          return ut(262);
        if (e.smallLeft)
          return ut(263);
        if (e.smallRight)
          return ut(264);
      }
      return null;
    }
  },
  mainMenuItems: { module: "ColumnMenu" },
  menuTabs: (e) => {
    var s;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (s = e.menuTabs) != null && s.some((i) => t.includes(i)) ? {
      module: "ColumnMenu"
    } : null;
  },
  pivot: { module: "SharedPivot" },
  pivotIndex: { module: "SharedPivot" },
  rowDrag: { module: "RowDrag" },
  rowGroup: { module: "SharedRowGrouping" },
  rowGroupIndex: { module: "SharedRowGrouping" },
  sortingOrder: {
    validate: (e) => {
      const t = e.sortingOrder;
      if (Array.isArray(t) && t.length > 0) {
        const s = t.filter((i) => !Cr.includes(i));
        if (s.length > 0)
          return `sortingOrder must be an array with elements from [${Cr.map(mo).join()}], currently it includes [${s.map(mo).join()}]`;
      } else if (!Array.isArray(t) || t.length <= 0)
        return `sortingOrder must be an array with at least one element, currently it's ${t}`;
      return null;
    }
  },
  tooltipField: { module: "Tooltip" },
  tooltipValueGetter: { module: "Tooltip" },
  type: {
    validate: (e) => {
      const t = e.type;
      return t instanceof Array ? t.some((i) => typeof i != "string") ? "if colDef.type is supplied an array it should be of type 'string[]'" : null : typeof t == "string" ? null : "colDef.type should be of type 'string' | 'string[]'";
    }
  },
  rowSpan: {
    validate: (e, { suppressRowTransform: t }) => t ? null : "colDef.rowSpan requires suppressRowTransform to be enabled."
  }
}), EF = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0
}, MF = () => Object.keys(EF), Np = () => ({
  objectName: "colDef",
  allProperties: MF(),
  docsUrl: "column-properties/",
  deprecations: TF(),
  validations: DF()
}), AF = () => ({
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." },
  enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." },
  suppressMultiRangeSelection: {
    version: "32.2",
    message: "Use `cellSelection.suppressMultiRanges` instead."
  },
  suppressClearOnFillReduction: {
    version: "32.2",
    message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
  },
  fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." },
  fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." },
  suppressRowClickSelection: {
    version: "32.2",
    message: "Use `rowSelection.enableClickSelection` instead."
  },
  suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." },
  rowMultiSelectWithClick: {
    version: "32.2",
    message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
  },
  groupSelectsChildren: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "descendants"` instead.'
  },
  groupSelectsFiltered: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.'
  },
  isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." },
  suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." },
  onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." },
  onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." },
  suppressBrowserResizeObserver: {
    version: "32.2",
    message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
  },
  onColumnEverythingChanged: {
    version: "32.2",
    message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
  },
  groupRemoveSingleChildren: {
    version: "33",
    message: "Use `groupHideParentOfSingleChild` instead."
  },
  groupRemoveLowestSingleChildren: {
    version: "33",
    message: 'Use `groupHideParentOfSingleChild: "leafGroupsOnly"` instead.'
  },
  suppressRowGroupHidesColumns: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressHideOnGroup"` instead.'
  },
  suppressMakeColumnVisibleAfterUnGroup: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressShowOnUngroup"` instead.'
  },
  unSortIcon: { version: "33", message: "Use `defaultColDef.unSortIcon` instead." },
  sortingOrder: { version: "33", message: "Use `defaultColDef.sortingOrder` instead." },
  suppressPropertyNamesCheck: {
    version: "33",
    message: "`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant."
  }
});
function Et(e, t, s, i = Number.MAX_VALUE) {
  return typeof t == "number" || t == null ? t == null || t >= s && t <= i ? null : i === Number.MAX_VALUE ? `${e}: value should be greater than or equal to ${s}` : `${e}: value should be between ${s} and ${i}` : `${e}: value should be a number`;
}
var IF = () => {
  const e = {
    alignedGrids: { module: "AlignedGrids" },
    allowContextMenuWithControlKey: { module: "ContextMenu" },
    autoSizePadding: {
      validate({ autoSizePadding: s }) {
        return Et("autoSizePadding", s, 0);
      }
    },
    autoSizeStrategy: { module: "ColumnAutoSize" },
    cacheBlockSize: {
      supportedRowModels: ["serverSide", "infinite"],
      validate({ cacheBlockSize: s }) {
        return Et("cacheBlockSize", s, 1);
      }
    },
    cacheOverflowSize: {
      validate({ cacheOverflowSize: s }) {
        return Et("cacheOverflowSize", s, 1);
      }
    },
    cellSelection: {
      module: "CellSelection"
    },
    columnHoverHighlight: { module: "ColumnHover" },
    datasource: {
      supportedRowModels: ["infinite"],
      module: "InfiniteRowModel"
    },
    doesExternalFilterPass: { module: "ExternalFilter" },
    domLayout: {
      validate: (s) => {
        const i = s.domLayout, r = ["autoHeight", "normal", "print"];
        return i && !r.includes(i) ? `domLayout must be one of [${r.join()}], currently it's ${i}` : null;
      }
    },
    editType: {
      module: "EditCore"
    },
    enableAdvancedFilter: { module: "AdvancedFilter" },
    enableCharts: { module: "IntegratedCharts" },
    enableFillHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeSelection: {
      module: "CellSelection",
      dependencies: {
        rowDragEntireRow: { required: [!1, void 0] }
      }
    },
    getContextMenuItems: { module: "ContextMenu" },
    getLocaleText: { module: "Locale" },
    getMainMenuItems: { module: "ColumnMenu" },
    getRowClass: { module: "RowStyle" },
    getRowStyle: { module: "RowStyle" },
    grandTotalRow: { module: "SharedRowGrouping" },
    groupDefaultExpanded: {
      supportedRowModels: ["clientSide"]
    },
    groupHideOpenParents: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: {
        groupTotalRow: { required: [void 0, "bottom"] },
        treeData: {
          required: [void 0, !1],
          reason: "Tree Data has values at the group level so it doesn't make sense to hide them."
        }
      }
    },
    groupHideParentOfSingleChild: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] }
      }
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveSingleChildren: { required: [void 0, !1] }
      }
    },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveLowestSingleChildren: { required: [void 0, !1] }
      }
    },
    groupSelectsChildren: {
      dependencies: {
        rowSelection: { required: ["multiple"] }
      }
    },
    icons: {
      validate: ({ icons: s }) => {
        if (s) {
          if (s.smallDown)
            return ut(262);
          if (s.smallLeft)
            return ut(263);
          if (s.smallRight)
            return ut(264);
        }
        return null;
      }
    },
    infiniteInitialRowCount: {
      validate({ infiniteInitialRowCount: s }) {
        return Et("infiniteInitialRowCount", s, 1);
      }
    },
    initialGroupOrderComparator: {
      supportedRowModels: ["clientSide"]
    },
    initialState: { module: "GridState" },
    isExternalFilterPresent: { module: "ExternalFilter" },
    keepDetailRowsCount: {
      validate({ keepDetailRowsCount: s }) {
        return Et("keepDetailRowsCount", s, 1);
      }
    },
    localeText: {
      module: "Locale"
    },
    masterDetail: { module: "SharedMasterDetail" },
    pagination: { module: "Pagination" },
    paginationPageSize: {
      validate({ paginationPageSize: s }) {
        return Et("paginationPageSize", s, 1);
      }
    },
    paginationPageSizeSelector: {
      validate: (s) => {
        const i = s.paginationPageSizeSelector;
        return typeof i == "boolean" || i == null || i.length ? null : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
      }
    },
    pinnedTopRowData: {
      module: "PinnedRow"
    },
    pinnedBottomRowData: {
      module: "PinnedRow"
    },
    pivotMode: {
      dependencies: {
        treeData: {
          required: [!1, void 0],
          reason: "Pivot Mode is not supported with Tree Data."
        }
      },
      module: "SharedPivot"
    },
    pivotPanelShow: { module: "RowGroupingPanel" },
    quickFilterText: {
      supportedRowModels: ["clientSide"],
      module: "QuickFilter"
    },
    rowBuffer: {
      validate({ rowBuffer: s }) {
        return Et("rowBuffer", s, 0);
      }
    },
    rowClass: {
      validate: (s) => typeof s.rowClass == "function" ? "rowClass should not be a function, please use getRowClass instead" : null,
      module: "RowStyle"
    },
    rowClassRules: { module: "RowStyle" },
    rowData: {
      supportedRowModels: ["clientSide"],
      module: "ClientSideRowModel"
    },
    rowDragManaged: {
      supportedRowModels: ["clientSide"],
      dependencies: {
        treeData: {
          required: [!1, void 0]
        },
        pagination: {
          required: [!1, void 0]
        }
      },
      module: "RowDrag"
    },
    rowGroupPanelShow: { module: "RowGroupingPanel" },
    rowSelection: {
      validate({ rowSelection: s }) {
        return s && typeof s == "string" ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.' : s && typeof s != "object" ? "Expected `RowSelectionOptions` object for the `rowSelection` property." : s && s.mode !== "multiRow" && s.mode !== "singleRow" ? `Selection mode "${s.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.` : null;
      },
      module: "SharedRowSelection"
    },
    rowStyle: {
      validate: (s) => {
        const i = s.rowStyle;
        return i && typeof i == "function" ? "rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead" : null;
      },
      module: "RowStyle"
    },
    serverSideDatasource: {
      supportedRowModels: ["serverSide"],
      module: "ServerSideRowModel"
    },
    serverSideInitialRowCount: {
      supportedRowModels: ["serverSide"],
      validate({ serverSideInitialRowCount: s }) {
        return Et("serverSideInitialRowCount", s, 1);
      }
    },
    serverSideOnlyRefreshFilteredGroups: {
      supportedRowModels: ["serverSide"]
    },
    serverSideSortAllLevels: {
      supportedRowModels: ["serverSide"]
    },
    sideBar: { module: "SideBar" },
    sortingOrder: {
      validate: (s) => {
        const i = s.sortingOrder;
        if (Array.isArray(i) && i.length > 0) {
          const r = i.filter((o) => !Cr.includes(o));
          if (r.length > 0)
            return `sortingOrder must be an array with elements from [${Cr.map(mo).join()}], currently it includes [${r.map(mo).join()}]`;
        } else if (!Array.isArray(i) || i.length <= 0)
          return `sortingOrder must be an array with at least one element, currently it's ${i}`;
        return null;
      }
    },
    statusBar: { module: "StatusBar" },
    tooltipHideDelay: {
      validate: (s) => s.tooltipHideDelay && s.tooltipHideDelay < 0 ? "tooltipHideDelay should not be lower than 0" : null
    },
    tooltipShowDelay: {
      validate: (s) => s.tooltipShowDelay && s.tooltipShowDelay < 0 ? "tooltipShowDelay should not be lower than 0" : null
    },
    treeData: {
      supportedRowModels: ["clientSide", "serverSide"],
      module: "SharedTreeData",
      validate: (s) => {
        const i = s.rowModelType ?? "clientSide";
        switch (i) {
          case "clientSide": {
            const r = `treeData requires 'getDataPath' in the ${i} row model.`;
            return s.treeDataChildrenField || s.getDataPath ? null : r;
          }
          case "serverSide": {
            const r = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${i} row model.`;
            return s.isServerSideGroup && s.getServerSideGroupKey ? null : r;
          }
        }
        return null;
      }
    },
    treeDataChildrenField: {
      module: "SharedTreeData"
    },
    undoRedoCellEditing: { module: "UndoRedoEdit" },
    valueCache: { module: "ValueCache" },
    viewportDatasource: {
      supportedRowModels: ["viewport"],
      module: "ViewportRowModel"
    },
    viewportRowModelBufferSize: {
      validate({ viewportRowModelBufferSize: s }) {
        return Et("viewportRowModelBufferSize", s, 0);
      }
    },
    viewportRowModelPageSize: {
      validate({ viewportRowModelPageSize: s }) {
        return Et("viewportRowModelPageSize", s, 1);
      }
    },
    rowDragEntireRow: {
      dependencies: {
        cellSelection: { required: [void 0] }
      }
    }
  }, t = {};
  return Gp.forEach((s) => {
    t[s] = { expectedType: "boolean" };
  }), Op.forEach((s) => {
    t[s] = { expectedType: "number" };
  }), pe(t, e), t;
}, LF = () => ({
  objectName: "gridOptions",
  allProperties: [...Aa, ...kp.map((e) => dl(e))],
  propertyExceptions: ["api", "treeDataChildrenField"],
  docsUrl: "grid-options/",
  deprecations: AF(),
  validations: IF()
}), kF = {
  expanded: 1,
  contracted: 1,
  "tree-closed": 1,
  "tree-open": 1,
  "tree-indeterminate": 1,
  pin: 1,
  "eye-slash": 1,
  arrows: 1,
  left: 1,
  right: 1,
  group: 1,
  aggregation: 1,
  pivot: 1,
  "not-allowed": 1,
  chart: 1,
  cross: 1,
  cancel: 1,
  tick: 1,
  first: 1,
  previous: 1,
  next: 1,
  last: 1,
  linked: 1,
  unlinked: 1,
  "color-picker": 1,
  loading: 1,
  menu: 1,
  "menu-alt": 1,
  filter: 1,
  columns: 1,
  maximize: 1,
  minimize: 1,
  copy: 1,
  cut: 1,
  paste: 1,
  grip: 1,
  save: 1,
  csv: 1,
  excel: 1,
  "small-down": 1,
  "small-left": 1,
  "small-right": 1,
  "small-up": 1,
  asc: 1,
  desc: 1,
  none: 1,
  up: 1,
  down: 1,
  plus: 1,
  minus: 1,
  settings: 1,
  "checkbox-checked": 1,
  "checkbox-indeterminate": 1,
  "checkbox-unchecked": 1,
  "radio-button-on": 1,
  "radio-button-off": 1,
  eye: 1
}, OF = {
  chart: "MenuCore",
  cancel: "EnterpriseCore",
  first: "Pagination",
  previous: "Pagination",
  next: "Pagination",
  last: "Pagination",
  linked: "IntegratedCharts",
  loadingMenuItems: "MenuCore",
  unlinked: "IntegratedCharts",
  menu: "ColumnHeaderComp",
  legacyMenu: "ColumnMenu",
  filter: "ColumnFilter",
  filterActive: "ColumnFilter",
  filterTab: "ColumnMenu",
  filtersToolPanel: "FiltersToolPanel",
  columns: ["MenuCore"],
  columnsToolPanel: ["ColumnsToolPanel"],
  maximize: "EnterpriseCore",
  minimize: "EnterpriseCore",
  save: "MenuCore",
  columnGroupOpened: "ColumnGroupHeaderComp",
  columnGroupClosed: "ColumnGroupHeaderComp",
  accordionOpen: "EnterpriseCore",
  accordionClosed: "EnterpriseCore",
  accordionIndeterminate: "EnterpriseCore",
  columnSelectClosed: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectOpen: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectIndeterminate: ["ColumnsToolPanel", "ColumnMenu"],
  columnMovePin: "SharedDragAndDrop",
  columnMoveHide: "SharedDragAndDrop",
  columnMoveMove: "SharedDragAndDrop",
  columnMoveLeft: "SharedDragAndDrop",
  columnMoveRight: "SharedDragAndDrop",
  columnMoveGroup: "SharedDragAndDrop",
  columnMoveValue: "SharedDragAndDrop",
  columnMovePivot: "SharedDragAndDrop",
  dropNotAllowed: "SharedDragAndDrop",
  groupContracted: "GroupCellRenderer",
  groupExpanded: "GroupCellRenderer",
  setFilterGroupClosed: "SetFilter",
  setFilterGroupOpen: "SetFilter",
  setFilterGroupIndeterminate: "SetFilter",
  close: "EnterpriseCore",
  check: "MenuItem",
  colorPicker: "CommunityCore",
  groupLoading: "LoadingCellRenderer",
  menuAlt: "ColumnHeaderComp",
  menuPin: "MenuCore",
  menuValue: "MenuCore",
  menuAddRowGroup: ["MenuCore", "ColumnsToolPanel"],
  menuRemoveRowGroup: ["MenuCore", "ColumnsToolPanel"],
  clipboardCopy: "MenuCore",
  clipboardCut: "MenuCore",
  clipboardPaste: "MenuCore",
  pivotPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  rowGroupPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  valuePanel: "ColumnsToolPanel",
  columnDrag: "EnterpriseCore",
  rowDrag: ["RowDrag", "DragAndDrop"],
  csvExport: "MenuCore",
  excelExport: "MenuCore",
  smallDown: "CommunityCore",
  selectOpen: "CommunityCore",
  richSelectOpen: "RichSelect",
  richSelectRemove: "RichSelect",
  smallLeft: "CommunityCore",
  smallRight: "CommunityCore",
  subMenuOpen: "MenuItem",
  subMenuOpenRtl: "MenuItem",
  panelDelimiter: "RowGroupingPanel",
  panelDelimiterRtl: "RowGroupingPanel",
  smallUp: "CommunityCore",
  sortAscending: ["MenuCore", "Sort"],
  sortDescending: ["MenuCore", "Sort"],
  sortUnSort: ["MenuCore", "Sort"],
  advancedFilterBuilder: "AdvancedFilter",
  advancedFilterBuilderDrag: "AdvancedFilter",
  advancedFilterBuilderInvalid: "AdvancedFilter",
  advancedFilterBuilderMoveUp: "AdvancedFilter",
  advancedFilterBuilderMoveDown: "AdvancedFilter",
  advancedFilterBuilderAdd: "AdvancedFilter",
  advancedFilterBuilderRemove: "AdvancedFilter",
  advancedFilterBuilderSelectOpen: "AdvancedFilter",
  chartsMenu: "IntegratedCharts",
  chartsMenuEdit: "IntegratedCharts",
  chartsMenuAdvancedSettings: "IntegratedCharts",
  chartsMenuAdd: "IntegratedCharts",
  chartsColorPicker: "IntegratedCharts",
  chartsThemePrevious: "IntegratedCharts",
  chartsThemeNext: "IntegratedCharts",
  chartsDownload: "IntegratedCharts",
  checkboxChecked: "CommunityCore",
  checkboxIndeterminate: "CommunityCore",
  checkboxUnchecked: "CommunityCore",
  radioButtonOn: "CommunityCore",
  radioButtonOff: "CommunityCore"
}, GF = /* @__PURE__ */ new Set([
  "colorPicker",
  "smallUp",
  "checkboxChecked",
  "checkboxIndeterminate",
  "checkboxUnchecked",
  "radioButtonOn",
  "radioButtonOff",
  "smallDown",
  "smallLeft",
  "smallRight"
]), BF = {
  pinSubMenu: "PinnedColumn",
  pinLeft: "PinnedColumn",
  pinRight: "PinnedColumn",
  clearPinned: "PinnedColumn",
  valueAggSubMenu: "SharedAggregation",
  autoSizeThis: "ColumnAutoSize",
  autoSizeAll: "ColumnAutoSize",
  rowGroup: "SharedRowGrouping",
  rowUnGroup: "SharedRowGrouping",
  resetColumns: "CommunityCore",
  expandAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  contractAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  copy: "Clipboard",
  copyWithHeaders: "Clipboard",
  copyWithGroupHeaders: "Clipboard",
  cut: "Clipboard",
  paste: "Clipboard",
  export: ["CsvExport", "ExcelExport"],
  csvExport: "CsvExport",
  excelExport: "ExcelExport",
  separator: "CommunityCore",
  pivotChart: "IntegratedCharts",
  chartRange: "IntegratedCharts",
  columnFilter: "ColumnFilter",
  columnChooser: "ColumnMenu",
  sortAscending: "Sort",
  sortDescending: "Sort",
  sortUnSort: "Sort"
}, VF = class extends P {
  constructor() {
    super(...arguments), this.beanName = "validation";
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, xC(this);
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  warnOnInitialPropertyUpdate(e, t) {
    e === "api" && gF[t] && R(22, { key: t });
  }
  processGridOptions(e) {
    this.processOptions(e, LF());
  }
  validateApiFunction(e, t) {
    return CF(e, t, this.beans);
  }
  missingUserComponent(e, t, s, i) {
    const r = Ci[t];
    r ? this.gos.assertModuleRegistered(
      r,
      `AG Grid '${e}' component: ${t}`
    ) : R(101, {
      propertyName: e,
      componentName: t,
      agGridDefaults: s,
      jsComps: i
    });
  }
  checkRowEvents(e) {
    HF.has(e) && R(10, { eventType: e });
  }
  validateIcon(e) {
    if (GF.has(e) && R(43, { iconName: e }), kF[e])
      return;
    const t = OF[e];
    if (t) {
      z(200, {
        reasonOrId: `icon '${e}'`,
        moduleName: t,
        gridScoped: gl(),
        gridId: this.beans.context.getGridId(),
        rowModelType: this.gos.get("rowModelType"),
        additionalText: "Alternatively, use the CSS icon name directly."
      });
      return;
    }
    R(134, { iconName: e });
  }
  validateMenuItem(e) {
    const t = BF[e];
    t && this.gos.assertModuleRegistered(t, `menu item '${e}'`);
  }
  isProvidedUserComp(e) {
    return !!Ci[e];
  }
  validateColDef(e, t, s) {
    var i;
    (s || !((i = this.beans.dataTypeSvc) != null && i.isColPendingInference(t))) && this.processOptions(e, Np());
  }
  processOptions(e, t) {
    const { validations: s, deprecations: i, allProperties: r, propertyExceptions: o, objectName: n, docsUrl: a } = t;
    r && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...o ?? [], ...Object.keys(i)],
      r,
      n,
      a
    );
    const l = /* @__PURE__ */ new Set(), d = (h) => {
      const u = s[h];
      if (u)
        if (typeof u == "function") {
          const p = u(e, this.gridOptions, this.beans);
          if (!p)
            return;
          if ("objectName" in p) {
            const g = e[h];
            if (Array.isArray(g)) {
              g.forEach((f) => {
                this.processOptions(f, p);
              });
              return;
            }
            this.processOptions(e[h], p);
            return;
          }
          return p;
        } else
          return u;
      else return;
    };
    Object.keys(e).forEach((h) => {
      const u = i[h];
      if (u) {
        const { message: y, version: F } = u;
        l.add(`As of v${F}, ${String(h)} is deprecated. ${y ?? ""}`);
      }
      const p = e[h];
      if (p == null || p === !1)
        return;
      const g = d(h);
      if (!g)
        return;
      const { module: f, dependencies: m, validate: C, supportedRowModels: v, expectedType: b } = g;
      if (b) {
        const y = typeof p;
        if (y !== b) {
          l.add(
            `${String(h)} should be of type '${b}' but received '${y}' (${p}).`
          );
          return;
        }
      }
      if (v) {
        const y = this.gridOptions.rowModelType ?? "clientSide";
        if (!v.includes(y)) {
          l.add(
            `${String(h)} is not supported with the '${y}' row model. It is only valid with: ${v.join(", ")}.`
          );
          return;
        }
      }
      if (f) {
        const y = Array.isArray(f) ? f : [f];
        let F = !0;
        if (y.forEach((D) => {
          this.gos.assertModuleRegistered(D, String(h)) || (F = !1);
        }), !F)
          return;
      }
      if (m) {
        const y = this.checkForRequiredDependencies(h, m, e);
        if (y) {
          l.add(y);
          return;
        }
      }
      if (C) {
        const y = C(e, this.gridOptions, this.beans);
        if (y) {
          l.add(y);
          return;
        }
      }
    }), l.size > 0 && l.forEach((h) => {
      kt(h);
    });
  }
  checkForRequiredDependencies(e, t, s) {
    const r = Object.entries(t).filter(([o, n]) => {
      const a = s[o];
      return !n.required.includes(a);
    });
    return r.length === 0 ? null : r.map(
      ([o, n]) => `'${String(e)}' requires '${o}' to be one of [${n.required.map((a) => a === null ? "null" : a === void 0 ? "undefined" : a).join(", ")}]. ${n.reason ?? ""}`
    ).join(`
           `);
  }
  checkProperties(e, t, s, i, r) {
    const o = ["__ob__", "__v_skip", "__metadata__"], n = NF(
      Object.getOwnPropertyNames(e),
      [...o, ...t, ...s],
      s
    );
    if (Object.entries(n).forEach(([a, l]) => {
      let d = `invalid ${i} property '${a}' did you mean any of these: ${l.slice(0, 8).join(", ")}.`;
      s.includes("context") && (d += `
If you are trying to annotate ${i} with application data, use the '${i}.context' property instead.`), kt(d);
    }), Object.keys(n).length > 0 && r) {
      const a = this.beans.frameworkOverrides.getDocLink(r);
      kt(`to see all the valid ${i} properties please check: ${a}`);
    }
  }
  getConsoleMessage(e, t) {
    return RF(e, t);
  }
};
function NF(e, t, s) {
  const i = {}, r = e.filter(
    (o) => !t.some((n) => n === o)
  );
  return r.length > 0 && r.forEach(
    (o) => i[o] = un({ inputValue: o, allSuggestions: s }).values
  ), i;
}
var HF = /* @__PURE__ */ new Set([
  "firstChildChanged",
  "lastChildChanged",
  "childIndexChanged"
]), Hp = {
  moduleName: "Validation",
  version: G,
  beans: [VF]
};
function zp(e) {
  e.sibling && (e.sibling.childrenAfterFilter = e.childrenAfterFilter);
}
var zF = class extends P {
  constructor() {
    super(...arguments), this.beanName = "filterStage", this.refreshProps = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), this.step = "filter";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var s;
    const t = !!((s = this.filterManager) != null && s.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const s = (i, r) => {
      i.hasChildren() && e && !r ? i.childrenAfterFilter = i.childrenAfterGroup.filter((o) => {
        const n = o.childrenAfterFilter && o.childrenAfterFilter.length > 0, a = o.data && this.filterManager.doesRowPassFilter({ rowNode: o });
        return n || a;
      }) : i.childrenAfterFilter = i.childrenAfterGroup, zp(i);
    };
    if (this.doingTreeDataFiltering()) {
      const i = (o, n) => {
        if (o.childrenAfterGroup)
          for (let a = 0; a < o.childrenAfterGroup.length; a++) {
            const l = o.childrenAfterGroup[a], d = n || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? i(o.childrenAfterGroup[a], d) : s(l, d);
          }
        s(o, n);
      }, r = (o) => i(o, !1);
      t.executeFromRootNode(r);
    } else {
      const i = (r) => s(r, !1);
      t.forEachChangedNodeDepthFirst(i, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, WF = class extends El {
  constructor() {
    super(...arguments), this.iconCreated = !1;
  }
  setComp(e, t, s, i, r) {
    this.comp = e;
    const o = xr(this, this.beans.context, r);
    this.eButtonShowMainFilter = s, this.eFloatingFilterBody = i, this.setGui(t, o), this.setupActive(), this.setupWidth(o), this.setupLeft(o), this.setupHover(o), this.setupFocus(o), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(o), this.setupUi(), o.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(o), o.addManagedListeners(this.column, { colDefChanged: () => this.onColDefChanged(o) }), o.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.clearComponent();
    });
  }
  // empty abstract method
  resizeHeader() {
  }
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, s = !!e.floatingFilter;
    this.active = t && s;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = B("filter", this.beans, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus(e) {
    e.createManagedBean(
      new Ps(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.getLocaleTextFunc();
    oe(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    var n;
    const { beans: t } = this;
    if (q(t) === this.eGui)
      return;
    const r = Pe(t, this.eGui, null, e.shiftKey);
    if (r) {
      (n = t.headerNavigation) == null || n.scrollToColumn(this.column), e.preventDefault(), r.focus();
      return;
    }
    const o = this.findNextColumnWithFloatingFilter(e.shiftKey);
    o && t.focusSvc.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.rowCtrl.rowIndex,
        column: o
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleCols;
    let s = this.column;
    do
      if (s = e ? t.getColBefore(s) : t.getColAfter(s), !s)
        break;
    while (!s.getColDef().filter || !s.getColDef().floatingFilter);
    return s;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case w.UP:
      case w.DOWN:
        t || e.preventDefault();
      case w.LEFT:
      case w.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case w.ENTER:
        t && ve(this.eGui) && e.preventDefault();
        break;
      case w.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const s = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), i = !!e.relatedTarget && Hs(e.relatedTarget, "ag-floating-filter");
    if (s && i && e.target === this.eGui) {
      const r = this.lastFocusEvent, o = !!(r && r.key === w.TAB);
      if (r && o) {
        const n = r.shiftKey;
        ve(this.eGui, n);
      }
    }
    this.focusThis();
  }
  setupHover(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderFilterColumnHoverListener(e, this.comp, this.column, this.eGui);
  }
  setupLeft(e) {
    const t = new Dl(this.column, this.eGui, this.beans);
    e.createManagedBean(t);
  }
  setupFilterButton() {
    var e;
    this.suppressFilterButton = !((e = this.beans.menuSvc) != null && e.isFloatingFilterButtonEnabled(this.column)), this.highlightFilterButtonWhenActive = !we(this.gos);
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.filterManager) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    var t;
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    (t = this.beans.menuSvc) == null || t.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter(e) {
    if (!this.active)
      return;
    const { filterManager: t } = this.beans, s = (i) => {
      if ((i == null ? void 0 : i.source) === "filterDestroyed" && !this.isAlive())
        return;
      const r = this.comp.getFloatingFilterComp();
      r && r.then((o) => {
        if (o) {
          const n = t == null ? void 0 : t.getCurrentFloatingFilterParentModel(this.column), a = i ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...i,
            columns: i.columns ?? [],
            source: i.source === "api" ? "api" : "columnFilter"
          } : null;
          o.onParentModelChanged(n, a);
        }
      });
    };
    [this.destroySyncListener] = e.addManagedListeners(this.column, { filterChanged: s }), t != null && t.isFilterActive(this.column) && s(null);
  }
  setupWidth(e) {
    const t = () => {
      const s = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(s);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupFilterChangedListener(e) {
    this.active && ([this.destroyFilterChangedListener] = e.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged(e) {
    var o;
    const t = this.active;
    this.setupActive();
    const s = !t && this.active;
    t && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const i = this.active ? (o = this.beans.filterManager) == null ? void 0 : o.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, r = this.comp.getFloatingFilterComp();
    !r || !i ? this.updateCompDetails(e, i, s) : r.then((n) => {
      var a;
      !n || (a = this.beans.filterManager) != null && a.areFilterCompsDifferent(this.userCompDetails ?? null, i) ? this.updateCompDetails(e, i, s) : this.updateFloatingFilterParams(i);
    });
  }
  updateCompDetails(e, t, s) {
    this.isAlive() && (this.setCompDetails(t), this.setupFilterButton(), this.setupUi(), s && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)));
  }
  updateFloatingFilterParams(e) {
    var s;
    if (!e)
      return;
    const t = e.params;
    (s = this.comp.getFloatingFilterComp()) == null || s.then((i) => {
      i != null && i.refresh && typeof i.refresh == "function" && i.refresh(t);
    });
  }
  addResizeAndMoveKeyboardListeners() {
  }
  destroy() {
    super.destroy(), this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
};
function _F(e, t) {
  var i;
  const s = e.colModel.getCol(t);
  if (!s) {
    z(12, { colKey: t });
    return;
  }
  (i = e.menuSvc) == null || i.showColumnMenu({
    column: s,
    positionBy: "auto"
  });
}
function UF(e) {
  var t;
  (t = e.menuSvc) == null || t.hidePopupMenu();
}
var Wp = {
  moduleName: "SharedMenu",
  version: G,
  beans: [yy],
  apiFunctions: {
    showColumnMenu: _F,
    hidePopupMenu: UF
  }
}, KF = 0, $F = 200, jF = class extends P {
  constructor() {
    super(...arguments), this.beanName = "popupSvc", this.popupList = [];
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: s } = e, i = this.getPopupIndex(s);
    if (i !== -1) {
      const p = this.popupList[i];
      p.alignedToElement = t;
    }
    const r = t.getBoundingClientRect(), o = this.getParentRect(), n = this.keepXYWithinBounds(
      s,
      r.top - o.top,
      0
      /* vertical */
    ), a = s.clientWidth > 0 ? s.clientWidth : 200;
    s.style.minWidth = `${a}px`;
    const d = o.right - o.left - a;
    let c;
    this.gos.get("enableRtl") ? (c = u(), c < 0 && (c = h(), this.setAlignedStyles(s, "left")), c > d && (c = 0, this.setAlignedStyles(s, "right"))) : (c = h(), c > d && (c = u(), this.setAlignedStyles(s, "right")), c < 0 && (c = 0, this.setAlignedStyles(s, "left"))), s.style.left = `${c}px`, s.style.top = `${n}px`;
    function h() {
      return r.right - o.left - 2;
    }
    function u() {
      return r.left - o.left - a;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: s, nudgeY: i, skipObserver: r } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: !0,
      skipObserver: r,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        e.type,
        e.ePopup,
        null,
        e.mouseEvent,
        e.column,
        e.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: r,
      eventSource: o,
      alignSide: n = "left",
      position: a = "over",
      column: l,
      rowNode: d,
      type: c
    } = e, h = o.getBoundingClientRect(), u = this.getParentRect(), p = this.getPopupIndex(t);
    if (p !== -1) {
      const f = this.popupList[p];
      f.alignedToElement = o;
    }
    const g = () => {
      let f = h.left - u.left;
      n === "right" && (f -= t.offsetWidth - h.width);
      let m;
      return a === "over" ? (m = h.top - u.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, h, u, e.nudgeY || 0) === "under" ? m = h.top - u.top + h.height : m = h.top - t.offsetHeight - (i || 0) * 2 - u.top), { x: f, y: m };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: r,
      updatePosition: g,
      postProcessCallback: () => this.callPostProcessPopup(c, t, o, null, l, d)
    });
  }
  shouldRenderUnderOrAbove(e, t, s, i) {
    const r = s.bottom - t.bottom, o = t.top - s.top, n = e.offsetHeight + i;
    return r > n ? "under" : o > n || o > r ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const s = this.getPopupIndex(e);
    if (s === -1)
      return;
    const i = this.popupList[s], { alignedToElement: r } = i;
    !r || (["right", "left", "over", "above", "under"].forEach((n) => {
      r.classList.remove(`ag-has-popup-positioned-${n}`), e.classList.remove(`ag-popup-positioned-${n}`);
    }), !t) || (r.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, s, i, r, o) {
    const n = this.gos.getCallback("postProcessPopup");
    n && n({
      column: r,
      rowNode: o,
      ePopup: t,
      type: e,
      eventSource: s,
      mouseEvent: i
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: s, nudgeX: i, nudgeY: r, skipObserver: o, updatePosition: n } = e, a = { width: 0, height: 0 }, l = (d = !1) => {
      let { x: c, y: h } = n();
      d && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, i && (c += i), r && (h += r), s && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* horizontal */
      ), h = this.keepXYWithinBounds(
        t,
        h,
        0
        /* vertical */
      )), t.style.left = `${c}px`, t.style.top = `${h}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !o) {
      const d = Rt(this.beans, t, () => l(!0));
      setTimeout(() => d(), $F);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getParentRect() {
    const e = Z(this.beans);
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), Ph(t);
  }
  keepXYWithinBounds(e, t, s) {
    const i = s === 0, r = i ? "clientHeight" : "clientWidth", o = i ? "top" : "left", n = i ? "height" : "width", a = i ? "scrollTop" : "scrollLeft", l = Z(this.beans), d = l.documentElement, c = this.getPopupParent(), h = e.getBoundingClientRect(), u = c.getBoundingClientRect(), p = l.documentElement.getBoundingClientRect(), g = c === l.body, f = Math.ceil(h[n]);
    let C = g ? (i ? jo : $s)(d) + d[a] : c[r];
    g && (C -= Math.abs(p[o] - u[o]));
    const v = C - f;
    return Math.min(Math.max(t, 0), Math.abs(v));
  }
  addPopup(e) {
    const t = Z(this.beans), { eChild: s, ariaLabel: i, alwaysOnTop: r, positionCallback: o, anchorToElement: n } = e;
    if (!t)
      return R(122), { hideFunc: () => {
      } };
    const a = this.getPopupIndex(s);
    if (a !== -1)
      return { hideFunc: this.popupList[a].hideFunc };
    this.initialisePopupPosition(s);
    const l = this.createPopupWrapper(s, i, !!r), d = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return o && o(), this.addPopupToPopupList(s, l, d, n), {
      hideFunc: d
    };
  }
  initialisePopupPosition(e) {
    const s = this.getPopupParent().getBoundingClientRect();
    A(e.style.top) || (e.style.top = `${s.top * -1}px`), A(e.style.left) || (e.style.left = `${s.left * -1}px`);
  }
  createPopupWrapper(e, t, s) {
    const i = this.getPopupParent(), r = document.createElement("div"), { environment: o, gos: n } = this.beans;
    return o.applyThemeClasses(r), r.classList.add("ag-popup"), e.classList.add(n.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || re(e, "dialog"), oe(e, t), r.appendChild(e), i.appendChild(r), s ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), r;
  }
  handleThemeChange(e) {
    if (e.themeChanged) {
      const t = this.beans.environment;
      for (const s of this.popupList)
        t.applyThemeClasses(s.wrapper);
    }
  }
  addEventListenersToPopup(e) {
    const t = this.beans, s = Z(t), i = this.getPopupParent(), { wrapperEl: r, eChild: o, closedCallback: n, afterGuiAttached: a, closeOnEsc: l, modal: d } = e;
    let c = !1;
    const h = (f) => {
      if (!r.contains(q(t)))
        return;
      f.key === w.ESCAPE && !nt(f) && g({ keyboardEvent: f });
    }, u = (f) => g({ mouseEvent: f }), p = (f) => g({ touchEvent: f }), g = (f = {}) => {
      const { mouseEvent: m, touchEvent: C, keyboardEvent: v, forceHide: b } = f;
      !b && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: m, touchEvent: C }, o) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      c) || (c = !0, i.removeChild(r), s.removeEventListener("keydown", h), s.removeEventListener("mousedown", u), s.removeEventListener("touchstart", p), s.removeEventListener("contextmenu", u), this.eventSvc.removeEventListener("dragStarted", u), n && n(m || C || v), this.removePopupFromPopupList(o));
    };
    return a && a({ hidePopup: g }), window.setTimeout(() => {
      l && s.addEventListener("keydown", h), d && (s.addEventListener("mousedown", u), this.eventSvc.addEventListener("dragStarted", u), s.addEventListener("touchstart", p), s.addEventListener("contextmenu", u));
    }, 0), g;
  }
  addPopupToPopupList(e, t, s, i) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: s,
      instanceId: KF++,
      isAnchored: !!i
    }), i && this.setPopupPositionRelatedToElement(e, i);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const s = this.getPopupIndex(e);
    if (s === -1)
      return;
    const i = this.popupList[s];
    if (i.stopAnchoringPromise && i.stopAnchoringPromise.then((o) => o && o()), i.stopAnchoringPromise = void 0, i.isAnchored = !1, !t)
      return;
    const r = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: i.hideFunc
    });
    return i.stopAnchoringPromise = r, i.isAnchored = !0, r;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), s = t.getBoundingClientRect(), { element: i, ePopup: r } = e, o = i.getBoundingClientRect(), n = (h) => parseInt(h.substring(0, h.length - 1), 10), a = (h, u) => {
      const p = s[h] - o[h], g = n(r.style[h]);
      return {
        initialDiff: p,
        lastDiff: p,
        initial: g,
        last: g,
        direction: u
      };
    }, l = a(
      "top",
      0
      /* vertical */
    ), d = a(
      "left",
      1
      /* horizontal */
    ), c = this.beans.frameworkOverrides;
    return new U((h) => {
      c.wrapIncoming(() => {
        c.setInterval(() => {
          const u = t.getBoundingClientRect(), p = i.getBoundingClientRect();
          if (p.top == 0 && p.left == 0 && p.height == 0 && p.width == 0) {
            e.hidePopup();
            return;
          }
          const f = (m, C) => {
            const v = n(r.style[C]);
            m.last !== v && (m.initial = v, m.last = v);
            const b = u[C] - p[C];
            if (b != m.lastDiff) {
              const y = this.keepXYWithinBounds(
                r,
                m.initial + m.initialDiff - b,
                m.direction
              );
              r.style[C] = `${y}px`, m.last = y;
            }
            m.lastDiff = b;
          };
          f(l, "top"), f(d, "left");
        }, 200).then((u) => {
          h(() => {
            u != null && window.clearInterval(u);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: s, touchEvent: i } = e, r = s || i;
    if (!r)
      return !1;
    const o = this.getPopupIndex(t);
    if (o === -1)
      return !1;
    for (let n = o; n < this.popupList.length; n++) {
      const a = this.popupList[n];
      if (wa(a.element, r))
        return !0;
    }
    return this.isElementWithinCustomPopup(r.target);
  }
  isElementWithinCustomPopup(e) {
    const t = Z(this.beans);
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const s = this.getWrapper(e);
    s && (s.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(s));
  }
  /** @return true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), s = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), i = s.length, r = this.getWrapper(e);
    if (!r || i <= 1 || !t.contains(e))
      return;
    const o = [], n = [];
    for (const u of s)
      u !== r && (u.classList.contains("ag-always-on-top") ? n.push(u) : o.push(u));
    const a = [], l = n.length, h = r.classList.contains("ag-always-on-top") || !l ? [...o, ...n, r] : [...o, r, ...n];
    for (let u = 0; u <= i; u++) {
      const p = h[u];
      if (s[u] === h[u] || p === r)
        continue;
      p.querySelectorAll("div").forEach((f) => {
        f.scrollTop !== 0 && a.push([f, f.scrollTop]);
      }), u === 0 ? t.insertAdjacentElement("afterbegin", p) : h[u - 1].insertAdjacentElement("afterend", p);
    }
    for (; a.length; ) {
      const u = a.pop();
      u[0].scrollTop = u[1];
    }
  }
}, ts = {
  moduleName: "Popup",
  version: G,
  beans: [jF]
}, qF = (
  /*css*/
  ".ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-set-floating-filter-input [disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:1px solid var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}"
);
function YF(e) {
  const t = e.filterManager;
  return !!(t != null && t.isColumnFilterPresent()) || !!(t != null && t.isAggregateFilterPresent());
}
function XF(e, t) {
  var s;
  return ((s = e.filterManager) == null ? void 0 : s.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function ZF(e, t) {
  var i;
  const s = e.colModel.getColDefCol(t);
  if (s)
    return (i = e.filterManager) == null ? void 0 : i.destroyFilter(s, "api");
}
function QF(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.filterManager) == null ? void 0 : s.setFilterModel(t);
  });
}
function JF(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function eR(e, t) {
  var s;
  return ((s = e.filterManager) == null ? void 0 : s.getColumnFilterModel(t)) ?? null;
}
function tR(e, t, s) {
  var i;
  return ((i = e.filterManager) == null ? void 0 : i.setColumnFilterModel(t, s)) ?? Promise.resolve();
}
function sR(e, t) {
  var i;
  const s = e.colModel.getCol(t);
  if (!s) {
    z(12, { colKey: t });
    return;
  }
  (i = e.menuSvc) == null || i.showFilterMenu({
    column: s,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
var tc = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, sc = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
function iR(e, t) {
  return e == null ? -1 : t == null ? 1 : parseFloat(e) - parseFloat(t);
}
var rR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colFilter", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  postConstruct() {
    var e, t;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      beforeRefreshModel: ({ params: s }) => {
        var i;
        (s.rowDataUpdated || (i = s.changedProps) != null && i.has("treeData")) && this.onNewRowsLoaded("rowDataUpdated");
      },
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.initialFilterModel = {
      ...((t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) ?? {}
    };
  }
  setFilterModel(e, t = "api") {
    const { colModel: s, dataTypeSvc: i, filterManager: r } = this.beans;
    if (i != null && i.isPendingInference) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const o = [], n = this.getFilterModel(!0);
    if (e) {
      const a = new Set(Object.keys(e));
      this.allColumnFilters.forEach((l, d) => {
        const c = e[d];
        o.push(Ur(l.filterPromise, c)), a.delete(d);
      }), a.forEach((l) => {
        const d = s.getColDefCol(l) || s.getCol(l);
        if (!d) {
          R(62, { colId: l });
          return;
        }
        if (!d.isFilterAllowed()) {
          R(63, { colId: l });
          return;
        }
        const c = this.getOrCreateFilterWrapper(d);
        if (!c) {
          R(64, { colId: l });
          return;
        }
        o.push(Ur(c.filterPromise, e[l]));
      });
    } else
      this.allColumnFilters.forEach((a) => {
        o.push(Ur(a.filterPromise, null));
      });
    U.all(o).then(() => {
      const a = this.getFilterModel(!0), l = [];
      this.allColumnFilters.forEach((d, c) => {
        const h = n ? n[c] : null, u = a ? a[c] : null;
        bi(h, u) || l.push(d.column);
      }), l.length > 0 && (r == null || r.onFilterChanged({ columns: l, source: t }));
    });
  }
  getFilterModel(e) {
    const t = {}, {
      allColumnFilters: s,
      initialFilterModel: i,
      beans: { colModel: r }
    } = this;
    return s.forEach((o, n) => {
      const a = this.getModelFromFilterWrapper(o);
      A(a) && (t[n] = a);
    }), e || Object.entries(i).forEach(([o, n]) => {
      var a;
      A(n) && !s.has(o) && ((a = r.getCol(o)) != null && a.isFilterAllowed()) && (t[o] = n);
    }), t;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (R(66), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    const { allColumnFilters: e } = this;
    return e.size ? (e.forEach(
      (t) => this.disposeFilterWrapper(t, "advancedFilterEnabled")
    ), !0) : !1;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  updateActiveFilters() {
    const e = (a) => a ? a.isFilterActive ? a.isFilterActive() : (R(67), !1) : !1, { colModel: t, gos: s } = this.beans, i = !!ur(s), r = (a) => {
      if (!a.isPrimary())
        return !0;
      const d = !t.isPivotActive();
      return !a.isValueActive() || !d ? !1 : t.isPivotMode() ? !0 : i;
    }, o = [], n = [];
    return this.forEachColumnFilter((a, l) => {
      e(a) && (r(l.column) ? o.push(a) : n.push(a));
    }).then(() => {
      this.activeAggregateFilters = o, this.activeColumnFilters = n;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter(
      (s, i) => this.setColFilterActive(i.column, s.isFilterActive(), e, t)
    );
  }
  forEachColumnFilter(e) {
    const t = [];
    return this.allColumnFilters.forEach((s) => {
      const i = s.filterPromise;
      i && t.push(i.then((r) => e(r, s)));
    }), U.all(t);
  }
  doColumnFiltersPass(e, t, s) {
    const { data: i, aggData: r } = e, o = s ? this.activeAggregateFilters : this.activeColumnFilters, n = s ? r : i;
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function") {
          z(91);
          continue;
        }
        if (!l.doesFilterPass({ node: e, data: n }))
          return !1;
      }
    }
    return !0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const { rowRenderer: t, filterManager: s } = this.beans, i = () => {
      this.isAlive() && (s == null || s.onFilterChanged(e));
    };
    t.isRefreshInProgress() ? setTimeout(i, 0) : i();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: s } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", s).then(() => {
        this.allColumnFilters.forEach((i) => {
          i.filterPromise && i.filterPromise.then((r) => {
            r && r !== t && r.onAnyFilterChanged && r.onAnyFilterChanged();
          });
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      var s;
      (s = t.onNewRowsLoaded) == null || s.call(t);
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 })).then(() => this.updateActiveFilters());
  }
  createGetValue(e) {
    const { filterValueSvc: t, colModel: s } = this.beans;
    return (i, r) => {
      const o = r ? s.getCol(r) : e;
      return o ? t.getValue(o, i) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed())
      return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    let t;
    const { gos: s, dataTypeSvc: i } = this.beans;
    if (kn(s))
      t = "agSetColumnFilter";
    else {
      const r = i == null ? void 0 : i.getBaseDataType(e);
      r === "number" ? t = "agNumberColumnFilter" : r === "date" || r === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    let t;
    const { gos: s, dataTypeSvc: i } = this.beans;
    if (kn(s))
      t = "agSetColumnFloatingFilter";
    else {
      const r = i == null ? void 0 : i.getBaseDataType(e);
      r === "number" ? t = "agNumberColumnFloatingFilter" : r === "date" || r === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const s = this.getDefaultFilter(e), i = e.getColDef();
    let r;
    const o = {
      ...this.createFilterParams(e, i),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(r, e)(),
      filterChangedCallback: (a) => this.filterChangedCallbackFactory(r, e)(a),
      doesRowPassOtherFilter: (a) => {
        var l;
        return ((l = this.beans.filterManager) == null ? void 0 : l.doesRowPassOtherFilters(r, a)) ?? !0;
      }
    }, n = wu(this.beans.userCompFactory, i, o, s);
    return n ? {
      filterPromise: () => {
        const a = n.newAgStackInstance();
        return a.then((l) => {
          r = l, t && (t.filter = l ?? void 0);
        }), a;
      },
      compDetails: n
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({
      column: e,
      colDef: t,
      rowModel: this.beans.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e) {
    const t = {
      column: e,
      filterPromise: null,
      compDetails: null
    }, { filterPromise: s, compDetails: i } = this.createFilterInstance(e, t);
    return t.filterPromise = (s == null ? void 0 : s()) ?? null, t.compDetails = i, t;
  }
  onColumnsChanged() {
    const e = [], { colModel: t, filterManager: s } = this.beans;
    this.allColumnFilters.forEach((r, o) => {
      let n;
      r.column.isPrimary() ? n = t.getColDefCol(o) : n = t.getCol(o), !(n && n === r.column) && (e.push(r.column), this.disposeFilterWrapper(r, "columnChanged"), this.disposeColumnListener(o));
    });
    const i = e.every(
      (r) => r.getColDef().filter === "agGroupColumnFilter"
    );
    e.length > 0 && !i ? s == null || s.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    var e, t;
    (t = (e = this.beans.autoColSvc) == null ? void 0 : e.getAutoCols()) == null || t.forEach((s) => {
      s.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(s);
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const { filter: s } = this.allColumnFilters.get(e.getColId()) ?? {};
    return s && typeof (s == null ? void 0 : s.isFilterAllowed) == "function" ? s.isFilterAllowed() : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const s = (c) => {
      var u;
      const h = (u = this.getOrCreateFilterWrapper(e)) == null ? void 0 : u.filterPromise;
      h != null && h.then((p) => {
        c(Ys(p));
      });
    }, i = e.getColDef(), r = {
      ...this.createFilterParams(e, i),
      filterChangedCallback: () => s(
        (c) => this.filterChangedCallbackFactory(c, e)()
      )
    }, { userCompFactory: o, frameworkOverrides: n } = this.beans, a = qv(
      o,
      i,
      r
    );
    let l = Uu(
      n,
      i,
      () => this.getDefaultFloatingFilter(e)
    );
    return l == null && (l = "agReadOnlyFloatingFilter"), yu(o, i, {
      column: e,
      filterParams: a,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: s,
      showParentFilter: t
    }, l);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var r;
    const s = e.getColId(), i = this.allColumnFilters.get(s);
    this.disposeColumnListener(s), delete this.initialFilterModel[s], i && (this.disposeFilterWrapper(i, t), (r = this.beans.filterManager) == null || r.onFilterChanged({
      columns: [e],
      source: "api"
    }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    var s;
    (s = e.filterPromise) == null || s.then((i) => {
      this.destroyBean(i), this.setColFilterActive(e.column, !1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId()), this.eventSvc.dispatchEvent({
        type: "filterDestroyed",
        source: t,
        column: e.column
      });
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      this.eventSvc.dispatchEvent({
        type: "filterModified",
        column: t,
        filterInstance: e
      });
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (s) => {
      const i = (s == null ? void 0 : s.source) ?? "columnFilter", r = {
        filter: e,
        additionalEventAttributes: s,
        columns: [t],
        source: i
      };
      this.callOnFilterChangedOutsideRenderCycle(r);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const s = t.column, { compDetails: i } = s.isFilterAllowed() ? this.createFilterInstance(s) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, i)) {
      this.destroyFilter(s, "paramsUpdated");
      return;
    }
    const r = s.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(s, "paramsUpdated");
      return;
    }
    t.filterPromise.then((o) => {
      (o != null && o.refresh ? o.refresh({
        ...this.createFilterParams(s, s.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(o, s),
        filterChangedCallback: this.filterChangedCallbackFactory(o, s),
        doesRowPassOtherFilter: (a) => {
          var l;
          return ((l = this.beans.filterManager) == null ? void 0 : l.doesRowPassOtherFilters(o, a)) ?? !0;
        },
        ...r
      }) : !0) === !1 && this.destroyFilter(s, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const s = e.getColId();
    this.allColumnFilters.set(s, t), this.allColumnListeners.set(
      s,
      this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(s) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: s } = e, { componentClass: i } = t;
    return !(s === i || // react hooks returns new wrappers, so check nested render method
    (s == null ? void 0 : s.render) && (i == null ? void 0 : i.render) && s.render === i.render);
  }
  hasFloatingFilters() {
    return this.beans.colModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((s) => {
        t(Ys(s));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var i;
    const t = this.beans.colModel.getColDefCol(e);
    return t ? ((i = this.getOrCreateFilterWrapper(t)) == null ? void 0 : i.filterPromise) ?? U.resolve(null) : U.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: s }) => {
      this.setColumnFilterModel(e, t).then(() => s());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    const { colModel: s, dataTypeSvc: i } = this.beans;
    if (i != null && i.isPendingInference) {
      let a = () => {
      };
      const l = new Promise((d) => {
        a = d;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: a }), l;
    }
    const r = s.getColDefCol(e), o = r ? this.getOrCreateFilterWrapper(r) : null;
    return o ? ((a) => new Promise((l) => {
      a.then((d) => l(d));
    }))(Ur(o.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.beans.colModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  setColDefPropertiesForDataType(e, t, s) {
    const i = kn(this.gos), r = this.getLocaleTextFunc(), o = (n) => {
      const { filterParams: a } = e;
      e.filterParams = typeof a == "object" ? {
        ...a,
        ...n
      } : n;
    };
    switch (t.baseDataType) {
      case "number": {
        i && o({
          comparator: iR
        });
        break;
      }
      case "boolean": {
        o(i ? {
          valueFormatter: (n) => A(n.value) ? r(String(n.value), n.value ? "True" : "False") : r("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (n, a) => a,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (n, a) => a === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        i && o({
          valueFormatter: (n) => {
            const a = s(n);
            return A(a) ? a : r("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (n, a) => {
            if (a === 1 && n != null) {
              const l = sc[Number(n) - 1];
              return r(l, tc[l]);
            }
            return n ?? r("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        const n = t.dateParser;
        o(i ? {
          valueFormatter: (a) => {
            const l = s(a);
            return A(l) ? l : r("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (a) => {
            const l = n(a ?? void 0);
            return l ? [String(l.getFullYear()), String(l.getMonth() + 1), String(l.getDate())] : null;
          },
          treeListFormatter: (a, l) => {
            if (l === 1 && a != null) {
              const d = sc[Number(a) - 1];
              return r(d, tc[d]);
            }
            return a ?? r("blanks", "(Blanks)");
          }
        } : {
          comparator: (a, l) => {
            const d = n(l);
            return l == null || d < a ? -1 : d > a ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        i ? o({
          valueFormatter: (n) => {
            const a = s(n);
            return A(a) ? a : r("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (n) => s({
          column: n.column,
          node: n.node,
          value: this.beans.valueSvc.getValue(n.column, n.node)
        });
        break;
      }
    }
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setColFilterActive(e, t, s, i) {
    e.filterActive !== t && (e.filterActive = t, e.dispatchColEvent("filterActiveChanged", s)), e.dispatchColEvent("filterChanged", s, i);
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function Ur(e, t) {
  return e ? new U((s) => {
    e.then((i) => {
      typeof i.setModel != "function" && (R(65), s()), (i.setModel(t) || U.resolve()).then(() => s());
    });
  }) : U.resolve();
}
function oR(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function nR(e, t = "api") {
  var s;
  (s = e.filterManager) == null || s.onFilterChanged({ source: t });
}
var aR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.quickFilter = e.quickFilter, this.advancedFilter = e.advancedFilter, this.colFilter = e.colFilter;
  }
  postConstruct() {
    const e = this.refreshFiltersForAggregations.bind(this), t = this.updateAdvFilterColumns.bind(this);
    this.addManagedEventListeners({
      columnValueChanged: e,
      columnPivotChanged: e,
      columnPivotModeChanged: e,
      newColumnsLoaded: t,
      columnVisible: t,
      advancedFilterEnabledChanged: ({ enabled: i }) => this.onAdvFilterEnabledChanged(i),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.quickFilter && this.addManagedListeners(this.quickFilter, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
    const { gos: s } = this;
    this.alwaysPassFilter = s.get("alwaysPassFilter"), this.addManagedPropertyListener("alwaysPassFilter", () => {
      this.alwaysPassFilter = s.get("alwaysPassFilter"), this.onFilterChanged({ source: "api" });
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" && e({});
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" && t(e);
  }
  setFilterModel(e, t = "api") {
    var s;
    if (this.isAdvFilterEnabled()) {
      this.warnAdvFilters();
      return;
    }
    (s = this.colFilter) == null || s.setFilterModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.colFilter) == null ? void 0 : e.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isAggregateFilterPresent());
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.externalFilterPresent || this.isAdvFilterPresent();
  }
  isAnyFilterPresent() {
    return this.isChildFilterPresent() || this.isAggregateFilterPresent();
  }
  isAdvFilterPresent() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
  }
  onAdvFilterEnabledChanged(e) {
    var t, s;
    e ? (t = this.colFilter) != null && t.disableColumnFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (s = this.advancedFilter) != null && s.isFilterPresent() && (this.advancedFilter.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvFilterEnabled() {
    var e;
    return !!((e = this.advancedFilter) != null && e.isEnabled());
  }
  isAdvFilterHeaderActive() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
  }
  resetQuickFilterCache() {
    var e;
    (e = this.quickFilter) == null || e.resetCache();
  }
  refreshFiltersForAggregations() {
    ur(this.gos) && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: s, columns: i = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.colFilter ? this.colFilter.updateBeforeFilterChanged(e) : U.resolve()).then(() => {
      var o;
      const r = {
        source: t,
        type: "filterChanged",
        columns: i
      };
      s && pe(r, s), this.eventSvc.dispatchEvent(r), (o = this.colFilter) == null || o.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.colFilter) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilter) != null && e.isFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!ur(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.beans.colModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    var s;
    const { rowNode: t } = e;
    return (s = this.alwaysPassFilter) != null && s.call(this, t) ? !0 : !(this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.isAggregateFilterPresent() && !this.colFilter.doAggregateFiltersPass(t, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    var s;
    const { rowNode: t } = e;
    return (s = this.alwaysPassFilter) != null && s.call(this, t) ? !0 : !(this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.externalFilterPresent && !this.doesExternalFilterPass(t) || this.isColumnFilterPresent() && !this.colFilter.doColumnFiltersPass(t, e.filterInstanceToSkip) || this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(t));
  }
  isFilterActive(e) {
    var t;
    return !!((t = this.colFilter) != null && t.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var t;
    return ((t = this.colFilter) == null ? void 0 : t.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.colFilter.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.colFilter.createFilterParams(e, t);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvFilterEnabled() ? !1 : !!((t = this.colFilter) != null && t.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var s;
    return (s = this.colFilter) == null ? void 0 : s.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var t;
    return (t = this.colFilter) == null ? void 0 : t.getCurrentFloatingFilterParentModel(e);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var s;
    (s = this.colFilter) == null || s.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var s;
    return !!((s = this.colFilter) != null && s.areFilterCompsDifferent(e, t));
  }
  getAdvFilterModel() {
    return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
  }
  setAdvFilterModel(e) {
    var t;
    if (this.isAdvFilterEnabled()) {
      if ((t = this.beans.dataTypeSvc) != null && t.isPendingInference) {
        this.advFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilter.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  toggleAdvFilterBuilder(e, t) {
    this.isAdvFilterEnabled() && this.advancedFilter.getCtrl().toggleFilterBuilder({ source: t, force: e });
  }
  updateAdvFilterColumns() {
    this.isAdvFilterEnabled() && this.advancedFilter.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvFilterEnabled() ? !1 : !!((e = this.colFilter) != null && e.hasFloatingFilters());
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve(void 0)) : ((t = this.colFilter) == null ? void 0 : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvFilters() {
    R(68);
  }
  setupAdvFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilter) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advFilterModelUpdateQueue.forEach((e) => this.setAdvFilterModel(e)), this.advFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var t;
    return (t = this.colFilter) == null ? void 0 : t.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var s;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve()) : ((s = this.colFilter) == null ? void 0 : s.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
  setColDefPropertiesForDataType(e, t, s) {
    var i;
    (i = this.colFilter) == null || i.setColDefPropertiesForDataType(e, t, s);
  }
}, lR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  hideActiveMenu() {
    var e;
    (e = this.hidePopup) == null || e.call(this);
  }
  showMenuAfterMouseEvent(e, t, s) {
    this.showPopup(
      e,
      (i) => {
        var r;
        (r = this.popupSvc) == null || r.positionPopupUnderMouseEvent({
          column: e,
          type: s,
          mouseEvent: t,
          ePopup: i
        });
      },
      s,
      t.target,
      we(this.gos)
    );
  }
  showMenuAfterButtonClick(e, t, s) {
    let i = -1, r = "left";
    const o = we(this.gos);
    !o && this.gos.get("enableRtl") && (i = 1, r = "right");
    const n = o ? void 0 : 4 * i, a = o ? void 0 : 4;
    this.showPopup(
      e,
      (l) => {
        var d;
        (d = this.popupSvc) == null || d.positionPopupByComponent({
          type: s,
          eventSource: t,
          ePopup: l,
          nudgeX: n,
          nudgeY: a,
          alignSide: r,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      s,
      t,
      o
    );
  }
  showPopup(e, t, s, i, r) {
    var g;
    const o = e ? this.createBean(new sn(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = o, !(o != null && o.hasFilter()) || !e) {
      z(57);
      return;
    }
    const n = document.createElement("div");
    re(n, "presentation"), n.classList.add("ag-menu"), r || n.classList.add("ag-filter-menu"), [this.tabListener] = this.addManagedElementListeners(n, {
      keydown: (f) => this.trapFocusWithin(f, n)
    }), n.appendChild(o == null ? void 0 : o.getGui());
    let a;
    const l = () => o == null ? void 0 : o.afterGuiDetached(), d = $h(this.gos) ? i ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody : void 0, c = (f) => {
      Eo(e, !1, "contextMenu");
      const m = f instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), m && i && ke(i)) {
        const C = ml(i);
        C == null || C.focus({ preventScroll: !0 });
      }
      l(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, s, e);
    }, h = this.getLocaleTextFunc(), u = r && s !== "columnFilter" ? h("ariaLabelColumnMenu", "Column Menu") : h("ariaLabelColumnFilter", "Column Filter"), p = (g = this.popupSvc) == null ? void 0 : g.addPopup({
      modal: !0,
      eChild: n,
      closeOnEsc: !0,
      closedCallback: c,
      positionCallback: () => t(n),
      anchorToElement: d,
      ariaLabel: u
    });
    p && (this.hidePopup = a = p.hideFunc), o.afterInit().then(() => {
      t(n), o.afterGuiAttached({ container: s, hidePopup: a });
    }), Eo(e, !0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, s, e);
  }
  trapFocusWithin(e, t) {
    e.key !== w.TAB || e.defaultPrevented || Pe(this.beans, t, !1, e.shiftKey) || (e.preventDefault(), ve(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, s) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: s ?? null,
      columnGroup: null
    });
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, dR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "filterValueSvc";
  }
  getValue(e, t) {
    if (!t)
      return;
    const s = e.getColDef(), { filterValueGetter: i } = s;
    return i ? this.executeFilterValueGetter(i, t.data, e, t, s) : this.beans.valueSvc.getValue(e, t);
  }
  executeFilterValueGetter(e, t, s, i, r) {
    const { expressionSvc: o, valueSvc: n } = this.beans, a = this.gos.addGridCommonParams({
      data: t,
      node: i,
      column: s,
      colDef: r,
      getValue: n.getValueCallback.bind(n, i)
    });
    return typeof e == "function" ? e(a) : o == null ? void 0 : o.evaluate(e, a);
  }
}, cR = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [mt]
    ), this.eFloatingFilterText = S;
  }
  init(e) {
    this.params = e;
    const t = this.beans.colNames.getDisplayNameForColumn(e.column, "header", !0);
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const s = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(s);
      }
    });
  }
  refresh(e) {
    this.init(e);
  }
}, _p = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  mapCustomOptions() {
    const { filterOptions: e } = this;
    e && e.forEach((t) => {
      if (typeof t == "string")
        return;
      const s = [["displayKey"], ["displayName"], ["predicate", "test"]], i = (r) => r.some((o) => t[o] != null) ? !0 : (R(72, { keys: r }), !1);
      if (!s.every(i)) {
        this.filterOptions = e.filter((r) => r === t) || [];
        return;
      }
      this.customFilterOptions[t.displayKey] = t;
    });
  }
  selectDefaultItem(e) {
    const { filterOptions: t } = this;
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (t.length >= 1) {
      const s = t[0];
      typeof s == "string" ? this.defaultOption = s : s.displayKey ? this.defaultOption = s.displayKey : R(73);
    } else
      R(74);
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
};
function nr(e, t, s) {
  return s == null ? e.splice(t) : e.splice(t, s);
}
function Ao(e) {
  return e == null || typeof e == "string" && e.trim().length === 0;
}
function hR(e) {
  return e === "AND" || e === "OR" ? e : "AND";
}
function uR(e, t, s) {
  if (e == null)
    return;
  const { predicate: i } = e;
  if (i != null && !t.some((r) => r == null))
    return i(t, s);
}
function pR(e, t) {
  let s = e.length;
  return s > t && (e.splice(t), R(78), s = t), s;
}
var Up = class extends on {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: i } = t;
      return i ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, s) => {
      const i = s === 0 ? e : this.optionsFactory.defaultOption;
      t.setValue(i, !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.filterType,
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    const { eJoinOperatorsOr: e, defaultJoinOperator: t } = this;
    return e.length === 0 ? t : e[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const s = !e.operator, i = !t.operator;
    if (!s && i || s && !i)
      return !1;
    let o;
    if (s) {
      const n = e, a = t;
      o = this.areSimpleModelsEqual(n, a);
    } else {
      const n = e, a = t;
      o = n.operator === a.operator && Re(
        n.conditions,
        a.conditions,
        (l, d) => this.areSimpleModelsEqual(l, d)
      );
    }
    return o;
  }
  shouldRefresh(e) {
    var o;
    const t = this.getModel(), s = t ? t.conditions ?? [t] : null, i = ((o = e.filterOptions) == null ? void 0 : o.map((n) => typeof n == "string" ? n : n.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!s || s.every((n) => i.find((a) => a === n.type) !== void 0)) || typeof e.maxNumConditions == "number" && s && s.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? !1 : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const s = e;
      let i = s.conditions;
      i == null && (i = [], R(77));
      const r = pR(i, this.maxNumConditions), o = this.getNumConditions();
      if (r < o)
        this.removeConditionsAndOperators(r);
      else if (r > o)
        for (let a = o; a < r; a++)
          this.createJoinOperatorPanel(), this.createOption();
      const n = s.operator === "OR";
      this.eJoinOperatorsAnd.forEach((a) => a.setValue(!n, !0)), this.eJoinOperatorsOr.forEach((a) => a.setValue(n, !0)), i.forEach((a, l) => {
        this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l);
      });
    } else {
      const s = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(s.type, !0), this.setConditionIntoUi(s, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), U.resolve();
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null)
      return !0;
    const { operator: s } = t, i = [];
    if (s) {
      const o = t;
      i.push(...o.conditions ?? []);
    } else
      i.push(t);
    return i[s && s === "OR" ? "some" : "every"]((o) => this.individualConditionPasses(e, o));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = hR(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new _p(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    let t = e.maxNumConditions ?? 2;
    t < 1 && (R(79), t = 1), this.maxNumConditions = t;
    let s = e.numAlwaysVisibleConditions ?? 1;
    s < 1 && (R(80), s = 1), s > t && (R(81), s = t), this.numAlwaysVisibleConditions = s;
  }
  createOption() {
    const e = this.createManagedBean(new Ne());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const s = this.getNumConditions() - 1;
    this.forEachPositionInput(s, (i) => this.resetInput(i)), this.addChangedListeners(e, s);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), s = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const i = this.eJoinOperatorPanels.length - 1, r = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, i, r), this.resetJoinOperatorOr(s, i, r), this.isReadOnly() || (t.onValueChange(this.listener), s.onValueChange(this.listener));
  }
  createJoinOperator(e, t, s) {
    const i = this.createManagedBean(new Iy());
    e.push(i);
    const r = "ag-filter-condition-operator";
    return i.addCssClass(r), i.addCssClass(`${r}-${s}`), t.appendChild(i.getGui()), i;
  }
  createFilterListOptions() {
    this.filterListOptions = this.optionsFactory.filterOptions.map(
      (e) => typeof e == "string" ? this.createBoilerplateListOption(e) : this.createCustomListOption(e)
    );
  }
  putOptionsIntoDropdown(e) {
    const { filterListOptions: t } = this;
    t.forEach((s) => {
      e.addOption(s);
    }), e.setDisabled(t.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, s = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: s ? this.getLocaleTextFunc()(s.displayKey, s.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let s = 0; s < this.getNumConditions(); s++)
      this.isConditionUiComplete(s) ? e = s : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const s = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < s) {
        this.removeConditionsAndOperators(s + 1);
        const i = e + 1, r = s - i;
        r > 0 && this.removeConditionsAndOperators(i, r), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((i, r) => {
      const o = this.isConditionDisabled(r, e);
      i.setDisabled(o || this.filterListOptions.length <= 1), r === 1 && (lt(this.eJoinOperatorPanels[0], o), this.eJoinOperatorsAnd[0].setDisabled(o), this.eJoinOperatorsOr[0].setDisabled(o));
    }), this.eConditionBodies.forEach((i, r) => {
      O(i, this.isConditionBodyVisible(r));
    });
    const s = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((i) => {
      i.setValue(!s, !0);
    }), this.eJoinOperatorsOr.forEach((i) => {
      i.setValue(s, !0);
    }), this.forEachInput((i, r, o, n) => {
      this.setElementDisplayed(i, r < n), this.setElementDisabled(i, this.isConditionDisabled(o, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    const { eTypes: s, eConditionBodies: i, eJoinOperatorPanels: r, eJoinOperatorsAnd: o, eJoinOperatorsOr: n } = this;
    this.removeComponents(s, e, t), this.removeElements(i, e, t), this.removeValueElements(e, t);
    const a = Math.max(e - 1, 0);
    this.removeElements(r, a, t), this.removeComponents(o, a, t), this.removeComponents(n, a, t);
  }
  removeElements(e, t, s) {
    nr(e, t, s).forEach((r) => ce(r));
  }
  removeComponents(e, t, s) {
    nr(e, t, s).forEach((r) => {
      ce(r.getGui()), this.destroyBean(r);
    });
  }
  afterGuiAttached(e) {
    var t;
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus)) {
      const { eFilterBody: s, eTypes: i } = this;
      let r;
      if (!this.isReadOnly()) {
        const o = this.getInputs(0)[0];
        o instanceof us && this.isConditionBodyVisible(0) ? r = o.getInputElement() : r = (t = i[0]) == null ? void 0 : t.getFocusableElement();
      }
      (r ?? s).focus({ preventScroll: !0 });
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, s = -1, i = !1;
    const r = this.getJoinOperator();
    for (let n = this.getNumConditions() - 1; n >= 0; n--)
      if (this.isConditionUiComplete(n))
        t === -1 && (t = n, s = n);
      else {
        const a = n >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(n - 1), l = n < t;
        (a || l) && (this.removeConditionsAndOperators(n, 1), i = !0, l && s--);
      }
    let o = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), o = !0), this.shouldAddNewConditionAtEnd(s === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), o = !0), o && this.updateConditionStatusesAndValues(s, r), i && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = s;
  }
  getPlaceholderText(e, t) {
    let s = this.translate(e);
    if (typeof this.filterPlaceholder == "function") {
      const i = this.eTypes[t].getValue(), r = this.translate(i);
      s = this.filterPlaceholder({
        filterOptionKey: i,
        filterOption: r,
        placeholder: s
      });
    } else typeof this.filterPlaceholder == "string" && (s = this.filterPlaceholder);
    return s;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.getLocaleTextFunc();
    this.forEachInput((t, s, i, r) => {
      if (!(t instanceof us))
        return;
      const o = s === 0 && r > 1 ? "inRangeStart" : s === 0 ? "filterOoo" : "inRangeEnd", n = s === 0 && r > 1 ? e("ariaFilterFromValue", "Filter from value") : s === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(o, i)), t.setInputAriaLabel(n);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, s) {
    e instanceof us && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof L && O(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof L && lt(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof us && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, s) => {
      this.forEachPositionTypeInput(s, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const s = this.getConditionType(e);
    this.forEachPositionTypeInput(e, s, t);
  }
  forEachPositionTypeInput(e, t, s) {
    const i = this.getNumberOfInputs(t), r = this.getInputs(e);
    for (let o = 0; o < r.length; o++) {
      const n = r[o];
      n != null && s(n, o, e, i);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((s) => s == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach(
      (t, s) => this.resetJoinOperatorAnd(t, s, this.joinOperatorId + s)
    ), this.eJoinOperatorsOr.forEach(
      (t, s) => this.resetJoinOperatorOr(t, s, this.joinOperatorId + s)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), U.resolve();
  }
  resetType(e) {
    const s = this.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.defaultOption, !0).setAriaLabel(s).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, s) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "AND",
      this.translate("andCondition"),
      s
    );
  }
  resetJoinOperatorOr(e, t, s) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "OR",
      this.translate("orCondition"),
      s
    );
  }
  resetJoinOperator(e, t, s, i, r) {
    this.updateJoinOperatorDisabled(
      e.setValue(s, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${r}`).setLabel(i),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    const e = (t, s) => this.updateJoinOperatorDisabled(t, s);
    this.eJoinOperatorsAnd.forEach(e), this.eJoinOperatorsOr.forEach(e);
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const s = this.mapValuesFromModel(e);
    this.forEachInput((i, r, o) => {
      o === t && this.setElementValue(i, s[r] != null ? s[r] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, s, i) => {
      this.setElementValue(t, s === 0 && i === 0 ? e : null, !0);
    });
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (s) => {
      this.attachElementOnChange(s, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const s = this.getCellValue(e.node), i = this.mapValuesFromModel(t), r = this.optionsFactory.getCustomOption(t.type), o = uR(r, i, s);
    return o ?? (s == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(i, s, t, e));
  }
  hasInvalidInputs() {
    return !1;
  }
}, Kp = class extends Up {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    const {
      includeBlanksInEquals: t,
      includeBlanksInNotEqual: s,
      includeBlanksInGreaterThan: i,
      includeBlanksInLessThan: r,
      includeBlanksInRange: o
    } = this.scalarFilterParams;
    switch (e) {
      case "equals":
        if (t)
          return !0;
        break;
      case "notEqual":
        if (s)
          return !0;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (i)
          return !0;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (r)
          return !0;
        break;
      case "inRange":
        if (o)
          return !0;
        break;
      case "blank":
        return !0;
      case "notBlank":
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, s) {
    const i = this.comparator(), r = e[0] != null ? i(e[0], t) : 0;
    switch (s.type) {
      case "equals":
        return r === 0;
      case "notEqual":
        return r !== 0;
      case "greaterThan":
        return r > 0;
      case "greaterThanOrEqual":
        return r >= 0;
      case "lessThan":
        return r < 0;
      case "lessThanOrEqual":
        return r <= 0;
      case "inRange": {
        const o = i(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? r >= 0 && o <= 0 : r > 0 && o < 0;
      }
      case "blank":
        return Ao(t);
      case "notBlank":
        return !Ao(t);
      default:
        return R(76, { filterModelType: s.type }), !0;
    }
  }
}, $p = class {
  constructor(e, t, s, i, r) {
    this.alive = !0, this.context = e, this.eParent = i;
    const o = _v(t, s);
    o && o.newAgStackInstance().then((n) => {
      var d, c;
      if (!this.alive) {
        e.destroyBean(n);
        return;
      }
      if (this.dateComp = n, !n)
        return;
      i.appendChild(n.getGui()), (d = n == null ? void 0 : n.afterGuiAttached) == null || d.call(n);
      const { tempValue: a, disabled: l } = this;
      a && n.setDate(a), l != null && ((c = n.setDisabled) == null || c.call(n, l)), r == null || r(this);
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    const t = this.dateComp;
    t ? t.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    var s;
    const t = this.dateComp;
    t ? (s = t.setDisabled) == null || s.call(t, e) : this.disabled = e;
  }
  setDisplayed(e) {
    O(this.eParent, e);
  }
  setInputPlaceholder(e) {
    var t, s;
    (s = (t = this.dateComp) == null ? void 0 : t.setInputPlaceholder) == null || s.call(t, e);
  }
  setInputAriaLabel(e) {
    var t, s;
    (s = (t = this.dateComp) == null ? void 0 : t.setInputAriaLabel) == null || s.call(t, e);
  }
  afterGuiAttached(e) {
    var t, s;
    (s = (t = this.dateComp) == null ? void 0 : t.afterGuiAttached) == null || s.call(t, e);
  }
  updateParams(e) {
    var t, s;
    (s = (t = this.dateComp) == null ? void 0 : t.refresh) == null || s.call(t, e);
  }
}, jp = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
], Wl = class {
  constructor(e, t, s) {
    this.getLocaleTextFunc = e, this.optionsFactory = t, this.valueFormatter = s;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, s = this.getLocaleTextFunc();
    if (t) {
      const i = e, o = (i.conditions ?? []).map((a) => this.getModelAsString(a)), n = i.operator === "AND" ? "andCondition" : "orCondition";
      return o.join(
        ` ${s(n, _u[n])} `
      );
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return s(e.type, e.type);
      {
        const i = e, r = this.optionsFactory.getCustomOption(i.type), { displayKey: o, displayName: n, numberOfInputs: a } = r || {};
        return o && n && a === 0 ? (s(o, n), n) : this.conditionToString(i, r);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    const t = this.valueFormatter;
    return t ? t(e ?? null) ?? "" : String(e);
  }
}, qp = class extends Wl {
  constructor(e, t, s) {
    super(t, s), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: s } = e, { numberOfInputs: i } = t || {}, r = s == "inRange" || i === 2, o = Le(e.dateFrom), n = Le(e.dateTo), a = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (r) {
      const l = o !== null ? ir(o, a) : "null", d = n !== null ? ir(n, a) : "null";
      return `${l}-${d}`;
    }
    return o != null ? ir(o, a) : `${s}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, ic = 1e3, rc = 1 / 0, gR = class extends Kp {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = ic, this.maxValidYear = rc, this.minValidDate = null, this.maxValidDate = null, this.filterType = "date";
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: s, type: i } = e || {};
    return [
      t && Le(t) || null,
      s && Le(s) || null
    ].slice(0, this.getNumberOfInputs(i));
  }
  comparator() {
    return this.dateFilterParams.comparator ?? fR;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (s, i) => {
      if (e[s] != null)
        if (isNaN(e[s]))
          R(82, { param: s });
        else
          return e[s] == null ? i : Number(e[s]);
      return i;
    };
    this.minValidYear = t("minValidYear", ic), this.maxValidYear = t("maxValidYear", rc), this.minValidYear > this.maxValidYear && R(83), this.minValidDate = e.minValidDate ? e.minValidDate instanceof Date ? e.minValidDate : Le(e.minValidDate) : null, this.maxValidDate = e.maxValidDate ? e.maxValidDate instanceof Date ? e.maxValidDate : Le(e.maxValidDate) : null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && R(84), this.filterModelFormatter = new qp(
      this.dateFilterParams,
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  createDateCompWrapper(e) {
    const { userCompFactory: t, context: s } = this.beans, i = new $p(
      s,
      t,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams,
        location: "filter"
      },
      e
    );
    return this.addDestroyFunc(() => i.destroy()), i;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return jp;
  }
  createValueElement() {
    const t = Z(this.beans).createElement("div");
    return t.classList.add("ag-filter-body"), this.createFromToElement(t, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(t, this.eConditionPanelsTo, this.dateConditionToComps, "to"), t;
  }
  createFromToElement(e, t, s, i) {
    const o = Z(this.beans).createElement("div");
    o.classList.add(`ag-filter-${i}`), o.classList.add(`ag-filter-date-${i}`), t.push(o), e.appendChild(o), s.push(this.createDateCompWrapper(o));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), nr(this.eConditionPanelsFrom, e, t), nr(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, s) {
    nr(e, t, s).forEach((r) => r.destroy());
  }
  isValidDateValue(e) {
    if (e === null)
      return !1;
    const { minValidDate: t, maxValidDate: s, minValidYear: i, maxValidYear: r } = this;
    if (t) {
      if (e < t)
        return !1;
    } else if (e.getUTCFullYear() < i)
      return !1;
    if (s) {
      if (e > s)
        return !1;
    } else if (e.getUTCFullYear() > r)
      return !1;
    return !0;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    let t = !0;
    return this.forEachInput((s, i, r, o) => {
      r !== e || !t || i >= o || (t = t && this.isValidDateValue(s.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  createCondition(e) {
    const t = this.getConditionType(e), s = {}, i = this.getValues(e);
    return i.length > 0 && (s.dateFrom = Ze(i[0])), i.length > 1 && (s.dateTo = Ze(i[1])), {
      dateFrom: null,
      dateTo: null,
      filterType: this.filterType,
      type: t,
      ...s
    };
  }
  resetPlaceholder() {
    const e = this.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), s = e("ariaFilterValue", "Filter Value");
    this.forEachInput((i) => {
      i.setInputPlaceholder(t), i.setInputAriaLabel(s);
    });
  }
  getInputs(e) {
    const { dateConditionFromComps: t, dateConditionToComps: s } = this;
    return e >= t.length ? [null, null] : [t[e], s[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (s, i, r, o) => {
      i < o && t.push(s.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
};
function fR(e, t) {
  const s = t;
  return t == null || s < e ? -1 : s > e ? 1 : 0;
}
var Yp = class extends L {
  constructor() {
    super(...arguments), this.defaultDebounceMs = 0;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.defaultOption;
      return;
    }
    const t = e.operator;
    let s;
    t ? s = e.conditions[0] : s = e, this.lastType = s.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const s = e;
    return this.isTypeEditable(s.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    const s = new _p();
    this.optionsFactory = s, s.init(e.filterParams, this.getDefaultOptions());
    const i = s.defaultOption;
    t || (this.lastType = i), this.readOnly = !!e.filterParams.readOnly;
    const r = this.isTypeEditable(i);
    this.setEditable(r);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  hasSingleInput(e) {
    var s;
    const t = (s = this.optionsFactory.getCustomOption(e)) == null ? void 0 : s.numberOfInputs;
    return t == null || t == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.readOnly && this.hasSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    return `${this.beans.colNames.getDisplayNameForColumn(e.column, "header", !0)} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`;
  }
}, mR = class extends Yp {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
      [mt]
    ), this.eReadOnlyText = S, this.eDateWrapper = S;
  }
  getDefaultOptions() {
    return jp;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new qp(
      this.filterParams,
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
    const t = this.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams;
    const t = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(t), this.filterModelFormatter.updateParams({
      optionsFactory: this.optionsFactory,
      dateFilterParams: this.filterParams
    }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.readOnly && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      const s = e ? Le(e.dateFrom) : null;
      this.dateComp.setDate(s), this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    O(this.eDateWrapper, e), O(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    t != null && t.afterFloatingFilter || t != null && t.afterDataChange || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Ze(e);
    this.params.parentFilterInstance((s) => {
      if (s) {
        const i = Le(t);
        s.onFloatingFilterChanged(this.lastType || null, i);
      }
    });
  }
  getDateComponentParams() {
    const { filterParams: e, column: t } = this.params, s = wl(e, this.defaultDebounceMs);
    return {
      onDateChanged: Ce(this, this.onDateChanged.bind(this), s),
      filterParams: t.getColDef().filterParams,
      location: "floatingFilter"
    };
  }
  createDateComponent() {
    const {
      beans: { context: e, userCompFactory: t },
      eDateWrapper: s
    } = this;
    this.dateComp = new $p(
      e,
      t,
      this.getDateComponentParams(),
      s,
      (i) => {
        i.setInputAriaLabel(this.getAriaLabel(this.params));
      }
    ), this.addDestroyFunc(() => this.dateComp.destroy());
  }
}, CR = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
      [mt]
    ), this.eDateInput = S, this.isApply = !1, this.applyOnFocusOut = !1;
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus({ preventScroll: !0 });
      },
      input: this.handleInput.bind(this, !1),
      change: this.handleInput.bind(this, !0),
      focusout: this.handleFocusOut.bind(this)
    });
  }
  handleInput(e, t) {
    if (t.target === q(this.beans) && !this.eDateInput.isDisabled()) {
      if (this.isApply) {
        this.applyOnFocusOut = !e, e && this.params.onDateChanged();
        return;
      }
      e || this.params.onDateChanged();
    }
  }
  handleFocusOut() {
    this.applyOnFocusOut && (this.applyOnFocusOut = !1, this.params.onDateChanged());
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), s = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = s && si(), t.type = s ? "date" : "text";
    const { minValidYear: i, maxValidYear: r, minValidDate: o, maxValidDate: n, buttons: a } = e.filterParams || {};
    if (o && i && R(85), n && r && R(86), o && n) {
      const [l, d] = [o, n].map(
        (c) => c instanceof Date ? c : Le(c)
      );
      l && d && l.getTime() > d.getTime() && R(87);
    }
    o ? o instanceof Date ? t.min = ir(o) : t.min = o : i && (t.min = `${i}-01-01`), n ? n instanceof Date ? t.max = ir(n) : t.max = n : r && (t.max = `${r}-12-31`), this.isApply = e.location === "floatingFilter" && !!(a != null && a.includes("apply"));
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return Le(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Ze(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus({ preventScroll: !0 });
  }
  shouldUseBrowserDatePicker(e) {
    var t;
    return ((t = e == null ? void 0 : e.filterParams) == null ? void 0 : t.browserDatePicker) ?? !0;
  }
}, Xp = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
], Zp = class extends Wl {
  conditionToString(e, t) {
    const { numberOfInputs: s } = t || {}, { filter: i, filterTo: r, type: o } = e, n = o == "inRange" || s === 2, a = this.formatValue.bind(this);
    return n ? `${a(i)}-${a(r)}` : i != null ? a(i) : `${o}`;
  }
};
function Ia(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var vR = class extends Kp {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [], this.filterType = "number", this.defaultDebounceMs = 500;
  }
  refresh(e) {
    return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern ? !1 : super.refresh(e);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: s, type: i } = e || {};
    return [this.processValue(t), this.processValue(s)].slice(0, this.getNumberOfInputs(i));
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new Zp(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory,
      this.numberFilterParams.numberFormatter
    );
  }
  getDefaultFilterOptions() {
    return Xp;
  }
  setElementValue(e, t, s) {
    const { numberFormatter: i } = this.numberFilterParams, r = !s && i ? i(t ?? null) : t;
    super.setElementValue(e, r);
  }
  createValueElement() {
    const e = Ia(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), re(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, s, i) {
    const r = this.createManagedBean(
      i ? new Tt({ allowedCharPattern: i }) : new nn()
    );
    r.addCssClass(`ag-filter-${s}`), r.addCssClass("ag-filter-filter"), t.push(r), e.appendChild(r.getGui());
  }
  removeValueElements(e, t) {
    const s = (i) => this.removeComponents(i, e, t);
    s(this.eValuesFrom), s(this.eValuesTo);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (s, i, r, o) => {
      i < o && t.push(this.processValue(this.stringToFloat(s.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = ge(e);
    t != null && t.trim() === "" && (t = null);
    const s = this.numberFilterParams.numberParser;
    return s ? s(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), s = {
      filterType: this.filterType,
      type: t
    }, i = this.getValues(e);
    return i.length > 0 && (s.filter = i[0]), i.length > 1 && (s.filterTo = i[1]), s;
  }
  getInputs(e) {
    const { eValuesFrom: t, eValuesTo: s } = this;
    return e >= t.length ? [null, null] : [t[e], s[e]];
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}, Qp = class extends P {
  constructor(e) {
    super(), this.params = e, this.eInput = S, this.onValueChanged = () => {
    };
  }
  setupGui(e) {
    var i;
    this.eInput = this.createManagedBean(new Tt((i = this.params) == null ? void 0 : i.config));
    const t = this.eInput.getGui();
    e.appendChild(t);
    const s = (r) => this.onValueChanged(r);
    this.addManagedListeners(t, {
      input: s,
      keydown: s
    });
  }
  setEditable(e) {
    this.eInput.setDisabled(!e);
  }
  getValue() {
    return this.eInput.getValue();
  }
  setValue(e, t) {
    this.eInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.onValueChanged = e;
  }
  setParams({ ariaLabel: e, autoComplete: t }) {
    const { eInput: s } = this;
    s.setInputAriaLabel(e), t !== void 0 && s.setAutoComplete(t);
  }
};
function Jp(e) {
  const t = e == null ? void 0 : e.trim();
  return t === "" ? e : t;
}
var eg = class extends Yp {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = S, this.defaultDebounceMs = 500;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  onParentModelChanged(e, t) {
    t != null && t.afterFloatingFilter || t != null && t.afterDataChange || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.inputSvc = this.createFloatingFilterInputService(e), this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? !1, { inputSvc: s, defaultDebounceMs: i, readOnly: r } = this;
    if (s.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = Do(e.filterParams), !r) {
      const o = wl(e.filterParams, i), n = Ce(
        this,
        this.syncUpWithParentFilter.bind(this),
        o
      );
      s.setValueChangedListener(n);
    }
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const { inputSvc: t } = this, s = t.getValue();
    X(this.eFloatingFilterInputContainer), this.destroyBean(t), this.setupFloatingFilterInputService(e), t.setValue(s, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === w.ENTER;
    if (this.applyActive && !t)
      return;
    const { inputSvc: s, params: i } = this;
    let r = s.getValue();
    i.filterParams.trimInput && (r = Jp(r), s.setValue(r, !0)), i.parentFilterInstance((o) => {
      o == null || o.onFloatingFilterChanged(this.lastType || null, r || null);
    });
  }
  setEditable(e) {
    this.inputSvc.setEditable(e);
  }
}, wR = class extends P {
  constructor() {
    super(...arguments), this.onValueChanged = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eNumberInput = this.createManagedBean(new nn()), this.eTextInput = this.createManagedBean(new Tt()), this.eTextInput.setDisabled(!0);
    const t = this.eNumberInput.getGui(), s = this.eTextInput.getGui();
    e.appendChild(t), e.appendChild(s), this.setupListeners(t, (i) => this.onValueChanged(i)), this.setupListeners(s, (i) => this.onValueChanged(i));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eNumberInput.setDisplayed(this.numberInputActive), this.eTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eNumberInput.setAutoComplete(e), this.eTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eNumberInput : this.eTextInput;
  }
  setValueChangedListener(e) {
    this.onValueChanged = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, {
      input: t,
      keydown: t
    });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eNumberInput.setInputAriaLabel(e), this.eTextInput.setInputAriaLabel(e);
  }
}, yR = class extends eg {
  init(e) {
    var t;
    super.init(e), this.filterModelFormatter = new Zp(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory,
      (t = e.filterParams) == null ? void 0 : t.numberFormatter
    );
  }
  refresh(e) {
    Ia(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultOptions() {
    return Xp;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = Ia(e.filterParams), this.allowedCharPattern ? this.createManagedBean(
      new Qp({
        config: { allowedCharPattern: this.allowedCharPattern }
      })
    ) : this.createManagedBean(new wR());
  }
}, tg = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], sg = class extends Wl {
  conditionToString(e, t) {
    const { numberOfInputs: s } = t || {}, { filter: i, filterTo: r, type: o } = e;
    return o == "inRange" || s === 2 ? `${i}-${r}` : i != null ? `${i}` : `${o}`;
  }
}, bR = class extends Up {
  constructor() {
    super("textFilter"), this.filterType = "text", this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: s }) => {
      if (s == null)
        return !1;
      switch (e) {
        case "contains":
          return t.indexOf(s) >= 0;
        case "notContains":
          return t.indexOf(s) < 0;
        case "equals":
          return t === s;
        case "notEqual":
          return t != s;
        case "startsWith":
          return t.indexOf(s) === 0;
        case "endsWith": {
          const i = t.lastIndexOf(s);
          return i >= 0 && i === t.length - s.length;
        }
        default:
          return !1;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [], this.defaultDebounceMs = 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = e.textMatcher || this.defaultMatcher, this.formatter = e.textFormatter || (e.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new sg(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  createCondition(e) {
    const t = this.getConditionType(e), s = {
      filterType: this.filterType,
      type: t
    }, i = this.getValuesWithSideEffects(e, !0);
    return i.length > 0 && (s.filter = i[0]), i.length > 1 && (s.filterTo = i[1]), s;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    const { eValuesFrom: t, eValuesTo: s } = this;
    return e >= t.length ? [null, null] : [t[e], s[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1);
  }
  getValuesWithSideEffects(e, t) {
    const s = [];
    return this.forEachPositionInput(e, (i, r, o, n) => {
      if (r < n) {
        let a = ge(i.getValue());
        t && this.textFilterParams.trimInput && (a = Jp(a) ?? null, i.setValue(a, !0)), s.push(a);
      }
    }), s;
  }
  getDefaultFilterOptions() {
    return tg;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), re(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, s) {
    const i = this.createManagedBean(new Tt());
    i.addCssClass(`ag-filter-${s}`), i.addCssClass("ag-filter-filter"), t.push(i), e.appendChild(i.getGui());
  }
  removeValueElements(e, t) {
    const s = (i) => this.removeComponents(i, e, t);
    s(this.eValuesFrom), s(this.eValuesTo);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: s, type: i } = e || {};
    return [t || null, s || null].slice(0, this.getNumberOfInputs(i));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, s, i) {
    const r = e.map((u) => this.formatter(u)) || [], o = this.formatter(t), { api: n, colDef: a, column: l, context: d, textFormatter: c } = this.textFilterParams;
    if (s.type === "blank")
      return Ao(t);
    if (s.type === "notBlank")
      return !Ao(t);
    const h = {
      api: n,
      colDef: a,
      column: l,
      context: d,
      node: i.node,
      data: i.data,
      filterOption: s.type,
      value: o,
      textFormatter: c
    };
    return r.some((u) => this.matcher({ ...h, filterText: u }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, SR = class extends eg {
  init(e) {
    super.init(e), this.filterModelFormatter = new sg(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultOptions() {
    return tg;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new Qp());
  }
};
function xR(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isQuickFilterPresent());
}
function FR(e) {
  return e.gos.get("quickFilterText");
}
function RR(e) {
  var t;
  (t = e.filterManager) == null || t.resetQuickFilterCache();
}
var PR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "quickFilter", this.quickFilter = null, this.quickFilterParts = null;
  }
  postConstruct() {
    const e = this.resetCache.bind(this), t = this.gos;
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: e,
      columnRowGroupChanged: e,
      columnVisible: () => {
        t.get("includeHiddenColumnsInQuickFilter") || this.resetCache();
      }
    }), this.addManagedPropertyListener("quickFilterText", (s) => this.setFilter(s.currentValue)), this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onColumnConfigChanged()
    ), this.quickFilter = this.parseFilter(t.get("quickFilterText")), this.parser = t.get("quickFilterParser"), this.matcher = t.get("quickFilterMatcher"), this.setFilterParts(), this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setParserAndMatcher());
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshCols() {
    var l;
    const { autoColSvc: e, colModel: t, gos: s, pivotResultCols: i } = this.beans, r = t.isPivotMode(), o = e == null ? void 0 : e.getAutoCols(), n = t.getColDefCols();
    let a = (r && !s.get("applyQuickFilterBeforePivotOrAgg") ? (l = i == null ? void 0 : i.getPivotResultCols()) == null ? void 0 : l.list : n) ?? [];
    o && (a = a.concat(o)), this.colsToUse = s.get("includeHiddenColumnsInQuickFilter") ? a : a.filter((d) => d.isVisible() || d.isRowGroupActive());
  }
  isFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPass(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassMatcher(t, e) : this.quickFilterParts.every(
      (s) => t ? this.doesRowPassCache(e, s) : this.doesRowPassNoCache(e, s)
    );
  }
  resetCache() {
    this.beans.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseFilter(e) {
    return A(e) ? e.toUpperCase() : null;
  }
  setFilter(e) {
    if (e != null && typeof e != "string") {
      R(70, { newFilter: e });
      return;
    }
    const t = this.parseFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), s = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, s && (this.setFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onColumnConfigChanged() {
    this.refreshCols(), this.resetCache(), this.isFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassNoCache(e, t) {
    return this.colsToUse.some((s) => {
      const i = this.getTextForColumn(s, e);
      return A(i) && i.indexOf(t) >= 0;
    });
  }
  doesRowPassCache(e, t) {
    return this.checkGenerateAggText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassMatcher(e, t) {
    let s;
    e ? (this.checkGenerateAggText(t), s = t.quickFilterAggregateText) : s = this.getAggText(t);
    const { quickFilterParts: i, matcher: r } = this;
    return r(i, s);
  }
  checkGenerateAggText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getAggText(e));
  }
  getTextForColumn(e, t) {
    let s = this.beans.filterValueSvc.getValue(e, t);
    const i = e.getColDef();
    if (i.getQuickFilterText) {
      const r = this.gos.addGridCommonParams({
        value: s,
        node: t,
        data: t.data,
        column: e,
        colDef: i
      });
      s = i.getQuickFilterText(r);
    }
    return A(s) ? s.toString().toUpperCase() : null;
  }
  getAggText(e) {
    const t = [];
    return this.colsToUse.forEach((s) => {
      const i = this.getTextForColumn(s, e);
      A(i) && t.push(i);
    }), t.join(`
`);
  }
}, TR = {
  moduleName: "ClientSideRowModelFilter",
  version: G,
  rowModels: ["clientSide"],
  beans: [zF]
}, pn = {
  moduleName: "FilterCore",
  version: G,
  beans: [aR],
  apiFunctions: {
    isAnyFilterPresent: oR,
    onFilterChanged: nR
  },
  css: [qF],
  dependsOn: [TR]
}, _l = {
  moduleName: "FilterValue",
  version: G,
  beans: [dR]
}, Ds = {
  moduleName: "ColumnFilter",
  version: G,
  beans: [rR, lR],
  dynamicBeans: { headerFilterCellCtrl: WF },
  icons: {
    // open filter button - header, floating filter, menu
    filter: "filter",
    // filter is applied - header (legacy column menu), filter tool panel
    filterActive: "filter"
  },
  apiFunctions: {
    isColumnFilterPresent: YF,
    getColumnFilterInstance: XF,
    destroyFilter: ZF,
    setFilterModel: QF,
    getFilterModel: JF,
    getColumnFilterModel: eR,
    setColumnFilterModel: tR,
    showColumnFilter: sR
  },
  dependsOn: [pn, ts, _l, Wp]
}, DR = {
  moduleName: "CustomFilter",
  version: G,
  userComponents: { agReadOnlyFloatingFilter: cR },
  dependsOn: [Ds]
}, ER = {
  moduleName: "TextFilter",
  version: G,
  dependsOn: [Ds],
  userComponents: {
    agTextColumnFilter: bR,
    agTextColumnFloatingFilter: SR
  }
}, MR = {
  moduleName: "NumberFilter",
  version: G,
  dependsOn: [Ds],
  userComponents: {
    agNumberColumnFilter: vR,
    agNumberColumnFloatingFilter: yR
  }
}, AR = {
  moduleName: "DateFilter",
  version: G,
  dependsOn: [Ds],
  userComponents: {
    agDateColumnFilter: gR,
    agDateInput: CR,
    agDateColumnFloatingFilter: mR
  }
}, IR = {
  moduleName: "QuickFilter",
  version: G,
  rowModels: ["clientSide"],
  beans: [PR],
  apiFunctions: {
    isQuickFilterPresent: xR,
    getQuickFilter: FR,
    resetQuickFilter: RR
  },
  dependsOn: [pn, _l]
}, LR = {
  moduleName: "ExternalFilter",
  version: G,
  dependsOn: [pn]
}, Yi = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, qn = class extends Yi {
  constructor(e, t, s, i) {
    super(e), this.initialRange = t, this.finalRange = s, this.ranges = i;
  }
}, kR = 10, oc = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || kR, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, OR = class extends P {
  constructor() {
    super(...arguments), this.beanName = "undoRedo", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, s = this.activeCellEdit !== null && Ti(this.activeCellEdit, t), i = this.activeRowEdit !== null && fe(this.activeRowEdit, t);
      if (!(s || i || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: o, rowIndex: n, column: a, oldValue: l, value: d } = e, c = {
        rowPinned: o,
        rowIndex: n,
        columnId: a.getColId(),
        newValue: d,
        oldValue: l
      };
      this.cellValueChanges.push(c);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  postConstruct() {
    const { gos: e, ctrlsSvc: t } = this.beans;
    if (!e.get("undoRedoCellEditing"))
      return;
    const s = e.get("undoRedoCellEditingLimit");
    if (s <= 0)
      return;
    this.undoStack = new oc(s), this.redoStack = new oc(s), this.addListeners();
    const i = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (r) => {
        r.keepUndoRedoStack || this.clearStacks();
      },
      columnPivotModeChanged: i,
      newColumnsLoaded: i,
      columnGroupOpened: i,
      columnRowGroupChanged: i,
      columnMoved: i,
      columnPinned: i,
      columnVisible: i,
      rowDragEnd: i
    }), t.whenReady(this, (r) => {
      this.gridBodyCtrl = r.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    var e;
    return ((e = this.undoStack) == null ? void 0 : e.getCurrentStackSize()) ?? 0;
  }
  getCurrentRedoStackSize() {
    var e;
    return ((e = this.redoStack) == null ? void 0 : e.getCurrentStackSize()) ?? 0;
  }
  undo(e) {
    const { eventSvc: t, undoStack: s, redoStack: i } = this;
    t.dispatchEvent({
      type: "undoStarted",
      source: e
    });
    const r = this.undoRedo(s, i, "initialRange", "oldValue", "undo");
    t.dispatchEvent({
      type: "undoEnded",
      source: e,
      operationPerformed: r
    });
  }
  redo(e) {
    const { eventSvc: t, undoStack: s, redoStack: i } = this;
    t.dispatchEvent({
      type: "redoStarted",
      source: e
    });
    const r = this.undoRedo(i, s, "finalRange", "newValue", "redo");
    t.dispatchEvent({
      type: "redoEnded",
      source: e,
      operationPerformed: r
    });
  }
  undoRedo(e, t, s, i, r) {
    if (!e)
      return !1;
    const o = e.pop();
    return !o || !o.cellValueChanges ? !1 : (this.processAction(
      o,
      (n) => n[i],
      r
    ), o instanceof qn ? this.processRange(o.ranges || [o[s]]) : this.processCell(o.cellValueChanges), t.push(o), !0);
  }
  processAction(e, t, s) {
    e.cellValueChanges.forEach((i) => {
      const { rowIndex: r, rowPinned: o, columnId: n } = i, a = { rowIndex: r, rowPinned: o }, l = St(this.beans, a);
      l.displayed && l.setDataValue(n, t(i), s);
    });
  }
  processRange(e) {
    let t;
    const s = this.beans.rangeSvc;
    s.removeAllCellRanges(!0), e.forEach((i, r) => {
      if (!i)
        return;
      const o = i.startRow, n = i.endRow;
      r === e.length - 1 && (t = {
        rowPinned: o.rowPinned,
        rowIndex: o.rowIndex,
        columnId: i.startColumn.getColId()
      }, this.setLastFocusedCell(t));
      const a = {
        rowStartIndex: o.rowIndex,
        rowStartPinned: o.rowPinned,
        rowEndIndex: n.rowIndex,
        rowEndPinned: n.rowPinned,
        columnStart: i.startColumn,
        columns: i.columns
      };
      s.addCellRange(a);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: s, rowPinned: i } = t, r = { rowIndex: s, rowPinned: i }, o = St(this.beans, r), n = {
      rowPinned: t.rowPinned,
      rowIndex: o.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(n);
  }
  setLastFocusedCell(e) {
    const { rowIndex: t, columnId: s, rowPinned: i } = e, { colModel: r, focusSvc: o, rangeSvc: n } = this.beans, a = r.getCol(s);
    if (!a)
      return;
    const { scrollFeature: l } = this.gridBodyCtrl;
    l.ensureIndexVisible(t), l.ensureColumnVisible(a);
    const d = { rowIndex: t, column: a, rowPinned: i };
    o.setFocusedCell({ ...d, forceBrowserFocus: !0 }), n == null || n.setRangeToCell(d);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const e = new Yi(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
          const s = new Yi(this.cellValueChanges);
          this.pushActionsToUndoStack(s);
        }
      },
      pasteStart: () => {
        this.isPasting = !0;
      },
      pasteEnd: () => {
        const e = new Yi(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.isPasting = !1;
      },
      fillStart: () => {
        this.isRangeInAction = !0;
      },
      fillEnd: (e) => {
        const t = new qn(this.cellValueChanges, e.initialRange, e.finalRange);
        this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = !0;
      },
      keyShortcutChangedCellEnd: () => {
        let e;
        const { rangeSvc: t, gos: s } = this.beans;
        t && Ve(s) ? e = new qn(this.cellValueChanges, void 0, void 0, [
          ...t.getCellRanges()
        ]) : e = new Yi(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
      }
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
}, GR = (
  /*css*/
  ".ag-cell-inline-editing{border:var(--ag-cell-editing-border)!important;border-radius:var(--ag-border-radius);box-shadow:var(--ag-cell-editing-shadow);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-wrapper,:where(.ag-cell-editor) .ag-input-field-input,:where(.ag-cell-editor) .ag-wrapper{height:100%;line-height:normal;width:100%}}:where(.ag-popup-editor) .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{height:auto;padding:var(--ag-cell-horizontal-padding)}:where(.ag-rtl .ag-large-text-input) textarea{resize:none}:where(.ag-ltr) .ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-checkbox-edit{padding-right:var(--ag-cell-horizontal-padding)}"
), BR = class extends Ts {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [Pt]
    ), this.eCheckbox = S;
  }
  init(e) {
    this.params = e;
    const t = e.value ?? void 0, s = this.eCheckbox;
    s.setValue(t), s.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(s, {
      fieldValueChanged: (r) => this.setAriaLabel(r.selected)
    });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.getLocaleTextFunc(), s = tl(t, e), i = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${i} (${s})`);
  }
}, gn = class extends Ts {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`,
      e.getAgComponents()
    ), this.cellEditorInput = e, this.eInput = S;
  }
  init(e) {
    this.params = e;
    const { cellStartedEdit: t, eventKey: s, suppressPreventDefault: i } = e, r = this.eInput;
    this.cellEditorInput.init(r, e);
    let o, n = !0;
    t ? (this.focusAfterAttached = !0, s === w.BACKSPACE || s === w.DELETE ? o = "" : s && s.length === 1 ? i ? n = !1 : o = s : (o = this.cellEditorInput.getStartValue(), s !== w.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, o = this.cellEditorInput.getStartValue()), n && o != null && r.setStartValue(o), this.addManagedElementListeners(r.getGui(), {
      keydown: (a) => {
        const { key: l } = a;
        (l === w.PAGE_UP || l === w.PAGE_DOWN) && a.preventDefault();
      }
    });
  }
  afterGuiAttached() {
    var i, r;
    const e = this.getLocaleTextFunc(), t = this.eInput;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    si() || t.getFocusableElement().focus();
    const s = t.getInputElement();
    this.highlightAllOnFocus ? s.select() : (r = (i = this.cellEditorInput).setCaret) == null || r.call(i);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), s = e.getInputElement();
    t.focus(), s.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
}, VR = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [rp];
  }
  init(e, t) {
    this.eInput = e, this.params = t;
    const { min: s, max: i, step: r } = t;
    s != null && e.setMin(s), i != null && e.setMax(i), r != null && e.setStep(r);
  }
  getValue() {
    const { eInput: e, params: t } = this, s = e.getDate();
    return !A(s) && !A(t.value) ? t.value : s ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Ze(e, !1);
  }
}, NR = class extends gn {
  constructor() {
    super(new VR());
  }
}, HR = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [rp];
  }
  init(e, t) {
    this.eInput = e, this.params = t;
    const { min: s, max: i, step: r } = t;
    s != null && e.setMin(s), i != null && e.setMax(i), r != null && e.setStep(r);
  }
  getValue() {
    const { params: e, eInput: t } = this, s = this.formatDate(t.getDate());
    return !A(s) && !A(e.value) ? e.value : e.parseValue(s ?? "");
  }
  getStartValue() {
    return Ze(this.parseDate(this.params.value ?? void 0) ?? null, !1);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : Le(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Ze(e ?? null, !1) ?? void 0;
  }
}, zR = class extends gn {
  constructor() {
    super(new HR(() => this.beans.dataTypeSvc));
  }
}, WR = class extends Ts {
  constructor() {
    super(
      /* html */
      `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
      [Gy]
    ), this.eTextArea = S;
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), e.value != null && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === w.LEFT || t === w.UP || t === w.RIGHT || t === w.DOWN || e.shiftKey && t === w.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue(), t = this.params;
    return !A(e) && !A(t.value) ? t.value : t.parseValue(e);
  }
}, _R = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>'
    );
  }
  getAgComponents() {
    return [an];
  }
  init(e, t) {
    this.eInput = e, this.params = t;
    const { max: s, min: i, precision: r, step: o } = t;
    s != null && e.setMax(s), i != null && e.setMin(i), r != null && e.setPrecision(r), o != null && e.setStep(o);
    const n = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(n, { keydown: this.preventStepping }) : t.showStepperButtons && n.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === w.UP || e.key === w.DOWN) && e.preventDefault();
  }
  getValue() {
    const { eInput: e, params: t } = this, s = e.getValue();
    if (!A(s) && !A(t.value))
      return t.value;
    let i = t.parseValue(s);
    if (i == null)
      return i;
    if (typeof i == "string") {
      if (i === "")
        return null;
      i = Number(i);
    }
    return isNaN(i) ? null : i;
  }
  getStartValue() {
    return this.params.value;
  }
  setCaret() {
    si() && this.eInput.getInputElement().focus({ preventScroll: !0 });
  }
}, UR = class extends gn {
  constructor() {
    super(new _R());
  }
}, KR = class extends Ts {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
      [Rr]
    ), this.eSelect = S, this.startedByEnter = !1;
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueSvc: s, gos: i } = this, { values: r, value: o, eventKey: n } = e;
    if (Y(r)) {
      R(58);
      return;
    }
    this.startedByEnter = n != null ? n === w.ENTER : !1;
    let a = !1;
    r.forEach((h) => {
      const u = { value: h }, p = s.formatValue(e.column, null, h), g = p != null;
      u.text = g ? p : h, t.addOption(u), a = a || o === h;
    }), a ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: d, valueListMaxHeight: c } = e;
    l != null && t.setPickerGap(l), c != null && t.setPickerMaxHeight(c), d != null && t.setPickerMaxWidth(d), i.get("editType") !== "fullRow" && this.addManagedListeners(this.eSelect, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}, $R = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>'
    );
  }
  getAgComponents() {
    return [mt];
  }
  init(e, t) {
    this.eInput = e, this.params = t;
    const s = t.maxLength;
    s != null && e.setMaxLength(s);
  }
  getValue() {
    const { eInput: e, params: t } = this, s = e.getValue();
    return !A(s) && !A(t.value) ? t.value : t.parseValue(s);
  }
  getStartValue() {
    const e = this.params;
    return e.useFormatter || e.column.getColDef().refData ? e.formatValue(e.value) : e.value;
  }
  setCaret() {
    const e = this.eInput, t = e.getValue(), s = A(t) && t.length || 0;
    s && e.getInputElement().setSelectionRange(s, s);
  }
}, nc = class extends gn {
  constructor() {
    super(new $R());
  }
};
function jR(e) {
  return e.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
function qR(e) {
  return e.ctrlsSvc.getScrollFeature().getHScrollPosition();
}
function ig(e, t, s = "auto") {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureColumnVisible(t, s),
    "ensureVisible"
  );
}
function rg(e, t, s) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureIndexVisible(t, s),
    "ensureVisible"
  );
}
function YR(e, t, s = null) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureNodeVisible(t, s),
    "ensureVisible"
  );
}
function XR(e) {
  var t;
  (t = e.undoRedo) == null || t.undo("api");
}
function ZR(e) {
  var t;
  (t = e.undoRedo) == null || t.redo("api");
}
function QR(e, t = {}) {
  const s = [];
  return e.rowRenderer.getCellCtrls(t.rowNodes, t.columns).forEach((i) => {
    var o;
    const r = (o = i.comp) == null ? void 0 : o.getCellEditor();
    r && s.push(Ys(r));
  }), s;
}
function JR(e) {
  const t = [];
  return e.rowRenderer.getAllCellCtrls().forEach((s) => {
    if (s.editing) {
      const { cellPosition: i } = s;
      t.push(i);
    }
  }), t;
}
function eP(e, t = !1) {
  var s;
  (s = e.editSvc) == null || s.stopAllEditing(t);
}
function tP(e, t) {
  const s = e.colModel.getCol(t.colKey);
  if (!s) {
    R(12, { colKey: t.colKey });
    return;
  }
  const i = {
    rowIndex: t.rowIndex,
    rowPinned: t.rowPinned || null,
    column: s
  };
  t.rowPinned == null && rg(e, t.rowIndex), ig(e, t.colKey);
  const o = It(e, i);
  if (!o)
    return;
  const { focusSvc: n, gos: a, editSvc: l } = e, d = () => {
    const h = q(e), u = o.eGui;
    return h !== u && !!(u != null && u.contains(h));
  }, c = a.get("stopEditingWhenCellsLoseFocus") && d();
  (c || !n.isCellFocused(i)) && n.setFocusedCell({
    ...i,
    forceBrowserFocus: c,
    preventScrollOnBrowserFocus: !0
  }), l == null || l.startRowOrCellEdit(o, t.key);
}
function sP(e) {
  var t;
  return ((t = e.undoRedo) == null ? void 0 : t.getCurrentUndoStackSize()) ?? 0;
}
function iP(e) {
  var t;
  return ((t = e.undoRedo) == null ? void 0 : t.getCurrentRedoStackSize()) ?? 0;
}
var rP = class extends Ts {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = e;
  }
  postConstruct() {
    js(this.gos, this.getGui(), "popupEditorWrapper", !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, s = (i) => {
      Sa(this.gos, i, t.node, t.column, !0) || t.onKeyDown(i);
    };
    this.addManagedElementListeners(e, { keydown: s });
  }
}, oP = class extends P {
  constructor() {
    super(...arguments), this.beanName = "editSvc";
  }
  startEditing(e, t = null, s = !1, i = null) {
    var d;
    if (!e.isCellEditable() || e.editing)
      return !0;
    if (!e.comp)
      return e.onCompAttachedFuncs.push(() => {
        this.startEditing(e, t, s, i);
      }), !0;
    const r = this.createCellEditorParams(e, t, s), o = e.column.getColDef(), n = Ld(this.beans.userCompFactory, o, r), a = (n == null ? void 0 : n.popupFromSelector) != null ? n.popupFromSelector : !!o.cellEditorPopup, l = (n == null ? void 0 : n.popupPositionFromSelector) != null ? n.popupPositionFromSelector : o.cellEditorPopupPosition;
    return ac(e, !0, n), e.comp.setEditDetails(n, a, l, this.gos.get("reactiveCustomComponents")), this.eventSvc.dispatchEvent(e.createEvent(i, "cellEditingStarted")), !((d = n == null ? void 0 : n.params) != null && d.suppressPreventDefault);
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(e, t = !1) {
    if (e.onEditorAttachedFuncs = [], !e.editing)
      return !1;
    const { comp: s, column: i, rowNode: r } = e, { newValue: o, newValueExists: n } = nP(t, s), a = this.beans.valueSvc.getValueForDisplay(i, r);
    let l = !1;
    return n && (l = aP(e, a, o, r, i)), ac(e, !1, void 0), s.setEditDetails(), e.updateAndFormatValue(!1), e.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.eventSvc.dispatchEvent({
      ...e.createEvent(null, "cellEditingStopped"),
      oldValue: a,
      newValue: o,
      valueChanged: l
    }), l;
  }
  handleColDefChanged(e) {
    var s;
    const t = (s = e.comp) == null ? void 0 : s.getCellEditor();
    if (t != null && t.refresh) {
      const { eventKey: i, cellStartedEdit: r } = e.editCompDetails.params, o = this.createCellEditorParams(e, i, r), n = e.column.getColDef(), a = Ld(this.beans.userCompFactory, n, o);
      t.refresh(a.params);
    }
  }
  setFocusOutOnEditor(e) {
    if (!e.editing)
      return;
    const t = e.comp.getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor(e) {
    if (!e.editing)
      return;
    const t = e.comp, s = t.getCellEditor();
    s != null && s.focusIn ? s.focusIn() : (e.focusCell(!0), e.onEditorAttachedFuncs.push(() => {
      var i, r;
      return (r = (i = t.getCellEditor()) == null ? void 0 : i.focusIn) == null ? void 0 : r.call(i);
    }));
  }
  stopEditingAndFocus(e, t = !1, s = !1) {
    this.stopRowOrCellEdit(e), e.focusCell(!0), t || this.navigateAfterEdit(s, e.cellPosition);
  }
  createPopupEditorWrapper(e) {
    return new rP(e);
  }
  stopAllEditing(e = !1) {
    this.beans.rowRenderer.getAllRowCtrls().forEach((t) => this.stopRowEditing(t, e));
  }
  stopRowEditing(e, t = !1) {
    var o;
    if (e.stoppingRowEdit)
      return;
    const s = e.getAllCellCtrls(), i = e.editing;
    e.stoppingRowEdit = !0;
    let r = !1;
    for (const n of s) {
      const a = n.stopEditing(t);
      i && !t && !r && a && (r = !0);
    }
    r && this.eventSvc.dispatchEvent(e.createRowEvent("rowValueChanged")), i && ((o = this.beans.rowEditSvc) == null || o.setEditing(e, !1)), e.stoppingRowEdit = !1;
  }
  addStopEditingWhenGridLosesFocus(e) {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus"))
      return;
    const t = (s) => {
      const i = s.relatedTarget;
      if (pa(i) === null) {
        this.stopAllEditing();
        return;
      }
      let r = (
        // see if click came from inside the viewports
        e.some((o) => o.contains(i)) && // and also that it's not from a detail grid
        Lu(this.gos, i)
      );
      if (!r) {
        const o = this.beans.popupSvc;
        r = !!o && (o.getActivePopups().some((n) => n.contains(i)) || o.isElementWithinCustomPopup(i));
      }
      r || this.stopAllEditing();
    };
    e.forEach((s) => this.addManagedElementListeners(s, { focusout: t }));
  }
  setInlineEditingCss(e) {
    const t = e.editing || e.getAllCellCtrls().some((s) => s.editing);
    e.forEachGui(void 0, (s) => {
      s.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), s.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  isCellEditable(e, t) {
    if (t.group) {
      if (this.gos.get("treeData")) {
        if (!t.data && !this.gos.get("enableGroupEdit"))
          return !1;
      } else if (!this.gos.get("enableGroupEdit"))
        return !1;
    }
    return e.isColumnFunc(t, e.colDef.editable);
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(e, t, s = null) {
    var i;
    return e.comp ? this.gos.get("editType") === "fullRow" ? ((i = this.beans.rowEditSvc) == null ? void 0 : i.startEditing(e.rowCtrl, t, e)) ?? !0 : this.startEditing(e, t, !0, s) : (e.onCompAttachedFuncs.push(() => {
      this.startRowOrCellEdit(e, t, s);
    }), !0);
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(e, t = !1) {
    this.gos.get("editType") === "fullRow" ? this.stopRowEditing(e.rowCtrl, t) : this.stopEditing(e, t);
  }
  createCellEditorParams(e, t, s) {
    const {
      column: i,
      rowNode: r,
      eGui: o,
      cellPosition: { rowIndex: n }
    } = e, { valueSvc: a, gos: l } = this.beans;
    return l.addGridCommonParams({
      value: a.getValueForDisplay(i, r),
      eventKey: t,
      column: i,
      colDef: i.getColDef(),
      rowIndex: n,
      node: r,
      data: r.data,
      cellStartedEdit: s,
      onKeyDown: e.onKeyDown.bind(e),
      stopEditing: e.stopEditingAndFocus.bind(e),
      eGridCell: o,
      parseValue: (d) => a.parseValue(i, r, d, e.value),
      formatValue: e.formatValue.bind(e)
    });
  }
  navigateAfterEdit(e, t) {
    var i;
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const r = e ? w.UP : w.DOWN;
      (i = this.beans.navigation) == null || i.navigateToNextCell(null, r, t, !1);
    }
  }
};
function ac(e, t, s) {
  e.editCompDetails = s, e.editing !== t && (e.editing = t);
}
function nP(e, t) {
  const s = { newValueExists: !1 };
  if (e)
    return s;
  const i = t.getCellEditor();
  return !i || i.isCancelAfterEnd && i.isCancelAfterEnd() ? s : {
    newValue: i.getValue(),
    newValueExists: !0
  };
}
function aP(e, t, s, i, r) {
  if (s === t)
    return !1;
  e.suppressRefreshCell = !0;
  const o = i.setDataValue(r, s, "edit");
  return e.suppressRefreshCell = !1, o;
}
var lP = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowEditSvc";
  }
  startEditing(e, t = null, s = null, i = null) {
    if (e.editing)
      return !0;
    let r = !0, o = !1;
    const { editSvc: n } = this.beans;
    return e.getAllCellCtrls().forEach((a) => {
      const l = a === s;
      l ? r = (n == null ? void 0 : n.startEditing(a, t, l, i)) ?? !0 : n == null || n.startEditing(a, null, l, i), o || (o = a.editing);
    }), o && this.setEditing(e, !0), r;
  }
  setEditing(e, t) {
    e.editing = t, e.forEachGui(void 0, (i) => i.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const s = t ? e.createRowEvent("rowEditingStarted") : e.createRowEvent("rowEditingStopped");
    this.eventSvc.dispatchEvent(s);
  }
}, ss = {
  moduleName: "EditCore",
  version: G,
  beans: [oP, lP],
  apiFunctions: {
    getCellEditorInstances: QR,
    getEditingCells: JR,
    stopEditing: eP,
    startEditingCell: tP
  },
  dependsOn: [ts],
  css: [GR]
}, dP = {
  moduleName: "UndoRedoEdit",
  version: G,
  beans: [OR],
  apiFunctions: {
    undoCellEditing: XR,
    redoCellEditing: ZR,
    getCurrentUndoSize: sP,
    getCurrentRedoSize: iP
  },
  dependsOn: [ss]
}, cP = {
  moduleName: "TextEditor",
  version: G,
  userComponents: { agCellEditor: nc, agTextCellEditor: nc },
  dependsOn: [ss]
}, hP = {
  moduleName: "NumberEditor",
  version: G,
  userComponents: {
    agNumberCellEditor: {
      classImp: UR,
      params: {
        suppressPreventDefault: !0
      }
    }
  },
  dependsOn: [ss]
}, uP = {
  moduleName: "DateEditor",
  version: G,
  userComponents: {
    agDateCellEditor: NR,
    agDateStringCellEditor: zR
  },
  dependsOn: [ss]
}, pP = {
  moduleName: "CheckboxEditor",
  version: G,
  userComponents: {
    agCheckboxCellEditor: BR
  },
  dependsOn: [ss]
}, gP = {
  moduleName: "SelectEditor",
  version: G,
  userComponents: { agSelectCellEditor: KR },
  dependsOn: [ss]
}, fP = {
  moduleName: "LargeTextEditor",
  version: G,
  userComponents: { agLargeTextCellEditor: WR },
  dependsOn: [ss]
}, mP = {
  moduleName: "CustomEditor",
  version: G,
  dependsOn: [ss]
};
function CP(e, t) {
  var a;
  if (!t.nodes.every((l) => l.rowPinned ? (R(59), !1) : l.id === void 0 ? (R(60), !1) : !0))
    return;
  const { nodes: i, source: r, newValue: o } = t, n = i;
  (a = e.selectionSvc) == null || a.setNodesSelected({ nodes: n, source: r ?? "api", newValue: o });
}
function vP(e, t, s = "apiSelectAll") {
  var i;
  (i = e.selectionSvc) == null || i.selectAllRowNodes({ source: s, selectAll: t });
}
function wP(e, t, s = "apiSelectAll") {
  var i;
  (i = e.selectionSvc) == null || i.deselectAllRowNodes({ source: s, selectAll: t });
}
function yP(e, t = "apiSelectAllFiltered") {
  var s;
  (s = e.selectionSvc) == null || s.selectAllRowNodes({ source: t, selectAll: "filtered" });
}
function bP(e, t = "apiSelectAllFiltered") {
  var s;
  (s = e.selectionSvc) == null || s.deselectAllRowNodes({ source: t, selectAll: "filtered" });
}
function SP(e, t = "apiSelectAllCurrentPage") {
  var s;
  (s = e.selectionSvc) == null || s.selectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function xP(e, t = "apiSelectAllCurrentPage") {
  var s;
  (s = e.selectionSvc) == null || s.deselectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function FP(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedNodes()) ?? [];
}
function RP(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedRows()) ?? [];
}
var PP = class extends sp {
  constructor() {
    super(...arguments), this.beanName = "selectionSvc", this.selectedNodes = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    super.postConstruct();
    const { gos: e } = this;
    this.mode = Ri(e), this.groupSelectsDescendants = qs(e), this.groupSelectsFiltered = wo(e) === "filteredDescendants", this.addManagedPropertyListeners(["groupSelectsChildren", "groupSelectsFiltered", "rowSelection"], () => {
      const t = qs(e), s = Ri(e), i = wo(e) === "filteredDescendants";
      (t !== this.groupSelectsDescendants || i !== this.groupSelectsFiltered || s !== this.mode) && (this.deselectAllRowNodes({ source: "api" }), this.groupSelectsDescendants = t, this.groupSelectsFiltered = i, this.mode = s);
    }), this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes();
  }
  handleSelectionEvent(e, t, s) {
    if (this.isRowSelectionBlocked(t))
      return 0;
    const i = this.inferNodeSelections(t, e.shiftKey, e.metaKey || e.ctrlKey, s);
    return i == null ? 0 : "select" in i ? (i.reset ? this.resetNodes() : this.selectRange(i.deselect, !1, s), this.selectRange(i.select, !0, s)) : this.setNodesSelected({
      nodes: [i.node],
      newValue: i.newValue,
      clearSelection: i.clearSelection,
      event: e,
      source: s
    });
  }
  setNodesSelected({
    newValue: e,
    clearSelection: t,
    suppressFinishActions: s,
    nodes: i,
    event: r,
    source: o
  }) {
    var a;
    if (!ot(this.gos) && e)
      return R(132), 0;
    if (i.length === 0)
      return 0;
    if (i.length > 1 && !this.isMultiSelect())
      return R(130), 0;
    let n = 0;
    for (let l = 0; l < i.length; l++) {
      const d = i[l], c = d.footer ? d.sibling : d, h = this.groupSelectsFiltered && c.group;
      if (c.rowPinned) {
        R(59);
        continue;
      }
      if (c.id === void 0) {
        R(60);
        continue;
      }
      h || this.selectRowNode(c, e, r, o) && n++, this.groupSelectsDescendants && ((a = c.childrenAfterGroup) != null && a.length) && (n += this.selectChildren(c, e, o));
    }
    return s || (e && (t || !this.isMultiSelect()) && (n += this.clearOtherNodes(i[0], o)), n > 0 && (this.updateGroupsFromChildrenSelections(o), this.dispatchSelectionChanged(o))), n;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, s) {
    let i = 0;
    return e.forEach((r) => {
      if (r.group && this.groupSelectsDescendants)
        return;
      this.selectRowNode(r, t, void 0, s) && i++;
    }), i > 0 && (this.updateGroupsFromChildrenSelections(s), this.dispatchSelectionChanged(s)), i;
  }
  selectChildren(e, t, s) {
    const i = this.groupSelectsFiltered ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return i ? this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      source: s,
      nodes: i
    }) : 0;
  }
  getSelectedNodes() {
    return Array.from(this.selectedNodes.values());
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => e.push(t.data)), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((s, i) => {
      e(s) && t.set(i, s);
    }), this.selectedNodes = t;
  }
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsDescendants)
      return !1;
    const { gos: s, rowModel: i } = this.beans;
    if (!J(s))
      return !1;
    const r = i.rootNode;
    if (!r)
      return !1;
    t || (t = new Mi(!0, r), t.active = !1);
    let o = !1;
    return t.forEachChangedNodeDepthFirst((n) => {
      if (n !== r) {
        const a = this.calculateSelectedFromChildren(n);
        o = this.selectRowNode(n, a === null ? !1 : a, void 0, e) || o;
      }
    }), o;
  }
  clearOtherNodes(e, t) {
    const s = /* @__PURE__ */ new Map();
    let i = 0;
    return this.selectedNodes.forEach((r) => {
      if (r && r.id !== e.id) {
        const o = this.selectedNodes.get(r.id);
        i += this.setNodesSelected({
          nodes: [o],
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsDescendants && r.parent && s.set(r.parent.id, r.parent);
      }
    }), s.forEach((r) => {
      const o = this.calculateSelectedFromChildren(r);
      this.selectRowNode(r, o === null ? !1 : o, void 0, t);
    }), i;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsDescendants && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  createDaemonNode(e) {
    if (!e.id)
      return;
    const t = new Qe(this.beans);
    return t.id = e.id, t.data = e.data, t.__daemon = !0, t.__selected = e.__selected, t.level = e.level, t;
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    t && e.id !== t.id && this.selectedNodes.get(t.id) == e && this.selectedNodes.set(t.id, t);
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.__selected = !0, this.selectedNodes.set(e.id, e)) : e.__selected = !1;
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    this.selectedNodes.forEach((e) => {
      this.selectRowNode(e, !1);
    }), this.selectedNodes.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    const { gos: e, rowModel: t } = this.beans;
    if (!J(e))
      return;
    const s = t.getTopLevelNodes();
    if (s === null)
      return;
    const i = [];
    function r(o) {
      for (let n = 0, a = o.length; n < a; n++) {
        const l = o[n];
        l.isSelected() ? i.push(l) : l.group && l.childrenAfterGroup && r(l.childrenAfterGroup);
      }
    }
    return r(s), i;
  }
  isEmpty() {
    return this.getSelectionCount() === 0;
  }
  deselectAllRowNodes(e) {
    const t = (o) => this.selectRowNode(o.footer ? o.sibling : o, !1, void 0, i), s = J(this.gos), { source: i, selectAll: r } = e;
    if (r === "currentPage" || r === "filtered") {
      if (!s) {
        z(102);
        return;
      }
      this.getNodesToSelect(r).forEach(t);
    } else
      this.selectedNodes.forEach(t), this.reset(i);
    s && this.groupSelectsDescendants && this.updateGroupsFromChildrenSelections(i), this.dispatchSelectionChanged(i);
  }
  getSelectedCounts(e) {
    let t = 0, s = 0;
    const i = (r) => {
      this.groupSelectsDescendants && r.group || (r.isSelected() ? t++ : r.selectable && s++);
    };
    return this.getNodesToSelect(e).forEach(i), { selectedCount: t, notSelectedCount: s };
  }
  getSelectAllState(e) {
    const { selectedCount: t, notSelectedCount: s } = this.getSelectedCounts(e);
    return t === 0 && s === 0 ? !1 : t > 0 && s > 0 ? null : t > 0;
  }
  hasNodesToSelect(e) {
    return this.getNodesToSelect(e).filter((t) => t.selectable).length > 0;
  }
  /**
   * @param selectAll See `MultiRowSelectionOptions.selectAll`
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e) {
    if (!this.canSelectAll())
      return [];
    const t = [];
    if (e === "currentPage")
      return this.forEachNodeOnPage((i) => {
        if (!i.group) {
          t.push(i);
          return;
        }
        if (!i.expanded && !i.footer) {
          const r = (o) => {
            var n;
            t.push(o), (n = o.childrenAfterFilter) != null && n.length && o.childrenAfterFilter.forEach(r);
          };
          r(i);
          return;
        }
        this.groupSelectsDescendants || t.push(i);
      }), t;
    const s = this.beans.rowModel;
    return e === "filtered" ? (s.forEachNodeAfterFilter((i) => {
      t.push(i);
    }), t) : (s.forEachNode((i) => {
      t.push(i);
    }), t);
  }
  forEachNodeOnPage(e) {
    const { pageBounds: t, rowModel: s } = this.beans, i = t.getFirstRow(), r = t.getLastRow();
    for (let o = i; o <= r; o++) {
      const n = s.getRow(o);
      n && e(n);
    }
  }
  selectAllRowNodes(e) {
    const { gos: t } = this;
    if (!ot(t)) {
      R(132);
      return;
    }
    if (ll(t) && !bs(t)) {
      R(130);
      return;
    }
    if (!this.canSelectAll())
      return;
    const { source: s, selectAll: i } = e;
    this.getNodesToSelect(i).forEach((r) => {
      this.selectRowNode(r.footer ? r.sibling : r, !0, void 0, s);
    }), J(t) && this.groupSelectsDescendants && this.updateGroupsFromChildrenSelections(s), this.dispatchSelectionChanged(s);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t != null && t.id && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e)) {
      z(103);
      return;
    }
    const s = new Set(e), i = [];
    this.beans.rowModel.forEachNode((r) => {
      s.has(r.id) && i.push(r);
    }), this.setNodesSelected({
      newValue: !0,
      nodes: i,
      source: t
    });
  }
  canSelectAll() {
    const { gos: e, rowModel: t } = this.beans;
    return J(e) ? !0 : (z(100, { rowModelType: t.getType() }), !1);
  }
  /**
   * Updates the selectable state for a node by invoking isRowSelectable callback.
   * If the node is not selectable, it will be deselected.
   *
   * Callers:
   *  - property isRowSelectable changed
   *  - after grouping / treeData via `updateSelectableAfterGrouping`
   */
  updateSelectable(e) {
    var l;
    const { gos: t, rowModel: s } = this.beans;
    if (!ot(t))
      return;
    const i = "selectableChanged", r = e !== void 0, o = J(t) && this.groupSelectsDescendants, n = [], a = (d) => {
      var h;
      if (r && !d.group)
        return;
      if (o && d.group) {
        const u = ((h = d.childrenAfterGroup) == null ? void 0 : h.some((p) => p.selectable)) ?? !1;
        this.setRowSelectable(d, u, !0);
        return;
      }
      !this.updateRowSelectable(d, !0) && d.isSelected() && n.push(d);
    };
    if (o) {
      if (e === void 0) {
        const d = s.rootNode;
        e = d ? new Mi(!1, d) : void 0;
      }
      e == null || e.forEachChangedNodeDepthFirst(a, !r, !r);
    } else
      s.forEachNode(a);
    n.length && this.setNodesSelected({
      nodes: n,
      newValue: !1,
      source: i
    }), !r && o && ((l = this.updateGroupsFromChildrenSelections) == null || l.call(this, i));
  }
  // only called by CSRM
  updateSelectableAfterGrouping(e) {
    var t;
    this.updateSelectable(e), this.groupSelectsDescendants && ((t = this.updateGroupsFromChildrenSelections) != null && t.call(this, "rowGroupChanged", e)) && this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: "rowGroupChanged"
    });
  }
}, og = {
  moduleName: "SharedRowSelection",
  version: G,
  beans: [ev],
  apiFunctions: {
    setNodesSelected: CP,
    selectAll: vP,
    deselectAll: wP,
    selectAllFiltered: yP,
    deselectAllFiltered: bP,
    selectAllOnCurrentPage: SP,
    deselectAllOnCurrentPage: xP,
    getSelectedNodes: FP,
    getSelectedRows: RP
  }
}, TP = {
  moduleName: "RowSelection",
  version: G,
  rowModels: ["clientSide", "infinite", "viewport"],
  beans: [PP],
  dependsOn: [og]
};
function DP(e) {
  var t;
  (t = e.expansionSvc) == null || t.expandAll(!0);
}
function EP(e) {
  var t;
  (t = e.expansionSvc) == null || t.expandAll(!1);
}
function MP(e) {
  const t = Dt(e), s = ki(e);
  t ? t.onRowHeightChanged() : s && s.onRowHeightChanged();
}
function AP(e, t, s) {
  var o;
  const i = ki(e);
  if (i) {
    if (((o = e.rowGroupColsSvc) == null ? void 0 : o.columns.length) === 0) {
      if (t < 0) {
        z(238);
        return;
      }
      i.setRowCount(t, s);
      return;
    }
    z(28);
    return;
  }
  const r = hn(e);
  if (r) {
    r.setRowCount(t, s);
    return;
  }
}
function IP(e) {
  var t;
  return Te(e.gos) ? e.rowModel.getBlockStates() : ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {};
}
function LP(e) {
  return e.rowModel.isLastRowIndexKnown();
}
var ng = {
  moduleName: "CsrmSsrmSharedApi",
  version: G,
  apiFunctions: {
    expandAll: DP,
    collapseAll: EP,
    onRowHeightChanged: MP
  }
}, ag = {
  moduleName: "SsrmInfiniteSharedApi",
  version: G,
  apiFunctions: {
    setRowCount: AP,
    getCacheBlockState: IP,
    isLastRowIndexKnown: LP
  }
}, kP = class extends P {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsSvc", this.consuming = !1;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    return typeof e == "function" && (e = e()), e.map((i) => {
      var o;
      if (!i) {
        z(18), t || z(20);
        return;
      }
      if (this.isGridApi(i))
        return i;
      const r = i;
      return "current" in r ? (o = r.current) == null ? void 0 : o.api : (r.api || z(19), r.api);
    }).filter((i) => !!i && !i.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: e,
      columnVisible: e,
      columnPinned: e,
      columnGroupOpened: e,
      columnResized: e,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
      alignedGridScroll: ({ event: t }) => this.onScrollEvent(t)
    });
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    this.fireEvent({
      type: "alignedGridColumn",
      event: e
    });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent({
      type: "alignedGridScroll",
      event: e
    });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.beans.ctrlsSvc.getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  extractDataFromEvent(e, t) {
    const s = [];
    return e.columns ? e.columns.forEach((i) => {
      s.push(t(i));
    }) : e.column && s.push(t(e.column)), s;
  }
  getMasterColumns(e) {
    return this.extractDataFromEvent(e, (t) => t);
  }
  getColumnIds(e) {
    return this.extractDataFromEvent(e, (t) => t.getColId());
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          this.processColumnEvent(e);
          break;
        }
        case "columnGroupOpened": {
          this.processGroupOpenedEvent(e);
          break;
        }
        case "columnPivotChanged":
          R(21);
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    const { colGroupSvc: t } = this.beans;
    t && e.columnGroups.forEach((s) => {
      let i = null;
      s && (i = t.getProvidedColGroup(s.getGroupId())), !(s && !i) && t.setColumnGroupOpened(i, s.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var c;
    const t = e.column;
    let s = null;
    const i = this.beans, { colResize: r, ctrlsSvc: o, colModel: n } = i;
    if (t && (s = n.getColDefCol(t.getColId())), t && !s)
      return;
    const a = this.getMasterColumns(e);
    switch (e.type) {
      case "columnMoved":
        {
          const u = e.api.getColumnState().map((p) => ({ colId: p.colId }));
          Xe(i, { state: u, applyOrder: !0 }, "alignedGridChanged");
        }
        break;
      case "columnVisible":
        {
          const u = e.api.getColumnState().map((p) => ({ colId: p.colId, hide: p.hide }));
          Xe(i, { state: u }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const u = e.api.getColumnState().map((p) => ({ colId: p.colId, pinned: p.pinned }));
          Xe(i, { state: u }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const h = e, u = {};
        a.forEach((p) => {
          u[p.getId()] = { key: p.getColId(), newWidth: p.getActualWidth() };
        }), (c = h.flexColumns) == null || c.forEach((p) => {
          u[p.getId()] && delete u[p.getId()];
        }), r == null || r.setColumnWidths(
          Object.values(u),
          !1,
          h.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const d = o.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((h) => {
      h.setGridOption("alwaysShowVerticalScroll", d);
    });
  }
}, OP = {
  moduleName: "AlignedGrids",
  version: G,
  beans: [kP]
}, GP = class extends tp {
  constructor() {
    super(...arguments), this.beanName = "csrmNodeSvc";
  }
}, Yn = class {
  constructor() {
    this.removals = /* @__PURE__ */ new Set(), this.updates = /* @__PURE__ */ new Map();
  }
  /** Marks a row as removed. Order of operations is: remove, update, add */
  remove(e) {
    this.removals.add(e), this.updates.delete(e);
  }
  /** Marks a row as updated. Order of operations is: remove, update, add */
  update(e) {
    this.updates.has(e) || (this.removals.delete(e), this.updates.set(e, !1));
  }
  /** Marks a row as added. Order of operation is: remove, update, add */
  add(e) {
    this.removals.delete(e), this.updates.set(e, !0);
  }
};
function BP(e) {
  if (Y(e.childrenAfterSort))
    return;
  const t = e.childrenAfterSort;
  for (let s = 0; s < t.length; s++) {
    const i = t[s], r = s === 0, o = s === e.childrenAfterSort.length - 1;
    i.setFirstChild(r), i.lastChild !== o && (i.lastChild = o, i.dispatchRowEvent("lastChildChanged")), i.childIndex !== s && (i.childIndex = s, i.dispatchRowEvent("childIndexChanged"));
  }
}
function lg(e) {
  e.sibling && (e.sibling.childrenAfterSort = e.childrenAfterSort), BP(e);
}
var VP = class extends P {
  constructor() {
    super(...arguments), this.beanName = "sortStage", this.refreshProps = /* @__PURE__ */ new Set(["postSortRows", "groupDisplayType", "accentedSort"]), this.step = "sort";
  }
  execute(e) {
    const t = this.beans, s = t.sortSvc.getSortOptions(), i = A(s) && s.length > 0, r = i && !!e.changedRowNodes && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort"), o = s.some(({ column: n }) => wt(t.gos) ? n.isPrimary() && n.isRowGroupActive() : !!n.getColDef().showRowGroup);
    this.sort(
      t,
      s,
      i,
      r,
      e.changedRowNodes,
      e.changedPath,
      o
    );
  }
  sort(e, t, s, i, r, o, n) {
    const { gos: a, colModel: l, rowGroupColsSvc: d, groupHideOpenParentsSvc: c, rowNodeSorter: h } = e, u = a.get("groupMaintainOrder"), p = l.getCols().some((C) => C.isRowGroupActive()), g = l.isPivotMode(), f = a.getCallback("postSortRows"), m = (C) => {
      var F;
      c == null || c.pullDownGroupDataForHideOpenParents(C.childrenAfterAggFilter, !0);
      const v = g && C.leafGroup, b = u && p && !C.leafGroup && !n;
      let y;
      if (b) {
        const D = (F = d == null ? void 0 : d.columns) == null ? void 0 : F[C.level + 1], x = (D == null ? void 0 : D.getSort()) === null, T = C.childrenAfterAggFilter.slice(0);
        if (C.childrenAfterSort && !x) {
          const I = {};
          C.childrenAfterSort.forEach((E, M) => {
            I[E.id] = M;
          }), T.sort(
            (E, M) => (I[E.id] ?? 0) - (I[M.id] ?? 0)
          );
        }
        y = T;
      } else !s || v ? y = C.childrenAfterAggFilter.slice(0) : i && r ? y = NP(h, C, r, o, t) : y = h.doFullSort(C.childrenAfterAggFilter, t);
      if (C.childrenAfterSort = y, lg(C), f) {
        const D = { nodes: C.childrenAfterSort };
        f(D);
      }
    };
    o == null || o.forEachChangedNodeDepthFirst(m);
  }
};
function NP(e, t, s, i, r) {
  const o = t.childrenAfterAggFilter, n = t.childrenAfterSort;
  if (!n)
    return e.doFullSort(o, r);
  const a = /* @__PURE__ */ new Set(), l = [], d = s.updates;
  for (let h = 0, u = o.length; h < u; ++h) {
    const p = o[h];
    d.has(p) || i && !i.canSkip(p) ? l.push({
      currentPos: l.length,
      rowNode: p
    }) : a.add(p.id);
  }
  const c = n.filter((h) => a.has(h.id)).map((h, u) => ({ currentPos: u, rowNode: h }));
  return l.sort((h, u) => e.compareRowNodes(r, h, u)), HP(e, r, l, c);
}
function HP(e, t, s, i) {
  const r = [];
  let o = 0, n = 0;
  const a = s.length, l = i.length;
  for (; o < a && n < l; ) {
    const d = s[o], c = i[n], h = e.compareRowNodes(t, d, c);
    let u;
    h < 0 ? (u = d, ++o) : (u = c, ++n), r.push(u.rowNode);
  }
  for (; o < a; )
    r.push(s[o++].rowNode);
  for (; n < l; )
    r.push(i[n++].rowNode);
  return r;
}
var zP = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = Ce(this, this.onRowHeightChanged.bind(this), 100), this.rootNode = null, this.rowsToDisplay = [], this.started = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowNodesCountReady = !1, this.rowCountReady = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.valueCache = e.valueCache, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggStage = e.aggStage, this.pivotStage = e.pivotStage, this.filterAggStage = e.filterAggStage;
  }
  postConstruct() {
    this.orderedStages = [
      this.groupStage,
      this.filterStage,
      this.pivotStage,
      this.aggStage,
      this.sortStage,
      this.filterAggStage,
      this.flattenStage
    ].filter((s) => !!s);
    const e = this.refreshModel.bind(this, { step: "group" }), t = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: !this.gos.get("suppressAnimationFrame")
    });
    this.addManagedEventListeners({
      newColumnsLoaded: t,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, { step: "pivot" }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Qe(this.beans), this.initRowManager();
  }
  initRowManager() {
    const { gos: e, beans: t, nodeManager: s } = this, i = e.get("treeData"), r = e.get("treeDataChildrenField"), o = r || i;
    let n;
    o && (n = r ? t.csrmChildrenTreeNodeSvc : t.csrmPathTreeNodeSvc), n || (n = t.csrmNodeSvc), s !== n && (s == null || s.deactivate(), this.nodeManager = n), n.activate(this.rootNode);
  }
  addPropertyListeners() {
    const e = [
      "treeData",
      "treeDataChildrenField",
      ...this.orderedStages.flatMap(({ refreshProps: t }) => [...t])
    ];
    this.addManagedPropertyListeners(e, (t) => {
      var i;
      const s = (i = t.changeSet) == null ? void 0 : i.properties;
      s && this.onPropChange(s);
    }), this.addManagedPropertyListener("rowData", () => this.onPropChange(["rowData"])), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.started = !0, this.shouldSkipSettingDataOnStart ? this.refreshModel({
      step: "group",
      newData: !0,
      rowDataUpdated: !0
    }) : this.setInitialData();
  }
  setInitialData() {
    this.gos.get("rowData") && (this.shouldSkipSettingDataOnStart = !0, this.onPropChange(["rowData"]));
  }
  ensureRowHeightsValid(e, t, s, i) {
    let r, o = !1;
    do {
      r = !1;
      const n = this.getRowIndexAtPixel(e), a = this.getRowIndexAtPixel(t), l = Math.max(n, s), d = Math.min(a, i);
      for (let c = l; c <= d; c++) {
        const h = this.getRow(c);
        if (h.rowHeightEstimated) {
          const u = Ie(this.beans, h);
          h.setRowHeight(u.height), r = !0, o = !0;
        }
      }
      r && this.setRowTopAndRowIndex();
    } while (r);
    return o;
  }
  onPropChange(e) {
    var d, c;
    if (!this.rootNode)
      return;
    const t = this.gos, s = new Set(e), i = {
      step: "nothing",
      changedProps: s
    }, r = s.has("rowData"), o = s.has("treeData"), a = s.has("treeDataChildrenField") || o && !t.get("treeDataChildrenField");
    let l;
    if (o && (i.step = "group"), (a || r) && (l = t.get("rowData"), l != null && !Array.isArray(l) && (l = null, R(1))), a && (r || (l = ((d = this.nodeManager) == null ? void 0 : d.extractRowData()) ?? l), this.initRowManager()), l && (!a && this.started && !this.isEmpty() && l.length > 0 && t.exists("getRowId") && // this property is a backwards compatibility property, for those who want
    // the old behaviour of Row IDs but NOT Immutable Data.
    !t.get("resetRowDataOnUpdate") ? (i.keepRenderedRows = !0, i.animate = !this.gos.get("suppressAnimationFrame"), i.changedRowNodes = new Yn(), this.nodeManager.setImmutableRowData(i, l)) : (i.step = "group", i.rowDataUpdated = !0, i.newData = !0, (c = this.beans.selectionSvc) == null || c.reset("rowDataChanged"), this.rowNodesCountReady = !0, this.nodeManager.setNewRowData(l))), i.step === "nothing") {
      for (const { refreshProps: h, step: u } of this.orderedStages)
        if (e.some((p) => h.has(p))) {
          i.step = u;
          break;
        }
    }
    i.step !== "nothing" && this.refreshModel(i);
  }
  setRowTopAndRowIndex() {
    const { beans: e } = this, t = e.environment.getDefaultRowHeight();
    let s = 0;
    const i = /* @__PURE__ */ new Set(), r = ye(this.gos, "normal"), o = this.rowsToDisplay;
    for (let n = 0, a = o.length; n < a; ++n) {
      const l = o[n];
      if (l.id != null && i.add(l.id), l.rowHeight == null) {
        const d = Ie(e, l, r, t);
        l.setRowHeight(d.height, d.estimated);
      }
      l.setRowTop(s), l.setRowIndex(n), s += l.rowHeight;
    }
    return i;
  }
  clearRowTopAndRowIndex(e, t) {
    const s = e.active, i = (o) => {
      o && o.id != null && !t.has(o.id) && o.clearRowTopAndRowIndex();
    }, r = (o) => {
      if (o !== null && (i(o), i(o.detailNode), i(o.sibling), o.hasChildren() && o.childrenAfterGroup)) {
        const n = o.level == -1;
        s && !n && !o.expanded || o.childrenAfterGroup.forEach(r);
      }
    };
    r(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, s = 0) {
    var a;
    const i = this.getRowIndexAtPixel(t), r = this.getRow(i), o = !this.gos.get("suppressAnimationFrame");
    if (r === e[0])
      return !1;
    const n = (a = this.rootNode) == null ? void 0 : a.allLeafChildren;
    return n ? (e.forEach((l) => {
      be(n, l);
    }), e.forEach((l, d) => {
      n.splice(Math.max(i + s, 0) + d, 0, l);
    }), e.forEach((l, d) => {
      l.sourceRowIndex = d;
    }), this.refreshModel({
      step: "group",
      keepRenderedRows: !0,
      animate: o,
      rowNodesOrderChanged: !0
      // We assume the order changed and we don't need to check if it really did
    }), !0) : !1;
  }
  highlightRowAtPixel(e, t) {
    const s = t != null ? this.getRowIndexAtPixel(t) : null, i = s != null ? this.getRow(s) : null;
    if (!i || !e || t == null) {
      this.clearHighlightedRow();
      return;
    }
    const r = this.getHighlightPosition(t, i), o = this.isHighlightingCurrentPosition(e, i, r), n = this.lastHighlightedRow != null && this.lastHighlightedRow !== i;
    (o || n) && (this.clearHighlightedRow(), o) || (this.setRowNodeHighlighted(i, r), this.lastHighlightedRow = i);
  }
  setRowNodeHighlighted(e, t) {
    e.highlighted !== t && (e.highlighted = t, e.dispatchRowEvent("rowHighlightChanged"));
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const r = this.getRowIndexAtPixel(e);
      if (t = this.getRow(r || 0), !t)
        return "Below";
    }
    const { rowTop: s, rowHeight: i } = t;
    return e - s < i / 2 ? "Above" : "Below";
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isHighlightingCurrentPosition(e, t, s) {
    if (e === t)
      return !0;
    const i = s === "Above" ? -1 : 1;
    return this.getRow(t.rowIndex + i) === e;
  }
  clearHighlightedRow() {
    this.lastHighlightedRow && (this.setRowNodeHighlighted(this.lastHighlightedRow, null), this.lastHighlightedRow = null);
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  /**
   * Returns the number of rows with level === 1
   */
  getTopLevelRowCount() {
    const e = this.rootNode;
    if (!e || this.rowsToDisplay.length === 0)
      return 0;
    if (this.rowsToDisplay && this.rowsToDisplay[0] === e)
      return 1;
    const s = e.childrenAfterAggFilter, i = e.sibling ? 1 : 0;
    return (s ? s.length : 0) + i;
  }
  /**
   * Get the row display index by the top level index
   * top level index is the index of rows with level === 1
   */
  getTopLevelRowDisplayedIndex(e) {
    const { rootNode: t, rowsToDisplay: s } = this;
    if (!t || !s.length || s[0] === t)
      return e;
    const { childrenAfterSort: r } = t, o = (a) => {
      let l = r[a];
      if (this.gos.get("groupHideOpenParents"))
        for (; l.expanded && l.childrenAfterSort && l.childrenAfterSort.length > 0; )
          l = l.childrenAfterSort[0];
      return l.rowIndex;
    }, { footerSvc: n } = this.beans;
    return n ? n.getTopDisplayIndex(s, e, r, o) : o(e);
  }
  getRowBounds(e) {
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = fi(this.gos);
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = fi(this.gos), i = e.columns.length === 0 || e.columns.some((r) => r.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: i, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = fi(this.gos);
    this.refreshModel({
      step: "sort",
      keepRenderedRows: !0,
      animate: e
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.refreshModel({ step: this.colModel.isPivotActive() ? "pivot" : "aggregate" });
  }
  createChangePath(e) {
    const t = !(e != null && e.length), s = new Mi(!1, this.rootNode);
    return t && (s.active = !1), s;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction"))
      return !1;
    const t = e.rowNodeTransactions;
    return t ? !t.some(
      (r) => r.add != null && r.add.length > 0 || r.remove != null && r.remove.length > 0
    ) : !1;
  }
  refreshModel(e) {
    var r, o;
    if (!this.rootNode)
      return;
    const t = e.rowNodeTransactions, s = e.changedPath ?? (e.changedPath = this.createChangePath(t));
    if ((o = (r = this.nodeManager).refreshModel) == null || o.call(r, e), this.eventSvc.dispatchEvent({ type: "beforeRefreshModel", params: e }), !this.started || (e.rowDataUpdated && this.eventSvc.dispatchEvent({ type: "rowDataUpdated" }), this.isRefreshingModel || this.colModel.changeEventsDispatching || this.isSuppressModelUpdateAfterUpdateTransaction(e)))
      return;
    switch (this.isRefreshingModel = !0, e.step) {
      case "group":
        this.doRowGrouping(
          e.rowNodeTransactions,
          e.changedRowNodes,
          s,
          !!e.rowNodesOrderChanged,
          !!e.afterColumnsChanged
        );
      case "filter":
        this.doFilter(s);
      case "pivot":
        this.doPivot(s);
      case "aggregate":
        this.doAggregate(s);
      case "filter_aggregates":
        this.doFilterAggregates(s);
      case "sort":
        this.doSort(e.changedRowNodes, s);
      case "map":
        this.doRowsToDisplay();
    }
    const i = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(s, i), this.isRefreshingModel = !1, this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: e.animate,
      keepRenderedRows: e.keepRenderedRows,
      newData: e.newData,
      newPage: !1,
      keepUndoRedoStack: e.keepUndoRedoStack
    });
  }
  isEmpty() {
    var e, t, s;
    return !((t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) != null && t.length) || !((s = this.colModel) != null && s.ready);
  }
  isRowsToRender() {
    return this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let s = !1, i = !1;
    const r = [], o = qs(this.gos);
    return this.forEachNodeAfterFilterAndSort((n) => {
      if (i)
        return;
      if (s && (n === t || n === e) && (i = !0, n.group && o)) {
        r.push(...n.allLeafChildren);
        return;
      }
      if (!s) {
        if (n !== t && n !== e)
          return;
        s = !0;
      }
      if (!n.group || !o) {
        r.push(n);
        return;
      }
    }), r;
  }
  getTopLevelNodes() {
    var e;
    return ((e = this.rootNode) == null ? void 0 : e.childrenAfterGroup) ?? null;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    const t = this.rowsToDisplay;
    if (this.isEmpty() || t.length === 0)
      return -1;
    let s = 0, i = t.length - 1;
    if (e <= 0)
      return 0;
    if (V(t).rowTop <= e)
      return t.length - 1;
    let o = -1, n = -1;
    for (; ; ) {
      const a = Math.floor((s + i) / 2), l = t[a];
      if (this.isRowInPixel(l, e) || (l.rowTop < e ? s = a + 1 : l.rowTop > e && (i = a - 1), o === s && n === i))
        return a;
      o = s, n = i;
    }
  }
  isRowInPixel(e, t) {
    const s = e.rowTop, i = e.rowTop + e.rowHeight;
    return s <= t && i > t;
  }
  forEachLeafNode(e) {
    var t, s;
    (s = (t = this.rootNode) == null ? void 0 : t.allLeafChildren) == null || s.forEach((i, r) => e(i, r));
  }
  forEachNode(e, t = !1) {
    var s;
    this.recursivelyWalkNodesAndCallback({
      nodes: [...((s = this.rootNode) == null ? void 0 : s.childrenAfterGroup) || []],
      callback: e,
      recursionType: 0,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    var s;
    this.recursivelyWalkNodesAndCallback({
      nodes: [...((s = this.rootNode) == null ? void 0 : s.childrenAfterAggFilter) || []],
      callback: e,
      recursionType: 1,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    var s;
    this.recursivelyWalkNodesAndCallback({
      nodes: [...((s = this.rootNode) == null ? void 0 : s.childrenAfterSort) || []],
      callback: e,
      recursionType: 2,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    const s = this.rootNode;
    s && this.recursivelyWalkNodesAndCallback({
      nodes: [s],
      callback: e,
      recursionType: 3,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: s, recursionType: i, includeFooterNodes: r } = e;
    let { index: o } = e;
    const { footerSvc: n } = this.beans;
    n == null || n.addNodes(e, t, s, r, this.rootNode, "top");
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (s(l, o++), l.hasChildren() && !l.footer) {
        let d = null;
        switch (i) {
          case 0:
            d = l.childrenAfterGroup;
            break;
          case 1:
            d = l.childrenAfterAggFilter;
            break;
          case 2:
            d = l.childrenAfterSort;
            break;
          case 3:
            d = l.leafGroup ? null : l.childrenAfterSort;
            break;
        }
        d && (o = this.recursivelyWalkNodesAndCallback({
          nodes: [...d],
          callback: s,
          recursionType: i,
          index: o,
          includeFooterNodes: r
        }));
      }
    }
    return n == null || n.addNodes(e, t, s, r, this.rootNode, "bottom"), o;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var s;
    const t = this.rootNode;
    t && ((s = this.aggStage) == null || s.execute({ rowNode: t, changedPath: e }));
  }
  doFilterAggregates(e) {
    const t = this.rootNode;
    this.filterAggStage ? this.filterAggStage.execute({ rowNode: t, changedPath: e }) : t.childrenAfterAggFilter = t.childrenAfterFilter;
  }
  doSort(e, t) {
    const { groupHideOpenParentsSvc: s } = this.beans;
    this.sortStage ? this.sortStage.execute({
      rowNode: this.rootNode,
      changedRowNodes: e,
      changedPath: t
    }) : t.forEachChangedNodeDepthFirst((i) => {
      s == null || s.pullDownGroupDataForHideOpenParents(i.childrenAfterAggFilter, !0), i.childrenAfterSort = i.childrenAfterAggFilter.slice(0), lg(i);
    }), s == null || s.updateGroupDataForHideOpenParents(t);
  }
  doRowGrouping(e, t, s, i, r) {
    const o = this.nodeManager.treeData, n = this.rootNode;
    if (!o) {
      const a = this.groupStage;
      if (a)
        a.execute({
          rowNode: n,
          changedPath: s,
          changedRowNodes: t,
          rowNodeTransactions: e,
          rowNodesOrderChanged: i,
          afterColumnsChanged: r
        });
      else {
        const l = n.sibling;
        n.childrenAfterGroup = n.allLeafChildren, l && (l.childrenAfterGroup = n.childrenAfterGroup), n.updateHasChildren();
      }
    }
    this.rowNodesCountReady && (this.rowCountReady = !0, this.eventSvc.dispatchEventOnce({ type: "rowCountReady" }));
  }
  doFilter(e) {
    this.filterStage ? this.filterStage.execute({ rowNode: this.rootNode, changedPath: e }) : e.forEachChangedNodeDepthFirst((t) => {
      t.childrenAfterFilter = t.childrenAfterGroup, zp(t);
    }, !0);
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(fr) == 0) {
      let s;
      return this.forEachNode((i) => {
        i.id === e && (s = i);
      }), s;
    }
    return this.nodeManager.getRowNode(e);
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const s = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.isAlive() && this.executeBatchUpdateRowData();
      }, s);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    var r, o;
    (r = this.valueCache) == null || r.onDataChanged();
    const e = [], t = [], s = new Yn();
    let i = !1;
    (o = this.rowDataTransactionBatch) == null || o.forEach((n) => {
      this.rowNodesCountReady = !0;
      const { rowNodeTransaction: a, rowsInserted: l } = this.nodeManager.updateRowData(
        n.rowDataTransaction,
        s
      );
      l && (i = !0), t.push(a), n.callback && e.push(n.callback.bind(null, a));
    }), this.commitTransactions(t, i, s), e.length > 0 && window.setTimeout(() => {
      e.forEach((n) => n());
    }, 0), t.length > 0 && this.eventSvc.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    }), this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  /**
   * Used to apply transaction changes.
   * Called by gridApi & rowDragFeature
   */
  updateRowData(e) {
    var r;
    (r = this.valueCache) == null || r.onDataChanged(), this.rowNodesCountReady = !0;
    const t = new Yn(), { rowNodeTransaction: s, rowsInserted: i } = this.nodeManager.updateRowData(e, t);
    return this.commitTransactions([s], i, t), s;
  }
  /**
   * Common to:
   * - executeBatchUpdateRowData (batch transactions)
   * - updateRowData (single transaction)
   * - setImmutableRowData (generated transaction)
   *
   * @param rowNodeTrans - the transactions to apply
   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
   */
  commitTransactions(e, t, s) {
    this.refreshModel({
      step: "group",
      rowDataUpdated: !0,
      rowNodeTransactions: e,
      rowNodesOrderChanged: t,
      keepRenderedRows: !0,
      animate: !this.gos.get("suppressAnimationFrame"),
      changedRowNodes: s,
      changedPath: this.createChangePath(e)
    });
  }
  doRowsToDisplay() {
    const { flattenStage: e, rootNode: t } = this;
    let s;
    if (e)
      s = e.execute({ rowNode: t });
    else {
      s = (t == null ? void 0 : t.childrenAfterSort) ?? [];
      for (const i of s)
        i.setUiLevel(0);
    }
    this.rowsToDisplay = s;
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: !0,
      keepUndoRedoStack: !0
    });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.rootNode;
    if (!e)
      return;
    const t = this.resetRowHeightsForAllRowNodes();
    e.setRowHeight(e.rowHeight, !0), e.sibling && e.sibling.setRowHeight(e.sibling.rowHeight, !0), t && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const s = t.detailNode;
      s && s.setRowHeight(s.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    var t;
    if (e.rowHeightChanged) {
      if ((t = this.beans.rowAutoHeight) != null && t.active)
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.started || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy(), this.clearHighlightedRow(), this.started = !1, this.rootNode = null, this.nodeManager = null, this.rowDataTransactionBatch = null, this.lastHighlightedRow = null, this.orderedStages = me, this.rowsToDisplay = me;
  }
};
function WP(e) {
  var t;
  (t = e.expansionSvc) == null || t.onGroupExpandedOrCollapsed();
}
function _P(e, t) {
  const s = Dt(e);
  s && ((!t || t === "everything") && (t = "group"), s.refreshModel({
    step: t,
    keepRenderedRows: !0,
    animate: !e.gos.get("suppressAnimationFrame")
  }));
}
function UP(e) {
  var t;
  return ((t = Dt(e)) == null ? void 0 : t.isEmpty()) ?? !0;
}
function KP(e, t) {
  var s;
  (s = Dt(e)) == null || s.forEachLeafNode(t);
}
function $P(e, t) {
  var s;
  (s = Dt(e)) == null || s.forEachNodeAfterFilter(t);
}
function jP(e, t) {
  var s;
  (s = Dt(e)) == null || s.forEachNodeAfterFilterAndSort(t);
}
function qP(e) {
  var t, s;
  if ((t = e.rowAutoHeight) != null && t.active) {
    R(3);
    return;
  }
  (s = Dt(e)) == null || s.resetRowHeights();
}
function YP(e, t) {
  return e.frameworkOverrides.wrapIncoming(
    () => {
      var s;
      return (s = Dt(e)) == null ? void 0 : s.updateRowData(t);
    }
  );
}
function XP(e, t, s) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var i;
      return (i = Dt(e)) == null ? void 0 : i.batchUpdateRowData(t, s);
    }
  );
}
function ZP(e) {
  e.frameworkOverrides.wrapIncoming(() => {
    var t;
    return (t = Dt(e)) == null ? void 0 : t.flushAsyncTransactions();
  });
}
function QP(e) {
  var t;
  return (t = e.selectionSvc) == null ? void 0 : t.getBestCostNodeSelection();
}
var JP = {
  moduleName: "ClientSideRowModel",
  version: G,
  rowModels: ["clientSide"],
  beans: [GP, zP, VP],
  dependsOn: [Nl]
}, eT = {
  moduleName: "ClientSideRowModelApi",
  version: G,
  rowModels: ["clientSide"],
  apiFunctions: {
    onGroupExpandedOrCollapsed: WP,
    refreshClientSideRowModel: _P,
    isRowDataEmpty: UP,
    forEachLeafNode: KP,
    forEachNodeAfterFilter: $P,
    forEachNodeAfterFilterAndSort: jP,
    resetRowHeights: qP,
    applyTransaction: YP,
    applyTransactionAsync: XP,
    flushAsyncTransactions: ZP,
    getBestCostNodeSelection: QP
  },
  dependsOn: [ng]
}, tT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "gridSerializer";
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.colModel = e.colModel, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel;
  }
  serialize(e, t = {}) {
    const { allColumns: s, columnKeys: i, skipRowGroups: r } = t, o = this.getColumnsToExport(
      s,
      r,
      i
    );
    return [
      // first pass, put in the header names of the cols
      this.prepareSession(o),
      this.prependContent(t),
      this.exportColumnGroups(t, o),
      this.exportHeaders(t, o),
      this.processPinnedTopRows(t, o),
      this.processRows(t, o),
      this.processPinnedBottomRows(t, o),
      this.appendContent(t)
    ].reduce((n, a) => a(n), e).parse();
  }
  processRow(e, t, s, i) {
    var g;
    const r = t.shouldRowBeSkipped || (() => !1), n = t.rowPositions != null || !!t.onlySelected, a = this.gos.get("groupHideOpenParents") && !n, l = this.colModel.isPivotMode() ? i.leafGroup : !i.group, d = !!i.footer, c = i.allChildrenCount === 1 && ((g = i.childrenAfterGroup) == null ? void 0 : g.length) === 1 && LC(this.gos, i);
    if (!l && !d && (t.skipRowGroups || c || a) || t.onlySelected && !i.isSelected() || t.skipPinnedTop && i.rowPinned === "top" || t.skipPinnedBottom && i.rowPinned === "bottom" || i.level === -1 && !l && !d || r(this.gos.addGridCommonParams({ node: i })))
      return;
    const p = e.onNewBodyRow(i);
    if (s.forEach((f, m) => {
      p.onColumn(f, m, i);
    }), t.getCustomContentBelowRow) {
      const f = t.getCustomContentBelowRow(this.gos.addGridCommonParams({ node: i }));
      f && e.addCustomContent(f);
    }
  }
  appendContent(e) {
    return (t) => {
      const s = e.appendContent;
      return s && t.addCustomContent(s), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const s = e.prependContent;
      return s && t.addCustomContent(s), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (s) => {
      if (!e.skipColumnGroupHeaders) {
        const i = new mu(), { colGroupSvc: r } = this.beans, o = r ? r.createColumnGroups({
          columns: t,
          idCreator: i,
          pinned: null,
          isStandaloneStructure: !0
        }) : t;
        this.recursivelyAddHeaderGroups(
          o,
          s,
          e.processGroupHeaderCallback
        );
      }
      return s;
    };
  }
  exportHeaders(e, t) {
    return (s) => {
      if (!e.skipColumnHeaders) {
        const i = s.onNewHeaderRow();
        t.forEach((r, o) => {
          i.onColumn(r, o, void 0);
        });
      }
      return s;
    };
  }
  processPinnedTopRows(e, t) {
    return (s) => {
      var r;
      const i = this.processRow.bind(this, s, e, t);
      return e.rowPositions ? e.rowPositions.filter((o) => o.rowPinned === "top").sort((o, n) => o.rowIndex - n.rowIndex).map((o) => {
        var n;
        return (n = this.pinnedRowModel) == null ? void 0 : n.getPinnedTopRow(o.rowIndex);
      }).forEach(i) : (r = this.pinnedRowModel) == null || r.forEachPinnedRow("top", i), s;
    };
  }
  processRows(e, t) {
    return (s) => {
      var d;
      const i = this.rowModel, r = J(this.gos), o = Te(this.gos), n = !r && e.onlySelected, a = this.processRow.bind(this, s, e, t), { exportedRows: l = "filteredAndSorted" } = e;
      if (e.rowPositions)
        return e.rowPositions.filter((c) => c.rowPinned == null).sort((c, h) => c.rowIndex - h.rowIndex).map((c) => i.getRow(c.rowIndex)).forEach(a), s;
      if (this.colModel.isPivotMode())
        return r ? i.forEachPivotNode(a, !0) : o ? i.forEachNodeAfterFilterAndSort(a, !0) : i.forEachNode(a), s;
      if (e.onlySelectedAllPages || n) {
        const c = ((d = this.beans.selectionSvc) == null ? void 0 : d.getSelectedNodes()) ?? [];
        this.replicateSortedOrder(c), c.forEach(a);
      } else
        l === "all" ? i.forEachNode(a) : r || o ? i.forEachNodeAfterFilterAndSort(a, !0) : i.forEachNode(a);
      return s;
    };
  }
  replicateSortedOrder(e) {
    const { sortSvc: t, rowNodeSorter: s } = this.beans;
    if (!t || !s)
      return;
    const i = t.getSortOptions(), r = (o, n) => {
      var a, l;
      return o.rowIndex != null && n.rowIndex != null ? o.rowIndex - n.rowIndex : o.level === n.level ? ((a = o.parent) == null ? void 0 : a.id) === ((l = n.parent) == null ? void 0 : l.id) ? s.compareRowNodes(
        i,
        {
          rowNode: o,
          currentPos: o.rowIndex ?? -1
        },
        {
          rowNode: n,
          currentPos: n.rowIndex ?? -1
        }
      ) : r(o.parent, n.parent) : o.level > n.level ? r(o.parent, n) : r(o, n.parent);
    };
    e.sort(r);
  }
  processPinnedBottomRows(e, t) {
    return (s) => {
      var r;
      const i = this.processRow.bind(this, s, e, t);
      return e.rowPositions ? e.rowPositions.filter((o) => o.rowPinned === "bottom").sort((o, n) => o.rowIndex - n.rowIndex).map((o) => {
        var n;
        return (n = this.pinnedRowModel) == null ? void 0 : n.getPinnedBottomRow(o.rowIndex);
      }).forEach(i) : (r = this.pinnedRowModel) == null || r.forEachPinnedRow("bottom", i), s;
    };
  }
  getColumnsToExport(e = !1, t = !1, s) {
    const { colModel: i, gos: r, visibleCols: o } = this, n = i.isPivotMode();
    if (s && s.length)
      return i.getColsForKeys(s);
    const a = r.get("treeData");
    let l = [];
    return e && !n ? l = i.getCols() : l = o.allCols, l = l.filter(
      (d) => !Ot(d) && (t && !a ? !en(d) : !0)
    ), l;
  }
  recursivelyAddHeaderGroups(e, t, s) {
    const i = [];
    e.forEach((r) => {
      const o = r;
      o.getChildren && o.getChildren().forEach((n) => i.push(n));
    }), e.length > 0 && de(e[0]) && this.doAddHeaderHeader(t, e, s), i && i.length > 0 && this.recursivelyAddHeaderGroups(
      i,
      t,
      s
    );
  }
  doAddHeaderHeader(e, t, s) {
    const i = e.onNewHeaderGroupingRow();
    let r = 0;
    t.forEach((o) => {
      const n = o;
      let a;
      s ? a = s(
        this.gos.addGridCommonParams({
          columnGroup: n
        })
      ) : a = this.beans.colNames.getDisplayNameForColumnGroup(n, "header");
      const l = n.getLeafColumns().reduce((d, c, h, u) => {
        let p = V(d);
        return c.getColumnGroupShow() === "open" ? (!p || p[1] != null) && (p = [h], d.push(p)) : p && p[1] == null && (p[1] = h - 1), h === u.length - 1 && p && p[1] == null && (p[1] = h), d;
      }, []);
      i.onColumn(
        n,
        a || "",
        r++,
        n.getLeafColumns().length - 1,
        l
      );
    });
  }
}, dg = {
  moduleName: "SharedExport",
  version: G,
  beans: [tT]
}, lc = `\r
`, sT = class extends Vp {
  constructor(e) {
    super(e), this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: s } = e;
    this.suppressQuotes = t, this.columnSeparator = s;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, lc), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((s, i) => {
        i !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(s.data.value || ""), s.mergeAcross && this.appendEmptyCells(s.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, s, i) {
    s != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(i);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, s) {
    t != 0 && (this.result += this.columnSeparator);
    const i = this.extractRowCellValue(e, t, t, "csv", s);
    this.result += this.putInQuotes(i.valueFormatted ?? i.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (R(53), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += lc), this.isFirstLine = !1;
  }
}, iT = class extends Bp {
  constructor() {
    super(...arguments), this.beanName = "csvCreator";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.colNames = e.colNames, this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueSvc = e.valueSvc;
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      R(51);
      return;
    }
    const t = this.getMergedParams(e), s = this.getData(t), i = new Blob(["\uFEFF", s], { type: "text/plain" }), r = typeof t.fileName == "function" ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
    zl(this.getFileName(r), i);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const s = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(s);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { colModel: t, colNames: s, rowGroupColsSvc: i, valueSvc: r, gos: o } = this, {
      processCellCallback: n,
      processHeaderCallback: a,
      processGroupHeaderCallback: l,
      processRowGroupCallback: d,
      suppressQuotes: c,
      columnSeparator: h
    } = e;
    return new sT({
      colModel: t,
      colNames: s,
      valueSvc: r,
      gos: o,
      processCellCallback: n || void 0,
      processHeaderCallback: a || void 0,
      processGroupHeaderCallback: l || void 0,
      processRowGroupCallback: d || void 0,
      suppressQuotes: c || !1,
      columnSeparator: h || ",",
      rowGroupColsSvc: i
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
function rT(e, t) {
  var s;
  return (s = e.csvCreator) == null ? void 0 : s.getDataAsCsv(t);
}
function oT(e, t) {
  var s;
  (s = e.csvCreator) == null || s.exportDataAsCsv(t);
}
var cg = {
  moduleName: "CsvExport",
  version: G,
  beans: [iT],
  apiFunctions: {
    getDataAsCsv: rT,
    exportDataAsCsv: oT
  },
  dependsOn: [dg]
}, nT = class extends P {
  constructor(e, t, s) {
    super(), this.id = e, this.parentCache = t, this.params = s, this.state = "needsLoading", this.version = 0, this.startRow = e * s.blockSize, this.endRow = this.startRow + s.blockSize;
  }
  load() {
    this.state = "loading", this.loadFromDatasource();
  }
  setStateWaitingToLoad() {
    this.version++, this.state = "needsLoading";
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = "failed"), this.dispatchLocalEvent({ type: "loadComplete" });
  }
  pageLoaded(e, t, s) {
    this.successCommon(e, { rowData: t, rowCount: s });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, s = this.isAlive();
    return t && s;
  }
  successCommon(e, t) {
    this.dispatchLocalEvent({ type: "loadComplete" }), this.isRequestMostRecentAndLive(e) && (this.state = "loaded", this.processServerResult(t));
  }
  postConstruct() {
    this.rowNodes = [];
    const {
      params: { blockSize: e, rowHeight: t },
      startRow: s,
      beans: i,
      rowNodes: r
    } = this;
    for (let o = 0; o < e; o++) {
      const n = s + o, a = new Qe(i);
      a.setRowHeight(t), a.uiLevel = 0, a.setRowIndex(n), a.setRowTop(t * n), r.push(a);
    }
  }
  getBlockStateJson() {
    const { id: e, startRow: t, endRow: s, state: i } = this;
    return {
      id: "" + e,
      state: {
        blockNumber: e,
        startRow: t,
        endRow: s,
        pageStatus: i
      }
    };
  }
  setDataAndId(e, t, s) {
    A(t) ? e.setDataAndId(t, s.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (Y(this.params.datasource.getRows)) {
      R(90);
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  createLoadParams() {
    const {
      startRow: e,
      endRow: t,
      version: s,
      params: { sortModel: i, filterModel: r },
      gos: o
    } = this;
    return {
      startRow: e,
      endRow: t,
      successCallback: this.pageLoaded.bind(this, s),
      failCallback: this.pageLoadFailed.bind(this, s),
      sortModel: i,
      filterModel: r,
      context: o.getGridCommonParams().context
    };
  }
  forEachNode(e, t, s) {
    this.rowNodes.forEach((i, r) => {
      this.startRow + r < s && e(i, t.value++);
    });
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.value++);
    const s = e - this.startRow;
    return this.rowNodes[s];
  }
  processServerResult(e) {
    const { rowNodes: t, beans: s } = this;
    t.forEach((r, o) => {
      const n = e.rowData ? e.rowData[o] : void 0;
      !r.id && r.alreadyRendered && n && (t[o] = new Qe(s), t[o].setRowIndex(r.rowIndex), t[o].setRowTop(r.rowTop), t[o].setRowHeight(r.rowHeight), r.clearRowTopAndRowIndex()), this.setDataAndId(t[o], n, this.startRow + o);
    });
    const i = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, i);
  }
  destroy() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    }), super.destroy();
  }
}, aT = 2, lT = class extends P {
  constructor(e) {
    super(), this.params = e, this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const s = Math.floor(e / this.params.blockSize);
    let i = this.blocks[s];
    if (!i) {
      if (t)
        return;
      i = this.createBlock(s);
    }
    return i.getRow(e);
  }
  createBlock(e) {
    const t = this.params, s = this.createBean(new nT(e, this, t));
    return this.blocks[s.id] = s, this.blockCount++, this.purgeBlocksIfNeeded(s), t.rowNodeBlockLoader.addBlock(s), s;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)), super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (ws(this.gos, `InfiniteCache - onPageLoaded: page = ${e.id}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((n) => n != e), s = (n, a) => a.lastAccessed - n.lastAccessed;
    t.sort(s);
    const i = this.params.maxBlocksInCache > 0, r = i ? this.params.maxBlocksInCache - 1 : null, o = aT - 1;
    t.forEach((n, a) => {
      const l = n.state === "needsLoading" && a >= o, d = i ? a >= r : !1;
      if (l || d) {
        if (this.isBlockCurrentlyDisplayed(n) || this.isBlockFocused(n))
          return;
        this.removeBlockFromCache(n);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const { startRow: s, endRow: i } = e;
    return t.rowIndex >= s && t.rowIndex < i;
  }
  isBlockCurrentlyDisplayed(e) {
    const { startRow: t, endRow: s } = e;
    return this.beans.rowRenderer.isRangeInRenderedViewport(t, s - 1);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const { blockSize: s, overflowSize: i } = this.params, o = (e.id + 1) * s + i;
      this.rowCount < o && (this.rowCount = o);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, A(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = { value: 0 };
    this.getBlocksInOrder().forEach((s) => s.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (s, i) => s.id - i.id;
    return Object.values(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.id], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    this.isAlive() && (this.destroyAllBlocksPastVirtualRowCount(), this.eventSvc.dispatchEvent({
      type: "storeUpdated"
    }));
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.id * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const s = [];
    let i = -1, r = !1;
    const o = { value: 0 };
    let n = !1;
    return this.getBlocksInOrder().forEach((l) => {
      if (!n) {
        if (r && i + 1 !== l.id) {
          n = !0;
          return;
        }
        i = l.id, l.forEachNode(
          (d) => {
            const c = d === e || d === t;
            (r || c) && s.push(d), c && (r = !r);
          },
          o,
          this.rowCount
        );
      }
    }), n || r ? [] : s;
  }
}, dT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowModel";
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  postConstruct() {
    this.gos.get("rowModelType") === "infinite" && (this.rowHeight = Ye(this.beans), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()));
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    this.datasource && (this.destroyBean(this.datasource), this.beans.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.reset.bind(this),
      sortChanged: this.reset.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.dispatchModelUpdatedEvent.bind(this)
    }), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = Ye(this.beans), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onColumnEverything() {
    var t;
    let e;
    this.cacheParams ? e = !bi(this.cacheParams.sortModel, ((t = this.beans.sortSvc) == null ? void 0 : t.getSortModel()) ?? []) : e = !0, e && this.reset();
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    var s;
    return ((s = this.infiniteCache) == null ? void 0 : s.getRowNodesInRange(e, t)) ?? [];
  }
  reset() {
    var s;
    if (!this.datasource)
      return;
    Yt(this.gos) != null || (s = this.beans.selectionSvc) == null || s.reset("rowDataChanged"), this.resetCache();
  }
  dispatchModelUpdatedEvent() {
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    });
  }
  resetCache() {
    this.destroyCache();
    const e = this.beans, { filterManager: t, sortSvc: s, rowNodeBlockLoader: i, eventSvc: r, gos: o } = e;
    this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: (t == null ? void 0 : t.getFilterModel()) ?? {},
      sortModel: (s == null ? void 0 : s.getSortModel()) ?? [],
      rowNodeBlockLoader: i,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: o.get("infiniteInitialRowCount"),
      maxBlocksInCache: o.get("maxBlocksInCache"),
      rowHeight: Ye(e),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: o.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: o.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: { value: 0 }
    }, this.infiniteCache = this.createBean(new lT(this.cacheParams)), r.dispatchEventOnce({
      type: "rowCountReady"
    }), this.dispatchModelUpdatedEvent();
  }
  updateRowHeights() {
    this.forEachNode((e) => {
      e.setRowHeight(this.rowHeight), e.setRowTop(this.rowHeight * e.rowIndex);
    }), this.dispatchModelUpdatedEvent();
  }
  destroyCache() {
    this.infiniteCache = this.destroyBean(this.infiniteCache);
  }
  getRow(e) {
    const t = this.infiniteCache;
    if (t && !(e >= t.getRowCount()))
      return t.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((s) => {
      s.id === e && (t = s);
    }), t;
  }
  forEachNode(e) {
    var t;
    (t = this.infiniteCache) == null || t.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), s = this.getRowCount() - 1;
      return t > s ? s : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    var e;
    (e = this.infiniteCache) == null || e.refreshCache();
  }
  purgeCache() {
    var e;
    (e = this.infiniteCache) == null || e.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    var e;
    return ((e = this.infiniteCache) == null ? void 0 : e.isLastRowIndexKnown()) ?? !1;
  }
  setRowCount(e, t) {
    var s;
    (s = this.infiniteCache) == null || s.setRowCount(e, t);
  }
};
function cT(e) {
  var t;
  (t = hn(e)) == null || t.refreshCache();
}
function hT(e) {
  var t;
  (t = hn(e)) == null || t.purgeCache();
}
function uT(e) {
  var t;
  return (t = hn(e)) == null ? void 0 : t.getRowCount();
}
var pT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowNodeBlockLoader", this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  postConstruct() {
    this.maxConcurrentRequests = Wh(this.gos);
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = Ce(
      this,
      this.performCheckBlocksToLoad.bind(this),
      e
    ));
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener("loadComplete", this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    be(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad();
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      ws(this.gos, "RowNodeBlockLoader - checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.maxConcurrentRequests != null ? this.maxConcurrentRequests - this.activeBlockLoadsCount : 1, t = this.blocks.filter((s) => s.state === "needsLoading").slice(0, e);
    this.activeBlockLoadsCount += t.length, t.forEach((s) => s.load()), this.printCacheStatus();
  }
  getBlockState() {
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: s, state: i } = t.getBlockStateJson();
      e[s] = i;
    }), e;
  }
  printCacheStatus() {
    ws(
      this.gos,
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
}, gT = {
  moduleName: "InfiniteRowModel",
  version: G,
  rowModels: ["infinite"],
  apiFunctions: {
    refreshInfiniteCache: cT,
    purgeInfiniteCache: hT,
    getInfiniteRowCount: uT
  },
  beans: [dT, pT],
  dependsOn: [ag]
}, fT = "↑", mT = "↓", CT = class extends L {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const s = document.createElement("span");
    s.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(s), this.setTemplateFromElement(e);
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0);
  }
  showDelta(e, t) {
    const s = Math.abs(t), i = e.formatValue(s), r = A(i) ? i : s, o = t >= 0, n = this.eDelta;
    o ? n.textContent = fT + r : n.textContent = mT + r, n.classList.toggle("ag-value-change-delta-up", o), n.classList.toggle("ag-value-change-delta-down", !o);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), X(this.eDelta);
  }
  refresh(e, t = !1) {
    var a;
    const { value: s, valueFormatted: i } = e, { eValue: r, lastValue: o, beans: n } = this;
    if (s === o || (A(i) ? r.textContent = i : A(s) ? r.textContent = s : X(r), (a = n.filterManager) != null && a.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof s == "number" && typeof o == "number") {
      const l = s - o;
      this.showDelta(e, l);
    }
    return o && r.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = s, !0;
  }
}, vT = (
  /*css*/
  ".ag-value-slide-out{opacity:1}:where(.ag-ltr) .ag-value-slide-out{margin-right:5px;transition:opacity 3s,margin-right 3s}:where(.ag-rtl) .ag-value-slide-out{margin-left:5px;transition:opacity 3s,margin-left 3s}:where(.ag-ltr,.ag-rtl) .ag-value-slide-out{transition-timing-function:linear}.ag-value-slide-out-end{opacity:0}:where(.ag-ltr) .ag-value-slide-out-end{margin-right:10px}:where(.ag-rtl) .ag-value-slide-out-end{margin-left:10px}"
), wT = class extends L {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current"), this.registerCSS(vT);
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const { beans: t, eCurrent: s } = this, i = Z(t).createElement("span");
    i.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = i, i.textContent = s.textContent, this.getGui().insertBefore(i, s), t.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    var r;
    let s = e.value;
    if (Y(s) && (s = ""), s === this.lastValue || (r = this.beans.filterManager) != null && r.isSuppressFlashingCellsBecauseFiltering())
      return !1;
    t || this.addSlideAnimation(), this.lastValue = s;
    const i = this.eCurrent;
    return A(e.valueFormatted) ? i.textContent = e.valueFormatted : A(e.value) ? i.textContent = s : X(i), !0;
  }
}, yT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "cellFlashSvc";
  }
  onFlashCells(e, t) {
    if (!e.comp)
      return;
    const s = ns(e.cellPosition);
    t.cells[s] && this.animateCell(e, "highlight");
  }
  flashCell(e, t) {
    this.animateCell(e, "data-changed", t == null ? void 0 : t.flashDuration, t == null ? void 0 : t.fadeDuration);
  }
  animateCell(e, t, s, i) {
    const r = e.comp;
    if (!r)
      return;
    const { gos: o } = this;
    if (s || (s = o.get("cellFlashDuration")), s === 0)
      return;
    A(i) || (i = o.get("cellFadeDuration"));
    const n = `ag-cell-${t}`, a = `ag-cell-${t}-animation`;
    r.addOrRemoveCssClass(n, !0), r.addOrRemoveCssClass(a, !1);
    const { eGui: l } = e;
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e.isAlive() && (r.addOrRemoveCssClass(n, !1), r.addOrRemoveCssClass(a, !0), l.style.transition = `background-color ${i}ms`, window.setTimeout(() => {
          e.isAlive() && (r.addOrRemoveCssClass(a, !1), l.style.transition = "");
        }, i));
      }, s);
    });
  }
};
function bT(e, t = {}) {
  const { cellFlashSvc: s } = e;
  s && e.frameworkOverrides.wrapIncoming(() => {
    e.rowRenderer.getCellCtrls(t.rowNodes, t.columns).forEach((i) => s.flashCell(i, t));
  });
}
var hg = {
  moduleName: "HighlightChanges",
  version: G,
  beans: [yT],
  userComponents: {
    agAnimateShowChangeCellRenderer: CT,
    agAnimateSlideCellRenderer: wT
  },
  apiFunctions: {
    flashCells: bT
  }
};
function ST(e) {
  var t;
  return ((t = e.stateSvc) == null ? void 0 : t.getState()) ?? {};
}
function xT(e) {
  switch (e = { ...e }, e.version || (e.version = "32.1.0"), e.version) {
    case "32.1.0":
      e = FT(e);
  }
  return e;
}
function FT(e) {
  return e.cellSelection = RT(e, "rangeSelection"), e;
}
function RT(e, t) {
  if (e && typeof e == "object")
    return e[t];
}
var PT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "stateSvc", this.updateRowGroupExpansionStateTimer = 0, this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = Ce(this, () => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = Ce(
      this,
      () => {
        this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
      },
      0
    ), this.onRowSelectedDebounced = Ce(
      this,
      () => {
        this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
      },
      0
    ), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  postConstruct() {
    this.isClientSideRowModel = J(this.gos), this.cachedState = this.getInitialState(), this.setCachedStateValue("version", G);
    const e = this.suppressEventsAndDispatchInitEvent.bind(this);
    this.beans.ctrlsSvc.whenReady(
      this,
      () => e(() => this.setupStateOnGridReady())
    );
    const [t, s, i] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source: r }) => {
        r === "gridInitializing" && (t(), e(() => this.setupStateOnColumnsInitialised()));
      },
      rowCountReady: () => {
        s == null || s(), e(() => this.setupStateOnRowCountReady());
      },
      firstDataRendered: () => {
        i == null || i(), e(() => this.setupStateOnFirstDataRendered());
      }
    });
  }
  destroy() {
    super.destroy(), clearTimeout(this.updateRowGroupExpansionStateTimer), this.queuedUpdateSources.clear();
  }
  getInitialState() {
    return xT(this.gos.get("initialState") ?? {});
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    const e = () => this.updateCachedState("sideBar", this.getSideBarState());
    e(), this.addManagedEventListeners({
      toolPanelVisibleChanged: e,
      sideBarUpdated: e
    });
  }
  setupStateOnColumnsInitialised() {
    const e = this.getInitialState();
    this.setColumnState(e), this.setColumnGroupState(e), this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState());
    const t = (s) => () => this.updateColumnState([s]);
    this.addManagedEventListeners({
      columnValueChanged: t("aggregation"),
      columnMoved: t("columnOrder"),
      columnPinned: t("columnPinning"),
      columnResized: t("columnSizing"),
      columnVisible: t("columnVisibility"),
      columnPivotChanged: t("pivot"),
      columnPivotModeChanged: t("pivot"),
      columnRowGroupChanged: t("rowGroup"),
      sortChanged: t("sort"),
      newColumnsLoaded: () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "rowGroup",
        "sort"
      ]),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setupStateOnRowCountReady() {
    const {
      filter: e,
      rowGroupExpansion: t,
      rowSelection: s,
      pagination: i
    } = this.getInitialState();
    e && this.setFilterState(e), t && this.setRowGroupExpansionState(t), s && this.setRowSelectionState(s), i && this.setPaginationState(i);
    const r = this.updateCachedState.bind(this);
    r("filter", this.getFilterState()), r("rowGroupExpansion", this.getRowGroupExpansionState()), r("rowSelection", this.getRowSelectionState()), r("pagination", this.getPaginationState());
    const o = () => {
      this.updateRowGroupExpansionStateTimer = 0, r("rowGroupExpansion", this.getRowGroupExpansionState());
    };
    this.addManagedEventListeners({
      filterChanged: () => r("filter", this.getFilterState()),
      rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
      expandOrCollapseAll: o,
      // `groupDefaultExpanded` updates expansion state without an expansion event
      columnRowGroupChanged: o,
      rowDataUpdated: () => {
        this.gos.get("groupDefaultExpanded") !== 0 && (this.updateRowGroupExpansionStateTimer || (this.updateRowGroupExpansionStateTimer = setTimeout(o)));
      },
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
      },
      paginationChanged: (n) => {
        (n.newPage || n.newPageSize) && r("pagination", this.getPaginationState());
      }
    });
  }
  setupStateOnFirstDataRendered() {
    const {
      scroll: e,
      cellSelection: t,
      focusedCell: s,
      columnOrder: i
    } = this.getInitialState();
    s && this.setFocusedCellState(s), t && this.setCellSelectionState(t), e && this.setScrollState(e), this.setColumnPivotState(!!(i != null && i.orderedColIds));
    const r = this.updateCachedState.bind(this);
    r("sideBar", this.getSideBarState()), r("focusedCell", this.getFocusedCellState());
    const o = this.getRangeSelectionState();
    r("rangeSelection", o), r("cellSelection", o), r("scroll", this.getScrollState()), this.addManagedEventListeners({
      cellFocused: () => r("focusedCell", this.getFocusedCellState()),
      cellSelectionChanged: (n) => {
        if (n.finished) {
          const a = this.getRangeSelectionState();
          r("rangeSelection", a), r("cellSelection", a);
        }
      },
      bodyScrollEnd: () => r("scroll", this.getScrollState())
    });
  }
  getColumnState() {
    const e = this.beans, t = e.colModel.isPivotMode(), s = [], i = [], r = [], o = [], n = [], a = [], l = [], d = [], c = [];
    let h = 0;
    const u = pr(e);
    for (let p = 0; p < u.length; p++) {
      const {
        colId: g,
        sort: f,
        sortIndex: m,
        rowGroup: C,
        rowGroupIndex: v,
        aggFunc: b,
        pivot: y,
        pivotIndex: F,
        pinned: D,
        hide: x,
        width: T,
        flex: I
      } = u[p];
      c.push(g), f && (s[m ?? h++] = { colId: g, sort: f }), C && (i[v ?? 0] = g), typeof b == "string" && r.push({ colId: g, aggFunc: b }), y && (o[F ?? 0] = g), D && (D === "right" ? a : n).push(g), x && l.push(g), (I || T) && d.push({ colId: g, flex: I ?? void 0, width: T });
    }
    return {
      sort: s.length ? { sortModel: s } : void 0,
      rowGroup: i.length ? { groupColIds: i } : void 0,
      aggregation: r.length ? { aggregationModel: r } : void 0,
      pivot: o.length || t ? { pivotMode: t, pivotColIds: o } : void 0,
      columnPinning: n.length || a.length ? { leftColIds: n, rightColIds: a } : void 0,
      columnVisibility: l.length ? { hiddenColIds: l } : void 0,
      columnSizing: d.length ? { columnSizingModel: d } : void 0,
      columnOrder: c.length ? { orderedColIds: c } : void 0
    };
  }
  setColumnState(e) {
    const {
      sort: t,
      rowGroup: s,
      aggregation: i,
      pivot: r,
      columnPinning: o,
      columnVisibility: n,
      columnSizing: a,
      columnOrder: l,
      partialColumnState: d
    } = e, c = {}, h = (m) => {
      let C = c[m];
      return C || (C = { colId: m }, c[m] = C, C);
    }, u = d ? {} : {
      sort: null,
      sortIndex: null,
      rowGroup: null,
      rowGroupIndex: null,
      aggFunc: null,
      pivot: null,
      pivotIndex: null,
      pinned: null,
      hide: null,
      flex: null
    };
    t && (t.sortModel.forEach(({ colId: m, sort: C }, v) => {
      const b = h(m);
      b.sort = C, b.sortIndex = v;
    }), u.sort = null, u.sortIndex = null), s && (s.groupColIds.forEach((m, C) => {
      const v = h(m);
      v.rowGroup = !0, v.rowGroupIndex = C;
    }), u.rowGroup = null, u.rowGroupIndex = null), i && (i.aggregationModel.forEach(({ colId: m, aggFunc: C }) => {
      h(m).aggFunc = C;
    }), u.aggFunc = null), r && (r.pivotColIds.forEach((m, C) => {
      const v = h(m);
      v.pivot = !0, v.pivotIndex = C;
    }), this.gos.updateGridOptions({
      options: { pivotMode: r.pivotMode },
      source: "gridInitializing"
    }), u.pivot = null, u.pivotIndex = null), o && (o.leftColIds.forEach((m) => {
      h(m).pinned = "left";
    }), o.rightColIds.forEach((m) => {
      h(m).pinned = "right";
    }), u.pinned = null), n && (n.hiddenColIds.forEach((m) => {
      h(m).hide = !0;
    }), u.hide = null), a && (a.columnSizingModel.forEach(({ colId: m, flex: C, width: v }) => {
      const b = h(m);
      b.flex = C ?? null, b.width = v;
    }), u.flex = null);
    const p = l == null ? void 0 : l.orderedColIds, g = !!(p != null && p.length), f = g ? p.map((m) => h(m)) : Object.values(c);
    f.length && (this.columnStates = f, Xe(
      this.beans,
      {
        state: f,
        applyOrder: g,
        defaultState: u
      },
      "gridInitializing"
    ));
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const s = this.columnGroupStates;
    this.columnGroupStates = void 0;
    const i = this.beans, { pivotResultCols: r, colGroupSvc: o } = i;
    if (r != null && r.isPivotResultColsPresent()) {
      if (t) {
        const n = [];
        for (const a of t)
          r.getPivotResultCol(a.colId) && n.push(a);
        Xe(
          i,
          {
            state: n,
            applyOrder: e
          },
          "gridInitializing"
        );
      }
      s && (o == null || o.setColumnGroupState(s, "gridInitializing"));
    }
  }
  getColumnGroupState() {
    const e = this.beans.colGroupSvc;
    if (!e)
      return;
    const t = e.getColumnGroupState(), s = [];
    return t.forEach(({ groupId: i, open: r }) => {
      r && s.push(i);
    }), s.length ? { openColumnGroupIds: s } : void 0;
  }
  setColumnGroupState(e) {
    var o;
    const t = this.beans.colGroupSvc;
    if (!Object.prototype.hasOwnProperty.call(e, "columnGroup") || !t)
      return;
    const s = new Set((o = e.columnGroup) == null ? void 0 : o.openColumnGroupIds), r = t.getColumnGroupState().map(({ groupId: n }) => {
      const a = s.has(n);
      return a && s.delete(n), {
        groupId: n,
        open: a
      };
    });
    s.forEach((n) => {
      r.push({
        groupId: n,
        open: !0
      });
    }), r.length && (this.columnGroupStates = r), t.setColumnGroupState(r, "gridInitializing");
  }
  getFilterState() {
    const e = this.beans.filterManager;
    let t = e == null ? void 0 : e.getFilterModel();
    t && Object.keys(t).length === 0 && (t = void 0);
    const s = (e == null ? void 0 : e.getAdvFilterModel()) ?? void 0;
    return t || s ? { filterModel: t, advancedFilterModel: s } : void 0;
  }
  setFilterState(e) {
    const t = this.beans.filterManager, { filterModel: s, advancedFilterModel: i } = e ?? {};
    s && (t == null || t.setFilterModel(s, "columnFilter")), i && (t == null || t.setAdvFilterModel(i));
  }
  getRangeSelectionState() {
    var t;
    const e = (t = this.beans.rangeSvc) == null ? void 0 : t.getCellRanges().map((s) => {
      const { id: i, type: r, startRow: o, endRow: n, columns: a, startColumn: l } = s;
      return {
        id: i,
        type: r,
        startRow: o,
        endRow: n,
        colIds: a.map((d) => d.getColId()),
        startColId: l.getColId()
      };
    });
    return e != null && e.length ? { cellRanges: e } : void 0;
  }
  setCellSelectionState(e) {
    const { gos: t, rangeSvc: s, colModel: i, visibleCols: r } = this.beans;
    if (!Ve(t) || !s)
      return;
    const o = [];
    e.cellRanges.forEach((n) => {
      const a = [];
      if (n.colIds.forEach((d) => {
        const c = i.getCol(d);
        c && a.push(c);
      }), !a.length)
        return;
      let l = i.getCol(n.startColId);
      if (!l) {
        const d = r.allCols, c = new Set(a);
        l = d.find((h) => c.has(h));
      }
      o.push({
        ...n,
        columns: a,
        startColumn: l
      });
    }), s.setCellRanges(o);
  }
  getScrollState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.beans.ctrlsSvc.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: s } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return s || t ? {
      top: s,
      left: t
    } : void 0;
  }
  setScrollState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { top: t, left: s } = e, { frameworkOverrides: i, rowRenderer: r, animationFrameSvc: o, ctrlsSvc: n } = this.beans;
    i.wrapIncoming(() => {
      var a;
      n.get("center").setCenterViewportScrollLeft(s), (a = n.getScrollFeature()) == null || a.setVerticalScrollPosition(t), r.redraw({ afterScroll: !0 }), o == null || o.flushAllFrames();
    });
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.beans.sideBar) == null ? void 0 : e.comp) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.beans.focusSvc.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: s, rowPinned: i } = e;
      return {
        colId: t.getColId(),
        rowIndex: s,
        rowPinned: i
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { colId: t, rowIndex: s, rowPinned: i } = e, { focusSvc: r, colModel: o } = this.beans;
    r.setFocusedCell({
      column: o.getCol(t),
      rowIndex: s,
      rowPinned: i,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    const { pagination: e, gos: t } = this.beans;
    if (!e)
      return;
    const s = e.getCurrentPage(), i = t.get("paginationAutoPageSize") ? void 0 : e.getPageSize();
    if (!(!s && !i))
      return { page: s, pageSize: i };
  }
  setPaginationState(e) {
    const { pagination: t, gos: s } = this.beans;
    t && (e.pageSize && !s.get("paginationAutoPageSize") && t.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && t.setPage(e.page));
  }
  getRowSelectionState() {
    var i;
    const e = this.beans.selectionSvc;
    if (!e)
      return;
    const t = e.getSelectionState();
    return !t || !Array.isArray(t) && (t.selectAll === !1 || t.selectAllChildren === !1) && !((i = t == null ? void 0 : t.toggledNodes) != null && i.length) ? void 0 : t;
  }
  setRowSelectionState(e) {
    var t;
    (t = this.beans.selectionSvc) == null || t.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const { expansionSvc: e, rowModel: t } = this.beans;
    if (!e)
      return;
    const s = [];
    return t.forEachNode(({ expanded: i, id: r }) => {
      i && r && s.push(r);
    }), s.length ? {
      expandedRowGroupIds: s
    } : void 0;
  }
  setRowGroupExpansionState(e) {
    var t;
    (t = this.beans.expansionSvc) == null || t.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let s = !1;
    const i = this.cachedState;
    Object.entries(t).forEach(([r, o]) => {
      bi(o, i[r]) || (s = !0);
    }), this.cachedState = {
      ...i,
      ...t
    }, s && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const s = this.cachedState[e];
    this.setCachedStateValue(e, t), bi(t, s) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = {
      ...this.cachedState,
      [e]: t
    };
  }
  refreshStaleState() {
    const e = this.staleStateKeys;
    e.forEach((t) => {
      switch (t) {
        case "rowSelection":
          this.setCachedStateValue(t, this.getRowSelectionState());
          break;
      }
    }), e.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = this.queuedUpdateSources, t = Array.from(e);
    e.clear(), this.eventSvc.dispatchEvent({
      type: "stateUpdated",
      sources: t,
      state: this.cachedState
    });
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = !0;
    const t = this.beans.colAnimation;
    t == null || t.setSuppressAnimation(!0), e(), setTimeout(() => {
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (t == null || t.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
}, TT = {
  moduleName: "GridState",
  version: G,
  beans: [PT],
  apiFunctions: {
    getState: ST
  }
};
function DT(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function ET(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getPageSize()) ?? 100;
}
function MT(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getCurrentPage()) ?? 0;
}
function AT(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getTotalPages()) ?? 1;
}
function IT(e) {
  return e.pagination ? e.pagination.getMasterRowCount() : e.rowModel.getRowCount();
}
function LT(e) {
  var t;
  (t = e.pagination) == null || t.goToNextPage();
}
function kT(e) {
  var t;
  (t = e.pagination) == null || t.goToPreviousPage();
}
function OT(e) {
  var t;
  (t = e.pagination) == null || t.goToFirstPage();
}
function GT(e) {
  var t;
  (t = e.pagination) == null || t.goToLastPage();
}
function BT(e, t) {
  var s;
  (s = e.pagination) == null || s.goToPage(t);
}
var VT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeSvc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t
      }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.beans.pagination.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.viewportSizeFeature.getBodyHeight();
    if (e > 0) {
      const t = this.beans, s = () => {
        const i = Math.max(Ye(t), 1), r = Math.floor(e / i);
        t.pagination.setPageSize(r, "autoCalculated");
      };
      this.isBodyRendered ? Ce(this, s, 50)() : (s(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
}, Wi = "paginationPageSizeSelector", NT = class extends L {
  constructor() {
    super(
      /* html */
      '<span class="ag-paging-page-size"></span>'
    ), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.pagination.getPageSize() || (this.pagination.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.pagination = e.pagination;
  }
  postConstruct() {
    this.addManagedPropertyListener(Wi, () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.pagination.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && !e && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp);
  }
  reset() {
    X(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get(Wi) !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.pagination.getPageSize(), s = !t || !e.includes(t);
    if (s) {
      const r = this.gos.exists("paginationPageSize"), o = this.gos.get(Wi) !== !0;
      R(94, { pageSizeSet: r, pageSizesSet: o, pageSizeOptions: e, paginationPageSizeOption: t }), o || R(95, { paginationPageSizeOption: t, paginationPageSizeSelector: Wi }), e.unshift("");
    }
    const i = String(s ? "" : t);
    this.selectPageSizeComp ? (Re(this.pageSizeOptions, e) || (this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(e)), this.pageSizeOptions = e), this.selectPageSizeComp.setValue(i, !0)) : this.createPageSizeSelectorComp(e, i), this.hasEmptyOption = s;
  }
  createPageSizeSelectOptions(e) {
    return e.map((t) => ({
      value: String(t)
    }));
  }
  createPageSizeSelectorComp(e, t) {
    const s = this.getLocaleTextFunc(), i = s("pageSizeSelectorLabel", "Page Size:"), r = s("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new Ne()).addOptions(this.createPageSizeSelectOptions(e)).setValue(t).setAriaLabel(r).setLabel(i).onValueChange(() => this.handlePageSizeItemSelected()), this.appendChild(this.selectPageSizeComp);
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get(Wi);
    return !Array.isArray(t) || !(t != null && t.length) ? e : [...t].sort((s, i) => s - i);
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
}, HT = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: NT
}, zT = (
  /*css*/
  ".ag-paging-panel{align-items:center;border-top:var(--ag-footer-row-border);display:flex;gap:calc(var(--ag-spacing)*4);height:max(var(--ag-row-height),22px);justify-content:flex-end;padding:0 var(--ag-cell-horizontal-padding)}:where(.ag-paging-page-size) .ag-wrapper{min-width:50px}.ag-paging-page-summary-panel{align-items:center;display:flex;gap:var(--ag-cell-widget-spacing);.ag-disabled &{pointer-events:none}}.ag-paging-button{cursor:pointer;position:relative;&.ag-disabled{cursor:default;opacity:.5}}.ag-paging-number,.ag-paging-row-summary-panel-number{font-weight:500}"
), WT = class extends Nt {
  constructor() {
    super(), this.btFirst = S, this.btPrevious = S, this.btNext = S, this.btLast = S, this.lbRecordCount = S, this.lbFirstRowOnPage = S, this.lbLastRowOnPage = S, this.lbCurrent = S, this.lbTotal = S, this.pageSizeComp = S, this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1, this.allowFocusInnerElement = !1, this.registerCSS(zT);
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pagination = e.pagination, this.ariaAnnounce = e.ariaAnnounce;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [HT]);
    const { btFirst: t, btPrevious: s, btNext: i, btLast: r } = this;
    this.activateTabIndex([t, s, i, r]), t.insertAdjacentElement("afterbegin", B(e ? "last" : "first", this.beans)), s.insertAdjacentElement("afterbegin", B(e ? "next" : "previous", this.beans)), i.insertAdjacentElement("afterbegin", B(e ? "previous" : "next", this.beans)), r.insertAdjacentElement("afterbegin", B(e ? "first" : "last", this.beans)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (o) => {
        this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(o) : Eu(this.beans, o);
      },
      forceFocusOutWhenTabGuardsAreEmpty: !0
    }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: s } = e;
      this.addManagedListeners(t, {
        click: s,
        keydown: (i) => {
          (i.key === w.ENTER || i.key === w.SPACE) && (i.preventDefault(), s());
        }
      });
    }), Du(this.beans, this, this.getGui()), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.pagination.goToFirstPage();
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    return t ? t({ value: e }) : Xs(e, this.getLocaleTextFunc.bind(this));
  }
  getTemplate() {
    const e = this.getLocaleTextFunc(), t = e("page", "Page"), s = e("to", "to"), i = e("of", "of"), r = e("firstPage", "First Page"), o = e("previousPage", "Previous Page"), n = e("nextPage", "Next Page"), a = e("lastPage", "Last Page"), l = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel">
                    <span id="ag-${l}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${s}</span>
                    <span id="ag-${l}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${i}</span>
                    <span id="ag-${l}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${r}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <span class="ag-paging-description">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${i}</span>
                        <span id="ag-${l}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.pagination.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.pagination.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.pagination.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.pagination.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), s = this.pagination.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const i = this.isZeroPagesToDisplay(), r = e === s - 1;
    this.nextButtonDisabled = r || i, this.lastButtonDisabled = !t || i || e === s - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    co(e, t), e.classList.toggle("ag-disabled", t);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.pagination.getTotalPages();
    return e && t === 0;
  }
  updateLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.pagination.getTotalPages(), s = this.pagination.getMasterRowCount(), i = e ? s : null;
    if (i === 1) {
      const v = this.rowModel.getRow(0);
      if (v && v.group && !(v.groupData || v.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    const r = this.pagination.getCurrentPage(), o = this.pagination.getPageSize();
    let n, a;
    this.isZeroPagesToDisplay() ? n = a = 0 : (n = o * r + 1, a = n + o - 1, e && a > i && (a = i));
    const l = n + o - 1, d = !e && s < l, c = this.formatNumber(n);
    this.lbFirstRowOnPage.textContent = c;
    let h;
    const u = this.getLocaleTextFunc();
    d ? h = u("pageLastRowUnknown", "?") : h = this.formatNumber(a), this.lbLastRowOnPage.textContent = h;
    const g = t > 0 ? r + 1 : 0, f = this.formatNumber(g);
    this.lbCurrent.textContent = f;
    let m, C;
    if (e)
      m = this.formatNumber(t), C = this.formatNumber(i);
    else {
      const v = u("more", "more");
      m = v, C = v;
    }
    this.lbTotal.textContent = m, this.lbRecordCount.textContent = C, this.announceAriaStatus(c, h, C, f, m);
  }
  announceAriaStatus(e, t, s, i, r) {
    var h, u;
    const o = this.getLocaleTextFunc(), n = o("page", "Page"), a = o("to", "to"), l = o("of", "of"), d = `${e} ${a} ${t} ${l} ${s}`, c = `${n} ${i} ${l} ${r}`;
    d !== this.ariaRowStatus && (this.ariaRowStatus = d, (h = this.ariaAnnounce) == null || h.announceValue(d, "paginationRow")), c !== this.ariaPageStatus && (this.ariaPageStatus = c, (u = this.ariaAnnounce) == null || u.announceValue(c, "paginationPage"));
  }
  setTotalLabelsToZero() {
    const e = this.formatNumber(0);
    this.lbFirstRowOnPage.textContent = e, this.lbCurrent.textContent = e, this.lbLastRowOnPage.textContent = e, this.lbTotal.textContent = e, this.lbRecordCount.textContent = e, this.announceAriaStatus(e, e, e, e, e);
  }
}, _T = {
  selector: "AG-PAGINATION",
  component: WT
}, UT = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pagination", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  postConstruct() {
    const e = this.gos;
    this.active = e.get("pagination"), this.pageSizeFromGridOptions = e.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return _T;
  }
  isPaginateChildRows() {
    const e = this.gos;
    return e.get("groupHideParentOfSingleChild") || // following two properties deprecated v32.3.0
    e.get("groupRemoveSingleChildren") || e.get("groupRemoveLowestSingleChildren") ? !0 : e.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    const t = this.currentPage;
    !this.active || t === e || typeof t != "number" || (this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: !0 }));
  }
  isRowPresent(e) {
    return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex;
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.beans.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return A(this.pageSizeAutoCalculated) && this.gos.get("paginationAutoPageSize") ? this.pageSizeAutoCalculated : A(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : A(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : A(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.beans.pageBounds.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0 }));
  }
  setPageSize(e, t) {
    const s = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    s !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0, keepRenderedRows: !0 }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    const e = this.totalPages;
    this.currentPage >= e && (this.currentPage = e - 1);
    const t = this.currentPage;
    (!isFinite(t) || isNaN(t) || t < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    const e = this.beans.rowModel, t = e.getTopLevelRowCount();
    if (this.masterRowCount = t, t <= 0) {
      this.setZeroRows();
      return;
    }
    const s = this.pageSize, i = t - 1;
    this.totalPages = Math.floor(i / s) + 1, this.adjustCurrentPageIfInvalid();
    const r = this.currentPage, o = s * r;
    let n = s * (r + 1) - 1;
    if (n > i && (n = i), this.topDisplayedRowIndex = e.getTopLevelRowDisplayedIndex(o), n === i)
      this.bottomDisplayedRowIndex = e.getRowCount() - 1;
    else {
      const a = e.getTopLevelRowDisplayedIndex(n + 1);
      this.bottomDisplayedRowIndex = a - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    const e = this.beans.rowModel.getRowCount();
    if (this.masterRowCount = e, e === 0) {
      this.setZeroRows();
      return;
    }
    const { pageSize: t, currentPage: s } = this, i = e - 1;
    this.totalPages = Math.floor(i / t) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = t * s, this.bottomDisplayedRowIndex = t * (s + 1) - 1, this.bottomDisplayedRowIndex > i && (this.bottomDisplayedRowIndex = i);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.beans.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = !1, newPage: s = !1, newPageSize: i = !1 } = e;
    this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: !1,
      newData: !1,
      newPage: s,
      newPageSize: i,
      keepRenderedRows: t
    });
  }
}, KT = {
  moduleName: "Pagination",
  version: G,
  beans: [UT, VT],
  icons: {
    // "go to first" button in pagination controls
    first: "first",
    // "go to previous" button in pagination controls
    previous: "previous",
    // "go to next" button in pagination controls
    next: "next",
    // "go to last" button in pagination controls
    last: "last"
  },
  apiFunctions: {
    paginationIsLastPageFound: DT,
    paginationGetPageSize: ET,
    paginationGetCurrentPage: MT,
    paginationGetTotalPages: AT,
    paginationGetRowCount: IT,
    paginationGoToNextPage: LT,
    paginationGoToPreviousPage: kT,
    paginationGoToFirstPage: OT,
    paginationGoToLastPage: GT,
    paginationGoToPage: BT
  },
  dependsOn: [ts]
};
function $T(e, t = {}) {
  const s = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(s));
}
function ug(e, t, s, i, r) {
  t && (i && t.parent && t.parent.level !== -1 && ug(e, t.parent, s, i, r), t.setExpanded(s, void 0, r));
}
function jT(e, t) {
  return e.rowModel.getRowNode(t);
}
function qT(e, t, s, i) {
  e.rowRenderer.addRenderedRowListener(t, s, i);
}
function YT(e) {
  return e.rowRenderer.getRenderedNodes();
}
function XT(e, t, s) {
  e.rowModel.forEachNode(t, s);
}
function ZT(e) {
  return e.rowRenderer.firstRenderedRow;
}
function QT(e) {
  return e.rowRenderer.lastRenderedRow;
}
function JT(e, t) {
  return e.rowModel.getRow(t);
}
function eD(e) {
  return e.rowModel.getRowCount();
}
var pg = {
  moduleName: "RowApi",
  version: G,
  apiFunctions: {
    redrawRows: $T,
    setRowNodeExpanded: ug,
    getRowNode: jT,
    addRenderedRowListener: qT,
    getRenderedNodes: YT,
    forEachNode: XT,
    getFirstDisplayedRowIndex: ZT,
    getLastDisplayedRowIndex: QT,
    getDisplayedRowAtIndex: JT,
    getDisplayedRowCount: eD
  }
}, tD = {
  moduleName: "ScrollApi",
  version: G,
  apiFunctions: {
    getVerticalPixelRange: jR,
    getHorizontalPixelRange: qR,
    ensureColumnVisible: ig,
    ensureIndexVisible: rg,
    ensureNodeVisible: YR
  }
};
function sD(e, t, s) {
  if (!t)
    return;
  const i = e.ctrlsSvc.getGridBodyCtrl().eGridBody, r = `aria-${t}`;
  s === null ? i.removeAttribute(r) : i.setAttribute(r, s);
}
function iD(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function rD(e) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getHeaderRowContainerCtrls().forEach((t) => t.refresh())
  );
}
function oD(e) {
  var t;
  return ((t = e.animationFrameSvc) == null ? void 0 : t.isQueueEmpty()) ?? !0;
}
function nD(e) {
  var t;
  (t = e.animationFrameSvc) == null || t.flushAllFrames();
}
function aD(e) {
  return {
    rowHeight: Ye(e),
    headerHeight: Fr(e)
  };
}
function lD(e, t = {}) {
  var o;
  const s = [];
  if (e.rowRenderer.getCellCtrls(t.rowNodes, t.columns).forEach((n) => {
    const a = n.getCellRenderer();
    a != null && s.push(Ys(a));
  }), (o = t.columns) != null && o.length)
    return s;
  const i = [], r = Ea(t.rowNodes);
  return e.rowRenderer.getAllRowCtrls().forEach((n) => {
    if (r && !Ma(n.rowNode, r) || !n.isFullWidth())
      return;
    const a = n.getFullWidthCellRenderers();
    for (let l = 0; l < a.length; l++) {
      const d = a[l];
      d != null && i.push(Ys(d));
    }
  }), [...i, ...s];
}
var dD = {
  moduleName: "RenderApi",
  version: G,
  apiFunctions: {
    setGridAriaProperty: sD,
    refreshCells: iD,
    refreshHeader: rD,
    isAnimationFrameQueueEmpty: oD,
    flushAllAnimationFrames: nD,
    getSizesForCurrentTheme: aD,
    getCellRendererInstances: lD
  }
};
function cD(e, t) {
  var s, i;
  typeof t == "number" ? (s = e.colAutosize) == null || s.sizeColumnsToFit(t, "api") : (i = e.colAutosize) == null || i.sizeColumnsToFitGridBody(t);
}
function hD(e, t, s) {
  var i;
  (i = e.colAutosize) == null || i.autoSizeCols({ colKeys: t, skipHeader: s, source: "api" });
}
function uD(e, t) {
  var s;
  (s = e.colAutosize) == null || s.autoSizeAllColumns("api", t);
}
var pD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colAutosize", this.timesDelayed = 0, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  postConstruct() {
    this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  autoSizeCols(e) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const { colKeys: t, skipHeader: s, skipHeaderGroups: i, stopAtGroup: r, source: o = "api" } = e, { animationFrameSvc: n, renderStatus: a, colModel: l, autoWidthCalc: d, visibleCols: c } = this.beans;
    if (n == null || n.flushAllFrames(), this.timesDelayed < 5 && a && !a.areHeaderCellsRendered()) {
      this.timesDelayed++, setTimeout(() => {
        this.isAlive() && this.autoSizeCols(e);
      });
      return;
    }
    this.timesDelayed = 0;
    const h = [];
    let u = -1;
    const p = s ?? this.gos.get("skipHeaderOnAutoSize"), g = i ?? p;
    for (; u !== 0; ) {
      u = 0;
      const f = [];
      t.forEach((m) => {
        if (!m)
          return;
        const C = l.getCol(m);
        if (!C || h.indexOf(C) >= 0)
          return;
        const v = d.getPreferredWidthForColumn(C, p);
        if (v > 0) {
          const b = gD(C, v);
          C.setActualWidth(b, o), h.push(C), u++;
        }
        f.push(C);
      }), f.length && c.refresh(o);
    }
    g || this.autoSizeColumnGroupsByColumns(t, o, r), Pi(this.eventSvc, h, !0, "autosizeColumns");
  }
  autoSizeColumn(e, t, s) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: s, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, s) {
    const { colModel: i, ctrlsSvc: r } = this.beans, o = /* @__PURE__ */ new Set();
    i.getColsForKeys(e).forEach((d) => {
      let c = d.getParent();
      for (; c && c != s; )
        c.isPadding() || o.add(c), c = c.getParent();
    });
    let a;
    const l = [];
    for (const d of o) {
      for (const c of r.getHeaderRowContainerCtrls())
        if (a = c.getHeaderCtrlForColumn(d), a)
          break;
      a && a.resizeLeafColumnsToFit(t);
    }
    return l;
  }
  autoSizeAllColumns(e, t) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const s = this.beans.visibleCols.allCols;
    this.autoSizeCols({ colKeys: s, skipHeader: t, source: e });
  }
  addColumnAutosize(e, t) {
    const s = this.gos.get("skipHeaderOnAutoSize"), i = () => {
      this.autoSizeColumn(t, "uiColumnResized", s);
    };
    e.addEventListener("dblclick", i);
    const r = new hs(e);
    return r.addEventListener("doubleTap", i), () => {
      e.removeEventListener("dblclick", i), r.removeEventListener("doubleTap", i), r.destroy();
    };
  }
  addColumnGroupResize(e, t, s) {
    const i = this.gos.get("skipHeaderOnAutoSize"), r = () => {
      const o = [];
      t.getDisplayedLeafColumns().forEach((a) => {
        a.getColDef().suppressAutoSize || o.push(a.getColId());
      }), o.length > 0 && this.autoSizeCols({
        colKeys: o,
        skipHeader: i,
        stopAtGroup: t,
        source: "uiColumnResized"
      }), s();
    };
    return e.addEventListener("dblclick", r), () => e.removeEventListener("dblclick", r);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFitGridBody(e, t) {
    if (!this.isAlive())
      return;
    const { ctrlsSvc: s, scrollVisibleSvc: i } = this.beans, r = s.getGridBodyCtrl(), n = r.isVerticalScrollShowing() ? i.getScrollbarWidth() : 0, l = yi(r.eGridBody) - n;
    if (l > 0) {
      this.sizeColumnsToFit(l, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, -1);
    }, 500) : R(29);
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", s, i) {
    var p;
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.sizeColumnsToFit(e, t, s, i));
      return;
    }
    const r = {};
    i && ((p = i == null ? void 0 : i.columnLimits) == null || p.forEach(({ key: g, ...f }) => {
      r[typeof g == "string" ? g : g.getColId()] = f;
    }));
    const o = this.beans.visibleCols.allCols, n = e === _t(o);
    if (e <= 0 || !o.length || n)
      return;
    const a = [], l = [];
    o.forEach((g) => {
      g.getColDef().suppressSizeToFit === !0 ? l.push(g) : a.push(g);
    });
    const d = a.slice(0);
    let c = !1;
    const h = (g) => {
      be(a, g), l.push(g);
    };
    for (a.forEach((g) => {
      g.resetActualWidth(t);
      const f = r == null ? void 0 : r[g.getId()], m = (f == null ? void 0 : f.minWidth) ?? (i == null ? void 0 : i.defaultMinWidth), C = (f == null ? void 0 : f.maxWidth) ?? (i == null ? void 0 : i.defaultMaxWidth), v = g.getActualWidth();
      typeof m == "number" && v < m ? g.setActualWidth(m, t, !0) : typeof C == "number" && v > C && g.setActualWidth(C, t, !0);
    }); !c; ) {
      c = !0;
      const g = e - _t(l);
      if (g <= 0)
        a.forEach((f) => {
          var C;
          const m = ((C = r == null ? void 0 : r[f.getId()]) == null ? void 0 : C.minWidth) ?? (i == null ? void 0 : i.defaultMinWidth);
          if (typeof m == "number") {
            f.setActualWidth(m, t, !0);
            return;
          }
          f.setActualWidth(f.minWidth, t);
        });
      else {
        const f = g / _t(a);
        let m = g;
        for (let C = a.length - 1; C >= 0; C--) {
          const v = a[C], b = r == null ? void 0 : r[v.getId()], y = (b == null ? void 0 : b.minWidth) ?? (i == null ? void 0 : i.defaultMinWidth), F = (b == null ? void 0 : b.maxWidth) ?? (i == null ? void 0 : i.defaultMaxWidth), D = v.getMinWidth(), x = v.getMaxWidth(), T = typeof y == "number" && y > D ? y : D, I = typeof F == "number" && F < x ? F : x;
          let E = Math.round(v.getActualWidth() * f);
          E < T ? (E = T, h(v), c = !1) : E > I ? (E = I, h(v), c = !1) : C === 0 && (E = m), v.setActualWidth(E, t, !0), m -= E;
        }
      }
    }
    d.forEach((g) => {
      g.fireColumnWidthChangedEvent(t);
    });
    const u = this.beans.visibleCols;
    u.setLeftValues(t), u.updateBodyWidths(), !s && Pi(this.eventSvc, d, !0, t);
  }
  applyAutosizeStrategy() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e)
      return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: s, defaultMinWidth: i, defaultMaxWidth: r } = e, o = s == null ? void 0 : s.map(({ colId: n, minWidth: a, maxWidth: l }) => ({
          key: n,
          minWidth: a,
          maxWidth: l
        }));
        this.sizeColumnsToFitGridBody({
          defaultMinWidth: i,
          defaultMaxWidth: r,
          columnLimits: o
        });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents")
      return;
    const { colIds: t, skipHeader: s } = e;
    setTimeout(() => {
      t ? this.autoSizeCols({
        colKeys: t,
        skipHeader: s,
        source: "autosizeColumns"
      }) : this.autoSizeAllColumns("autosizeColumns", s);
    });
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  destroy() {
    this.resizeOperationQueue.length = 0, super.destroy();
  }
};
function gD(e, t) {
  const s = e.getMinWidth();
  t < s && (t = s);
  const i = e.getMaxWidth();
  return e.isGreaterThanMax(t) && (t = i), t;
}
var fD = {
  moduleName: "ColumnAutoSize",
  version: G,
  beans: [pD],
  apiFunctions: {
    sizeColumnsToFit: cD,
    autoSizeColumns: hD,
    autoSizeAllColumns: uD
  },
  dependsOn: [pp]
};
function mD(e) {
  var t;
  return ((t = e.pinnedRowModel) == null ? void 0 : t.getPinnedTopRowCount()) ?? 0;
}
function CD(e) {
  var t;
  return ((t = e.pinnedRowModel) == null ? void 0 : t.getPinnedBottomRowCount()) ?? 0;
}
function vD(e, t) {
  var s;
  return (s = e.pinnedRowModel) == null ? void 0 : s.getPinnedTopRow(t);
}
function wD(e, t) {
  var s;
  return (s = e.pinnedRowModel) == null ? void 0 : s.getPinnedBottomRow(t);
}
var yD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel", this.nextId = 0, this.pinnedTopRows = { cache: {}, order: [] }, this.pinnedBottomRows = { cache: {}, order: [] };
  }
  postConstruct() {
    const e = this.gos;
    this.setPinnedRowData(e.get("pinnedTopRowData"), "top"), this.setPinnedRowData(e.get("pinnedBottomRowData"), "bottom"), this.addManagedPropertyListener("pinnedTopRowData", (t) => this.setPinnedRowData(t.currentValue, "top")), this.addManagedPropertyListener("pinnedBottomRowData", (t) => this.setPinnedRowData(t.currentValue, "bottom")), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(e) {
    return this.getCache(e).order.length === 0;
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (s) => {
        s.setRowHeight(s.rowHeight, !0);
      };
      _i(this.pinnedBottomRows, t), _i(this.pinnedTopRows, t);
    }
  }
  ensureRowHeightsValid() {
    let e = !1, t = 0;
    const s = (i) => {
      if (i.rowHeightEstimated) {
        const r = Ie(this.beans, i);
        i.setRowTop(t), i.setRowHeight(r.height), t += r.height, e = !0;
      }
    };
    return _i(this.pinnedBottomRows, s), t = 0, _i(this.pinnedTopRows, s), this.eventSvc.dispatchEvent({
      type: "pinnedHeightChanged"
    }), e;
  }
  setPinnedRowData(e, t) {
    this.updateNodesFromRowData(e, t), this.eventSvc.dispatchEvent({
      type: "pinnedRowDataChanged"
    });
  }
  /**
   * Updates existing RowNode instances and creates new ones if necessary
   *
   * Setting data as `undefined` will clear row nodes
   */
  updateNodesFromRowData(e, t) {
    const s = this.getCache(t);
    if (e === void 0) {
      s.order.length = 0, s.cache = {};
      return;
    }
    const i = Yt(this.gos), r = t === "top" ? Vu : Nu, o = new Set(s.order), n = [], a = /* @__PURE__ */ new Set();
    let l = 0, d = -1;
    for (const c of e) {
      const h = (i == null ? void 0 : i({ data: c, level: 0, rowPinned: t })) ?? r + this.nextId++;
      if (a.has(h)) {
        R(96, { id: h, data: c });
        continue;
      }
      d++, a.add(h), n.push(h);
      const u = ar(s, h);
      if (u !== void 0)
        u.data !== c && u.setData(c), l += this.setRowTopAndRowIndex(u, l, d), o.delete(h);
      else {
        const p = new Qe(this.beans);
        p.id = h, p.data = c, p.rowPinned = t, l += this.setRowTopAndRowIndex(p, l, d), s.cache[h] = p, s.order.push(h);
      }
    }
    o.forEach((c) => {
      var h;
      (h = ar(s, c)) == null || h.clearRowTopAndRowIndex(), delete s.cache[c];
    }), s.order = n;
  }
  setRowTopAndRowIndex(e, t, s) {
    return e.setRowTop(t), e.setRowHeight(Ie(this.beans, e).height), e.setRowIndex(s), e.rowHeight;
  }
  getPinnedTopTotalHeight() {
    return dc(this.pinnedTopRows);
  }
  getPinnedBottomTotalHeight() {
    return dc(this.pinnedBottomRows);
  }
  getPinnedTopRowCount() {
    return ka(this.pinnedTopRows);
  }
  getPinnedBottomRowCount() {
    return ka(this.pinnedBottomRows);
  }
  getPinnedTopRow(e) {
    return La(this.pinnedTopRows, e);
  }
  getPinnedBottomRow(e) {
    return La(this.pinnedBottomRows, e);
  }
  getPinnedRowById(e, t) {
    return ar(this.getCache(t), e);
  }
  forEachPinnedRow(e, t) {
    return _i(this.getCache(e), t);
  }
  getCache(e) {
    return e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
  }
};
function dc(e) {
  const t = ka(e);
  if (t === 0)
    return 0;
  const s = La(e, t - 1);
  return s === void 0 ? 0 : s.rowTop + s.rowHeight;
}
function ar(e, t) {
  return e.cache[t];
}
function La(e, t) {
  return ar(e, e.order[t]);
}
function _i(e, t) {
  e.order.forEach((s, i) => {
    const r = ar(e, s);
    r && t(r, i);
  });
}
function ka(e) {
  return e.order.length;
}
var bD = {
  moduleName: "PinnedRow",
  version: G,
  beans: [yD],
  apiFunctions: {
    getPinnedTopRowCount: mD,
    getPinnedBottomRowCount: CD,
    getPinnedTopRow: vD,
    getPinnedBottomRow: wD
  }
}, SD = class extends P {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.staticClasses = [], this.beans = t, this.column = e.column;
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const { column: e, cellComp: t } = this, s = e.colDef, i = s.cellClassRules, r = this.getCellClassParams(e, s);
    Sl(
      this.beans.expressionSvc,
      // if current was previous, skip
      i === this.cellClassRules ? void 0 : this.cellClassRules,
      i,
      r,
      (o) => t.addOrRemoveCssClass(o, !0),
      (o) => t.addOrRemoveCssClass(o, !1)
    ), this.cellClassRules = i;
  }
  applyUserStyles() {
    const e = this.column, t = e.colDef, s = t.cellStyle;
    if (!s)
      return;
    let i;
    if (typeof s == "function") {
      const r = this.getCellClassParams(e, t);
      i = s(r);
    } else
      i = s;
    i && this.cellComp.setUserStyles(i);
  }
  applyClassesFromColDef() {
    const { column: e, cellComp: t } = this, s = e.colDef, i = this.getCellClassParams(e, s);
    this.staticClasses.forEach((o) => t.addOrRemoveCssClass(o, !1));
    const r = this.beans.cellStyles.getStaticCellClasses(s, i);
    this.staticClasses = r, r.forEach((o) => t.addOrRemoveCssClass(o, !0));
  }
  getCellClassParams(e, t) {
    const { value: s, rowNode: i } = this.cellCtrl;
    return this.beans.gos.addGridCommonParams({
      value: s,
      data: i.data,
      node: i,
      colDef: t,
      column: e,
      rowIndex: i.rowIndex
    });
  }
}, xD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "cellStyles";
  }
  processAllCellClasses(e, t, s, i) {
    Sl(
      this.beans.expressionSvc,
      void 0,
      e.cellClassRules,
      t,
      s,
      i
    ), this.processStaticCellClasses(e, t, s);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: s } = e;
    if (!s)
      return [];
    let i;
    return typeof s == "function" ? i = s(t) : i = s, typeof i == "string" && (i = [i]), i || [];
  }
  createCellCustomStyleFeature(e, t) {
    return new SD(e, t);
  }
  processStaticCellClasses(e, t, s) {
    this.getStaticCellClasses(e, t).forEach((r) => {
      s(r);
    });
  }
}, FD = {
  moduleName: "CellStyle",
  version: G,
  beans: [xD]
}, RD = {
  moduleName: "RowStyle",
  version: G,
  beans: [kw]
};
function PD(e, t) {
  var s;
  return !!((s = e.colHover) != null && s.isHovered(t));
}
var TD = class extends P {
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    if (this.gos.get("columnHoverHighlight")) {
      const e = this.beans.colHover;
      this.addManagedListeners(this.element, {
        mouseout: e.clearMouseOver.bind(e),
        mouseover: e.setMouseOver.bind(e, this.columns)
      });
    }
  }
}, DD = "ag-column-hover", ED = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colHover";
  }
  setMouseOver(e) {
    this.updateState(e);
  }
  clearMouseOver() {
    this.updateState(null);
  }
  isHovered(e) {
    const t = this.selectedColumns;
    return !!t && t.indexOf(e) >= 0;
  }
  addHeaderColumnHoverListener(e, t, s) {
    const i = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const r = this.isHovered(s);
      t.addOrRemoveCssClass("ag-column-hover", r);
    };
    e.addManagedEventListeners({ columnHoverChanged: i }), i();
  }
  onCellColumnHover(e, t) {
    if (!t || !this.gos.get("columnHoverHighlight"))
      return;
    const s = this.isHovered(e);
    t.addOrRemoveCssClass(DD, s);
  }
  addHeaderFilterColumnHoverListener(e, t, s, i) {
    this.createHoverFeature(e, [s], i);
    const r = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const o = this.isHovered(s);
      t.addOrRemoveCssClass("ag-column-hover", o);
    };
    e.addManagedEventListeners({ columnHoverChanged: r }), r();
  }
  createHoverFeature(e, t, s) {
    e.createManagedBean(new TD(t, s));
  }
  updateState(e) {
    this.selectedColumns = e, this.eventSvc.dispatchEvent({
      type: "columnHoverChanged"
    });
  }
}, MD = {
  moduleName: "ColumnHover",
  version: G,
  beans: [ED],
  apiFunctions: {
    isColumnHovered: PD
  }
}, AD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "apiEventSvc", this.syncListeners = /* @__PURE__ */ new Map(), this.asyncListeners = /* @__PURE__ */ new Map(), this.syncGlobalListeners = /* @__PURE__ */ new Set(), this.globalListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    var e, t;
    this.wrapSvc = (t = (e = this.beans.frameworkOverrides).createGlobalEventListenerWrapper) == null ? void 0 : t.call(e);
  }
  addEventListener(e, t) {
    var o;
    const s = ((o = this.wrapSvc) == null ? void 0 : o.wrap(t)) ?? t, i = !or.has(e), r = i ? this.asyncListeners : this.syncListeners;
    r.has(e) || r.set(e, /* @__PURE__ */ new Set()), r.get(e).add(s), this.eventSvc.addEventListener(e, s, i);
  }
  removeEventListener(e, t) {
    var o, n;
    const s = ((o = this.wrapSvc) == null ? void 0 : o.unwrap(t)) ?? t, i = this.asyncListeners.get(e), r = !!(i != null && i.delete(s));
    r || (n = this.syncListeners.get(e)) == null || n.delete(s), this.eventSvc.removeEventListener(e, s, r);
  }
  addGlobalListener(e) {
    var o;
    const t = ((o = this.wrapSvc) == null ? void 0 : o.wrapGlobal(e)) ?? e, s = (n, a) => {
      or.has(n) && t(n, a);
    }, i = (n, a) => {
      or.has(n) || t(n, a);
    };
    this.globalListenerPairs.set(e, { syncListener: s, asyncListener: i });
    const r = this.eventSvc;
    r.addGlobalListener(s, !1), r.addGlobalListener(i, !0);
  }
  removeGlobalListener(e) {
    const { eventSvc: t, wrapSvc: s, globalListenerPairs: i } = this, r = (s == null ? void 0 : s.unwrapGlobal(e)) ?? e;
    if (i.has(r)) {
      const { syncListener: n, asyncListener: a } = i.get(r);
      t.removeGlobalListener(n, !1), t.removeGlobalListener(a, !0), i.delete(e);
    } else
      this.syncGlobalListeners.delete(r), t.removeGlobalListener(r, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((s, i) => {
      s.forEach((r) => this.eventSvc.removeEventListener(i, r, t)), s.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((s) => this.eventSvc.removeGlobalListener(s, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncListeners, !1), this.destroyEventListeners(this.asyncListeners, !0), this.destroyGlobalListeners(this.syncGlobalListeners, !1);
    const { globalListenerPairs: e, eventSvc: t } = this;
    e.forEach(({ syncListener: s, asyncListener: i }) => {
      t.removeGlobalListener(s, !1), t.removeGlobalListener(i, !0);
    }), e.clear();
  }
};
function ID(e, t, s) {
  var i;
  (i = e.apiEventSvc) == null || i.addEventListener(t, s);
}
function LD(e, t, s) {
  var i;
  (i = e.apiEventSvc) == null || i.removeEventListener(t, s);
}
function kD(e, t) {
  var s;
  (s = e.apiEventSvc) == null || s.addGlobalListener(t);
}
function OD(e, t) {
  var s;
  (s = e.apiEventSvc) == null || s.removeGlobalListener(t);
}
var GD = {
  moduleName: "EventApi",
  version: G,
  apiFunctions: {
    addEventListener: ID,
    addGlobalListener: kD,
    removeEventListener: LD,
    removeGlobalListener: OD
  },
  beans: [AD]
}, BD = (
  /*css*/
  ".ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);white-space:normal}.ag-tooltip,.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:where(:not(.ag-tooltip-interactive)),.ag-tooltip:where(:not(.ag-tooltip-interactive)){pointer-events:none}.ag-tooltip-animate{transition:opacity 1s;&:where(.ag-tooltip-hiding){opacity:0}}"
), VD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "tooltipSvc";
  }
  setupHeaderTooltip(e, t, s, i) {
    e && t.destroyBean(e);
    const r = rr(this.gos), { column: o, eGui: n } = t, a = o.getColDef();
    !i && r && !a.headerComponent && (i = Us(
      () => n.querySelector(".ag-header-cell-text")
    ));
    const l = {
      getColumn: () => o,
      getColDef: () => o.getColDef(),
      getGui: () => n,
      getLocation: () => "header",
      getTooltipValue: () => s ?? o.getColDef().headerTooltip,
      shouldDisplayTooltip: i
    };
    let d = this.createTooltipFeature(l);
    return d && (d = t.createBean(d), t.setRefreshFunction("tooltip", () => d.refreshTooltip())), d;
  }
  setupHeaderGroupTooltip(e, t, s, i) {
    e && t.destroyBean(e);
    const r = rr(this.gos), { column: o, eGui: n } = t, a = o.getColGroupDef();
    !i && r && !(a != null && a.headerGroupComponent) && (i = Us(
      () => n.querySelector(".ag-header-group-text")
    ));
    const l = {
      getColumn: () => o,
      getGui: () => n,
      getLocation: () => "headerGroup",
      getTooltipValue: () => s ?? (a && a.headerTooltip),
      shouldDisplayTooltip: i
    };
    a && (l.getColDef = () => a);
    const d = this.createTooltipFeature(l);
    return d && t.createBean(d);
  }
  enableCellTooltipFeature(e, t, s) {
    const { column: i, rowNode: r } = e, o = () => {
      const l = i.getColDef(), d = r.data;
      if (l.tooltipField && A(d))
        return Ji(d, l.tooltipField, i.isTooltipFieldContainsDots());
      const c = l.tooltipValueGetter;
      return c ? c(
        this.gos.addGridCommonParams({
          location: "cell",
          colDef: i.getColDef(),
          column: i,
          rowIndex: e.cellPosition.rowIndex,
          node: r,
          data: r.data,
          value: e.value,
          valueFormatted: e.valueFormatted
        })
      ) : null;
    }, n = rr(this.gos);
    !s && n && !e.isCellRenderer() && (s = Us(() => {
      const { eGui: l } = e;
      return l.children.length === 0 ? l : l.querySelector(".ag-cell-value");
    }));
    const a = {
      getColumn: () => i,
      getColDef: () => i.getColDef(),
      getRowIndex: () => e.cellPosition.rowIndex,
      getRowNode: () => r,
      getGui: () => e.eGui,
      getLocation: () => "cell",
      getTooltipValue: t != null ? () => t : o,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => e.valueFormatted,
      shouldDisplayTooltip: s
    };
    return this.createTooltipFeature(a, this.beans);
  }
  refreshRowTooltip(e, t, s, i) {
    const r = {
      getGui: () => t.getFullWidthElement(),
      getTooltipValue: () => s,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: i
    }, o = this.beans, n = o.context;
    e && t.destroyBean(e, n);
    const a = this.createTooltipFeature(r, o);
    return t.createBean(a, n);
  }
  initCol(e) {
    const { colDef: t } = e;
    e.tooltipEnabled = A(t.tooltipField) || A(t.tooltipValueGetter) || A(t.tooltipComponent);
  }
  createTooltipFeature(e, t) {
    return this.beans.registry.createDynamicBean("tooltipFeature", !1, e, t);
  }
}, ND = {
  moduleName: "Tooltip",
  version: G,
  beans: [VD],
  dynamicBeans: {
    tooltipFeature: Hy
  },
  userComponents: {
    agTooltipComponent: hF
  },
  dependsOn: [ts],
  css: [BD]
}, HD = {
  moduleName: "Locale",
  version: G,
  beans: [iF]
}, zD = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowAutoHeight", this.wasEverActive = !1;
  }
  setRowAutoHeight(e, t, s) {
    e.__autoHeights || (e.__autoHeights = {}), e.__autoHeights[s.getId()] = t, t != null && (e.__checkAutoHeightsDebounced == null && (e.__checkAutoHeightsDebounced = Ce(this, this.doCheckAutoHeights.bind(this, e), 1)), e.__checkAutoHeightsDebounced());
  }
  checkAutoHeights(e) {
    this.wasEverActive && this.doCheckAutoHeights(e);
  }
  doCheckAutoHeights(e) {
    var c;
    const t = e.__autoHeights;
    if (t == null)
      return;
    let s = !1, i = !0, r = 0;
    const { visibleCols: o, colModel: n, colViewport: a, rowModel: l } = this.beans;
    o.autoHeightCols.forEach((h) => {
      let u = t[h.getId()];
      if (u == null)
        if (n.colSpanActive) {
          let p = [];
          switch (h.getPinned()) {
            case "left":
              p = o.getLeftColsForRow(e);
              break;
            case "right":
              p = o.getRightColsForRow(e);
              break;
            case null:
              p = a.getColsWithinViewport(e);
              break;
          }
          if (p.includes(h)) {
            s = !0;
            return;
          }
          u = -1;
        } else {
          s = !0;
          return;
        }
      else
        i = !1;
      u > r && (r = u);
    }), !s && ((i || r < 10) && (r = Ie(this.beans, e).height), r != e.rowHeight && (e.setRowHeight(r), (c = l.onRowHeightChangedDebounced) == null || c.call(l)));
  }
  setupCellAutoHeight(e, t, s) {
    const i = t.parentElement, { rowNode: r, column: o } = e, n = this.beans, a = Ie(n, r).height, l = (h) => {
      if (e.editing || !e.isAlive() || !s.isAlive())
        return;
      const { paddingTop: u, paddingBottom: p, borderBottomWidth: g, borderTopWidth: f } = ii(i), m = u + p + g + f, v = t.offsetHeight + m;
      if (h < 5) {
        const y = Z(n), F = !y || !y.contains(t), D = v == 0;
        if (F || D) {
          window.setTimeout(() => l(h + 1), 0);
          return;
        }
      }
      const b = Math.max(v, a);
      this.setRowAutoHeight(r, b, o);
    }, d = () => l(0);
    d();
    const c = Rt(n, t, d);
    s.addDestroyFunc(() => {
      c(), this.setRowAutoHeight(r, void 0, o);
    });
  }
  setAutoHeightActive(e) {
    this.active = e.list.some((t) => t.isVisible() && t.isAutoHeight()), this.active && (this.wasEverActive = !0);
  }
}, WD = {
  moduleName: "RowAutoHeight",
  version: G,
  beans: [zD]
}, gg = {
  moduleName: "AllCommunity",
  version: G,
  dependsOn: [
    JP,
    cg,
    gT,
    Hp,
    cP,
    hP,
    uP,
    pP,
    gP,
    fP,
    mP,
    dP,
    ER,
    MR,
    AR,
    DR,
    IR,
    LR,
    TT,
    OP,
    KT,
    KS,
    pg,
    tD,
    dD,
    fD,
    Tb,
    bD,
    TP,
    $0,
    FD,
    MD,
    RD,
    GD,
    Y0,
    hg,
    ND,
    HD,
    WD,
    Pb,
    eT
  ]
}, _D = class {
  constructor() {
    this.ieCompatibility = !1;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(e, t) {
    let s = e[0], i = e[1], r = e[2], o = e[3];
    s = this.ff(s, i, r, o, t[0], 7, -680876936), o = this.ff(o, s, i, r, t[1], 12, -389564586), r = this.ff(r, o, s, i, t[2], 17, 606105819), i = this.ff(i, r, o, s, t[3], 22, -1044525330), s = this.ff(s, i, r, o, t[4], 7, -176418897), o = this.ff(o, s, i, r, t[5], 12, 1200080426), r = this.ff(r, o, s, i, t[6], 17, -1473231341), i = this.ff(i, r, o, s, t[7], 22, -45705983), s = this.ff(s, i, r, o, t[8], 7, 1770035416), o = this.ff(o, s, i, r, t[9], 12, -1958414417), r = this.ff(r, o, s, i, t[10], 17, -42063), i = this.ff(i, r, o, s, t[11], 22, -1990404162), s = this.ff(s, i, r, o, t[12], 7, 1804603682), o = this.ff(o, s, i, r, t[13], 12, -40341101), r = this.ff(r, o, s, i, t[14], 17, -1502002290), i = this.ff(i, r, o, s, t[15], 22, 1236535329), s = this.gg(s, i, r, o, t[1], 5, -165796510), o = this.gg(o, s, i, r, t[6], 9, -1069501632), r = this.gg(r, o, s, i, t[11], 14, 643717713), i = this.gg(i, r, o, s, t[0], 20, -373897302), s = this.gg(s, i, r, o, t[5], 5, -701558691), o = this.gg(o, s, i, r, t[10], 9, 38016083), r = this.gg(r, o, s, i, t[15], 14, -660478335), i = this.gg(i, r, o, s, t[4], 20, -405537848), s = this.gg(s, i, r, o, t[9], 5, 568446438), o = this.gg(o, s, i, r, t[14], 9, -1019803690), r = this.gg(r, o, s, i, t[3], 14, -187363961), i = this.gg(i, r, o, s, t[8], 20, 1163531501), s = this.gg(s, i, r, o, t[13], 5, -1444681467), o = this.gg(o, s, i, r, t[2], 9, -51403784), r = this.gg(r, o, s, i, t[7], 14, 1735328473), i = this.gg(i, r, o, s, t[12], 20, -1926607734), s = this.hh(s, i, r, o, t[5], 4, -378558), o = this.hh(o, s, i, r, t[8], 11, -2022574463), r = this.hh(r, o, s, i, t[11], 16, 1839030562), i = this.hh(i, r, o, s, t[14], 23, -35309556), s = this.hh(s, i, r, o, t[1], 4, -1530992060), o = this.hh(o, s, i, r, t[4], 11, 1272893353), r = this.hh(r, o, s, i, t[7], 16, -155497632), i = this.hh(i, r, o, s, t[10], 23, -1094730640), s = this.hh(s, i, r, o, t[13], 4, 681279174), o = this.hh(o, s, i, r, t[0], 11, -358537222), r = this.hh(r, o, s, i, t[3], 16, -722521979), i = this.hh(i, r, o, s, t[6], 23, 76029189), s = this.hh(s, i, r, o, t[9], 4, -640364487), o = this.hh(o, s, i, r, t[12], 11, -421815835), r = this.hh(r, o, s, i, t[15], 16, 530742520), i = this.hh(i, r, o, s, t[2], 23, -995338651), s = this.ii(s, i, r, o, t[0], 6, -198630844), o = this.ii(o, s, i, r, t[7], 10, 1126891415), r = this.ii(r, o, s, i, t[14], 15, -1416354905), i = this.ii(i, r, o, s, t[5], 21, -57434055), s = this.ii(s, i, r, o, t[12], 6, 1700485571), o = this.ii(o, s, i, r, t[3], 10, -1894986606), r = this.ii(r, o, s, i, t[10], 15, -1051523), i = this.ii(i, r, o, s, t[1], 21, -2054922799), s = this.ii(s, i, r, o, t[8], 6, 1873313359), o = this.ii(o, s, i, r, t[15], 10, -30611744), r = this.ii(r, o, s, i, t[6], 15, -1560198380), i = this.ii(i, r, o, s, t[13], 21, 1309151649), s = this.ii(s, i, r, o, t[4], 6, -145523070), o = this.ii(o, s, i, r, t[11], 10, -1120210379), r = this.ii(r, o, s, i, t[2], 15, 718787259), i = this.ii(i, r, o, s, t[9], 21, -343485551), e[0] = this.add32(s, e[0]), e[1] = this.add32(i, e[1]), e[2] = this.add32(r, e[2]), e[3] = this.add32(o, e[3]);
  }
  cmn(e, t, s, i, r, o) {
    return t = this.add32(this.add32(t, e), this.add32(i, o)), this.add32(t << r | t >>> 32 - r, s);
  }
  ff(e, t, s, i, r, o, n) {
    return this.cmn(t & s | ~t & i, e, t, r, o, n);
  }
  gg(e, t, s, i, r, o, n) {
    return this.cmn(t & i | s & ~i, e, t, r, o, n);
  }
  hh(e, t, s, i, r, o, n) {
    return this.cmn(t ^ s ^ i, e, t, r, o, n);
  }
  ii(e, t, s, i, r, o, n) {
    return this.cmn(s ^ (t | ~i), e, t, r, o, n);
  }
  md51(e) {
    const t = e.length, s = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= e.length; i += 64)
      this.md5cycle(s, this.md5blk(e.substring(i - 64, i)));
    e = e.substring(i - 64);
    const r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < e.length; i++)
      r[i >> 2] |= e.charCodeAt(i) << (i % 4 << 3);
    if (r[i >> 2] |= 128 << (i % 4 << 3), i > 55)
      for (this.md5cycle(s, r), i = 0; i < 16; i++)
        r[i] = 0;
    return r[14] = t * 8, this.md5cycle(s, r), s;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(e) {
    const t = [];
    for (let s = 0; s < 64; s += 4)
      t[s >> 2] = e.charCodeAt(s) + (e.charCodeAt(s + 1) << 8) + (e.charCodeAt(s + 2) << 16) + (e.charCodeAt(s + 3) << 24);
    return t;
  }
  rhex(e) {
    const t = "0123456789abcdef".split("");
    let s = "", i = 0;
    for (; i < 4; i++)
      s += t[e >> i * 8 + 4 & 15] + t[e >> i * 8 & 15];
    return s;
  }
  hex(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = this.rhex(e[t]);
    return e.join("");
  }
  md5(e) {
    return this.hex(this.md51(e));
  }
  add32(e, t) {
    return this.ieCompatibility ? this.add32Compat(e, t) : this.add32Std(e, t);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(e, t) {
    return e + t & 4294967295;
  }
  add32Compat(e, t) {
    const s = (e & 65535) + (t & 65535);
    return (e >> 16) + (t >> 16) + (s >> 16) << 16 | s & 65535;
  }
}, Kr = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
}, cc = "https://ag-grid.com/licensing/", fg = class $e {
  constructor(t) {
    this.watermarkMessage = void 0, this.totalMessageLength = 124, this.document = t, this.md5 = new _D(), this.md5.init();
  }
  validateLicense() {
    const t = this.getLicenseDetails($e.licenseKey), s = `AG Grid ${t.currentLicenseType === "BOTH" ? "and AG Charts " : ""}Enterprise`, i = t.suppliedLicenseType === void 0 ? "" : `AG ${t.suppliedLicenseType === "BOTH" ? "Grid and AG Charts" : t.suppliedLicenseType === "GRID" ? "Grid" : "Charts"} Enterprise`;
    if (t.missing)
      (!this.isWebsiteUrl() || this.isForceWatermark()) && this.outputMissingLicenseKey(s);
    else if (t.expired) {
      const r = $e.getGridReleaseDate(), o = $e.formatDate(r);
      this.outputExpiredKey(t.expiry, o, s, i);
    } else t.valid ? t.isTrial && t.trialExpired && this.outputExpiredTrialKey(t.expiry, s, i) : this.outputInvalidLicenseKey(
      !!t.incorrectLicenseType,
      s,
      i
    );
  }
  static extractExpiry(t) {
    const s = t.substring(t.lastIndexOf("_") + 1, t.length);
    return new Date(parseInt($e.decode(s), 10));
  }
  static extractLicenseComponents(t) {
    let s = t.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (s = s.replace(/\r?\n|\r/g, ""), t.length <= 32)
      return { md5: null, license: t, version: null, isTrial: null };
    const i = s.length - 32, r = s.substring(i), o = s.substring(0, i), [n, a, l] = $e.extractBracketedInformation(s);
    return { md5: r, license: o, version: n, isTrial: a, type: l };
  }
  getLicenseDetails(t) {
    const s = $e.chartsLicenseManager ? "BOTH" : "GRID";
    if (!(t != null && t.length))
      return {
        licenseKey: t,
        valid: !1,
        missing: !0,
        currentLicenseType: s
      };
    const i = $e.getGridReleaseDate(), { md5: r, license: o, version: n, isTrial: a, type: l } = $e.extractLicenseComponents(t);
    let d = r === this.md5.md5(o) && t.indexOf("For_Trialing_ag-Grid_Only") === -1, c, h, u = null, p = !1, g;
    function f() {
      c = u < /* @__PURE__ */ new Date(), h = void 0;
    }
    if (d && (u = $e.extractExpiry(o), d = !isNaN(u.getTime()), d))
      switch (h = i > u, n) {
        case "legacy":
        case "2": {
          a && f();
          break;
        }
        case "3":
          l != null && l.length ? (g = l, l !== Kr["01"] && l !== Kr["0102"] || s === "BOTH" && g !== "BOTH" ? (d = !1, p = !0) : a && f()) : d = !1;
      }
    return d ? {
      licenseKey: t,
      valid: d,
      expiry: $e.formatDate(u),
      expired: h,
      version: n,
      isTrial: a,
      trialExpired: c,
      incorrectLicenseType: p,
      currentLicenseType: s,
      suppliedLicenseType: g
    } : {
      licenseKey: t,
      valid: d,
      incorrectLicenseType: p,
      currentLicenseType: s,
      suppliedLicenseType: g
    };
  }
  isDisplayWatermark() {
    var t;
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !!((t = this.watermarkMessage) != null && t.length);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    const s = (this.document.defaultView || window).location, { hostname: i = "" } = s;
    return i;
  }
  isForceWatermark() {
    const s = (this.document.defaultView || window).location, { pathname: i } = s;
    return i ? i.indexOf("forceWatermark") !== -1 : !1;
  }
  isWebsiteUrl() {
    return this.getHostname().match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    return this.getHostname().match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(t) {
    const s = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ], i = t.getDate(), r = t.getMonth(), o = t.getFullYear();
    return i + " " + s[r] + " " + o;
  }
  static getGridReleaseDate() {
    return new Date(parseInt($e.decode($e.RELEASE_INFORMATION), 10));
  }
  static decode(t) {
    const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let i = "", r, o, n, a, l, d, c, h = 0;
    const u = t.replace(/[^A-Za-z0-9+/=]/g, "");
    for (; h < u.length; )
      a = s.indexOf(u.charAt(h++)), l = s.indexOf(u.charAt(h++)), d = s.indexOf(u.charAt(h++)), c = s.indexOf(u.charAt(h++)), r = a << 2 | l >> 4, o = (l & 15) << 4 | d >> 2, n = (d & 3) << 6 | c, i = i + String.fromCharCode(r), d != 64 && (i = i + String.fromCharCode(o)), c != 64 && (i = i + String.fromCharCode(n));
    return i = $e.utf8_decode(i), i;
  }
  static utf8_decode(t) {
    t = t.replace(/rn/g, "n");
    let s = "";
    for (let i = 0; i < t.length; i++) {
      const r = t.charCodeAt(i);
      r < 128 ? s += String.fromCharCode(r) : r > 127 && r < 2048 ? (s += String.fromCharCode(r >> 6 | 192), s += String.fromCharCode(r & 63 | 128)) : (s += String.fromCharCode(r >> 12 | 224), s += String.fromCharCode(r >> 6 & 63 | 128), s += String.fromCharCode(r & 63 | 128));
    }
    return s;
  }
  static setChartsLicenseManager(t) {
    this.chartsLicenseManager = t;
  }
  static setLicenseKey(t) {
    var s;
    this.licenseKey = t, (s = this.chartsLicenseManager) == null || s.setLicenseKey(t, !0);
  }
  static extractBracketedInformation(t) {
    if (!t.includes("["))
      return ["legacy", !1, void 0];
    const s = t.match(/\[(.*?)\]/g).map((a) => a.replace("[", "").replace("]", ""));
    if (!s || s.length === 0)
      return ["legacy", !1, void 0];
    const i = s.filter((a) => a === "TRIAL").length === 1, r = s.filter((a) => a.indexOf("v") === 0)[0], o = r ? r.replace("v", "") : "legacy", n = Kr[s.filter((a) => Kr[a])[0]];
    return [o, i, n];
  }
  centerPadAndOutput(t) {
    const s = this.totalMessageLength - t.length;
    console.error(t.padStart(s / 2 + t.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(t, s = "*", i = "") {
    console.error(
      t.padEnd(this.totalMessageLength - i.length, s) + i
    );
  }
  outputInvalidLicenseKey(t, s, i) {
    t ? (this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Incompatible License Key "), this.padAndOutput(
      `* Your license key is for ${i} only and does not cover you for ${s}.`,
      " ",
      "*"
    ), this.padAndOutput(`* To troubleshoot your license key visit ${cc}.`, " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput("")) : (this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Invalid License Key "), this.padAndOutput("* Your license key is not valid.", " ", "*"), this.padAndOutput(`* To troubleshoot your license key visit ${cc}.`, " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput("")), this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(t, s, i) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Trial Period Expired. "), this.padAndOutput(
      `* Your trial only license for ${i} expired on ${t}.`,
      " ",
      "*"
    ), this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(t) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${t} License `), this.centerPadAndOutput(" License Key Not Found "), this.padAndOutput(`* All ${t} features are unlocked for trial.`, " ", "*"), this.padAndOutput(
      "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
      " ",
      "*"
    ), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(t, s, i, r) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${i} License `), this.centerPadAndOutput(" Incompatible Software Version "), this.padAndOutput(
      `* Your license key works with versions of ${r} released before ${t}.`,
      " ",
      "*"
    ), this.padAndOutput(`* The version you are trying to use was released on ${s}.`, " ", "*"), this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "License Expired";
  }
};
fg.RELEASE_INFORMATION = "MTczMzc1NjY3OTc2Mw==";
var Xi = fg, UD = (
  /*css*/
  '.ag-watermark{bottom:20px;color:#9b9b9b;opacity:.7;position:absolute;transition:opacity 1s ease-out 3s;&:before{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDkiIGhlaWdodD0iMzYiIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyMDkgMzYiPjxwYXRoIGZpbGw9IiM5QjlCOUIiIGQ9Ik0xOTIuOTkzIDIzLjY1OHYtNy45NDZoLTEzLjU0MWwtNy45NDcgNy45NDZ6TTIwOC4yNSAzLjk1aC0xNi45NzRsLTguMDEgNy45NDdoMjQuOTg0ek0xNjMuNjIyIDMxLjYwNWw0LjA2OS00LjA2OWgxMy43MzJ2Ny45NDdoLTE3LjgwMXoiLz48cGF0aCBmaWxsPSIjOUI5QjlCIiBkPSJNMTY2LjYxIDE5Ljc4aDguNzczbDguMDEtNy45NDZIMTY2LjYxek0xNTcuMDExIDMxLjYwNWg2LjYxMWw3Ljg4My03Ljk0N2gtMTQuNDk0ek0xOTEuMjc2IDMuOTVsLTQuMDY4IDQuMDdIMTYxLjI3Vi4wNzJoMzAuMDA2ek0yMC44NCAzMC4yMDZIOC4zNzhsLTIuMTYyIDUuMzRILjc1TDEyLjI1NyA4LjU5Mmg0Ljc2OEwyOC41MyAzNS41NDZoLTUuNTN6bS0xLjcxNy00LjI2TDE0LjYwOSAxNC45NWwtNC41MTQgMTAuOTk4ek0xMDQuNDM3IDE4LjUwOWMxLjU4OS0yLjM1MiA1LjU5NC0yLjYwNyA3LjI0Ny0yLjYwN3Y0LjU3OGMtMi4wMzQgMC00LjA2OS4wNjMtNS4yNzcuOTUzLTEuMjA3Ljg5LTEuODQzIDIuMDk4LTEuODQzIDMuNTZ2MTAuNTUzaC00Ljk1OVYxNS45MDJoNC43Njh6TTExOS4zNzYgMTUuOTAyaC00Ljk1OHYxOS42NDRoNC45NTh6TTExOS4zNzYgNy4xM2gtNC45NTh2NS44NDhoNC45NTh6TTE0My45NzkgNy4xM3YyOC40MTZoLTQuNzY4bC0uMTI3LTIuOTg4YTguMyA4LjMgMCAwIDEtMi42NyAyLjQ4Yy0xLjA4MS41NzItMi40MTYuODktMy45NDIuODktMS4zMzUgMC0yLjYwNi0uMjU1LTMuNjg3LS43LTEuMTQ0LS41MDgtMi4xNjItMS4xNDQtMi45ODgtMi4wMzRhOS42IDkuNiAwIDAgMS0xLjk3MS0zLjE3OWMtLjUwOC0xLjIwNy0uNjk5LTIuNjA2LS42OTktNC4xMzJzLjI1NC0yLjkyNC42OTktNC4xOTZjLjUwOS0xLjI3MSAxLjE0NS0yLjM1MiAxLjk3MS0zLjI0MnMxLjg0NC0xLjU4OSAyLjk4OC0yLjA5OCAyLjM1Mi0uNzYzIDMuNjg3LS43NjNjMS41MjYgMCAyLjc5Ny4yNTUgMy44NzguODI3czEuOTcxIDEuMzM1IDIuNjcgMi40MTZWNy4xOTNoNC45NTl6bS0xMC40MjYgMjQuNTM4YzEuNjUzIDAgMi45MjQtLjU3MiAzLjk0MS0xLjY1M3MxLjUyNi0yLjU0MyAxLjUyNi00LjMyMy0uNTA5LTMuMTc4LTEuNTI2LTQuMzIyYy0xLjAxNy0xLjA4MS0yLjI4OC0xLjY1My0zLjk0MS0xLjY1My0xLjU5IDAtMi45MjUuNTcyLTMuODc4IDEuNjUzLTEuMDE3IDEuMDgtMS41MjYgMi41NDMtMS41MjYgNC4zMjIgMCAxLjc4LjUwOSAzLjE4IDEuNTI2IDQuMjYgMS4wMTcgMS4xNDQgMi4yODggMS43MTYgMy44NzggMS43MTZNNTcuMjAyIDIwLjM1M0g0NC45MzN2NC4yNTloNi45OTNjLS4xOSAyLjE2MS0xLjAxNyAzLjgxNC0yLjQxNiA1LjE1LTEuMzk4IDEuMjctMy4xNzggMS45MDYtNS40NjcgMS45MDYtMS4yNzEgMC0yLjQ4LS4yNTQtMy40OTYtLjY5OWE3IDcgMCAwIDEtMi43MzQtMS45N2MtLjc2My0uODI3LTEuMzM1LTEuODQ0LTEuNzgtMy4wNTJzLS42MzYtMi40OC0uNjM2LTMuOTQyLjE5LTIuNzMzLjYzNi0zLjk0MWMuMzgxLTEuMjA4IDEuMDE3LTIuMTYyIDEuNzgtMy4wNTIuNzYzLS44MjYgMS42NTMtMS40NjIgMi43MzMtMS45N2E5LjEgOS4xIDAgMCAxIDMuNTYtLjdxNC4wMDUgMCA2LjEwMyAxLjkwN2wzLjMwNi0zLjMwNWMtMi40OC0xLjkwNy01LjY1OC0yLjkyNS05LjQwOS0yLjkyNS0yLjA5NyAwLTQuMDA0LjMxOC01LjcyMSAxLjAxOC0xLjcxNi42OTktMy4xNzkgMS41ODktNC4zODYgMi43OTdBMTIuMSAxMi4xIDAgMCAwIDMxLjIgMTYuMjJjLS42MzUgMS43MTctLjk1MyAzLjYyNC0uOTUzIDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1NyAxLjAxNyAyLjAzNSAwIDMuODc4LS4zMTggNS41MzEtMS4wMTcgMS42NTMtLjcgMy4wNTItMS41OSA0LjE5Ni0yLjc5N3ExLjcxNi0xLjgxMiAyLjY3LTQuMzg3Yy42MzYtMS43MTYuOTU0LTMuNjIzLjk1NC01LjY1OHYtLjgyNmMtLjE5MS0uMTI3LS4yNTUtLjQ0NS0uMjU1LS43TTk1Ljk4MiAyMC4zNTNoLTEyLjI3djQuMjU5aDYuOTkzYy0uMTkgMi4xNjEtMS4wMTcgMy44MTQtMi40MTYgNS4xNS0xLjM5OCAxLjI3LTMuMTc4IDEuOTA2LTUuNDY3IDEuOTA2LTEuMjcxIDAtMi40OC0uMjU0LTMuNDk2LS42OTlhNyA3IDAgMCAxLTIuNzM0LTEuOTdjLS43NjMtLjgyNy0xLjMzNS0xLjg0NC0xLjc4LTMuMDUycy0uNjM2LTIuNDgtLjYzNi0zLjk0Mi4xOS0yLjczMy42MzYtMy45NDFjLjM4MS0xLjIwOCAxLjAxNy0yLjE2MiAxLjc4LTMuMDUyLjc2My0uODI2IDEuNjUzLTEuNDYyIDIuNzM0LTEuOTdhOS4xIDkuMSAwIDAgMSAzLjU2LS43cTQuMDA1IDAgNi4xMDMgMS45MDdsMy4zMDUtMy4zMDVjLTIuNDc5LTEuOTA3LTUuNjU4LTIuOTI1LTkuNDA4LTIuOTI1LTIuMDk4IDAtNC4wMDUuMzE4LTUuNzIyIDEuMDE4LTEuNzE2LjY5OS0zLjE3OCAxLjU4OS00LjM4NiAyLjc5N2ExMi4xIDEyLjEgMCAwIDAtMi43OTcgNC4zODZjLS42MzYgMS43MTctLjk1NCAzLjYyNC0uOTU0IDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1OCAxLjAxNyAyLjAzNCAwIDMuODc4LS4zMTggNS41My0xLjAxNyAxLjY1My0uNyAzLjA1Mi0xLjU5IDQuMTk2LTIuNzk3cTEuNzE4LTEuODEyIDIuNjctNC4zODdjLjYzNi0xLjcxNi45NTQtMy42MjMuOTU0LTUuNjU4di0uODI2Yy0uMTktLjEyNy0uMjU1LS40NDUtLjI1NS0uNyIvPjwvc3ZnPg==");background-repeat:no-repeat;background-size:170px 40px;content:"";display:block;height:40px;width:170px}}:where(.ag-ltr) .ag-watermark{right:25px}:where(.ag-rtl) .ag-watermark{left:25px}.ag-watermark-text{font-family:Impact,sans-serif;font-size:19px;font-weight:700;opacity:.5}:where(.ag-ltr) .ag-watermark-text{padding-left:.7rem}:where(.ag-rtl) .ag-watermark-text{padding-right:.7rem}'
), KD = class extends L {
  constructor() {
    super(
      /* html*/
      `<div class="ag-watermark">
                <div data-ref="eLicenseTextRef" class="ag-watermark-text"></div>
            </div>`
    ), this.eLicenseTextRef = S, this.registerCSS(UD);
  }
  wireBeans(e) {
    this.licenseManager = e.licenseManager;
  }
  postConstruct() {
    const e = this.shouldDisplayWatermark();
    this.setDisplayed(e), e && (this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage(), window.setTimeout(() => this.addCssClass("ag-opacity-zero"), 0), window.setTimeout(() => this.setDisplayed(!1), 5e3));
  }
  shouldDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
}, $D = {
  selector: "AG-WATERMARK",
  component: KD
}, mg = class extends P {
  constructor() {
    super(...arguments), this.beanName = "licenseManager";
  }
  postConstruct() {
    this.validateLicense();
  }
  validateLicense() {
    this.licenseManager = new Xi(Z(this.beans)), this.licenseManager.validateLicense();
  }
  static getLicenseDetails(e) {
    return new Xi(null).getLicenseDetails(e);
  }
  getWatermarkSelector() {
    return $D;
  }
  isDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
  getWatermarkMessage() {
    return this.licenseManager.getWatermarkMessage();
  }
  static setLicenseKey(e) {
    Xi.setLicenseKey(e);
  }
  static setChartsLicenseManager(e) {
    Xi.setChartsLicenseManager(e);
  }
}, jD = 9525, hc = {
  0: 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49
}, $r = `\r
`;
function uc(e, t, s) {
  return !t && t !== "" && t !== 0 ? "" : ` ${e}="${t}"`;
}
function qD(e = {}) {
  const t = "<?", s = "?>", i = ["version"];
  e.version || (e.version = "1.0"), e.encoding && i.push("encoding"), e.standalone && i.push("standalone");
  const r = i.map((o) => `${o}="${e[o]}"`).join(" ");
  return `${t}xml ${r} ${s}`;
}
function Cg(e, t) {
  let s = "";
  e.properties && (e.properties.prefixedAttributes && e.properties.prefixedAttributes.forEach((r) => {
    Object.keys(r.map).forEach((o) => {
      s += uc(
        r.prefix + o,
        r.map[o]
      );
    });
  }), e.properties.rawMap && Object.keys(e.properties.rawMap).forEach((r) => {
    s += uc(r, e.properties.rawMap[r]);
  }));
  let i = "<" + e.name + s;
  return !e.children && e.textNode == null ? i + "/>" + $r : e.textNode != null ? i + ">" + e.textNode + "</" + e.name + ">" + $r : (i += ">" + $r, e.children && e.children.forEach((r) => {
    i += Cg(r);
  }), i + "</" + e.name + ">" + $r);
}
var YD = (e) => Math.round(e * 96 / 72), ai = (e) => Math.ceil(e * jD), XD = (e) => {
  if (e === void 0)
    return;
  const s = ["Automatic", "Roman", "Swiss", "Modern", "Script", "Decorative"].indexOf(e || "Automatic");
  return Math.max(s, 0);
}, ro = (e, t) => {
  if (!t)
    return;
  let s;
  return typeof t == "number" ? s = t : s = t({ rowIndex: e }), s;
}, ZD = (e, t) => {
  const { colSpan: s, column: i } = e.position;
  if (e.width)
    if (s) {
      const r = t.slice(i - 1, i + s - 1);
      let o = 0;
      for (let n = 0; n < r.length; n++) {
        const a = r[n].getActualWidth();
        if (e.width < o + a) {
          e.position.colSpan = n + 1, e.totalWidth = e.width, e.width = e.totalWidth - o;
          break;
        }
        o += a;
      }
    } else
      e.totalWidth = e.width;
}, QD = (e, t) => {
  const { rowSpan: s, row: i } = e.position;
  if (e.height)
    if (s) {
      let r = 0, o = 0;
      for (let n = i; n < i + s; n++) {
        const a = YD(ro(n, t) || 20);
        if (e.height < r + a) {
          e.position.rowSpan = o + 1, e.totalHeight = e.height, e.height = e.totalHeight - r;
          break;
        }
        r += a, o++;
      }
    } else
      e.totalHeight = e.height;
}, ze = (e, t) => {
  const s = qD({
    encoding: "UTF-8",
    standalone: "yes"
  }), i = Cg(e);
  return t ? i : `${s}${i}`;
}, Zs = (e) => {
  const i = String.fromCharCode, r = Math.floor(e / 26), o = e % 26;
  return !r || e === 26 ? i(65 + e - 1) : o ? r < 26 ? i(65 + r - 1) + i(65 + o - 1) : Zs(r) + i(65 + o - 1) : Zs(r - 1) + "Z";
}, Oa = (e) => {
  if (e == null)
    return null;
  let t = "";
  for (let s = 0; s < e.length; s++) {
    const i = e.charCodeAt(s);
    if (i >= 0 && i <= 31 && i !== 10) {
      const n = `_x${i.toString(16).toUpperCase().padStart(4, "0")}_`;
      t += n;
    } else
      t += e[s];
  }
  return t;
}, JD = (e) => {
  const t = [];
  for (const s of e.keys()) {
    const i = s.toString(), r = {
      name: "t",
      textNode: Q(Oa(i), !1)
    };
    i.trim().length !== i.length && (r.properties = {
      rawMap: {
        "xml:space": "preserve"
      }
    }), t.push({
      name: "si",
      children: [r]
    });
  }
  return t;
}, eE = {
  getTemplate(e) {
    const { name: t, ContentType: s, Extension: i, PartName: r } = e;
    return {
      name: t,
      properties: {
        rawMap: {
          Extension: i,
          PartName: r,
          ContentType: s
        }
      }
    };
  }
}, tE = eE, fn = (e) => e === "jpg" ? "jpeg" : e, sE = {
  getTemplate(e) {
    const t = new Array(e).fill(void 0).map((d, c) => ({
      name: "Override",
      ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
      PartName: `/xl/worksheets/sheet${c + 1}.xml`
    })), s = Js.size, i = Fs.size, r = {};
    Ai.forEach((d) => {
      r[fn(d.type)] = !0;
    });
    const o = new Array(s).fill(void 0).map((d, c) => ({
      name: "Override",
      ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml",
      PartName: `/xl/drawings/drawing${c + 1}.xml`
    })), n = [];
    Jt.forEach(({ name: d }) => {
      n.push({
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml",
        PartName: `/xl/tables/${d}.xml`
      });
    });
    const a = Object.keys(r).map((d) => ({
      name: "Default",
      ContentType: `image/${d}`,
      Extension: d
    }));
    i && a.push({
      name: "Default",
      Extension: "vml",
      ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing"
    });
    const l = [
      ...a,
      {
        name: "Default",
        Extension: "rels",
        ContentType: "application/vnd.openxmlformats-package.relationships+xml"
      },
      {
        name: "Default",
        ContentType: "application/xml",
        Extension: "xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
        PartName: "/xl/workbook.xml"
      },
      ...t,
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.theme+xml",
        PartName: "/xl/theme/theme1.xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
        PartName: "/xl/styles.xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
        PartName: "/xl/sharedStrings.xml"
      },
      ...o,
      ...n,
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-package.core-properties+xml",
        PartName: "/docProps/core.xml"
      }
    ].map((d) => tE.getTemplate(d));
    return {
      name: "Types",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
        }
      },
      children: l
    };
  }
}, iE = sE, rE = {
  getTemplate(e) {
    const s = (/* @__PURE__ */ new Date()).toJSON();
    return {
      name: "cp:coreProperties",
      properties: {
        prefixedAttributes: [
          {
            prefix: "xmlns:",
            map: {
              cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
              dc: "http://purl.org/dc/elements/1.1/",
              dcterms: "http://purl.org/dc/terms/",
              dcmitype: "http://purl.org/dc/dcmitype/",
              xsi: "http://www.w3.org/2001/XMLSchema-instance"
            }
          }
        ]
      },
      children: [
        {
          name: "dc:creator",
          textNode: e
        },
        {
          name: "dc:title",
          textNode: "Workbook"
        },
        {
          name: "dcterms:created",
          properties: {
            rawMap: {
              "xsi:type": "dcterms:W3CDTF"
            }
          },
          textNode: s
        },
        {
          name: "dcterms:modified",
          properties: {
            rawMap: {
              "xsi:type": "dcterms:W3CDTF"
            }
          },
          textNode: s
        }
      ]
    };
  }
}, oE = rE, pc = (e, t) => ({
  name: `xdr:${e}`,
  children: [
    {
      name: "xdr:col",
      textNode: t.col.toString()
    },
    {
      name: "xdr:colOff",
      textNode: t.offsetX.toString()
    },
    {
      name: "xdr:row",
      textNode: t.row.toString()
    },
    {
      name: "xdr:rowOff",
      textNode: t.offsetY.toString()
    }
  ]
}), nE = (e) => {
  const t = [
    {
      name: "a:ext",
      properties: {
        rawMap: {
          uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
        }
      },
      children: [
        {
          name: "a16:creationId",
          properties: {
            rawMap: {
              id: "{822E6D20-D7BC-2841-A643-D49A6EF008A2}",
              "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main"
            }
          }
        }
      ]
    }
  ];
  switch (e.recolor && e.recolor.toLowerCase()) {
    case "grayscale":
    case "sepia":
    case "washout":
      t.push({
        name: "a:ext",
        properties: {
          rawMap: {
            uri: "{C183D7F6-B498-43B3-948B-1728B52AA6E4}"
          }
        },
        children: [
          {
            name: "adec:decorative",
            properties: {
              rawMap: {
                val: "0",
                "xmlns:adec": "http://schemas.microsoft.com/office/drawing/2017/decorative"
              }
            }
          }
        ]
      });
  }
  return {
    name: "a:extLst",
    children: t
  };
}, aE = (e, t) => ({
  name: "xdr:nvPicPr",
  children: [
    {
      name: "xdr:cNvPr",
      properties: {
        rawMap: {
          id: t,
          name: e.id,
          descr: e.altText != null ? e.altText : void 0
        }
      },
      children: [nE(e)]
    },
    {
      name: "xdr:cNvPicPr",
      properties: {
        rawMap: {
          preferRelativeResize: "0"
        }
      },
      children: [
        {
          name: "a:picLocks"
        }
      ]
    }
  ]
}), gc = (e) => {
  if (!e.saturation && !e.tint)
    return;
  const t = [];
  return e.saturation && t.push({
    name: "a:satMod",
    properties: {
      rawMap: {
        val: e.saturation * 1e3
      }
    }
  }), e.tint && t.push({
    name: "a:tint",
    properties: {
      rawMap: {
        val: e.tint * 1e3
      }
    }
  }), t;
}, lE = (e, t) => ({
  name: "a:duotone",
  children: [
    {
      name: "a:prstClr",
      properties: {
        rawMap: {
          val: e.color
        }
      },
      children: gc(e)
    },
    {
      name: "a:srgbClr",
      properties: {
        rawMap: {
          val: t.color
        }
      },
      children: gc(t)
    }
  ]
}), dE = (e, t) => {
  let s;
  if (e.transparency) {
    const i = Math.min(Math.max(e.transparency, 0), 100);
    s = [
      {
        name: "a:alphaModFix",
        properties: {
          rawMap: {
            amt: 1e5 - Math.round(i * 1e3)
          }
        }
      }
    ];
  }
  if (e.recolor)
    switch (s || (s = []), e.recolor.toLocaleLowerCase()) {
      case "grayscale":
        s.push({ name: "a:grayscl" });
        break;
      case "sepia":
        s.push(lE({ color: "black" }, { color: "D9C3A5", tint: 50, saturation: 180 }));
        break;
      case "washout":
        s.push({
          name: "a:lum",
          properties: {
            rawMap: {
              bright: "70000",
              contrast: "-70000"
            }
          }
        });
        break;
    }
  return {
    name: "xdr:blipFill",
    children: [
      {
        name: "a:blip",
        properties: {
          rawMap: {
            cstate: "print",
            "r:embed": `rId${t}`,
            "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
          }
        },
        children: s
      },
      {
        name: "a:stretch",
        children: [
          {
            name: "a:fillRect"
          }
        ]
      }
    ]
  };
}, cE = (e, t) => {
  const s = {
    name: "a:xfrm",
    children: [
      {
        name: "a:off",
        properties: {
          rawMap: {
            x: 0,
            y: 0
          }
        }
      },
      {
        name: "a:ext",
        properties: {
          rawMap: {
            cx: t.width,
            cy: t.height
          }
        }
      }
    ]
  };
  if (e.rotation) {
    const o = e.rotation;
    s.properties = {
      rawMap: {
        rot: Math.min(Math.max(o, 0), 360) * 6e4
      }
    };
  }
  return {
    name: "xdr:spPr",
    children: [s, {
      name: "a:prstGeom",
      properties: {
        rawMap: {
          prst: "rect"
        }
      },
      children: [{ name: "a:avLst" }]
    }]
  };
}, hE = (e) => {
  e.fitCell = !!e.fitCell || !e.width || !e.height;
  const { position: t = {}, fitCell: s, width: i = 0, height: r = 0, totalHeight: o, totalWidth: n } = e, { offsetX: a = 0, offsetY: l = 0, row: d = 1, rowSpan: c = 1, column: h = 1, colSpan: u = 1 } = t;
  return {
    from: {
      row: d - 1,
      col: h - 1,
      offsetX: ai(a),
      offsetY: ai(l)
    },
    to: {
      row: d - 1 + (s ? 1 : c - 1),
      col: h - 1 + (s ? 1 : u - 1),
      offsetX: ai(i + a),
      offsetY: ai(r + l)
    },
    height: ai(o || r),
    width: ai(n || i)
  };
}, uE = (e, t, s, i) => ({
  name: "xdr:pic",
  children: [
    aE(e, t + 1),
    dE(e, s + 1),
    cE(e, i)
  ]
}), pE = {
  getTemplate(e) {
    const { sheetIndex: t } = e, s = Js.get(t), i = vr.get(t), r = s.map((o, n) => {
      const a = hE(o);
      return {
        name: "xdr:twoCellAnchor",
        properties: {
          rawMap: {
            editAs: "absolute"
          }
        },
        children: [
          pc("from", a.from),
          pc("to", a.to),
          uE(o, n, i.get(o.id).index, a),
          { name: "xdr:clientData" }
        ]
      };
    });
    return {
      name: "xdr:wsDr",
      properties: {
        rawMap: {
          "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
          "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
        }
      },
      children: r
    };
  }
}, gE = pE, fE = {
  getTemplate(e) {
    const { Id: t, Type: s, Target: i } = e;
    return {
      name: "Relationship",
      properties: {
        rawMap: {
          Id: t,
          Type: s,
          Target: i
        }
      }
    };
  }
}, mE = fE, CE = {
  getTemplate(e) {
    const t = e.map((s) => mE.getTemplate(s));
    return {
      name: "Relationships",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
        }
      },
      children: t
    };
  }
}, Dr = CE, vE = {
  getTemplate(e) {
    return {
      name: "sst",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          count: e.size,
          uniqueCount: e.size
        }
      },
      children: JD(e)
    };
  }
}, wE = vE, yE = (e) => {
  switch (e) {
    case 1:
      return "thin";
    case 2:
      return "medium";
    case 3:
      return "thick";
    default:
      return "hair";
  }
}, bE = {
  None: "None",
  Dot: "Dotted",
  Dash: "Dashed",
  Double: "Double",
  DashDot: "DashDot",
  DashDotDot: "DashDotDot",
  SlantDashDot: "SlantDashDot",
  Continuous: "Continuous"
}, SE = ["Dashed", "DashDot", "DashDotDot"], xE = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinDiagStripe: "lightUp",
  ThinHorzCross: "lightGrid",
  ThinDiagCross: "lightTrellis",
  Gray125: "gray125",
  Gray0625: "gray0625"
}, FE = {
  Automatic: "general",
  Left: "left",
  Center: "center",
  Right: "right",
  Fill: "fill",
  Justify: "justify",
  CenterAcrossSelection: "centerContinuous",
  Distributed: "distributed",
  JustifyDistributed: "justify"
}, RE = {
  Automatic: void 0,
  Top: "top",
  Bottom: "bottom",
  Center: "center",
  Justify: "justify",
  Distributed: "distributed",
  JustifyDistributed: "justify"
}, PE = (e) => e ? xE[e] || e : "none", ps = (e) => e == null ? e : (e.charAt(0) === "#" && (e = e.substring(1)), e.length === 6 ? "FF" + e : e), jr = (e, t) => {
  if (!e)
    return "thin";
  const s = yE(t);
  if (e === "Continuous")
    return s;
  const i = bE[e];
  return s === "medium" && SE.some((r) => r === i) ? `medium${i}` : `${i.charAt(0).toLowerCase()}${i.substring(1)}`;
}, TE = (e) => FE[e] || "general", DE = (e) => RE[e] || void 0, Ui = (e) => ({
  name: "color",
  properties: {
    rawMap: {
      rgb: ps(e || "#000000")
    }
  }
}), EE = {
  getTemplate(e) {
    const { left: t, right: s, top: i, bottom: r, diagonal: o } = e, n = t ? [Ui(t.color)] : void 0, a = s ? [Ui(s.color)] : void 0, l = i ? [Ui(i.color)] : void 0, d = r ? [Ui(r.color)] : void 0, c = o ? [Ui(o.color)] : void 0;
    return {
      name: "border",
      children: [
        {
          name: "left",
          properties: { rawMap: { style: t && t.style } },
          children: n
        },
        {
          name: "right",
          properties: { rawMap: { style: s && s.style } },
          children: a
        },
        {
          name: "top",
          properties: { rawMap: { style: i && i.style } },
          children: l
        },
        {
          name: "bottom",
          properties: { rawMap: { style: r && r.style } },
          children: d
        },
        {
          name: "diagonal",
          properties: { rawMap: { style: o && o.style } },
          children: c
        }
      ]
    };
  }
}, ME = EE, AE = {
  getTemplate(e) {
    return {
      name: "borders",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => ME.getTemplate(t))
    };
  }
}, IE = AE, LE = (e) => {
  const s = ["Context", "LeftToRight", "RightToLeft"].indexOf(e);
  return Math.max(s, 0);
}, kE = {
  getTemplate(e) {
    const { horizontal: t, indent: s, readingOrder: i, rotate: r, shrinkToFit: o, vertical: n, wrapText: a } = e;
    return {
      name: "alignment",
      properties: {
        rawMap: {
          horizontal: t && TE(t),
          indent: s,
          readingOrder: i && LE(i),
          textRotation: r,
          shrinkToFit: o,
          vertical: n && DE(n),
          wrapText: a
        }
      }
    };
  }
}, OE = kE, GE = {
  getTemplate(e) {
    const t = e.protected === !1 ? 0 : 1;
    return {
      name: "protection",
      properties: {
        rawMap: {
          hidden: e.hideFormula === !0 ? 1 : 0,
          locked: t
        }
      }
    };
  }
}, BE = GE, VE = {
  getTemplate(e) {
    const { alignment: t, borderId: s, fillId: i, fontId: r, numFmtId: o, protection: n, quotePrefix: a, xfId: l } = e, d = [];
    return t && d.push(OE.getTemplate(t)), n && d.push(BE.getTemplate(n)), {
      name: "xf",
      properties: {
        rawMap: {
          applyAlignment: t ? 1 : void 0,
          applyProtection: n ? 1 : void 0,
          applyBorder: s ? 1 : void 0,
          applyFill: i ? 1 : void 0,
          borderId: s,
          fillId: i,
          applyFont: r ? 1 : void 0,
          fontId: r,
          applyNumberFormat: o ? 1 : void 0,
          numFmtId: o,
          quotePrefix: a ? 1 : void 0,
          xfId: l
        }
      },
      children: d.length ? d : void 0
    };
  }
}, vg = VE, NE = {
  getTemplate(e) {
    return {
      name: "cellStyleXfs",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => vg.getTemplate(t))
    };
  }
}, HE = NE, zE = {
  getTemplate(e) {
    const { builtinId: t, name: s, xfId: i } = e;
    return {
      name: "cellStyle",
      properties: {
        rawMap: {
          builtinId: t,
          name: s,
          xfId: i
        }
      }
    };
  }
}, WE = zE, _E = {
  getTemplate(e) {
    return {
      name: "cellStyles",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => WE.getTemplate(t))
    };
  }
}, UE = _E, KE = {
  getTemplate(e) {
    return {
      name: "cellXfs",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => vg.getTemplate(t))
    };
  }
}, $E = KE, jE = {
  getTemplate(e) {
    const { patternType: t, fgTheme: s, fgTint: i, fgRgb: r, bgRgb: o, bgIndexed: n } = e, a = {
      name: "patternFill",
      properties: {
        rawMap: {
          patternType: t
        }
      }
    };
    return (s || i || r) && (a.children = [
      {
        name: "fgColor",
        properties: {
          rawMap: {
            theme: s,
            tint: i,
            rgb: r
          }
        }
      }
    ]), (n || o) && (a.children || (a.children = []), a.children.push({
      name: "bgColor",
      properties: {
        rawMap: {
          indexed: n,
          rgb: o
        }
      }
    })), {
      name: "fill",
      children: [a]
    };
  }
}, qE = jE, YE = {
  getTemplate(e) {
    return {
      name: "fills",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => qE.getTemplate(t))
    };
  }
}, XE = YE, ZE = {
  getTemplate(e) {
    const {
      size: t,
      colorTheme: s,
      color: i = "FF000000",
      fontName: r = "Calibri",
      family: o,
      scheme: n,
      italic: a,
      bold: l,
      strikeThrough: d,
      outline: c,
      shadow: h,
      underline: u,
      verticalAlign: p
    } = e, g = [
      { name: "sz", properties: { rawMap: { val: t } } },
      { name: "color", properties: { rawMap: { theme: s, rgb: i } } },
      { name: "name", properties: { rawMap: { val: r } } }
    ];
    return o && g.push({ name: "family", properties: { rawMap: { val: o } } }), n && g.push({ name: "scheme", properties: { rawMap: { val: n } } }), a && g.push({ name: "i" }), l && g.push({ name: "b" }), d && g.push({ name: "strike" }), c && g.push({ name: "outline" }), h && g.push({ name: "shadow" }), u && g.push({ name: "u", properties: { rawMap: { val: u } } }), p && g.push({ name: "vertAlign", properties: { rawMap: { val: p } } }), { name: "font", children: g };
  }
}, QE = ZE, JE = {
  getTemplate(e) {
    return {
      name: "fonts",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => QE.getTemplate(t))
    };
  }
}, eM = JE;
function tM(e) {
  const t = e.split(/(\[[^\]]*\])/);
  for (let s = 0; s < t.length; s++) {
    let i = t[s];
    i.length && (i.startsWith("[") || (i = i.replace(/\$/g, '"$"')), t[s] = Q(i));
  }
  return t.join("");
}
var sM = {
  getTemplate(e) {
    let { formatCode: t, numFmtId: s } = e;
    return t.length && (t = tM(t)), {
      name: "numFmt",
      properties: {
        rawMap: {
          formatCode: t,
          numFmtId: s
        }
      }
    };
  }
}, iM = sM, rM = {
  getTemplate(e) {
    return {
      name: "numFmts",
      properties: {
        rawMap: {
          count: e.length
        }
      },
      children: e.map((t) => iM.getTemplate(t))
    };
  }
}, oM = rM, Io, hi, lr, dr, cr, wg, Lo, yg, Ga, bg = (e, t) => (e.indexOf("mixedStyle") !== -1 && t > 1 && (e += `_${t}`), e), Sg = () => {
  Io = { base: 0 }, hi = [], lr = [{ fontName: "Calibri", colorTheme: "1", family: "2", scheme: "minor" }], dr = [{ patternType: "none" }, { patternType: "gray125" }], cr = [{ left: void 0, right: void 0, top: void 0, bottom: void 0, diagonal: void 0 }], wg = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0 }], Lo = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0, xfId: 0 }], yg = [{ builtinId: 0, name: "Normal", xfId: 0 }];
}, nM = (e) => {
  const t = PE(e.pattern), s = ps(e.color), i = ps(e.patternColor);
  let r = dr.findIndex((o) => {
    const { patternType: n, fgRgb: a, bgRgb: l } = o;
    return !(n != t || a != s || l != i);
  });
  return r === -1 && (r = dr.length, dr.push({
    patternType: t,
    fgRgb: s,
    bgRgb: i
  })), r;
}, aM = (e) => {
  if (hc[e])
    return hc[e];
  let t = hi.findIndex((s) => s.formatCode === e);
  return t === -1 ? (t = hi.length + 164, hi.push({ formatCode: e, numFmtId: t })) : t = hi[t].numFmtId, t;
}, lM = (e) => {
  const { borderBottom: t, borderTop: s, borderLeft: i, borderRight: r } = e;
  let o, n, a, l, d, c, h, u;
  i && (a = jr(i.lineStyle, i.weight), h = ps(i.color)), r && (l = jr(r.lineStyle, r.weight), u = ps(r.color)), t && (o = jr(t.lineStyle, t.weight), d = ps(t.color)), s && (n = jr(s.lineStyle, s.weight), c = ps(s.color));
  let p = cr.findIndex((g) => {
    const { left: f, right: m, top: C, bottom: v } = g;
    if (!f && (a || h) || !m && (l || u) || !C && (n || c) || !v && (o || d))
      return !1;
    const { style: b, color: y } = f || {}, { style: F, color: D } = m || {}, { style: x, color: T } = C || {}, { style: I, color: E } = v || {};
    return !(b != a || y != h || F != l || D != u || x != n || T != c || I != o || E != d);
  });
  return p === -1 && (p = cr.length, cr.push({
    left: {
      style: a,
      color: h
    },
    right: {
      style: l,
      color: u
    },
    top: {
      style: n,
      color: c
    },
    bottom: {
      style: o,
      color: d
    },
    diagonal: {
      style: void 0,
      color: void 0
    }
  })), p;
}, dM = (e) => {
  const {
    fontName: t = "Calibri",
    color: s,
    size: i,
    bold: r,
    italic: o,
    outline: n,
    shadow: a,
    strikeThrough: l,
    underline: d,
    family: c,
    verticalAlign: h
  } = e, u = ps(s), p = XD(c), g = d ? d.toLocaleLowerCase() : void 0, f = h ? h.toLocaleLowerCase() : void 0;
  let m = lr.findIndex((C) => !(C.fontName != t || C.color != u || C.size != i || C.bold != r || C.italic != o || C.outline != n || C.shadow != a || C.strikeThrough != l || C.underline != g || C.verticalAlign != f || C.family != p));
  return m === -1 && (m = lr.length, lr.push({
    fontName: t,
    color: u,
    size: i,
    bold: r,
    italic: o,
    outline: n,
    shadow: a,
    strikeThrough: l,
    underline: g,
    verticalAlign: f,
    family: p != null ? p.toString() : void 0
  })), m;
}, cM = (e) => {
  const { alignment: t, borders: s, font: i, interior: r, numberFormat: o, protection: n, quotePrefix: a } = e;
  let { id: l } = e, d = 0, c = 0, h = 0, u = 0;
  l && (l = bg(l, Ga), Io[l] == null && (r && (d = nM(r)), s && (c = lM(s)), i && (h = dM(i)), o && (u = aM(o.format)), Io[l] = Lo.length, Lo.push({
    alignment: t,
    borderId: c || 0,
    fillId: d || 0,
    fontId: h || 0,
    numFmtId: u || 0,
    protection: n,
    quotePrefix: a,
    xfId: 0
  })));
}, hM = {
  getTemplate(e) {
    const t = oM.getTemplate(hi), s = eM.getTemplate(
      lr.map((l) => ({ ...l, size: l.size != null ? l.size : e }))
    ), i = XE.getTemplate(dr), r = IE.getTemplate(cr), o = HE.getTemplate(wg), n = $E.getTemplate(Lo), a = UE.getTemplate(yg);
    return Sg(), {
      name: "styleSheet",
      properties: {
        rawMap: {
          "mc:Ignorable": "x14ac x16r2 xr",
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
          "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main",
          "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision"
        }
      },
      children: [
        t,
        s,
        i,
        r,
        o,
        n,
        a,
        {
          name: "tableStyles",
          properties: {
            rawMap: {
              count: 0,
              defaultPivotStyle: "PivotStyleLight16",
              defaultTableStyle: "TableStyleMedium2"
            }
          }
        }
      ]
    };
  }
}, uM = (e, t) => Io[bg(e, t)] || 0, pM = (e, t) => {
  Ga = t, Ga === 1 && Sg(), e.forEach(cM);
}, gM = hM, fM = {
  getTemplate(e, t) {
    const {
      name: s,
      columns: i,
      rowRange: r,
      displayName: o,
      showRowStripes: n,
      showColumnStripes: a,
      showFilterButtons: l,
      highlightFirstColumn: d,
      highlightLastColumn: c
    } = e || {}, h = !r || r[0] - r[1] === 0;
    if (!e || !s || !Array.isArray(i) || !i.length || h)
      return { name: "table" };
    const u = i.map((v, b) => ({
      name: "filterColumn",
      properties: {
        rawMap: {
          colId: b.toString(),
          // For filters, this should start with 0
          hiddenButton: l[b] ? 0 : 1
        }
      }
    })), p = `A${r[0]}`, g = `${Zs(i.length)}${r[1]}`, f = `${p}:${g}`, m = `${t + 1}`, C = t ? `${o}_${m}` : o;
    return {
      name: "table",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "mc:Ignorable": "xr xr3",
          "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
          "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3",
          name: s,
          displayName: C,
          ref: f,
          totalsRowShown: 0,
          id: m
        }
      },
      children: [
        {
          name: "autoFilter",
          properties: {
            rawMap: {
              ref: f
            }
          },
          children: u
        },
        {
          name: "tableColumns",
          properties: {
            rawMap: {
              count: i.length
            }
          },
          children: i.map((v, b) => ({
            name: "tableColumn",
            properties: {
              rawMap: {
                id: (b + 1).toString(),
                name: v,
                dataCellStyle: "Normal"
              }
            }
          }))
        },
        {
          name: "tableStyleInfo",
          properties: {
            rawMap: {
              name: "TableStyleLight1",
              showFirstColumn: d ? 1 : 0,
              showLastColumn: c ? 1 : 0,
              showRowStripes: n ? 1 : 0,
              showColumnStripes: a ? 1 : 0
            }
          }
        }
      ]
    };
  }
}, mM = fM, at = (e) => {
  const [t, s, i, r] = e;
  return {
    name: `a:${t}`,
    children: [
      {
        name: `a:${s}`,
        properties: {
          rawMap: {
            val: i,
            lastClr: r
          }
        }
      }
    ]
  };
}, CM = {
  getTemplate() {
    return {
      name: "a:clrScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [
        at(["dk1", "sysClr", "windowText", "000000"]),
        at(["lt1", "sysClr", "window", "FFFFFF"]),
        at(["dk2", "srgbClr", "44546A"]),
        at(["lt2", "srgbClr", "E7E6E6"]),
        at(["accent1", "srgbClr", "4472C4"]),
        at(["accent2", "srgbClr", "ED7D31"]),
        at(["accent3", "srgbClr", "A5A5A5"]),
        at(["accent4", "srgbClr", "FFC000"]),
        at(["accent5", "srgbClr", "5B9BD5"]),
        at(["accent6", "srgbClr", "70AD47"]),
        at(["hlink", "srgbClr", "0563C1"]),
        at(["folHlink", "srgbClr", "954F72"])
      ]
    };
  }
}, vM = CM, k = (e) => {
  const [t, s, i, r] = e;
  return {
    name: `a:${t}`,
    properties: {
      rawMap: {
        script: i,
        typeface: s,
        panose: r
      }
    }
  };
}, wM = {
  getTemplate() {
    return {
      name: "a:fontScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [
        {
          name: "a:majorFont",
          children: [
            k(["latin", "Calibri Light", void 0, "020F0302020204030204"]),
            k(["ea", ""]),
            k(["cs", ""]),
            k(["font", "游ゴシック Light", "Jpan"]),
            k(["font", "맑은 고딕", "Hang"]),
            k(["font", "等线 Light", "Hans"]),
            k(["font", "新細明體", "Hant"]),
            k(["font", "Times New Roman", "Arab"]),
            k(["font", "Times New Roman", "Hebr"]),
            k(["font", "Tahoma", "Thai"]),
            k(["font", "Nyala", "Ethi"]),
            k(["font", "Vrinda", "Beng"]),
            k(["font", "Shruti", "Gujr"]),
            k(["font", "MoolBoran", "Khmr"]),
            k(["font", "Tunga", "Knda"]),
            k(["font", "Raavi", "Guru"]),
            k(["font", "Euphemia", "Cans"]),
            k(["font", "Plantagenet Cherokee", "Cher"]),
            k(["font", "Microsoft Yi Baiti", "Yiii"]),
            k(["font", "Microsoft Himalaya", "Tibt"]),
            k(["font", "MV Boli", "Thaa"]),
            k(["font", "Mangal", "Deva"]),
            k(["font", "Gautami", "Telu"]),
            k(["font", "Latha", "Taml"]),
            k(["font", "Estrangelo Edessa", "Syrc"]),
            k(["font", "Kalinga", "Orya"]),
            k(["font", "Kartika", "Mlym"]),
            k(["font", "DokChampa", "Laoo"]),
            k(["font", "Iskoola Pota", "Sinh"]),
            k(["font", "Mongolian Baiti", "Mong"]),
            k(["font", "Times New Roman", "Viet"]),
            k(["font", "Microsoft Uighur", "Uigh"]),
            k(["font", "Sylfaen", "Geor"]),
            k(["font", "Arial", "Armn"]),
            k(["font", "Leelawadee UI", "Bugi"]),
            k(["font", "Microsoft JhengHei", "Bopo"]),
            k(["font", "Javanese Text", "Java"]),
            k(["font", "Segoe UI", "Lisu"]),
            k(["font", "Myanmar Text", "Mymr"]),
            k(["font", "Ebrima", "Nkoo"]),
            k(["font", "Nirmala UI", "Olck"]),
            k(["font", "Ebrima", "Osma"]),
            k(["font", "Phagspa", "Phag"]),
            k(["font", "Estrangelo Edessa", "Syrn"]),
            k(["font", "Estrangelo Edessa", "Syrj"]),
            k(["font", "Estrangelo Edessa", "Syre"]),
            k(["font", "Nirmala UI", "Sora"]),
            k(["font", "Microsoft Tai Le", "Tale"]),
            k(["font", "Microsoft New Tai Lue", "Talu"]),
            k(["font", "Ebrima", "Tfng"])
          ]
        },
        {
          name: "a:minorFont",
          children: [
            k(["latin", "Calibri", void 0, "020F0502020204030204"]),
            k(["ea", ""]),
            k(["cs", ""]),
            k(["font", "游ゴシック", "Jpan"]),
            k(["font", "맑은 고딕", "Hang"]),
            k(["font", "等线", "Hans"]),
            k(["font", "新細明體", "Hant"]),
            k(["font", "Arial", "Arab"]),
            k(["font", "Arial", "Hebr"]),
            k(["font", "Tahoma", "Thai"]),
            k(["font", "Nyala", "Ethi"]),
            k(["font", "Vrinda", "Beng"]),
            k(["font", "Shruti", "Gujr"]),
            k(["font", "DaunPenh", "Khmr"]),
            k(["font", "Tunga", "Knda"]),
            k(["font", "Raavi", "Guru"]),
            k(["font", "Euphemia", "Cans"]),
            k(["font", "Plantagenet Cherokee", "Cher"]),
            k(["font", "Microsoft Yi Baiti", "Yiii"]),
            k(["font", "Microsoft Himalaya", "Tibt"]),
            k(["font", "MV Boli", "Thaa"]),
            k(["font", "Mangal", "Deva"]),
            k(["font", "Gautami", "Telu"]),
            k(["font", "Latha", "Taml"]),
            k(["font", "Estrangelo Edessa", "Syrc"]),
            k(["font", "Kalinga", "Orya"]),
            k(["font", "Kartika", "Mlym"]),
            k(["font", "DokChampa", "Laoo"]),
            k(["font", "Iskoola Pota", "Sinh"]),
            k(["font", "Mongolian Baiti", "Mong"]),
            k(["font", "Arial", "Viet"]),
            k(["font", "Microsoft Uighur", "Uigh"]),
            k(["font", "Sylfaen", "Geor"]),
            k(["font", "Arial", "Armn"]),
            k(["font", "Leelawadee UI", "Bugi"]),
            k(["font", "Microsoft JhengHei", "Bopo"]),
            k(["font", "Javanese Text", "Java"]),
            k(["font", "Segoe UI", "Lisu"]),
            k(["font", "Myanmar Text", "Mymr"]),
            k(["font", "Ebrima", "Nkoo"]),
            k(["font", "Nirmala UI", "Olck"]),
            k(["font", "Ebrima", "Osma"]),
            k(["font", "Phagspa", "Phag"]),
            k(["font", "Estrangelo Edessa", "Syrn"]),
            k(["font", "Estrangelo Edessa", "Syrj"]),
            k(["font", "Estrangelo Edessa", "Syre"]),
            k(["font", "Nirmala UI", "Sora"]),
            k(["font", "Microsoft Tai Le", "Tale"]),
            k(["font", "Microsoft New Tai Lue", "Talu"]),
            k(["font", "Ebrima", "Tfng"])
          ]
        }
      ]
    };
  }
}, yM = wM, Lt = (e, t, s) => ({
  name: `a:${e}`,
  properties: {
    rawMap: {
      val: t
    }
  },
  children: s
}), Xn = (e) => {
  const [t, s, i, r, o, n] = e, a = [];
  return a.push(Lt("satMod", i)), r && a.push(Lt("lumMod", r)), o && a.push(Lt("tint", o)), n && a.push(Lt("shade", n)), {
    name: "a:gs",
    properties: {
      rawMap: {
        pos: t
      }
    },
    children: [
      {
        name: "a:schemeClr",
        properties: {
          rawMap: {
            val: s
          }
        },
        children: a
      }
    ]
  };
}, ko = (e, t) => ({
  name: "a:solidFill",
  children: [Lt("schemeClr", e, t)]
}), Ba = (e) => {
  const [t, s, i, r, o] = e, [n, a] = o;
  return {
    name: "a:gradFill",
    properties: {
      rawMap: {
        rotWithShape: t
      }
    },
    children: [
      {
        name: "a:gsLst",
        children: [Xn(s), Xn(i), Xn(r)]
      },
      {
        name: "a:lin",
        properties: {
          rawMap: {
            ang: n,
            scaled: a
          }
        }
      }
    ]
  };
}, Zn = (e) => {
  const [t, s, i, r] = e;
  return {
    name: "a:ln",
    properties: {
      rawMap: { w: t, cap: s, cmpd: i, algn: r }
    },
    children: [
      ko("phClr"),
      Lt("prstDash", "solid"),
      {
        name: "a:miter",
        properties: {
          rawMap: {
            lim: "800000"
          }
        }
      }
    ]
  };
}, Qn = (e) => {
  const t = [];
  if (e) {
    const [s, i, r, o, n] = e;
    t.push({
      name: "a:outerShdw",
      properties: {
        rawMap: { blurRad: s, dist: i, dir: r, algn: o, rotWithShape: n }
      },
      children: [Lt("srgbClr", "000000", [Lt("alpha", "63000")])]
    });
  }
  return {
    name: "a:effectStyle",
    children: [
      Object.assign(
        {},
        {
          name: "a:effectLst"
        },
        t.length ? { children: t } : {}
      )
    ]
  };
}, bM = () => ({
  name: "a:fillStyleLst",
  children: [
    ko("phClr"),
    Ba([
      "1",
      ["0", "phClr", "105000", "110000", "67000"],
      ["50000", "phClr", "103000", "105000", "73000"],
      ["100000", "phClr", "109000", "105000", "81000"],
      ["5400000", "0"]
    ]),
    Ba([
      "1",
      ["0", "phClr", "103000", "102000", "94000"],
      ["50000", "phClr", "110000", "100000", void 0, "100000"],
      ["100000", "phClr", "120000", "99000", void 0, "78000"],
      ["5400000", "0"]
    ])
  ]
}), SM = () => ({
  name: "a:lnStyleLst",
  children: [
    Zn(["6350", "flat", "sng", "ctr"]),
    Zn(["12700", "flat", "sng", "ctr"]),
    Zn(["19050", "flat", "sng", "ctr"])
  ]
}), xM = () => ({
  name: "a:effectStyleLst",
  children: [Qn(), Qn(), Qn(["57150", "19050", "5400000", "ctr", "0"])]
}), FM = () => ({
  name: "a:bgFillStyleLst",
  children: [
    ko("phClr"),
    ko("phClr", [Lt("tint", "95000"), Lt("satMod", "170000")]),
    Ba([
      "1",
      ["0", "phClr", "150000", "102000", "93000", "98000"],
      ["50000", "phClr", "130000", "103000", "98000", "90000"],
      ["100000", "phClr", "120000", void 0, void 0, "63000"],
      ["5400000", "0"]
    ])
  ]
}), RM = {
  getTemplate() {
    return {
      name: "a:fmtScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [bM(), SM(), xM(), FM()]
    };
  }
}, PM = RM, TM = {
  getTemplate() {
    return {
      name: "a:themeElements",
      children: [vM.getTemplate(), yM.getTemplate(), PM.getTemplate()]
    };
  }
}, DM = TM, EM = {
  getTemplate() {
    return {
      name: "a:theme",
      properties: {
        prefixedAttributes: [
          {
            prefix: "xmlns:",
            map: {
              a: "http://schemas.openxmlformats.org/drawingml/2006/main"
            }
          }
        ],
        rawMap: {
          name: "Office Theme"
        }
      },
      children: [
        DM.getTemplate(),
        {
          name: "a:objectDefaults"
        },
        {
          name: "a:extraClrSchemeLst"
        }
      ]
    };
  }
}, MM = EM, AM = () => ({
  name: "o:shapelayout",
  properties: {
    prefixedAttributes: [
      {
        prefix: "v:",
        map: {
          ext: "edit"
        }
      }
    ]
  },
  children: [
    {
      name: "o:idmap",
      properties: {
        prefixedAttributes: [
          {
            prefix: "v:",
            map: {
              ext: "edit"
            }
          }
        ],
        rawMap: {
          data: "1"
        }
      }
    }
  ]
}), IM = () => ({
  name: "v:stroke",
  properties: {
    rawMap: {
      joinstyle: "miter"
    }
  }
}), LM = (e) => ({
  name: "v:formulas",
  children: e.map((t) => ({
    name: "v:f",
    properties: {
      rawMap: {
        eqn: t
      }
    }
  }))
}), kM = () => ({
  name: "v:path",
  properties: {
    prefixedAttributes: [
      {
        prefix: "o:",
        map: {
          connecttype: "rect",
          extrusionok: "f"
        }
      }
    ],
    rawMap: {
      gradientshapeok: "t"
    }
  }
}), xg = (e) => {
  const { aspectratio: t, rotation: s } = e || {}, i = {};
  return t && (i.aspectratio = "t"), s && (i.rotation = "t"), {
    name: "o:lock",
    properties: {
      prefixedAttributes: [
        {
          prefix: "v:",
          map: {
            ext: "edit"
          }
        }
      ],
      rawMap: i
    }
  };
};
function OM(e, t, s, i, r) {
  return (e - t) / (s - t) * (r - i) + i;
}
var GM = (e, t) => {
  let s;
  const { recolor: i, brightness: r, contrast: o, id: n } = e;
  if (i && (s = {}, (i === "Washout" || i === "Grayscale") && (s.gain = "19661f", s.blacklevel = "22938f"), (i === "Black & White" || i === "Grayscale") && (s.grayscale = "t", i === "Black & White" && (s.bilevel = "t"))), !i || i === "Grayscale") {
    if (s || (s = {}), o != null && o !== 50) {
      let a = "1";
      o >= 0 && (o < 50 ? a = String(o / 50) : o < 100 ? a = String(50 / (100 - o)) : o === 100 && (a = "2147483647f")), s.gain = a;
    }
    r != null && r !== 50 && (s.blacklevel = OM(r, 0, 100, -0.5, 0.5).toString());
  }
  return {
    name: "v:imagedata",
    properties: {
      prefixedAttributes: [
        {
          prefix: "o:",
          map: {
            relid: `rId${t}`,
            title: n
          }
        }
      ],
      rawMap: s
    }
  };
}, BM = () => {
  const e = [
    "if lineDrawn pixelLineWidth 0",
    "sum @0 1 0",
    "sum 0 0 @1",
    "prod @2 1 2",
    "prod @3 21600 pixelWidth",
    "prod @3 21600 pixelHeight",
    "sum @0 0 1",
    "prod @6 1 2",
    "prod @7 21600 pixelWidth",
    "sum @8 21600 0",
    "prod @7 21600 pixelHeight",
    "sum @10 21600 0"
  ];
  return {
    name: "v:shapetype",
    properties: {
      prefixedAttributes: [
        {
          prefix: "o:",
          map: {
            spt: "75",
            preferrelative: "t"
          }
        }
      ],
      rawMap: {
        coordsize: "21600,21600",
        filled: "f",
        id: "_x0000_t75",
        path: "m@4@5l@4@11@9@11@9@5xe",
        stroked: "f"
      }
    },
    children: [IM(), LM(e), kM(), xg({ aspectratio: !0 })]
  };
}, fc = (e) => Math.floor((e ?? 0) * 0.74999943307122), VM = (e, t) => {
  const { width: s = 0, height: i = 0, altText: r } = e, o = fc(s), n = fc(i);
  return {
    name: "v:shape",
    properties: {
      rawMap: {
        id: e.headerFooterPosition,
        "o:spid": "_x0000_s1025",
        style: `position: absolute; margin-left: 0; margin-top: 10in; margin-bottom: 0; margin-right: 0; width: ${o}pt; height: ${n}pt; z-index: ${t + 1}`,
        type: "#_x0000_t75",
        alt: r
      }
    },
    children: [GM(e, t + 1), xg({ rotation: !0 })]
  };
}, NM = {
  getTemplate(e) {
    const t = Fs.get(e.sheetIndex) || [], s = [
      AM(),
      BM(),
      ...t.map((i, r) => VM(i, r))
    ];
    return {
      name: "xml",
      properties: {
        prefixedAttributes: [
          {
            prefix: "xmlns:",
            map: {
              v: "urn:schemas-microsoft-com:vml",
              o: "urn:schemas-microsoft-com:office:office",
              x: "urn:schemas-microsoft-com:office:excel"
            }
          }
        ]
      },
      children: s
    };
  }
}, HM = NM, zM = {
  getTemplate(e, t) {
    const s = (t + 1).toString();
    return {
      name: "sheet",
      properties: {
        rawMap: {
          name: e,
          sheetId: s,
          "r:id": `rId${s}`
        }
      }
    };
  }
}, WM = zM, _M = {
  getTemplate(e) {
    return {
      name: "sheets",
      children: e.map((t, s) => WM.getTemplate(t, s))
    };
  }
}, UM = _M, KM = {
  getTemplate(e, t) {
    return {
      name: "workbook",
      properties: {
        prefixedAttributes: [
          {
            prefix: "xmlns:",
            map: {
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
            }
          }
        ],
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        }
      },
      children: [
        {
          name: "bookViews",
          children: [
            {
              name: "workbookView",
              properties: {
                rawMap: {
                  activeTab: t
                }
              }
            }
          ]
        },
        UM.getTemplate(e)
      ]
    };
  }
}, $M = KM, jM = (e) => Math.ceil((e - 12) / 7 + 1), qM = {
  getTemplate(e) {
    const { min: t, max: s, outlineLevel: i, s: r, width: o, hidden: n, bestFit: a } = e;
    let l = 1, d = "0";
    return o > 1 && (l = jM(o), d = "1"), {
      name: "col",
      properties: {
        rawMap: {
          min: t,
          max: s,
          outlineLevel: i ?? void 0,
          width: l,
          style: r,
          hidden: n ? "1" : "0",
          bestFit: a ? "1" : "0",
          customWidth: d
        }
      }
    };
  }
}, YM = qM, XM = {
  getTemplate(e) {
    return {
      name: "mergeCell",
      properties: {
        rawMap: {
          ref: e
        }
      }
    };
  }
}, ZM = XM, QM = (e) => {
  const t = e.charAt(0).toLowerCase();
  return t === "s" ? "inlineStr" : t;
}, JM = {
  getTemplate(e, t, s) {
    const { ref: i, data: r, styleId: o } = e, { type: n, value: a } = r || { type: "empty", value: null };
    let l = n;
    n === "f" ? l = "str" : n.charAt(0) === n.charAt(0).toUpperCase() && (l = QM(n));
    const d = {
      name: "c",
      properties: {
        rawMap: {
          r: i,
          t: l === "empty" ? void 0 : l,
          s: o ? uM(o, s) : void 0
        }
      }
    };
    if (l === "empty")
      return d;
    let c;
    return l === "str" && n === "f" ? c = [
      {
        name: "f",
        textNode: Q(Oa(a), !1)
      }
    ] : l === "inlineStr" ? c = [
      {
        name: "is",
        children: [
          {
            name: "t",
            textNode: Q(Oa(a), !1)
          }
        ]
      }
    ] : c = [
      {
        name: "v",
        textNode: a
      }
    ], Object.assign({}, d, { children: c });
  }
}, eA = JM, tA = (e, t) => {
  const s = [];
  let i = 0;
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    o.mergeAcross && (s.push({
      pos: r,
      excelPos: i
    }), i += o.mergeAcross), i++;
  }
  if (s.length)
    for (let r = s.length - 1; r >= 0; r--) {
      const o = [], n = e[s[r].pos];
      for (let a = 1; a <= n.mergeAcross; a++)
        o.push({
          ref: `${Zs(s[r].excelPos + 1 + a)}${t + 1}`,
          styleId: n.styleId,
          data: { type: "empty", value: null }
        });
      o.length && e.splice(s[r].pos + 1, 0, ...o);
    }
}, sA = (e) => {
  var t;
  return ((t = e.data) == null ? void 0 : t.value) !== "" || e.styleId !== void 0;
}, iA = {
  getTemplate(e, t, s) {
    const { collapsed: i, hidden: r, height: o, outlineLevel: n, cells: a = [] } = e;
    tA(a, t);
    const l = a.filter(sA).map((d, c) => eA.getTemplate(d, c, s));
    return {
      name: "row",
      properties: {
        rawMap: {
          r: t + 1,
          collapsed: i ? "1" : "0",
          hidden: r ? "1" : "0",
          ht: o,
          customHeight: o != null ? "1" : "0",
          spans: "1:1",
          outlineLevel: n || void 0
        }
      },
      children: l
    };
  }
}, rA = iA, oA = (e, t, s) => {
  const i = [], r = [];
  e.forEach((a, l) => {
    const d = a.cells;
    let c = 0, h;
    d.forEach((u, p) => {
      const g = p + c + 1, f = Zs(g), m = l + 1;
      if (u.mergeAcross) {
        c += u.mergeAcross;
        const v = Zs(p + c + 1);
        i.push(`${f}${m}:${v}${m}`);
      }
      t[g - 1] || (t[g - 1] = {});
      const { collapsibleRanges: C } = u;
      C && C.forEach((v) => {
        r.push([g + v[0], g + v[1]]);
      }), h = t[g - 1], h.min = g, h.max = g, u.ref = `${f}${m}`;
    });
  }), r.sort((a, l) => a[0] !== l[0] ? a[0] - l[0] : l[1] - a[1]);
  const o = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return r.filter((a) => {
    const l = a.toString();
    return o.get(l) ? !1 : (o.set(l, !0), !0);
  }).forEach((a) => {
    const l = t.find((c) => c.min == a[0] && c.max == a[1]), d = n.get(a[0]);
    t.push({
      min: a[0],
      max: a[1],
      outlineLevel: s ? void 0 : d || 1,
      width: (l || { width: 100 }).width
    }), n.set(a[0], (d || 0) + 1);
  }), i;
}, nA = (e) => !e || e !== "Portrait" && e !== "Landscape" ? "portrait" : e.toLocaleLowerCase(), aA = (e) => {
  if (e == null)
    return 1;
  const s = [
    "Letter",
    "Letter Small",
    "Tabloid",
    "Ledger",
    "Legal",
    "Statement",
    "Executive",
    "A3",
    "A4",
    "A4 Small",
    "A5",
    "A6",
    "B4",
    "B5",
    "Folio",
    "Envelope",
    "Envelope DL",
    "Envelope C5",
    "Envelope B5",
    "Envelope C3",
    "Envelope C4",
    "Envelope C6",
    "Envelope Monarch",
    "Japanese Postcard",
    "Japanese Double Postcard"
  ].indexOf(e);
  return s === -1 ? 1 : s + 1;
}, lA = (e) => (Object.entries({
  "&[Page]": "&P",
  "&[Pages]": "&N",
  "&[Date]": "&D",
  "&[Time]": "&T",
  "&[Tab]": "&A",
  "&[Path]": "&Z",
  "&[File]": "&F",
  "&[Picture]": "&G"
}).forEach(([s, i]) => {
  e = e.replace(s, i);
}), e), dA = (e) => e === "Center" ? "C" : e === "Right" ? "R" : "L", cA = (e, t) => (t && (e += "&amp;&quot;", e += t.fontName || "Calibri", t.bold !== t.italic ? e += t.bold ? ",Bold" : ",Italic" : t.bold ? e += ",Bold Italic" : e += ",Regular", e += "&quot;", t.size && (e += `&amp;${t.size}`), t.strikeThrough && (e += "&amp;S"), t.underline && (e += `&amp;${t.underline === "Double" ? "E" : "U"}`), t.color && (e += `&amp;K${t.color.replace("#", "").toUpperCase()}`)), e), hA = (e, t, s) => e.reduce((i, r, o) => {
  const n = dA(r.position), a = cA(`${i}&amp;${n}`, r.font), l = ["Left", "Center", "Right"];
  r.position || (r.position = l[o]);
  const { image: d } = r;
  if (r.value === "&[Picture]" && d) {
    const c = `${n}${t}${s}`;
    OA(d, c);
  }
  return `${a}${Q(lA(r.value))}`;
}, ""), uA = (e) => {
  const t = ["all", "first", "even"], s = [];
  return t.forEach((i) => {
    const r = e[i], o = i === "all" ? "odd" : i;
    if (r)
      for (const [n, a] of Object.entries(r)) {
        const l = `${n.charAt(0).toUpperCase()}${n.slice(1)}`, d = n[0].toUpperCase();
        if (a) {
          const c = i === "all" ? "" : i.toUpperCase();
          s.push({
            name: `${o}${l}`,
            properties: {
              rawMap: { "xml:space": "preserve" }
            },
            textNode: hA(a, d, c)
          });
        }
      }
  }), s;
}, pA = (e) => (t) => (e.length && t.children.push({
  name: "cols",
  children: e.map((s) => YM.getTemplate(s))
}), t), gA = (e, t) => (s) => (e.length && s.children.push({
  name: "sheetData",
  children: e.map((i, r) => rA.getTemplate(i, r, t))
}), s), fA = (e) => (t) => (e.length && t.children.push({
  name: "mergeCells",
  properties: {
    rawMap: {
      count: e.length
    }
  },
  children: e.map((s) => ZM.getTemplate(s))
}), t), mA = (e) => (t) => {
  const { top: s = 0.75, right: i = 0.7, bottom: r = 0.75, left: o = 0.7, header: n = 0.3, footer: a = 0.3 } = e;
  return t.children.push({
    name: "pageMargins",
    properties: {
      rawMap: { bottom: r, footer: a, header: n, left: o, right: i, top: s }
    }
  }), t;
}, CA = (e) => (t) => (e && t.children.push({
  name: "pageSetup",
  properties: {
    rawMap: {
      horizontalDpi: 0,
      verticalDpi: 0,
      orientation: nA(e.orientation),
      paperSize: aA(e.pageSize)
    }
  }
}), t), vA = (e) => (t) => {
  if (!e)
    return t;
  const s = e.first != null ? 1 : 0, i = e.even != null ? 1 : 0;
  return t.children.push({
    name: "headerFooter",
    properties: {
      rawMap: {
        differentFirst: s,
        differentOddEven: i
      }
    },
    children: uA(e)
  }), t;
}, wA = (e) => (t) => (e && t.children.push({
  name: "tableParts",
  properties: {
    rawMap: {
      count: "1"
    }
  },
  children: [
    {
      name: "tablePart",
      properties: {
        rawMap: {
          "r:id": `rId${++t.rIdCounter}`
        }
      }
    }
  ]
}), t), yA = (e) => (t) => {
  const s = Js.get(e);
  return s != null && s.length && t.children.push({
    name: "drawing",
    properties: {
      rawMap: {
        "r:id": `rId${++t.rIdCounter}`
      }
    }
  }), t;
}, bA = (e) => (t) => (Fs.get(e) && t.children.push({
  name: "legacyDrawingHF",
  properties: {
    rawMap: {
      "r:id": `rId${++t.rIdCounter}`
    }
  }
}), t), SA = (e = 0, t = 0) => {
  const s = e > 0 || t > 0;
  return s ? [
    {
      name: "pane",
      properties: {
        rawMap: {
          state: s ? "frozen" : void 0,
          topLeftCell: s ? `${Zs(e + 1)}${t + 1}` : void 0,
          xSplit: e === 0 ? void 0 : e,
          ySplit: t === 0 ? void 0 : t
        }
      }
    }
  ] : void 0;
}, xA = (e = !1, t, s) => (i) => (i.children.push({
  name: "sheetViews",
  children: [
    {
      name: "sheetView",
      properties: {
        rawMap: {
          rightToLeft: e === !0 ? "1" : "0",
          workbookViewId: "0"
        }
      },
      children: SA(t, s)
    }
  ]
}), i), FA = () => (e) => (e.children.push({
  name: "sheetPr",
  children: [
    {
      name: "outlinePr",
      properties: {
        rawMap: {
          summaryBelow: 0
        }
      }
    }
  ]
}), e), RA = (e) => (t) => {
  const s = e.reduce((i, r) => r.outlineLevel && r.outlineLevel > i ? r.outlineLevel : i, 0);
  return t.children.push({
    name: "sheetFormatPr",
    properties: {
      rawMap: {
        baseColWidth: 10,
        defaultRowHeight: 16,
        outlineLevelRow: s || void 0
      }
    }
  }), t;
}, PA = {
  getTemplate(e) {
    const { worksheet: t, currentSheet: s, config: i } = e, {
      margins: r = {},
      pageSetup: o,
      headerFooterConfig: n,
      suppressColumnOutline: a,
      rightToLeft: l,
      frozenRowCount: d,
      frozenColumnCount: c
    } = i, { table: h } = t, { rows: u, columns: p } = h, g = p && p.length ? oA(u, p, !!a) : [], f = Jt.get(s), { children: m } = [
      FA(),
      xA(l, c, d),
      RA(u),
      pA(p),
      gA(u, s + 1),
      fA(g),
      mA(r),
      CA(o),
      vA(n),
      yA(s),
      bA(s),
      wA(f)
    ].reduce((C, v) => v(C), { children: [], rIdCounter: 0 });
    return {
      name: "worksheet",
      properties: {
        prefixedAttributes: [
          {
            prefix: "xmlns:",
            map: {
              r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
            }
          }
        ],
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        }
      },
      children: m
    };
  }
}, TA = PA, Os = /* @__PURE__ */ new Map(), Qt = [], Qs = /* @__PURE__ */ new Map(), Js = /* @__PURE__ */ new Map(), Fs = /* @__PURE__ */ new Map(), Ai = /* @__PURE__ */ new Map(), vr = /* @__PURE__ */ new Map(), Jt = /* @__PURE__ */ new Map(), DA = "AG-GRID-TABLE", Ul = "SINGLE_SHEET";
function EA() {
  return Ul;
}
function MA(e) {
  Ul = e;
}
function AA(e, t, s) {
  BA(t), pM(e, Qt.length);
  const i = Object.assign({}, s);
  return s.exportAsExcelTable && (s.colModel.isPivotActive() && (mc("pivot mode"), i.exportAsExcelTable = !1), s.gos.get("masterDetail") && (mc("master/detail"), i.exportAsExcelTable = !1)), kA(t, i), QA(t, i);
}
function mc(e) {
  R(163, { featureName: e });
}
function IA(e) {
  return e.replace(/^[^a-zA-Z_]+/, "_").replace(/\s/g, "_").replace(/[^a-zA-Z0-9_]/g, "_");
}
function LA(e, t) {
  if (Jt.has(e)) {
    R(164);
    return;
  }
  Jt.set(e, t);
}
function kA(e, t) {
  const { exportAsExcelTable: s, prependContent: i, appendContent: r, colModel: o } = t;
  if (!s)
    return;
  const n = typeof s == "boolean" ? {} : s, {
    name: a,
    showColumnStripes: l,
    showRowStripes: d,
    showFilterButton: c,
    highlightFirstColumn: h,
    highlightLastColumn: u
  } = n, p = IA(a || DA), g = Qt.length - 1, { table: f } = e, { rows: m, columns: C } = f, v = Xu(o), b = i ? i.length : 0, y = r ? r.length : 0, F = m.length, D = C.length, x = [], T = [];
  for (let I = 0; I < D; I++) {
    const E = C[I];
    x.push(E.displayName || ""), T.push(
      c === "match" || c === void 0 ? E.filterAllowed ?? !1 : c
    );
  }
  if (!x || !x.length || !F || !p) {
    R(165);
    return;
  }
  LA(g, {
    name: `table${Jt.size + 1}`,
    displayName: p,
    columns: x,
    showFilterButtons: T,
    rowRange: [v + b, v + (F - v) - y],
    showRowStripes: d ?? !0,
    showColumnStripes: l ?? !1,
    highlightFirstColumn: h ?? !1,
    highlightLastColumn: u ?? !1
  });
}
function OA(e, t) {
  const s = Qt.length - 1, i = e;
  i.headerFooterPosition = t, Fg({ imageToAdd: i, idx: s });
  let r = Fs.get(s);
  r || (r = [], Fs.set(s, r)), r.find((o) => o.id === e.id) || r.push(e);
}
function GA(e, t, s, i, r) {
  const o = Qt.length, { row: n, column: a } = e.position || {}, l = e;
  i && (t != null && s != null && (!n || !a) && (e.position || (e.position = {}), e.position = Object.assign({}, e.position, {
    row: t,
    column: i.indexOf(s) + 1
  })), ZD(l, i), QD(l, r)), Fg({ imageToAdd: l, idx: o });
  let d = vr.get(o);
  d || (d = /* @__PURE__ */ new Map(), vr.set(o, d));
  const c = Js.get(o);
  c ? c.push(l) : Js.set(o, [l]), d.get(e.id) || d.set(e.id, { index: d.size, type: e.imageType });
}
function Fg(e) {
  const { imageToAdd: t, idx: s } = e, i = Qs.get(t.id);
  if (i) {
    const r = i.find((o) => o.sheetId === s);
    r ? r.image.push(t) : i.push({
      sheetId: s,
      image: [t]
    });
  } else
    Qs.set(t.id, [{ sheetId: s, image: [t] }]), Ai.set(t.id, {
      type: t.imageType,
      index: Ai.size
    });
}
function BA(e) {
  const t = Q(e.name) || "";
  let s = "";
  for (; Qt.indexOf(`${t}${s}`) !== -1; )
    s === "" ? s = "_1" : s = `_${parseInt(s.slice(1), 10) + 1}`;
  e.name = `${t}${s}`, Qt.push(e.name);
}
function Cc(e) {
  return Os.has(e) ? Os.get(e) : (Os.set(e, Os.size), Os.size - 1);
}
function vc() {
  Os.clear(), Qs.clear(), Js.clear(), Fs.clear(), Ai.clear(), vr.clear(), Jt.clear(), Qt = [], Ul = "SINGLE_SHEET";
}
function VA(e) {
  return ze($M.getTemplate(Qt, e));
}
function NA(e) {
  return ze(gM.getTemplate(e));
}
function HA() {
  return ze(wE.getTemplate(Os));
}
function zA(e) {
  return ze(oE.getTemplate(e));
}
function WA(e) {
  return ze(iE.getTemplate(e));
}
function _A() {
  const e = Dr.getTemplate([
    {
      Id: "rId1",
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      Target: "xl/workbook.xml"
    },
    {
      Id: "rId2",
      Type: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      Target: "docProps/core.xml"
    }
  ]);
  return ze(e);
}
function UA() {
  return ze(MM.getTemplate());
}
function KA(e, t) {
  return ze(mM.getTemplate(e, t));
}
function $A(e) {
  const t = new Array(e).fill(void 0).map((i, r) => ({
    Id: `rId${r + 1}`,
    Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    Target: `worksheets/sheet${r + 1}.xml`
  })), s = Dr.getTemplate([
    ...t,
    {
      Id: `rId${e + 1}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
      Target: "theme/theme1.xml"
    },
    {
      Id: `rId${e + 2}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      Target: "styles.xml"
    },
    {
      Id: `rId${e + 3}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
      Target: "sharedStrings.xml"
    }
  ]);
  return ze(s);
}
function jA(e) {
  return ze(gE.getTemplate({ sheetIndex: e }));
}
function qA(e) {
  const t = vr.get(e) || [], s = [];
  for (const [i, r] of t) {
    const { index: o, type: n } = r;
    s.push({
      Id: `rId${o + 1}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: `../media/image${Ai.get(i).index + 1}.${fn(n)}`
    });
  }
  return ze(Dr.getTemplate(s));
}
function YA(e) {
  return ze(HM.getTemplate({ sheetIndex: e }), !0);
}
function XA(e) {
  const t = Fs.get(e) || [], s = [];
  for (let i = 0; i < t.length; i++) {
    const r = t[i], o = Ai.get(r.id);
    if (!o)
      continue;
    const { index: n, type: a } = o;
    s.push({
      Id: `rId${i + 1}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: `../media/image${n + 1}.${fn(a)}`
    });
  }
  return ze(Dr.getTemplate(s));
}
function ZA({
  drawingIndex: e,
  vmlDrawingIndex: t,
  tableName: s
} = {}) {
  if (e === void 0 && t === void 0 && s === void 0)
    return "";
  const i = [];
  e != null && i.push({
    Id: `rId${i.length + 1}`,
    Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
    Target: `../drawings/drawing${e + 1}.xml`
  }), t != null && i.push({
    Id: `rId${i.length + 1}`,
    Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    Target: `../drawings/vmlDrawing${t + 1}.vml`
  }), s != null && i.push({
    Id: `rId${i.length + 1}`,
    Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table",
    Target: `../tables/${s}.xml`
  });
  const r = Dr.getTemplate(i);
  return ze(r);
}
function QA(e, t) {
  return ze(
    TA.getTemplate({
      worksheet: e,
      currentSheet: Qt.length - 1,
      config: t
    })
  );
}
var JA = class extends Vp {
  constructor(e) {
    super(e), this.mixedStyles = {}, this.mixedStyleCounter = 0, this.rows = [], this.frozenRowCount = 0, this.skipFrozenRows = !1, this.frozenColumnCount = 0, this.skipFrozenColumns = !1, this.config = Object.assign({}, e), this.stylesByIds = {}, this.config.baseExcelStyles.forEach((t) => {
      this.stylesByIds[t.id] = t;
    }), this.excelStyles = [...this.config.baseExcelStyles, { id: "_quotePrefix", quotePrefix: 1 }];
  }
  addCustomContent(e) {
    e.forEach((t) => {
      const s = this.rows.length + 1;
      let i;
      !this.config.suppressRowOutline && t.outlineLevel != null && (i = t.outlineLevel);
      const r = {
        height: ro(s, t.height || this.config.rowHeight),
        cells: (t.cells || []).map((o, n) => {
          var u, p;
          const a = this.addImage(s, this.columnsToExport[n], (u = o.data) == null ? void 0 : u.value);
          let l = null;
          o.styleId && (l = typeof o.styleId == "string" ? [o.styleId] : o.styleId);
          const d = this.getStyleId(l);
          if (a)
            return this.createCell(
              d,
              this.getDataTypeForValue(a.value),
              a.value == null ? "" : a.value
            );
          const c = ((p = o.data) == null ? void 0 : p.value) ?? "", h = this.getDataTypeForValue(c);
          return o.mergeAcross ? this.createMergedCell(d, h, c, o.mergeAcross) : this.createCell(d, h, c);
        }),
        outlineLevel: i
      };
      t.collapsed != null && (r.collapsed = t.collapsed), t.hidden != null && (r.hidden = t.hidden), this.rows.push(r);
    });
  }
  onNewHeaderGroupingRow() {
    const e = [], { freezeRows: t, headerRowHeight: s } = this.config;
    return this.rows.push({
      cells: e,
      height: ro(this.rows.length + 1, s)
    }), t && this.frozenRowCount++, {
      onColumn: (i, r, o, n, a) => {
        const l = this.config.styleLinker({
          rowType: "HEADER_GROUPING",
          rowIndex: 1,
          value: `grouping-${r}`,
          columnGroup: i
        });
        e.push({
          ...this.createMergedCell(
            this.getStyleId(l),
            this.getDataTypeForValue("string"),
            r,
            n
          ),
          collapsibleRanges: a
        });
      }
    };
  }
  onNewHeaderRow() {
    const { freezeRows: e, headerRowHeight: t } = this.config;
    return e && this.frozenRowCount++, this.onNewRow(this.onNewHeaderColumn, t);
  }
  onNewBodyRow(e) {
    const { freezeRows: t, rowHeight: s } = this.config;
    this.skipFrozenRows || (t === "headersAndPinnedRows" && (e == null ? void 0 : e.rowPinned) === "top" ? this.frozenRowCount++ : typeof t == "function" ? t({ ...this.gos.getGridCommonParams(), node: e }) ? this.frozenRowCount++ : this.skipFrozenRows = !0 : this.skipFrozenRows = !0);
    const i = this.onNewRow(this.onNewBodyColumn, s);
    return e && this.addRowOutlineIfNecessary(e), i;
  }
  prepare(e) {
    super.prepare(e), this.columnsToExport = [...e], this.cols = e.map((t, s) => this.convertColumnToExcel(t, s));
  }
  parse() {
    const e = this.rows.reduce((r, o) => Math.max(r, o.cells.length), 0);
    for (; this.cols.length < e; )
      this.cols.push(this.convertColumnToExcel(null, this.cols.length + 1));
    const { config: t } = this;
    let s;
    if (t.sheetName != null) {
      const { sheetName: r } = t, o = typeof r == "function" ? r(this.gos.getGridCommonParams()) : r;
      s = String(o).substring(0, 31);
    } else
      s = "ag-grid";
    const i = {
      name: s,
      table: {
        columns: this.cols,
        rows: this.rows
      }
    };
    return this.createExcel(i);
  }
  addRowOutlineIfNecessary(e) {
    const { gos: t, suppressRowOutline: s, rowGroupExpandState: i = "expanded" } = this.config;
    if (t.get("groupHideOpenParents") || s || e.level == null)
      return;
    const o = e.footer ? 1 : 0, n = V(this.rows), a = Math.min(e.level + o, 7);
    if (n.outlineLevel = a, i === "expanded")
      return;
    const l = i === "collapsed";
    if (e.isExpandable()) {
      const d = !l && e.expanded;
      n.collapsed = !d;
    }
    n.hidden = // always show the node if there is no parent to be expanded
    !!e.parent && // or if it is a child of the root node
    e.parent.level !== -1 && (l || this.isAnyParentCollapsed(e.parent));
  }
  isAnyParentCollapsed(e) {
    for (; e && e.level !== -1; ) {
      if (!e.expanded)
        return !0;
      e = e.parent;
    }
    return !1;
  }
  convertColumnToExcel(e, t) {
    const s = this.config.columnWidth, r = (e ? this.extractHeaderValue(e) : void 0) ?? "", o = e ? e.isFilterAllowed() : !1;
    return s ? typeof s == "number" ? { width: s, displayName: r, filterAllowed: o } : { width: s({ column: e, index: t }), displayName: r, filterAllowed: o } : e ? { width: Math.max(e.getActualWidth(), 75), displayName: r, filterAllowed: o } : {
      displayName: r,
      filterAllowed: o
    };
  }
  onNewHeaderColumn(e, t) {
    return (s) => {
      const i = this.extractHeaderValue(s), r = this.config.styleLinker({
        rowType: "HEADER",
        rowIndex: e,
        value: i,
        column: s
      });
      t.push(
        this.createCell(this.getStyleId(r), this.getDataTypeForValue("string"), i)
      );
    };
  }
  onNewBodyColumn(e, t) {
    let s = 0;
    const { freezeColumns: i, rightToLeft: r } = this.config;
    return (o, n, a) => {
      if (s > 0) {
        s -= 1;
        return;
      }
      if (!this.skipFrozenColumns) {
        const g = o.getPinned();
        i === "pinned" && g && (g === !0 || g === "left") !== r ? this.frozenColumnCount++ : typeof i == "function" && i({ ...this.gos.getGridCommonParams(), column: o }) ? this.frozenColumnCount++ : this.skipFrozenColumns = !0;
      }
      const { value: l, valueFormatted: d } = this.extractRowCellValue(
        o,
        n,
        e,
        "excel",
        a
      ), c = this.config.styleLinker({
        rowType: "BODY",
        rowIndex: e,
        value: l,
        column: o,
        node: a
      }), h = this.getStyleId(c), u = o.getColSpan(a), p = this.addImage(e, o, l);
      p ? t.push(
        this.createCell(
          h,
          this.getDataTypeForValue(p.value),
          p.value == null ? "" : p.value
        )
      ) : u > 1 ? (s = u - 1, t.push(
        this.createMergedCell(
          h,
          this.getDataTypeForValue(l),
          l,
          u - 1
        )
      )) : t.push(
        this.createCell(h, this.getDataTypeForValue(l), l, d)
      );
    };
  }
  onNewRow(e, t) {
    const s = [];
    return this.rows.push({
      cells: s,
      height: ro(this.rows.length + 1, t)
    }), {
      onColumn: e.bind(this, this.rows.length, s)()
    };
  }
  createExcel(e) {
    const { excelStyles: t, config: s } = this;
    return this.frozenColumnCount && (s.frozenColumnCount = this.frozenColumnCount), this.frozenRowCount && (s.frozenRowCount = this.frozenRowCount), AA(t, e, s);
  }
  getDataTypeForValue(e) {
    return e === void 0 ? "empty" : this.isNumerical(e) ? "n" : "s";
  }
  getTypeFromStyle(e, t) {
    if (this.isFormula(t))
      return "f";
    if (e && e.dataType)
      switch (e.dataType.toLocaleLowerCase()) {
        case "formula":
          return "f";
        case "string":
          return "s";
        case "number":
          return "n";
        case "datetime":
          return "d";
        case "error":
          return "e";
        case "boolean":
          return "b";
        default:
          R(162, { id: e.id, dataType: e.dataType });
      }
    return null;
  }
  addImage(e, t, s) {
    if (!this.config.addImageToCell)
      return;
    const i = this.config.addImageToCell(e, t, s);
    if (i)
      return GA(i.image, e, t, this.columnsToExport, this.config.rowHeight), i;
  }
  createCell(e, t, s, i) {
    const r = this.getStyleById(e);
    !(r != null && r.dataType) && t === "s" && i && (s = i);
    const o = this.getTypeFromStyle(r, s) || t, { value: n, escaped: a } = this.getCellValue(o, s), l = [];
    return r && l.push(e), a && l.push("_quotePrefix"), e = this.getStyleId(l) || void 0, {
      styleId: e,
      data: {
        type: o,
        value: n
      }
    };
  }
  createMergedCell(e, t, s, i) {
    const r = s ?? "";
    return {
      styleId: this.getStyleById(e) ? e : void 0,
      data: {
        type: t,
        value: t === "s" ? Cc(r).toString() : s
      },
      mergeAcross: i
    };
  }
  getCellValue(e, t) {
    let s = !1;
    if (t == null || e === "s" && t === "")
      return { value: "", escaped: !1 };
    if (e === "s")
      t && t[0] === "'" && (s = !0, t = t.slice(1)), t = Cc(t).toString();
    else if (e === "f")
      t = t.slice(1);
    else if (e === "n") {
      const i = Number(t);
      isNaN(i) ? t = "" : t !== "" && (t = i.toString());
    }
    return { value: t, escaped: s };
  }
  getStyleId(e) {
    if (!e || !e.length)
      return null;
    if (e.length === 1)
      return e[0];
    const t = e.join("-");
    return this.mixedStyles[t] || this.addNewMixedStyle(e), this.mixedStyles[t].excelID;
  }
  deepCloneObject(e) {
    return JSON.parse(JSON.stringify(e));
  }
  addNewMixedStyle(e) {
    this.mixedStyleCounter += 1;
    const t = `mixedStyle${this.mixedStyleCounter}`, s = {};
    for (const r of e)
      for (const o of this.excelStyles)
        o.id === r && pe(s, this.deepCloneObject(o));
    s.id = t;
    const i = e.join("-");
    this.mixedStyles[i] = {
      excelID: t,
      key: i,
      result: s
    }, this.excelStyles.push(s), this.stylesByIds[t] = s;
  }
  isFormula(e) {
    return e == null ? !1 : this.config.autoConvertFormulas && e.toString().startsWith("=");
  }
  isNumerical(e) {
    return typeof e == "bigint" ? !0 : isFinite(e) && e !== "" && !isNaN(parseFloat(e));
  }
  getStyleById(e) {
    return e == null ? null : this.stylesByIds[e] || null;
  }
}, eI = async (e) => {
  let t = 0;
  const s = [], i = new WritableStream({
    write: (n) => {
      s.push(n), t += n.length;
    }
  }), r = new ReadableStream({
    start: (n) => {
      const a = new FileReader();
      a.onload = (l) => {
        var d;
        (d = l.target) != null && d.result && n.enqueue(l.target.result), n.close();
      }, a.readAsArrayBuffer(e);
    }
  }), o = new window.CompressionStream("deflate-raw");
  return await r.pipeThrough(o).pipeTo(i), {
    size: t,
    content: new Blob(s)
  };
}, tI = async (e) => {
  const t = new Blob([e]), { size: s, content: i } = await eI(t), r = new Uint8Array(await i.arrayBuffer());
  return {
    size: s,
    content: r
  };
}, sI = (e) => {
  let t = e.getHours();
  return t <<= 6, t = t | e.getMinutes(), t <<= 5, t = t | e.getSeconds() / 2, t;
}, iI = (e) => {
  let t = e.getFullYear() - 1980;
  return t <<= 4, t = t | e.getMonth() + 1, t <<= 5, t = t | e.getDate(), t;
};
function Ae(e, t) {
  let s = "";
  for (let i = 0; i < t; i++)
    s += String.fromCharCode(e & 255), e >>>= 8;
  return s;
}
var wc = (e) => {
  if (!e.length)
    return 0;
  let t = -1, s = 0, i = 0, r = 0;
  for (let o = 0; o < e.length; o++)
    s = e[o], i = (t ^ s) & 255, r = rI[i], t = t >>> 8 ^ r;
  return t ^ -1;
}, yc = (e) => e.length ? wc(typeof e == "string" ? new TextEncoder().encode(e) : e) : 0, rI = /* @__PURE__ */ new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function oI(e) {
  const t = String.fromCharCode;
  function s(h) {
    const u = [];
    if (!h)
      return [];
    const p = h.length;
    let g = 0, f, m;
    for (; g < p; )
      f = h.charCodeAt(g++), f >= 55296 && f <= 56319 && g < p ? (m = h.charCodeAt(g++), (m & 64512) == 56320 ? u.push(((f & 1023) << 10) + (m & 1023) + 65536) : (u.push(f), g--)) : u.push(f);
    return u;
  }
  function i(h) {
    if (h >= 55296 && h <= 57343)
      throw Error(ut(255, { point: h }));
  }
  function r(h, u) {
    return t(h >> u & 63 | 128);
  }
  function o(h) {
    if (!(h & 4294967168))
      return t(h);
    let u = "";
    return h & 4294965248 ? h & 4294901760 ? h & 4292870144 || (u = t(h >> 18 & 7 | 240), u += r(h, 12), u += r(h, 6)) : (i(h), u = t(h >> 12 & 15 | 224), u += r(h, 6)) : u = t(h >> 6 & 31 | 192), u += t(h & 63 | 128), u;
  }
  const n = s(e), a = n.length;
  let l = -1, d, c = "";
  for (; ++l < a; )
    d = n[l], c += o(d);
  return c;
}
var Rg = (e, t, s, i, r, o) => {
  const { content: n, path: a, created: l } = e, d = sI(l), c = iI(l), h = yc(r), u = o !== void 0 ? o : i, p = oI(a), g = p !== a;
  let f = "";
  if (g) {
    const b = Ae(1, 1) + Ae(yc(p), 4) + p;
    f = "up" + Ae(b.length, 2) + b;
  }
  const m = "\0" + // version needed to extract
  (g ? "\0\b" : "\0\0") + // Language encoding flag (EFS) (12th bit turned on)
  Ae(t ? 8 : 0, 2) + // As per ECMA-376 Part 2 specs
  Ae(d, 2) + // last modified time
  Ae(c, 2) + // last modified date
  Ae(u ? h : 0, 4) + Ae(o ?? i, 4) + // compressed size
  Ae(i, 4) + // uncompressed size
  Ae(p.length, 2) + // file name length
  Ae(f.length, 2), C = "PK" + m + p + f, v = "PK\0" + m + // file header
  "\0\0\0\0\0\0" + (n ? "\0\0\0\0" : "\0\0\0") + // external file attributes
  Ae(s, 4) + // relative offset of local header
  p + // file name
  f;
  return {
    localFileHeader: Uint8Array.from(C, (b) => b.charCodeAt(0)),
    centralDirectoryHeader: Uint8Array.from(v, (b) => b.charCodeAt(0))
  };
}, Pg = (e) => {
  let t;
  if (typeof e == "string") {
    const s = atob(e.split(";base64,")[1]);
    t = Uint8Array.from(s, (i) => i.charCodeAt(0));
  } else
    t = e;
  return {
    size: t.length,
    content: t
  };
}, nI = async (e, t) => {
  const { content: s } = e, { size: i, content: r } = s ? Pg(s) : { size: 0, content: Uint8Array.from([]) };
  let o, n, a = !1;
  if (e.type === "file" && r && i > 0) {
    const c = await tI(r);
    o = c.content, n = c.size, a = !0;
  }
  return {
    ...Rg(e, a, t, i, r, n),
    content: o || r,
    isCompressed: a
  };
}, aI = (e, t) => {
  const { content: s } = e, { content: i } = s ? Pg(s) : { content: Uint8Array.from([]) };
  return {
    ...Rg(e, !1, t, i.length, i, void 0),
    content: i,
    isCompressed: !1
  };
}, lI = (e, t, s) => {
  const i = "PK\0\0\0\0" + Ae(e, 2) + // total number of entries in the central folder
  Ae(e, 2) + // total number of entries in the central folder
  Ae(t, 4) + // size of the central folder
  Ae(s, 4) + // central folder start offset
  "\0\0";
  return Uint8Array.from(i, (r) => r.charCodeAt(0));
}, Tg = class {
  constructor() {
    this.folders = [], this.files = [];
  }
  addFolders(e) {
    e.forEach(this.addFolder.bind(this));
  }
  addFolder(e) {
    this.folders.push({
      path: e,
      created: /* @__PURE__ */ new Date(),
      isBase64: !1,
      type: "folder"
    });
  }
  addFile(e, t, s = !1) {
    this.files.push({
      path: e,
      created: /* @__PURE__ */ new Date(),
      content: s ? t : new TextEncoder().encode(t),
      isBase64: s,
      type: "file"
    });
  }
  async getZipFile(e = "application/zip") {
    const t = await this.buildCompressedFileStream();
    return this.clearStream(), new Blob([t], { type: e });
  }
  getUncompressedZipFile(e = "application/zip") {
    const t = this.buildFileStream();
    return this.clearStream(), new Blob([t], { type: e });
  }
  clearStream() {
    this.folders = [], this.files = [];
  }
  packageFiles(e) {
    let t = 0, s = 0;
    for (const d of e) {
      const { localFileHeader: c, centralDirectoryHeader: h, content: u } = d;
      t += c.length + u.length, s += h.length;
    }
    const i = new Uint8Array(t), r = new Uint8Array(s);
    let o = 0, n = 0;
    for (const d of e) {
      const { localFileHeader: c, centralDirectoryHeader: h, content: u } = d;
      i.set(c, o), o += c.length, i.set(u, o), o += u.length, r.set(h, n), n += h.length;
    }
    const a = lI(e.length, s, t), l = new Uint8Array(i.length + r.length + a.length);
    return l.set(i), l.set(r, i.length), l.set(a, i.length + r.length), l;
  }
  async buildCompressedFileStream() {
    const e = [...this.folders, ...this.files], t = [];
    let s = 0;
    for (const i of e) {
      const r = await nI(i, s), { localFileHeader: o, content: n } = r;
      t.push(r), s += o.length + n.length;
    }
    return this.packageFiles(t);
  }
  buildFileStream() {
    const e = [...this.folders, ...this.files], t = [];
    let s = 0;
    for (const i of e) {
      const r = aI(i, s), { localFileHeader: o, content: n } = r;
      t.push(r), s += o.length + n.length;
    }
    return this.packageFiles(t);
  }
}, dI = (e) => {
  if (e.addFolders(["_rels/", "docProps/", "xl/", "xl/theme/", "xl/_rels/", "xl/worksheets/"]), !Qs.size)
    return;
  e.addFolders(["xl/worksheets/_rels", "xl/drawings/", "xl/drawings/_rels", "xl/media/"]);
  let t = 0;
  Qs.forEach((s) => {
    const i = s[0].image[0], { base64: r, imageType: o } = i;
    e.addFile(`xl/media/image${++t}.${fn(o)}`, r, !0);
  });
}, cI = (e, t) => {
  let s = 0, i = 0;
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    e.addFile(`xl/worksheets/sheet${r + 1}.xml`, o, !1);
    const n = Qs.size > 0 && Js.has(r), a = Jt.size > 0 && Jt.get(r), l = Qs.size && Fs.has(r);
    if (!n && !a && !l)
      continue;
    let d, c, h;
    n && (hI(e, r, s), c = s, s++), l && (uI(e, r, i), h = i, i++), a && (d = a.name);
    const u = `xl/worksheets/_rels/sheet${r + 1}.xml.rels`;
    e.addFile(
      u,
      ZA({
        tableName: d,
        drawingIndex: c,
        vmlDrawingIndex: h
      })
    );
  }
}, hI = (e, t, s) => {
  const i = "xl/drawings", r = `${i}/drawing${s + 1}.xml`, o = `${i}/_rels/drawing${s + 1}.xml.rels`;
  e.addFile(o, qA(t)), e.addFile(r, jA(t));
}, uI = (e, t, s) => {
  const i = "xl/drawings", r = `${i}/vmlDrawing${s + 1}.vml`, o = `${i}/_rels/vmlDrawing${s + 1}.vml.rels`;
  e.addFile(r, YA(t)), e.addFile(o, XA(t));
}, pI = (e) => {
  const t = Jt, s = Array.from(t.keys());
  for (let i = 0; i < s.length; i++) {
    const r = s[i], o = t.get(r);
    o && e.addFile(`xl/tables/${o.name}.xml`, KA(o, i));
  }
}, gI = (e, t, s, i, r) => {
  e.addFile("xl/workbook.xml", VA(r)), e.addFile("xl/styles.xml", NA(t)), e.addFile("xl/sharedStrings.xml", HA()), e.addFile("xl/theme/theme1.xml", UA()), e.addFile("xl/_rels/workbook.xml.rels", $A(i)), e.addFile("docProps/core.xml", zA(s)), e.addFile("[Content_Types].xml", WA(i)), e.addFile("_rels/.rels", _A());
}, Dg = (e, t, s = {}) => {
  if (!t || t.length === 0)
    return R(159), vc(), !1;
  const { fontSize: i = 11, author: r = "AG Grid", activeTab: o = 0 } = s, n = t.length, a = Math.max(Math.min(o, n - 1), 0);
  return dI(e), pI(e), cI(e, t), gI(e, i, r, n, a), vc(), !0;
}, Eg = (e) => {
  const { data: t, fontSize: s, author: i, activeSheetIndex: r } = e, o = e.mimeType || "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", n = new Tg();
  return Dg(n, t, {
    author: i,
    fontSize: s,
    activeTab: r
  }) ? n.getZipFile(o) : Promise.resolve(void 0);
}, bc = (e) => {
  const { data: t, fontSize: s, author: i, activeSheetIndex: r } = e, o = e.mimeType || "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", n = new Tg();
  if (Dg(n, t, {
    author: i,
    fontSize: s,
    activeTab: r
  }))
    return n.getUncompressedZipFile(o);
}, fI = (e) => {
  const { fileName: t = "export.xlsx" } = e;
  Eg(e).then((s) => {
    if (s) {
      const i = typeof t == "function" ? t() : t;
      zl(i, s);
    }
  });
}, mI = class extends Bp {
  constructor() {
    super(...arguments), this.beanName = "excelCreator";
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultExcelExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      R(160);
      return;
    }
    const t = this.getMergedParams(e), i = {
      data: [this.getData(t)],
      fontSize: t.fontSize,
      author: t.author,
      mimeType: t.mimeType
    };
    this.packageCompressedFile(i).then((r) => {
      if (r) {
        const { fileName: o } = t, n = typeof o == "function" ? o(this.gos.getGridCommonParams()) : o;
        zl(this.getFileName(n), r);
      }
    });
  }
  exportDataAsExcel(e) {
    this.export(e);
  }
  getDataAsExcel(e) {
    const t = this.getMergedParams(e), i = {
      data: [this.getData(t)],
      fontSize: t.fontSize,
      author: t.author,
      mimeType: t.mimeType
    };
    return this.packageFile(i);
  }
  setFactoryMode(e) {
    MA(e);
  }
  getFactoryMode() {
    return EA();
  }
  getSheetDataForExcel(e) {
    const t = this.getMergedParams(e);
    return this.getData(t);
  }
  getMultipleSheetsAsExcel(e) {
    return bc(e);
  }
  exportMultipleSheetsAsExcel(e) {
    fI(e);
  }
  getDefaultFileExtension() {
    return "xlsx";
  }
  createSerializingSession(e) {
    const { colModel: t, colNames: s, rowGroupColsSvc: i, valueSvc: r, gos: o } = this.beans, n = {
      ...e,
      colModel: t,
      colNames: s,
      rowGroupColsSvc: i,
      valueSvc: r,
      gos: o,
      suppressRowOutline: e.suppressRowOutline || e.skipRowGroups,
      headerRowHeight: e.headerRowHeight || e.rowHeight,
      baseExcelStyles: o.get("excelStyles") || [],
      rightToLeft: e.rightToLeft ?? o.get("enableRtl"),
      styleLinker: this.styleLinker.bind(this)
    };
    return new JA(n);
  }
  styleLinker(e) {
    const { rowType: t, rowIndex: s, value: i, column: r, columnGroup: o, node: n } = e, a = t === "HEADER", l = t === "HEADER_GROUPING", d = a ? r : o;
    let c = [];
    const { gos: h, cellStyles: u } = this.beans;
    if (a || l)
      return c.push("header"), l && c.push("headerGroup"), d && (c = c.concat(
        fl(
          d.getDefinition(),
          h,
          r || null,
          o || null
        )
      )), c;
    const p = h.get("excelStyles"), g = ["cell"];
    if (!p || !p.length)
      return g;
    const f = p.map((C) => C.id), m = r.getDefinition();
    return u == null || u.processAllCellClasses(
      m,
      h.addGridCommonParams({
        value: i,
        data: n.data,
        node: n,
        colDef: m,
        column: r,
        rowIndex: s
      }),
      (C) => {
        f.indexOf(C) > -1 && g.push(C);
      }
    ), g.sort((C, v) => f.indexOf(C) < f.indexOf(v) ? -1 : 1);
  }
  isExportSuppressed() {
    return this.gos.get("suppressExcelExport");
  }
  packageCompressedFile(e) {
    return Eg(e);
  }
  packageFile(e) {
    return bc(e);
  }
}, j = "33.0.2", te = {
  moduleName: "EnterpriseCore",
  version: j,
  beans: [mg],
  icons: {
    // accordion open (filter tool panel group, charts group)
    accordionOpen: "tree-open",
    // accordion closed (filter tool panel group, charts group)
    accordionClosed: "tree-closed",
    // accordion indeterminate - shown when some children are expanded and
    //     others are collapsed (filter tool panel group, charts group)
    accordionIndeterminate: "tree-indeterminate",
    // dialog title bar
    close: "cross",
    // X (remove) on column 'pill' after adding it to a drop zone list
    cancel: "cancel",
    // button in chart regular size window title bar (click to maximise)
    maximize: "maximize",
    // button in chart maximised window title bar (click to make regular size)
    minimize: "minimize",
    // drag handle used to pick up draggable columns
    columnDrag: "grip"
  },
  dependsOn: []
}, CI = (
  /*css*/
  '.ag-advanced-filter-header{align-items:center;background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);display:flex;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);position:relative}.ag-advanced-filter{align-items:center;display:flex;width:100%}.ag-advanced-filter-apply-button,.ag-advanced-filter-builder-button{line-height:normal;white-space:nowrap}:where(.ag-ltr) .ag-advanced-filter-apply-button,:where(.ag-ltr) .ag-advanced-filter-builder-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-advanced-filter-apply-button,:where(.ag-rtl) .ag-advanced-filter-builder-button{margin-right:calc(var(--ag-spacing)*2)}.ag-advanced-filter-builder-button{align-items:center;background-color:unset;border:0;display:flex;font-size:var(--ag-font-size);font-weight:600;padding:var(--ag-spacing);&:where(:not(:disabled)){cursor:pointer;&:hover{background-color:var(--ag-row-hover-color)}}}:where(.ag-ltr) .ag-advanced-filter-builder-button-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-advanced-filter-builder-button-label{margin-right:var(--ag-spacing)}.ag-advanced-filter-builder{display:flex;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-advanced-filter-builder-list{flex:1;overflow:auto}.ag-advanced-filter-builder-button-panel{border-top:var(--ag-advanced-filter-builder-button-bar-border);display:flex;justify-content:flex-end;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-advanced-filter-builder-apply-button,:where(.ag-ltr) .ag-advanced-filter-builder-cancel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-advanced-filter-builder-apply-button,:where(.ag-rtl) .ag-advanced-filter-builder-cancel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-advanced-filter-builder-item-wrapper{align-items:center;display:flex;flex:1 1 auto;justify-content:space-between;overflow:hidden}:where(.ag-ltr) .ag-advanced-filter-builder-item-wrapper{padding-left:calc(var(--ag-icon-size)/2);padding-right:var(--ag-icon-size)}:where(.ag-rtl) .ag-advanced-filter-builder-item-wrapper{padding-left:var(--ag-icon-size);padding-right:calc(var(--ag-icon-size)/2)}:where(.ag-virtual-list-viewport .ag-advanced-filter-builder-item-wrapper) .ag-tab-guard{position:absolute}.ag-advanced-filter-builder-item-tree-lines>*{width:var(--ag-advanced-filter-builder-indent-size)}.ag-advanced-filter-builder-item-tree-line-root{width:var(--ag-icon-size);&:before{height:50%;top:50%}}.ag-advanced-filter-builder-item-tree-line-horizontal,.ag-advanced-filter-builder-item-tree-line-vertical,.ag-advanced-filter-builder-item-tree-line-vertical-bottom,.ag-advanced-filter-builder-item-tree-line-vertical-top{align-items:center;display:flex;height:100%;position:relative;&:after,&:before{content:"";height:100%;position:absolute}}.ag-advanced-filter-builder-item-tree-line-horizontal:after{border-bottom:1px solid var(--ag-border-color);height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size))}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-horizontal:after{left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-horizontal:after{right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical:before{top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-top:before{height:50%;top:0;width:calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical-top:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{height:calc(50% - var(--ag-icon-size)*1.5/2);top:calc(50% + var(--ag-icon-size)*1.5/2);width:calc(var(--ag-icon-size)/2)}:where(.ag-ltr) .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-left:1px solid var(--ag-border-color);left:calc(var(--ag-icon-size)/2)}:where(.ag-rtl) .ag-advanced-filter-builder-item-tree-line-vertical-bottom:before{border-right:1px solid var(--ag-border-color);right:calc(var(--ag-icon-size)/2)}.ag-advanced-filter-builder-item-condition{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing)}.ag-advanced-filter-builder-item,.ag-advanced-filter-builder-item-buttons,.ag-advanced-filter-builder-item-condition,.ag-advanced-filter-builder-item-tree-lines,.ag-advanced-filter-builder-pill,.ag-advanced-filter-builder-pill-wrapper{align-items:center;display:flex;height:100%}.ag-advanced-filter-builder-pill-wrapper{margin:0 var(--ag-spacing)}.ag-advanced-filter-builder-pill{border-radius:var(--ag-border-radius);min-height:calc(100% - var(--ag-spacing)*3);min-width:calc(var(--ag-spacing)*2);padding:var(--ag-spacing) calc(var(--ag-spacing)*2);position:relative}:where(.ag-advanced-filter-builder-pill){.ag-advanced-filter-builder-value-number{font-family:monospace;font-weight:700}.ag-advanced-filter-builder-value-empty{color:var(--ag-subtle-text-color)}}:where(.ag-ltr) :where(.ag-advanced-filter-builder-pill){.ag-picker-field-display{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-advanced-filter-builder-pill){.ag-picker-field-display{margin-left:var(--ag-spacing)}}.ag-advanced-filter-builder-pill-display{font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-advanced-filter-builder-join-pill{background-color:var(--ag-advanced-filter-builder-join-pill-color);cursor:pointer}.ag-advanced-filter-builder-column-pill{background-color:var(--ag-advanced-filter-builder-column-pill-color);cursor:pointer}.ag-advanced-filter-builder-option-pill{background-color:var(--ag-advanced-filter-builder-option-pill-color);cursor:pointer}.ag-advanced-filter-builder-value-pill{background-color:var(--ag-advanced-filter-builder-value-pill-color);cursor:text;max-width:140px;:where(.ag-advanced-filter-builder-pill-display){display:block}}.ag-advanced-filter-builder-item-buttons>*{margin:0 calc(var(--ag-spacing)*.5)}.ag-advanced-filter-builder-item-button{color:var(--ag-subtle-text-color);cursor:pointer;position:relative}.ag-advanced-filter-builder-item-button,.ag-advanced-filter-builder-pill{&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-advanced-filter-builder-item-button-disabled{cursor:default;opacity:.5}.ag-advanced-filter-builder-virtual-list-container{top:var(--ag-spacing)}.ag-advanced-filter-builder-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:hover{background-color:var(--ag-row-hover-color);:where(.ag-advanced-filter-builder-item-button){opacity:1}}}.ag-advanced-filter-builder-invalid{color:var(--ag-invalid-color);cursor:default;margin:0 var(--ag-spacing)}:where(.ag-advanced-filter-builder-validation) .ag-advanced-filter-builder-invalid,:where(.ag-advanced-filter-builder-virtual-list-item-highlight) .ag-advanced-filter-builder-item-button:focus-visible{opacity:1}'
);
function vI(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getAdvFilterModel()) ?? null;
}
function wI(e, t) {
  var s;
  (s = e.filterManager) == null || s.setAdvFilterModel(t);
}
function yI(e) {
  var t;
  (t = e.filterManager) == null || t.toggleAdvFilterBuilder(!0, "api");
}
function bI(e) {
  var t;
  (t = e.filterManager) == null || t.toggleAdvFilterBuilder(!1, "api");
}
var SI = {
  ariaAdvancedFilterBuilderItem: (e) => `${e[0]}. Level ${e[1]}. Press ENTER to edit`,
  ariaAdvancedFilterBuilderItemValidation: (e) => `${e[0]}. Level ${e[1]}. ${e[2]} Press ENTER to edit`,
  ariaAdvancedFilterBuilderList: "Advanced Filter Builder List",
  ariaAdvancedFilterBuilderFilterItem: "Filter Condition",
  ariaAdvancedFilterBuilderGroupItem: "Filter Group",
  ariaAdvancedFilterBuilderColumn: "Column",
  ariaAdvancedFilterBuilderOption: "Option",
  ariaAdvancedFilterBuilderValue: "Value",
  ariaAdvancedFilterBuilderJoinOperator: "Join Operator",
  ariaAdvancedFilterInput: "Advanced Filter Input",
  ariaLabelAdvancedFilterAutocomplete: "Advanced Filter Autocomplete",
  advancedFilterContains: "contains",
  advancedFilterNotContains: "does not contain",
  advancedFilterTextEquals: "equals",
  advancedFilterTextNotEqual: "does not equal",
  advancedFilterStartsWith: "begins with",
  advancedFilterEndsWith: "ends with",
  advancedFilterBlank: "is blank",
  advancedFilterNotBlank: "is not blank",
  advancedFilterEquals: "=",
  advancedFilterNotEqual: "!=",
  advancedFilterGreaterThan: ">",
  advancedFilterGreaterThanOrEqual: ">=",
  advancedFilterLessThan: "<",
  advancedFilterLessThanOrEqual: "<=",
  advancedFilterTrue: "is true",
  advancedFilterFalse: "is false",
  advancedFilterAnd: "AND",
  advancedFilterOr: "OR",
  advancedFilterApply: "Apply",
  advancedFilterBuilder: "Builder",
  advancedFilterValidationMissingColumn: "Column is missing",
  advancedFilterValidationMissingOption: "Option is missing",
  advancedFilterValidationMissingValue: "Value is missing",
  advancedFilterValidationInvalidColumn: "Column not found",
  advancedFilterValidationInvalidOption: "Option not found",
  advancedFilterValidationMissingQuote: "Value is missing an end quote",
  advancedFilterValidationNotANumber: "Value is not a number",
  advancedFilterValidationInvalidDate: "Value is not a valid date",
  advancedFilterValidationMissingCondition: "Condition is missing",
  advancedFilterValidationJoinOperatorMismatch: "Join operators within a condition must be the same",
  advancedFilterValidationInvalidJoinOperator: "Join operator not found",
  advancedFilterValidationMissingEndBracket: "Missing end bracket",
  advancedFilterValidationExtraEndBracket: "Too many end brackets",
  advancedFilterValidationMessage: (e) => `Expression has an error. ${e[0]} - ${e[1]}.`,
  advancedFilterValidationMessageAtEnd: (e) => `Expression has an error. ${e[0]} at end of expression.`,
  advancedFilterBuilderTitle: "Advanced Filter",
  advancedFilterBuilderApply: "Apply",
  advancedFilterBuilderCancel: "Cancel",
  advancedFilterBuilderAddButtonTooltip: "Add Filter or Group",
  advancedFilterBuilderRemoveButtonTooltip: "Remove",
  advancedFilterBuilderMoveUpButtonTooltip: "Move Up",
  advancedFilterBuilderMoveDownButtonTooltip: "Move Down",
  advancedFilterBuilderAddJoin: "Add Group",
  advancedFilterBuilderAddCondition: "Add Filter",
  advancedFilterBuilderSelectColumn: "Select a column",
  advancedFilterBuilderSelectOption: "Select an option",
  advancedFilterBuilderEnterValue: "Enter a value...",
  advancedFilterBuilderValidationAlreadyApplied: "Current filter already applied.",
  advancedFilterBuilderValidationIncomplete: "Not all conditions are complete.",
  advancedFilterBuilderValidationSelectColumn: "Must select a column.",
  advancedFilterBuilderValidationSelectOption: "Must select an option.",
  advancedFilterBuilderValidationEnterValue: "Must enter a value."
};
function Va(e, t, s) {
  if (!e)
    return "";
  const i = s - t;
  return i ? e.slice(0, e.length - i) : e;
}
function Cs(e, t, s, i, r, o, n) {
  const a = s + (!e.length || n ? 0 : 1);
  let l = 0;
  return r && (e[a] === " " ? l = 1 : (i += " ", o && (i += '"'))), { updatedValue: e.slice(0, t) + i + e.slice(a), updatedPosition: t + i.length + l };
}
function xI(e, t, s) {
  let i = t;
  for (; i < s && e[i] === " "; )
    i++;
  return i;
}
function Na(e, t, s, i) {
  let r = t, o = !1;
  for (; r < e.length; ) {
    const n = e[r];
    if (n === "(") {
      i && e[r - 1] === " " ? o = !0 : r = r - 1;
      break;
    } else if (n === " " || s && n === ")") {
      r = r - 1;
      break;
    }
    r++;
  }
  return { endPosition: r, isEmpty: o };
}
function Kl(e, t, s, i) {
  s !== t && (e.expression = Cs(
    e.expression,
    i - t.length + 1,
    i,
    s
  ).updatedValue);
}
function FI(e) {
  return e.replace(/(['"])/, "\\$1");
}
var RI = class {
  constructor(e, t) {
    this.params = e, this.startPosition = t, this.type = "column", this.valid = !0, this.hasStartChar = !1, this.hasEndChar = !1, this.colName = "";
  }
  parse(e, t) {
    if (e === Ha && !this.colName)
      this.hasStartChar = !0;
    else if (e === za && this.hasStartChar) {
      if (this.parseColumn(!1, t))
        return this.hasEndChar = !0, !1;
      this.colName += e;
    } else
      this.colName += e;
  }
  getDisplayValue() {
    return (this.hasStartChar ? Ha : "") + this.colName + (this.hasEndChar ? za : "");
  }
  getColId() {
    return this.colId;
  }
  complete(e) {
    this.parseColumn(!0, e);
  }
  getValidationError() {
    return this.valid ? null : {
      message: this.params.advFilterExpSvc.translate("advancedFilterValidationInvalidColumn"),
      startPosition: this.startPosition,
      endPosition: this.endPosition ?? this.params.expression.length - 1
    };
  }
  parseColumn(e, t) {
    var i;
    this.endPosition = t;
    const s = this.params.advFilterExpSvc.getColId(this.colName);
    return s && this.hasStartChar && (this.colId = s.colId, Kl(this.params, this.colName, s.columnName, t - 1), this.colName = s.columnName, this.column = this.params.colModel.getColDefCol(this.colId), this.column) ? (this.baseCellDataType = ((i = this.params.dataTypeSvc) == null ? void 0 : i.getBaseDataType(this.column)) ?? "text", !0) : (e && (this.valid = !1), this.baseCellDataType = "text", !1);
  }
}, PI = class {
  constructor(e, t, s) {
    this.params = e, this.startPosition = t, this.baseCellDataType = s, this.type = "operator", this.valid = !0, this.expectedNumOperands = 0, this.operator = "";
  }
  parse(e, t) {
    if (e === " " || e === ")") {
      if (this.parseOperator(!1, t - 1))
        return !0;
      this.operator += e;
    } else
      this.operator += e;
  }
  complete(e) {
    this.parseOperator(!0, e);
  }
  getValidationError() {
    return this.valid ? null : {
      message: this.params.advFilterExpSvc.translate("advancedFilterValidationInvalidOption"),
      startPosition: this.startPosition,
      endPosition: this.endPosition ?? this.params.expression.length - 1
    };
  }
  getDisplayValue() {
    return this.operator;
  }
  getOperatorKey() {
    return this.parsedOperator;
  }
  parseOperator(e, t) {
    const s = this.params.advFilterExpSvc.getDataTypeExpressionOperator(this.baseCellDataType), i = s.findOperator(this.operator);
    if (this.endPosition = t, i) {
      this.parsedOperator = i;
      const o = s.operators[i];
      this.expectedNumOperands = o.numOperands;
      const n = o.displayValue;
      return Kl(this.params, this.operator, n, t), this.operator = n, !0;
    }
    return (e || !(i === null)) && (this.valid = !1), !1;
  }
}, TI = class {
  constructor(e, t, s, i) {
    this.params = e, this.startPosition = t, this.baseCellDataType = s, this.column = i, this.type = "operand", this.valid = !0, this.operand = "", this.validationMessage = null;
  }
  parse(e, t) {
    if (e === " ")
      if (this.quotes)
        this.operand += e;
      else
        return this.parseOperand(!1, t), !0;
    else if (e === ")") {
      if (this.baseCellDataType === "number" || !this.quotes)
        return this.parseOperand(!1, t - 1), !0;
      this.operand += e;
    } else if (!this.operand && !this.quotes && (e === "'" || e === '"'))
      this.quotes = e;
    else {
      if (this.quotes && e === this.quotes)
        return this.parseOperand(!1, t), !1;
      this.operand += e;
    }
  }
  complete(e) {
    this.parseOperand(!0, e);
  }
  getValidationError() {
    return this.validationMessage ? {
      message: this.validationMessage,
      startPosition: this.startPosition,
      endPosition: this.endPosition ?? this.params.expression.length - 1
    } : null;
  }
  getRawValue() {
    return this.operand;
  }
  getModelValue() {
    return this.modelValue;
  }
  parseOperand(e, t) {
    const { advFilterExpSvc: s } = this.params;
    if (this.endPosition = t, this.modelValue = this.operand, e && this.quotes)
      this.valid = !1, this.validationMessage = s.translate("advancedFilterValidationMissingQuote");
    else if (this.modelValue === "")
      this.valid = !1, this.validationMessage = s.translate("advancedFilterValidationMissingValue");
    else {
      const i = s.getOperandModelValue(this.operand, this.baseCellDataType, this.column);
      switch (i != null && (this.modelValue = i), this.baseCellDataType) {
        case "number":
          (this.quotes || isNaN(this.modelValue)) && (this.valid = !1, this.validationMessage = s.translate("advancedFilterValidationNotANumber"));
          break;
        case "date":
        case "dateString":
          i == null && (this.valid = !1, this.validationMessage = s.translate("advancedFilterValidationInvalidDate"));
          break;
      }
    }
  }
}, Ha = "[", za = "]", DI = class {
  constructor(e, t) {
    this.params = e, this.startPosition = t, this.isAwaiting = !0;
  }
  parseExpression() {
    var s, i;
    let e = this.startPosition;
    const { expression: t } = this.params;
    for (; e < t.length; ) {
      const r = t[e];
      if (!(r === " " && this.isAwaiting)) {
        if (this.isAwaiting = !1, !this.parser) {
          let n;
          this.columnParser ? this.operatorParser ? (this.operandParser = new TI(
            this.params,
            e,
            this.columnParser.baseCellDataType,
            this.columnParser.column
          ), n = this.operandParser) : (this.operatorParser = new PI(this.params, e, this.columnParser.baseCellDataType), n = this.operatorParser) : (this.columnParser = new RI(this.params, e), n = this.columnParser), this.parser = n;
        }
        const o = this.parser.parse(r, e);
        if (o != null) {
          if (this.isComplete())
            return this.returnEndPosition(o ? e - 1 : e, !0);
          this.parser = void 0, this.isAwaiting = !0;
        }
      }
      e++;
    }
    return (i = (s = this.parser) == null ? void 0 : s.complete) == null || i.call(s, e - 1), this.returnEndPosition(e);
  }
  isValid() {
    return this.isComplete() && this.columnParser.valid && this.operatorParser.valid && (!this.operandParser || this.operandParser.valid);
  }
  getValidationError() {
    var i, r, o;
    const e = ((i = this.columnParser) == null ? void 0 : i.getValidationError()) ?? ((r = this.operatorParser) == null ? void 0 : r.getValidationError()) ?? ((o = this.operandParser) == null ? void 0 : o.getValidationError());
    if (e)
      return e;
    const t = this.params.expression.length;
    let s;
    return this.columnParser ? this.operatorParser ? this.operatorParser.expectedNumOperands && !this.operandParser && (s = "advancedFilterValidationMissingValue") : s = "advancedFilterValidationMissingOption" : s = "advancedFilterValidationMissingColumn", s ? {
      message: this.params.advFilterExpSvc.translate(s),
      startPosition: t,
      endPosition: t
    } : null;
  }
  getFunctionString(e) {
    return this.getFunctionCommon(e, (t, s, i, r) => {
      const o = FI(i), n = t == null ? "" : `, params.operands[${t}]`;
      return `params.operators[${s}].evaluator(expressionProxy.getValue('${o}', node), node, params.evaluatorParams[${r}]${n})`;
    });
  }
  getFunctionParsed(e) {
    return this.getFunctionCommon(e, (t, s, i, r) => (o, n, a) => a.operators[s].evaluator(
      o.getValue(i, n),
      n,
      a.evaluatorParams[r],
      t == null ? void 0 : a.operands[t]
    ));
  }
  getAutocompleteListParams(e) {
    if (this.isColumnPosition(e))
      return this.getColumnAutocompleteListParams(e);
    if (this.isOperatorPosition(e))
      return this.getOperatorAutocompleteListParams(e);
    if (!this.isBeyondEndPosition(e))
      return { enabled: !1 };
  }
  updateExpression(e, t, s) {
    var r, o, n;
    const { expression: i } = this.params;
    if (this.isColumnPosition(e))
      return Cs(
        this.params.expression,
        this.startPosition,
        (r = this.columnParser) != null && r.getColId() ? this.columnParser.endPosition : Na(i, e).endPosition,
        this.params.advFilterExpSvc.getColumnValue(t),
        !0
      );
    if (this.isOperatorPosition(e)) {
      const a = this.getBaseCellDataTypeFromOperatorAutocompleteType(s), l = this.hasOperand(a, t.key), d = l && this.doesOperandNeedQuotes(a);
      let c;
      if (((o = this.operatorParser) == null ? void 0 : o.startPosition) != null && e < this.operatorParser.startPosition)
        c = Cs(
          i,
          e,
          e,
          t.displayValue ?? t.key,
          l,
          d
        );
      else {
        let h, u = !1;
        if ((n = this.operatorParser) != null && n.getOperatorKey())
          h = this.operatorParser.endPosition;
        else {
          const { endPosition: p, isEmpty: g } = Na(
            i,
            e,
            !0,
            !0
          );
          h = p, u = g;
        }
        c = Cs(
          i,
          xI(i, this.columnParser.endPosition + 1, h),
          h,
          t.displayValue ?? t.key,
          l,
          d,
          u
        );
      }
      return { ...c, hideAutocomplete: !l };
    }
    return null;
  }
  getModel() {
    const e = this.columnParser.getColId(), t = {
      filterType: this.columnParser.baseCellDataType,
      colId: e,
      type: this.operatorParser.getOperatorKey()
    };
    return this.operatorParser.expectedNumOperands && (t.filter = this.operandParser.getModelValue()), t;
  }
  getFunctionCommon(e, t) {
    var u, p;
    const s = this.columnParser.getColId(), i = (u = this.operatorParser) == null ? void 0 : u.getOperatorKey(), { operators: r, evaluatorParams: o, operands: n } = e, a = this.params.advFilterExpSvc.getExpressionOperator(
      this.columnParser.baseCellDataType,
      i
    ), l = this.addToListAndGetIndex(r, a), d = this.params.advFilterExpSvc.getExpressionEvaluatorParams(s), c = this.addToListAndGetIndex(o, d), h = ((p = this.operatorParser) == null ? void 0 : p.expectedNumOperands) === 0 ? void 0 : this.addToListAndGetIndex(n, this.getOperandValue());
    return t(h, l, s, c);
  }
  getOperandValue() {
    let e = this.operandParser.getRawValue();
    const { baseCellDataType: t, column: s } = this.columnParser;
    switch (t) {
      case "number":
        e = Number(e);
        break;
      case "date":
      case "dateString":
        e = this.params.valueSvc.parseValue(s, null, e, void 0);
        break;
    }
    if (t === "dateString") {
      const { dataTypeSvc: i } = this.params;
      return i ? i.getDateParserFunction(s)(e) : e;
    }
    return e;
  }
  isComplete() {
    return !!(this.operatorParser && (!this.operatorParser.expectedNumOperands || this.operatorParser.expectedNumOperands && this.operandParser));
  }
  isColumnPosition(e) {
    return !this.columnParser || this.columnParser.endPosition == null || e <= this.columnParser.endPosition + 1;
  }
  isOperatorPosition(e) {
    return !this.operatorParser || this.operatorParser.endPosition == null || e <= this.operatorParser.endPosition + 1;
  }
  isBeyondEndPosition(e) {
    return this.isComplete() && this.endPosition != null && e > this.endPosition + 1 && this.endPosition + 1 < this.params.expression.length;
  }
  returnEndPosition(e, t) {
    return this.endPosition = t ? e : e - 1, e;
  }
  getColumnAutocompleteListParams(e) {
    return this.params.advFilterExpSvc.generateAutocompleteListParams(
      this.params.advFilterExpSvc.getColumnAutocompleteEntries(),
      "column",
      this.getColumnSearchString(e)
    );
  }
  getColumnSearchString(e) {
    var o, n, a, l;
    const t = ((o = this.columnParser) == null ? void 0 : o.getDisplayValue()) ?? "", s = Va(
      t,
      e,
      ((n = this.columnParser) == null ? void 0 : n.endPosition) == null ? this.params.expression.length : this.columnParser.endPosition + 1
    ), i = ((a = this.columnParser) == null ? void 0 : a.hasStartChar) && s.length > 0, r = ((l = this.columnParser) == null ? void 0 : l.hasEndChar) && s.length === t.length + 2;
    return i ? s.slice(1, r ? -1 : void 0) : s;
  }
  getOperatorAutocompleteListParams(e) {
    var r, o, n, a;
    const t = (r = this.columnParser) == null ? void 0 : r.column;
    if (!t)
      return { enabled: !1 };
    const s = this.columnParser.baseCellDataType, i = ((o = this.operatorParser) == null ? void 0 : o.startPosition) != null && e < this.operatorParser.startPosition ? "" : Va(
      ((n = this.operatorParser) == null ? void 0 : n.getDisplayValue()) ?? "",
      e,
      ((a = this.operatorParser) == null ? void 0 : a.endPosition) == null ? this.params.expression.length : this.operatorParser.endPosition + 1
    );
    return this.params.advFilterExpSvc.generateAutocompleteListParams(
      this.params.advFilterExpSvc.getOperatorAutocompleteEntries(t, s),
      `operator-${s}`,
      i
    );
  }
  getBaseCellDataTypeFromOperatorAutocompleteType(e) {
    return e == null ? void 0 : e.replace("operator-", "");
  }
  hasOperand(e, t) {
    var s;
    return !e || !t || (((s = this.params.advFilterExpSvc.getExpressionOperator(e, t)) == null ? void 0 : s.numOperands) ?? 0) > 0;
  }
  doesOperandNeedQuotes(e) {
    return e !== "number";
  }
  addToListAndGetIndex(e, t) {
    const s = e.length;
    return e.push(t), s;
  }
};
function mn(e, t, s) {
  let i = !1;
  const r = e.toLocaleLowerCase(), o = r + " ", n = Object.entries(t).find(([, a]) => {
    const l = s(a).toLocaleLowerCase();
    return l.startsWith(o) && (i = !0), l === r;
  });
  return n ? n[0] : i ? null : void 0;
}
function $l(e, t) {
  return (t ?? Object.keys(e)).map((i) => ({
    key: i,
    displayValue: e[i].displayValue
  }));
}
var Sc = class {
  constructor(e) {
    this.params = e, this.initOperators();
  }
  getEntries(e) {
    return $l(this.operators, e);
  }
  findOperator(e) {
    return mn(e, this.operators, ({ displayValue: t }) => t);
  }
  initOperators() {
    const { translate: e } = this.params;
    this.operators = {
      contains: {
        displayValue: e("advancedFilterContains"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !1, (o, n) => o.includes(n)),
        numOperands: 1
      },
      notContains: {
        displayValue: e("advancedFilterNotContains"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !0, (o, n) => !o.includes(n)),
        numOperands: 1
      },
      equals: {
        displayValue: e("advancedFilterTextEquals"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !1, (o, n) => o === n),
        numOperands: 1
      },
      notEqual: {
        displayValue: e("advancedFilterTextNotEqual"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !0, (o, n) => o != n),
        numOperands: 1
      },
      startsWith: {
        displayValue: e("advancedFilterStartsWith"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !1, (o, n) => o.startsWith(n)),
        numOperands: 1
      },
      endsWith: {
        displayValue: e("advancedFilterEndsWith"),
        evaluator: (t, s, i, r) => this.evaluateExpression(t, s, i, r, !1, (o, n) => o.endsWith(n)),
        numOperands: 1
      },
      blank: {
        displayValue: e("advancedFilterBlank"),
        evaluator: (t) => t == null || typeof t == "string" && t.trim().length === 0,
        numOperands: 0
      },
      notBlank: {
        displayValue: e("advancedFilterNotBlank"),
        evaluator: (t) => t != null && (typeof t != "string" || t.trim().length > 0),
        numOperands: 0
      }
    };
  }
  evaluateExpression(e, t, s, i, r, o) {
    return e == null ? r : s.caseSensitive ? o(s.valueConverter(e, t), i) : o(s.valueConverter(e, t).toLocaleLowerCase(), i.toLocaleLowerCase());
  }
}, Jn = class {
  constructor(e) {
    this.params = e, this.initOperators();
  }
  getEntries(e) {
    return $l(this.operators, e);
  }
  findOperator(e) {
    return mn(e, this.operators, ({ displayValue: t }) => t);
  }
  initOperators() {
    const { translate: e, equals: t } = this.params;
    this.operators = {
      equals: {
        displayValue: e("advancedFilterEquals"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInEquals,
          t
        ),
        numOperands: 1
      },
      notEqual: {
        displayValue: e("advancedFilterNotEqual"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInEquals,
          (n, a) => !t(n, a)
        ),
        numOperands: 1
      },
      greaterThan: {
        displayValue: e("advancedFilterGreaterThan"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInGreaterThan,
          (n, a) => n > a
        ),
        numOperands: 1
      },
      greaterThanOrEqual: {
        displayValue: e("advancedFilterGreaterThanOrEqual"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInGreaterThan,
          (n, a) => n >= a
        ),
        numOperands: 1
      },
      lessThan: {
        displayValue: e("advancedFilterLessThan"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInLessThan,
          (n, a) => n < a
        ),
        numOperands: 1
      },
      lessThanOrEqual: {
        displayValue: e("advancedFilterLessThanOrEqual"),
        evaluator: (s, i, r, o) => this.evaluateSingleOperandExpression(
          s,
          i,
          r,
          o,
          !!r.includeBlanksInLessThan,
          (n, a) => n <= a
        ),
        numOperands: 1
      },
      blank: {
        displayValue: e("advancedFilterBlank"),
        evaluator: (s) => s == null,
        numOperands: 0
      },
      notBlank: {
        displayValue: e("advancedFilterNotBlank"),
        evaluator: (s) => s != null,
        numOperands: 0
      }
    };
  }
  evaluateSingleOperandExpression(e, t, s, i, r, o) {
    return e == null ? r : o(s.valueConverter(e, t), i);
  }
}, EI = class {
  constructor(e) {
    this.params = e, this.initOperators();
  }
  getEntries(e) {
    return $l(this.operators, e);
  }
  findOperator(e) {
    return mn(e, this.operators, ({ displayValue: t }) => t);
  }
  initOperators() {
    const { translate: e } = this.params;
    this.operators = {
      true: {
        displayValue: e("advancedFilterTrue"),
        evaluator: (t) => !!t,
        numOperands: 0
      },
      false: {
        displayValue: e("advancedFilterFalse"),
        evaluator: (t) => t === !1,
        numOperands: 0
      },
      blank: {
        displayValue: e("advancedFilterBlank"),
        evaluator: (t) => t == null,
        numOperands: 0
      },
      notBlank: {
        displayValue: e("advancedFilterNotBlank"),
        evaluator: (t) => t != null,
        numOperands: 0
      }
    };
  }
}, MI = class extends P {
  constructor() {
    super(...arguments), this.beanName = "advFilterExpSvc", this.columnNameToIdMap = {}, this.columnAutocompleteEntries = null, this.expressionEvaluatorParams = {};
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc, this.colModel = e.colModel, this.colNames = e.colNames, this.dataTypeSvc = e.dataTypeSvc;
  }
  postConstruct() {
    this.expressionJoinOperators = this.generateExpressionJoinOperators(), this.expressionOperators = this.generateExpressionOperators();
  }
  parseJoinOperator(e) {
    const { type: t } = e;
    return this.expressionJoinOperators[t] ?? t;
  }
  getColumnDisplayValue(e) {
    const { colId: t } = e, i = this.getColumnAutocompleteEntries().find(({ key: o }) => o === t);
    let r;
    return i ? (r = i.displayValue, this.columnNameToIdMap[r.toLocaleUpperCase()] = { colId: t, columnName: r }) : r = t, r;
  }
  getOperatorDisplayValue(e) {
    var t;
    return ((t = this.getExpressionOperator(e.filterType, e.type)) == null ? void 0 : t.displayValue) ?? e.type;
  }
  getOperandModelValue(e, t, s) {
    switch (t) {
      case "number":
        return A(e) ? Number(e) : null;
      case "date":
        return Ze(this.valueSvc.parseValue(s, null, e, void 0), !1);
      case "dateString": {
        const i = this.valueSvc.parseValue(s, null, e, void 0);
        return this.dataTypeSvc ? Ze(this.dataTypeSvc.getDateParserFunction(s)(i) ?? null, !1) : i;
      }
    }
    return e;
  }
  getOperandDisplayValue(e, t) {
    var n;
    const { colId: s, filter: i } = e, r = this.colModel.getColDefCol(s);
    let o = "";
    if (i != null) {
      let a;
      switch (e.filterType) {
        case "number":
          a = qe(i) ?? "";
          break;
        case "date": {
          const l = Le(i);
          a = r ? this.valueSvc.formatValue(r, null, l) : null;
          break;
        }
        case "dateString": {
          let l;
          if (this.dataTypeSvc) {
            const d = Le(i);
            l = r ? (n = this.dataTypeSvc) == null ? void 0 : n.getDateFormatterFunction(r)(d ?? void 0) : null;
          } else
            l = i;
          a = r ? this.valueSvc.formatValue(r, null, l) : null;
          break;
        }
      }
      e.filterType !== "number" && (a = a ?? qe(i) ?? "", t || (a = `"${a}"`)), o = t ? a : ` ${a}`;
    }
    return o;
  }
  parseColumnFilterModel(e) {
    const t = this.getColumnDisplayValue(e) ?? "", s = this.getOperatorDisplayValue(e) ?? "", i = this.getOperandDisplayValue(e);
    return `[${t}] ${s}${i}`;
  }
  updateAutocompleteCache(e, t) {
    if (t === "column") {
      const { key: s, displayValue: i } = e;
      this.columnNameToIdMap[e.displayValue.toLocaleUpperCase()] = {
        colId: s,
        columnName: i
      };
    }
  }
  translate(e, t) {
    let s = SI[e];
    return typeof s == "function" && (s = s(t)), this.getLocaleTextFunc()(e, s, t);
  }
  generateAutocompleteListParams(e, t, s) {
    return {
      enabled: !0,
      type: t,
      searchString: s,
      entries: e
    };
  }
  getColumnAutocompleteEntries() {
    if (this.columnAutocompleteEntries)
      return this.columnAutocompleteEntries;
    const e = this.colModel.getColDefCols() ?? [], t = [], s = this.gos.get("includeHiddenColumnsInAdvancedFilter");
    return e.forEach((i) => {
      i.getColDef().filter && (s || i.isVisible() || i.isRowGroupActive()) && t.push({
        key: i.getColId(),
        displayValue: this.colNames.getDisplayNameForColumn(i, "advancedFilter")
      });
    }), t.sort((i, r) => {
      const o = i.displayValue ?? "", n = r.displayValue ?? "";
      return o < n ? -1 : n > o ? 1 : 0;
    }), t;
  }
  getOperatorAutocompleteEntries(e, t) {
    const s = this.getActiveOperators(e);
    return this.getDataTypeExpressionOperator(t).getEntries(s);
  }
  getJoinOperatorAutocompleteEntries() {
    return Object.entries(this.expressionJoinOperators).map(([e, t]) => ({ key: e, displayValue: t }));
  }
  getDefaultAutocompleteListParams(e) {
    return this.generateAutocompleteListParams(this.getColumnAutocompleteEntries(), "column", e);
  }
  getDataTypeExpressionOperator(e) {
    return this.expressionOperators[e];
  }
  getExpressionOperator(e, t) {
    var s, i;
    return (i = (s = this.getDataTypeExpressionOperator(e)) == null ? void 0 : s.operators) == null ? void 0 : i[t];
  }
  getExpressionJoinOperators() {
    return this.expressionJoinOperators;
  }
  getColId(e) {
    const t = e.toLocaleUpperCase(), s = this.columnNameToIdMap[t];
    if (s)
      return s;
    const r = this.getColumnAutocompleteEntries().find(
      ({ displayValue: o }) => o.toLocaleUpperCase() === t
    );
    if (r) {
      const { key: o, displayValue: n } = r, a = { colId: o, columnName: n };
      return this.columnNameToIdMap[t] = a, a;
    }
    return null;
  }
  getExpressionEvaluatorParams(e) {
    var o, n;
    let t = this.expressionEvaluatorParams[e];
    if (t)
      return t;
    const s = this.colModel.getColDefCol(e);
    if (!s)
      return { valueConverter: (a) => a };
    switch ((o = this.dataTypeSvc) == null ? void 0 : o.getBaseDataType(s)) {
      case "dateString":
        t = {
          valueConverter: ((n = this.dataTypeSvc) == null ? void 0 : n.getDateParserFunction(s)) ?? ((a) => a)
        };
        break;
      case "object":
        s.getColDef().filterValueGetter ? t = { valueConverter: (a) => a } : t = {
          valueConverter: (a, l) => this.valueSvc.formatValue(s, l, a) ?? (typeof a.toString == "function" ? a.toString() : "")
        };
        break;
      case "text":
      case void 0:
        t = { valueConverter: (a) => qe(a) };
        break;
      default:
        t = { valueConverter: (a) => a };
        break;
    }
    const { filterParams: r } = s.getColDef();
    return r && ["caseSensitive", "includeBlanksInEquals", "includeBlanksInLessThan", "includeBlanksInGreaterThan"].forEach(
      (a) => {
        const l = r[a];
        l && (t[a] = l);
      }
    ), this.expressionEvaluatorParams[e] = t, t;
  }
  getColumnDetails(e) {
    var i;
    const t = this.colModel.getColDefCol(e) ?? void 0, s = (t ? (i = this.dataTypeSvc) == null ? void 0 : i.getBaseDataType(t) : void 0) ?? "text";
    return { column: t, baseCellDataType: s };
  }
  generateExpressionOperators() {
    const e = (t, s) => this.translate(t, s);
    return {
      text: new Sc({ translate: e }),
      boolean: new EI({ translate: e }),
      object: new Sc({ translate: e }),
      number: new Jn({ translate: e, equals: (t, s) => t === s }),
      date: new Jn({
        translate: e,
        equals: (t, s) => t.getTime() === s.getTime()
      }),
      dateString: new Jn({
        translate: e,
        equals: (t, s) => t.getTime() === s.getTime()
      })
    };
  }
  getColumnValue({ displayValue: e }) {
    return `${Ha}${e}${za}`;
  }
  generateExpressionJoinOperators() {
    return {
      AND: this.translate("advancedFilterAnd"),
      OR: this.translate("advancedFilterOr")
    };
  }
  getActiveOperators(e) {
    var i;
    const t = (i = e.getColDef().filterParams) == null ? void 0 : i.filterOptions;
    return t && t.every((r) => typeof r == "string") ? t : void 0;
  }
  resetColumnCaches() {
    this.columnAutocompleteEntries = null, this.columnNameToIdMap = {}, this.expressionEvaluatorParams = {};
  }
}, AI = (
  /*css*/
  ".ag-panel{background-color:var(--ag-panel-background-color);display:flex;flex-direction:column;overflow:hidden;position:relative}.ag-dialog{border:var(--ag-dialog-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dialog-shadow);position:absolute}.ag-panel-title-bar{align-items:center;background-color:var(--ag-panel-title-bar-background-color);border-bottom:var(--ag-panel-title-bar-border);color:var(--ag-header-text-color);cursor:default;display:flex;flex:none;height:var(--ag-header-height);padding:var(--ag-spacing) var(--ag-cell-horizontal-padding)}.ag-panel-title-bar-button{cursor:pointer}:where(.ag-ltr) .ag-panel-title-bar-button{margin-left:calc(var(--ag-spacing)*2);margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-panel-title-bar-button{margin-left:var(--ag-spacing);margin-right:calc(var(--ag-spacing)*2)}.ag-panel-title-bar-title{color:var(--ag-header-text-color);flex:1 1 auto;font-weight:500}.ag-panel-title-bar-buttons{display:flex}.ag-panel-content-wrapper{display:flex;flex:1 1 auto;overflow:hidden;position:relative}:where(.ag-dragging-fill-handle) .ag-dialog,:where(.ag-dragging-range-handle) .ag-dialog{opacity:.7;pointer-events:none}"
);
function II(e) {
  const t = e.cssIdentifier || "default";
  return (
    /* html */
    `<div class="ag-panel ag-${t}-panel" tabindex="-1">
        <div data-ref="eTitleBar" class="ag-panel-title-bar ag-${t}-panel-title-bar ag-unselectable">
            <span data-ref="eTitle" class="ag-panel-title-bar-title ag-${t}-panel-title-bar-title"></span>
            <div data-ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${t}-panel-title-bar-buttons"></div>
        </div>
        <div data-ref="eContentWrapper" class="ag-panel-content-wrapper ag-${t}-panel-content-wrapper"></div>
    </div>`
  );
}
var LI = (
  /* html */
  '<div class="ag-button"></div>'
), Mg = class extends L {
  constructor(e) {
    super(II(e)), this.config = e, this.closable = !0, this.eContentWrapper = S, this.eTitleBar = S, this.eTitleBarButtons = S, this.eTitle = S, this.registerCSS(AI);
  }
  postConstruct() {
    const {
      component: e,
      closable: t,
      hideTitleBar: s,
      title: i,
      minWidth: r = 250,
      width: o,
      minHeight: n = 250,
      height: a,
      centered: l,
      popup: d,
      x: c,
      y: h
    } = this.config;
    this.positionableFeature = new rn(this.getGui(), {
      minWidth: r,
      width: o,
      minHeight: n,
      height: a,
      centered: l,
      x: c,
      y: h,
      popup: d,
      calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
    }), this.createManagedBean(this.positionableFeature);
    const u = this.getGui();
    e && this.setBodyComponent(e), s ? O(this.eTitleBar, !1) : (i && this.setTitle(i), this.setClosable(t ?? this.closable)), this.addManagedElementListeners(this.eTitleBar, {
      mousedown: (p) => {
        if (u.contains(p.relatedTarget) || u.contains(q(this.beans)) || this.eTitleBarButtons.contains(p.target)) {
          p.preventDefault();
          return;
        }
        const g = this.eContentWrapper.querySelector(
          "button, [href], input, select, textarea, [tabindex]"
        );
        g && g.focus();
      }
    }), !(d && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
  }
  renderComponent() {
    const e = this.getGui();
    e.focus(), this.close = () => {
      e.parentElement.removeChild(e), this.destroy();
    };
  }
  getHeight() {
    return this.positionableFeature.getHeight();
  }
  setHeight(e) {
    this.positionableFeature.setHeight(e);
  }
  getWidth() {
    return this.positionableFeature.getWidth();
  }
  setWidth(e) {
    this.positionableFeature.setWidth(e);
  }
  setClosable(e) {
    if (e !== this.closable && (this.closable = e), e) {
      const t = this.closeButtonComp = new L(LI);
      this.createBean(t);
      const s = t.getGui(), i = B("close", this.beans);
      i.classList.add("ag-panel-title-bar-button-icon"), s.appendChild(i), this.addTitleBarButton(t), t.addManagedElementListeners(s, { click: this.onBtClose.bind(this) });
    } else if (this.closeButtonComp) {
      const t = this.closeButtonComp.getGui();
      t.parentElement.removeChild(t), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
  }
  setBodyComponent(e) {
    e.setParentComponent(this), this.eContentWrapper.appendChild(e.getGui());
  }
  addTitleBarButton(e, t) {
    const s = this.eTitleBarButtons, i = s.children, r = i.length;
    t == null && (t = r), t = Math.max(0, Math.min(t, r)), e.addCssClass("ag-panel-title-bar-button");
    const o = e.getGui();
    t === 0 ? s.insertAdjacentElement("afterbegin", o) : t === r ? s.insertAdjacentElement("beforeend", o) : i[t - 1].insertAdjacentElement("afterend", o), e.setParentComponent(this);
  }
  getBodyHeight() {
    return $o(this.eContentWrapper);
  }
  getBodyWidth() {
    return yi(this.eContentWrapper);
  }
  setTitle(e) {
    this.eTitle.innerText = e;
  }
  // called when user hits the 'x' in the top right
  onBtClose() {
    this.close();
  }
  destroy() {
    this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
    const e = this.getGui();
    e && ke(e) && this.close(), super.destroy();
  }
}, Er = class extends Mg {
  constructor(e) {
    super({ ...e, popup: !0 }), this.isMaximizable = !1, this.isMaximized = !1, this.maximizeListeners = [], this.resizeListenerDestroy = null, this.lastPosition = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  postConstruct() {
    var n;
    const e = this.getGui(), { movable: t, resizable: s, maximizable: i, modal: r, postProcessPopupParams: o } = this.config;
    if (this.addCssClass("ag-dialog"), super.postConstruct(), o) {
      const { type: a, eventSource: l, column: d, mouseEvent: c, rowNode: h } = o;
      (n = this.popupSvc) == null || n.callPostProcessPopup(a, e, l, c, d, h);
    }
    if (this.tabGuardFeature = this.createManagedBean(new op(this)), this.tabGuardFeature.initialiseTabGuard({
      isFocusableContainer: !0,
      onFocusIn: () => {
        var a;
        (a = this.popupSvc) == null || a.bringPopupToFront(e);
      },
      onTabKeyDown: (a) => {
        if (r)
          return;
        const l = a.shiftKey, d = Pe(this.beans, e, !1, l);
        (!d || this.tabGuardFeature.getTabGuardCtrl().isTabGuard(d)) && Xt(this.beans, l) && a.preventDefault();
      }
    }), t && this.setMovable(t), i && this.setMaximizable(i), s && this.setResizable(s), !this.config.modal) {
      const a = this.beans.ctrlsSvc.get("gridCtrl");
      a.addFocusableContainer(this), this.addDestroyFunc(() => a.removeFocusableContainer(this));
    }
  }
  setAllowFocus(e) {
    this.tabGuardFeature.getTabGuardCtrl().setAllowFocus(e);
  }
  renderComponent() {
    var a;
    const e = this.getGui(), { alwaysOnTop: t, modal: s, title: i, afterGuiAttached: r } = this.config, o = this.getLocaleTextFunc(), n = (a = this.popupSvc) == null ? void 0 : a.addPopup({
      modal: s,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: this.onClosed.bind(this),
      alwaysOnTop: t,
      ariaLabel: i || o("ariaLabelDialog", "Dialog"),
      afterGuiAttached: r
    });
    n && (this.close = n.hideFunc);
  }
  onClosed(e) {
    var t, s;
    this.destroy(), (s = (t = this.config).closedCallback) == null || s.call(t, e);
  }
  toggleMaximize() {
    const e = this.positionableFeature.getPosition();
    if (this.isMaximized) {
      const { x: t, y: s, width: i, height: r } = this.lastPosition;
      this.setWidth(i), this.setHeight(r), this.positionableFeature.offsetElement(t, s);
    } else
      this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = e.x, this.lastPosition.y = e.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
    this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
  }
  refreshMaximizeIcon() {
    O(this.maximizeIcon, !this.isMaximized), O(this.minimizeIcon, this.isMaximized);
  }
  clearMaximizebleListeners() {
    this.maximizeListeners.length && (this.maximizeListeners.forEach((e) => e()), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
  }
  destroy() {
    this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), super.destroy();
  }
  setResizable(e) {
    this.positionableFeature.setResizable(e);
  }
  setMovable(e) {
    this.positionableFeature.setMovable(e, this.eTitleBar);
  }
  setMaximizable(e) {
    if (!e) {
      this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
      return;
    }
    const t = this.eTitleBar;
    if (!t || e === this.isMaximizable)
      return;
    const s = this.buildMaximizeAndMinimizeElements();
    this.refreshMaximizeIcon(), s.addManagedElementListeners(s.getGui(), {
      click: this.toggleMaximize.bind(this)
    }), this.addTitleBarButton(s, 0), this.maximizeListeners.push(
      ...this.addManagedElementListeners(t, {
        dblclick: this.toggleMaximize.bind(this)
      })
    ), [this.resizeListenerDestroy] = this.addManagedListeners(this.positionableFeature, {
      resize: () => {
        this.isMaximized = !1, this.refreshMaximizeIcon();
      }
    });
  }
  buildMaximizeAndMinimizeElements() {
    const e = this.maximizeButtonComp = this.createBean(
      new L(
        /* html */
        '<div class="ag-dialog-button"></span>'
      )
    ), t = e.getGui();
    return this.maximizeIcon = B("maximize", this.beans), t.appendChild(this.maximizeIcon), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), this.minimizeIcon = B("minimize", this.beans), t.appendChild(this.minimizeIcon), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon"), e;
  }
}, kI = (
  /*css*/
  ".ag-autocomplete{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}}.ag-autocomplete-list-popup{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-autocomplete-list{height:calc(var(--ag-row-height)*6.5);min-width:200px;position:relative;width:100%}.ag-autocomplete-virtual-list-item{cursor:default;display:flex;height:var(--ag-list-item-height);&:focus-visible:after{content:none}&:hover{background-color:var(--ag-row-hover-color)}}.ag-autocomplete-row{align-items:center;display:flex;flex:1 1 auto;overflow:hidden}.ag-autocomplete-row-label{margin:0 var(--ag-widget-container-horizontal-padding);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-autocomplete-row-selected{background-color:var(--ag-selected-row-background-color)}"
);
function OI(e) {
  return (
    /* html */
    `<div class="ag-virtual-list-viewport ag-${e}-virtual-list-viewport" role="presentation">
            <div class="ag-virtual-list-container ag-${e}-virtual-list-container" data-ref="eContainer"></div>
        </div>`
  );
}
var Oi = class extends Nt {
  constructor(e) {
    super(OI((e == null ? void 0 : e.cssIdentifier) || "default")), this.renderedRows = /* @__PURE__ */ new Map(), this.rowHeight = 20, this.pageSize = -1, this.isScrolling = !1, this.isHeightFromTheme = !0, this.eContainer = S, this.awaitStableCallbacks = [];
    const { cssIdentifier: t = "default", ariaRole: s = "listbox", listName: i } = e || {};
    this.cssIdentifier = t, this.ariaRole = s, this.listName = i;
  }
  wireBeans(e) {
    this.environment = e.environment;
  }
  postConstruct() {
    this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e),
      focusInnerElement: (e) => this.focusInnerElement(e),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    }), this.setAriaProperties(), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanged.bind(this) });
  }
  onGridStylesChanged(e) {
    e.listItemHeightChanged && (this.rowHeight = this.getItemHeight(), this.refresh());
  }
  setAriaProperties() {
    const t = this.getLocaleTextFunc()("ariaDefaultListName", this.listName || "List"), s = this.eContainer;
    re(s, this.ariaRole), oe(s, t);
  }
  addResizeObserver() {
    const e = () => pt(this.beans, () => this.drawVirtualRows()), t = Rt(this.beans, this.getGui(), e);
    this.addDestroyFunc(t);
  }
  focusInnerElement(e) {
    this.focusRow(e ? this.model.getRowCount() - 1 : 0);
  }
  onFocusIn(e) {
    const t = e.target;
    t.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = oC(t) - 1);
  }
  onFocusOut(e) {
    this.getFocusableElement().contains(e.relatedTarget) || (this.lastFocusedRowIndex = null);
  }
  handleKeyDown(e) {
    switch (e.key) {
      case w.UP:
      case w.DOWN:
        e.preventDefault(), this.navigate(e.key === w.UP);
        break;
      case w.PAGE_HOME:
      case w.PAGE_END:
      case w.PAGE_UP:
      case w.PAGE_DOWN:
        this.navigateToPage(e.key) !== null && e.preventDefault();
        break;
    }
  }
  onTabKeyDown(e) {
    he(e), this.forceFocusOutOfContainer(e.shiftKey);
  }
  navigate(e) {
    if (this.lastFocusedRowIndex == null)
      return;
    const t = this.lastFocusedRowIndex + (e ? -1 : 1);
    t < 0 || t >= this.model.getRowCount() || this.focusRow(t);
  }
  navigateToPage(e, t = "focused") {
    let s = !1;
    t === "focused" && (t = this.getLastFocusedRow(), s = !0);
    const i = this.model.getRowCount() - 1;
    let r = -1;
    return e === w.PAGE_HOME ? r = 0 : e === w.PAGE_END ? r = i : e === w.PAGE_DOWN ? r = Math.min(t + this.pageSize, i) : e === w.PAGE_UP && (r = Math.max(t - this.pageSize, 0)), r === -1 ? null : (s ? this.focusRow(r) : this.ensureIndexVisible(r), r);
  }
  getLastFocusedRow() {
    return this.lastFocusedRowIndex;
  }
  focusRow(e) {
    this.isScrolling || (this.isScrolling = !0, this.ensureIndexVisible(e), pt(this.beans, () => {
      if (this.isScrolling = !1, !this.isAlive())
        return;
      const t = this.renderedRows.get(e);
      t && t.eDiv.focus();
    }));
  }
  getComponentAt(e) {
    const t = this.renderedRows.get(e);
    return t && t.rowComponent;
  }
  forEachRenderedRow(e) {
    this.renderedRows.forEach((t, s) => e(t.rowComponent, s));
  }
  getItemHeight() {
    return this.isHeightFromTheme ? this.environment.getDefaultListItemHeight() : this.rowHeight;
  }
  /**
   * Returns true if the view had to be scrolled, otherwise, false.
   */
  ensureIndexVisible(e, t = !0) {
    const s = this.model.getRowCount();
    if (typeof e != "number" || e < 0 || e >= s)
      return R(229, { index: e }), !1;
    const i = e * this.rowHeight, r = i + this.rowHeight, o = this.getGui(), n = o.scrollTop, a = o.offsetHeight, l = n + a, d = t ? 0 : this.rowHeight, c = n > i + d, h = l < r - d;
    if (c)
      return o.scrollTop = i, !0;
    if (h) {
      const u = r - a;
      return o.scrollTop = u, !0;
    }
    return !1;
  }
  setComponentCreator(e) {
    this.componentCreator = e;
  }
  setComponentUpdater(e) {
    this.componentUpdater = e;
  }
  getRowHeight() {
    return this.rowHeight;
  }
  getScrollTop() {
    return this.getGui().scrollTop;
  }
  setRowHeight(e) {
    this.isHeightFromTheme = !1, this.rowHeight = e, this.refresh();
  }
  refresh(e) {
    if (this.model == null || !this.isAlive())
      return;
    const t = this.model.getRowCount();
    this.eContainer.style.height = `${t * this.rowHeight}px`, this.awaitStable(() => {
      this.isAlive() && (this.canSoftRefresh(e) ? this.drawVirtualRows(!0) : (this.clearVirtualRows(), this.drawVirtualRows()));
    });
  }
  awaitStable(e) {
    if (this.awaitStableCallbacks.push(e), this.awaitStableCallbacks.length > 1)
      return;
    const t = this.model.getRowCount();
    kh(
      () => this.eContainer.clientHeight >= t * this.rowHeight,
      () => {
        if (!this.isAlive())
          return;
        const s = this.awaitStableCallbacks;
        this.awaitStableCallbacks = [], s.forEach((i) => i());
      }
    );
  }
  canSoftRefresh(e) {
    return !!(e && this.renderedRows.size && typeof this.model.areRowsEqual == "function" && this.componentUpdater);
  }
  clearVirtualRows() {
    this.renderedRows.forEach((e, t) => this.removeRow(t));
  }
  drawVirtualRows(e) {
    if (!this.isAlive() || !this.model)
      return;
    const t = this.getGui(), s = t.scrollTop, i = s + t.offsetHeight, r = Math.floor(s / this.rowHeight), o = Math.floor(i / this.rowHeight);
    this.pageSize = Math.floor((i - s) / this.rowHeight), this.ensureRowsRendered(r, o, e);
  }
  ensureRowsRendered(e, t, s) {
    this.renderedRows.forEach((i, r) => {
      (r < e || r > t) && r !== this.lastFocusedRowIndex && this.removeRow(r);
    }), s && this.refreshRows();
    for (let i = e; i <= t; i++)
      this.renderedRows.has(i) || i < this.model.getRowCount() && this.insertRow(i);
  }
  insertRow(e) {
    const t = this.model.getRow(e), s = document.createElement("div");
    s.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`), re(s, this.ariaRole === "tree" ? "treeitem" : "option"), Uo(s, this.model.getRowCount()), Ko(s, e + 1), s.setAttribute("tabindex", "-1"), s.style.height = `${this.rowHeight}px`, s.style.top = `${this.rowHeight * e}px`;
    const i = this.componentCreator(t, s);
    i.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = e), s.appendChild(i.getGui()), this.renderedRows.has(e - 1) ? this.renderedRows.get(e - 1).eDiv.insertAdjacentElement("afterend", s) : this.renderedRows.has(e + 1) ? this.renderedRows.get(e + 1).eDiv.insertAdjacentElement("beforebegin", s) : this.eContainer.appendChild(s), this.renderedRows.set(e, { rowComponent: i, eDiv: s, value: t });
  }
  removeRow(e) {
    const t = this.renderedRows.get(e);
    this.eContainer.removeChild(t.eDiv), this.destroyBean(t.rowComponent), this.renderedRows.delete(e);
  }
  refreshRows() {
    const e = this.model.getRowCount();
    this.renderedRows.forEach((t, s) => {
      var i, r;
      if (s >= e)
        this.removeRow(s);
      else {
        const o = this.model.getRow(s);
        (r = (i = this.model).areRowsEqual) != null && r.call(i, t.value, o) ? this.componentUpdater(o, t.rowComponent) : this.removeRow(s);
      }
    });
  }
  addScrollListener() {
    this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: !0 });
  }
  setModel(e) {
    this.model = e;
  }
  getAriaElement() {
    return this.eContainer;
  }
  destroy() {
    this.isAlive() && (this.clearVirtualRows(), this.awaitStableCallbacks.length = 0, super.destroy());
  }
}, GI = class extends L {
  constructor() {
    super(
      /* html */
      `
        <div class="ag-autocomplete-row" role="presentation">
            <div class="ag-autocomplete-row-label"></div>
        </div>`
    ), this.hasHighlighting = !1;
  }
  setState(e, t) {
    this.value = e, this.render(), this.updateSelected(t);
  }
  updateSelected(e) {
    this.addOrRemoveCssClass("ag-autocomplete-row-selected", e);
  }
  setSearchString(e) {
    var s;
    let t = !1;
    if (A(e)) {
      const i = (s = this.value) == null ? void 0 : s.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
      if (i >= 0) {
        t = !0, this.hasHighlighting = !0;
        const r = i + e.length, o = Q(this.value.slice(0, i)), n = Q(this.value.slice(i, r)), a = Q(this.value.slice(r));
        this.getGui().lastElementChild.innerHTML = `${o}<b>${n}</b>${a}`;
      }
    }
    !t && this.hasHighlighting && (this.hasHighlighting = !1, this.render());
  }
  render() {
    this.getGui().lastElementChild.innerHTML = Q(this.value) ?? "&nbsp;";
  }
}, BI = class extends Ts {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-autocomplete-list-popup">
            <div data-ref="eList" class="ag-autocomplete-list"></div>
        <div>`
    ), this.params = e, this.eList = S, this.searchString = "";
  }
  postConstruct() {
    this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList = this.createManagedBean(new Oi({ cssIdentifier: "autocomplete" })), this.virtualList.setComponentCreator(this.createRowComponent.bind(this)), this.eList.appendChild(this.virtualList.getGui()), this.virtualList.setModel({
      getRowCount: () => this.autocompleteEntries.length,
      getRow: (t) => this.autocompleteEntries[t]
    });
    const e = this.virtualList.getGui();
    this.addManagedListeners(e, {
      click: () => this.params.onConfirmed(),
      mousemove: this.onMouseMove.bind(this),
      mousedown: (t) => t.preventDefault()
    }), this.setSelectedValue(0);
  }
  onNavigationKeyDown(e, t) {
    e.preventDefault();
    const s = this.autocompleteEntries.indexOf(this.selectedValue), i = t === w.UP ? s - 1 : s + 1;
    this.checkSetSelectedValue(i);
  }
  setSearch(e) {
    this.searchString = e, A(e) ? this.runSearch() : (this.autocompleteEntries = this.params.autocompleteEntries, this.virtualList.refresh(), this.checkSetSelectedValue(0)), this.updateSearchInList();
  }
  runContainsSearch(e, t) {
    let s, i = !1;
    const r = e.toLocaleLowerCase(), o = t.filter((n) => {
      const l = n.toLocaleLowerCase().indexOf(r), d = l === 0, c = l >= 0;
      return c && (!s || !i && d || i === d && n.length < s.length) && (s = n, i = d), c;
    });
    return !s && o.length && (s = o[0]), { topMatch: s, allMatches: o };
  }
  runSearch() {
    const { autocompleteEntries: e, useFuzzySearch: t, forceLastSelection: s } = this.params, i = e.map((l) => l.displayValue ?? l.key);
    let r, o;
    if (t)
      r = un({
        inputValue: this.searchString,
        allSuggestions: i,
        hideIrrelevant: !0,
        addSequentialWeight: !0
      }).values, o = r.length ? r[0] : void 0;
    else {
      const l = this.runContainsSearch(this.searchString, i);
      r = l.allMatches, o = l.topMatch;
    }
    let n = e.filter(
      ({ key: l, displayValue: d }) => r.includes(d ?? l)
    );
    if (!n.length && this.selectedValue && (s != null && s(this.selectedValue, this.searchString)) && (n = [this.selectedValue]), this.autocompleteEntries = n, this.virtualList.refresh(), !o)
      return;
    const a = r.indexOf(o);
    this.checkSetSelectedValue(a);
  }
  updateSearchInList() {
    this.virtualList.forEachRenderedRow((e) => e.setSearchString(this.searchString));
  }
  checkSetSelectedValue(e) {
    e >= 0 && e < this.autocompleteEntries.length && this.setSelectedValue(e);
  }
  setSelectedValue(e) {
    const t = this.autocompleteEntries[e];
    this.selectedValue !== t && (this.selectedValue = t, this.virtualList.ensureIndexVisible(e), this.virtualList.forEachRenderedRow((s, i) => {
      s.updateSelected(e === i);
    }));
  }
  createRowComponent(e) {
    const t = new GI();
    return this.createBean(t), t.setState(e.displayValue ?? e.key, e === this.selectedValue), t;
  }
  onMouseMove(e) {
    const t = this.virtualList, s = t.getGui().getBoundingClientRect(), i = t.getScrollTop(), r = e.clientY - s.top + i, o = Math.floor(r / t.getRowHeight());
    this.checkSetSelectedValue(o);
  }
  afterGuiAttached() {
    this.virtualList.refresh();
  }
  getSelectedValue() {
    return this.autocompleteEntries.length ? this.selectedValue ?? null : null;
  }
}, VI = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-autocomplete" role="presentation">
                <ag-input-text-field data-ref="eAutocompleteInput"></ag-input-text-field>
            </div>`,
      [mt]
    ), this.eAutocompleteInput = S, this.isListOpen = !1, this.lastPosition = 0, this.valid = !0, this.registerCSS(kI);
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  postConstruct() {
    this.eAutocompleteInput.onValueChange((e) => this.onValueChanged(e)), this.eAutocompleteInput.getInputElement().setAttribute("autocomplete", "off"), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.addGuiEventListener("click", this.updatePositionAndList.bind(this)), this.addDestroyFunc(() => {
      this.destroyBean(this.autocompleteList);
    }), this.addGuiEventListener("focusout", () => this.onFocusOut());
  }
  onValueChanged(e) {
    const t = ge(e);
    this.updateValue(t), this.updateAutocompleteList(t);
  }
  updateValue(e) {
    this.updateLastPosition(), this.dispatchLocalEvent({
      type: "eventValueChanged",
      value: e
    }), this.validate(e);
  }
  updateAutocompleteList(e) {
    var i, r;
    const t = ((i = this.listGenerator) == null ? void 0 : i.call(this, e, this.lastPosition)) ?? { enabled: !1 }, s = this.isListOpen;
    if ((!t.type || t.type !== ((r = this.autocompleteListParams) == null ? void 0 : r.type)) && s && this.closeList(), this.autocompleteListParams = t, t != null && t.enabled) {
      s || this.openList();
      const { searchString: o } = t;
      this.autocompleteList.setSearch(o ?? "");
    } else
      s && this.closeList();
  }
  onKeyDown(e) {
    const t = e.key;
    switch (this.updateLastPosition(), t) {
      case w.ENTER:
        this.onEnterKeyDown(e);
        break;
      case w.TAB:
        this.onTabKeyDown(e);
        break;
      case w.DOWN:
      case w.UP:
        this.onUpDownKeyDown(e, t);
        break;
      case w.LEFT:
      case w.RIGHT:
      case w.PAGE_HOME:
      case w.PAGE_END:
        setTimeout(() => {
          this.updatePositionAndList();
        });
        break;
      case w.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case w.SPACE:
        e.ctrlKey && !this.isListOpen && (e.preventDefault(), this.forceOpenList());
        break;
    }
  }
  confirmSelection() {
    var t;
    const e = (t = this.autocompleteList) == null ? void 0 : t.getSelectedValue();
    e && (this.closeList(), this.dispatchLocalEvent({
      type: "eventOptionSelected",
      value: this.getValue(),
      position: this.lastPosition,
      updateEntry: e,
      autocompleteType: this.autocompleteListParams.type
    }));
  }
  onTabKeyDown(e) {
    this.isListOpen && (e.preventDefault(), e.stopPropagation(), this.confirmSelection());
  }
  onEnterKeyDown(e) {
    e.preventDefault(), this.isListOpen ? this.confirmSelection() : this.onCompleted();
  }
  onUpDownKeyDown(e, t) {
    var s;
    e.preventDefault(), this.isListOpen ? (s = this.autocompleteList) == null || s.onNavigationKeyDown(e, t) : this.forceOpenList();
  }
  onEscapeKeyDown(e) {
    this.isListOpen && (e.preventDefault(), e.stopPropagation(), this.closeList(), this.setCaret(this.lastPosition, !0));
  }
  onFocusOut() {
    this.isListOpen && this.closeList();
  }
  updatePositionAndList() {
    this.updateLastPosition(), this.updateAutocompleteList(this.eAutocompleteInput.getValue() ?? null);
  }
  setCaret(e, t) {
    t && ys(this.beans) && this.eAutocompleteInput.getFocusableElement().focus();
    const s = this.eAutocompleteInput.getInputElement();
    s.setSelectionRange(e, e), e === s.value.length && (s.scrollLeft = s.scrollWidth);
  }
  forceOpenList() {
    this.onValueChanged(this.eAutocompleteInput.getValue());
  }
  updateLastPosition() {
    this.lastPosition = this.eAutocompleteInput.getInputElement().selectionStart ?? 0;
  }
  validate(e) {
    if (!this.validator)
      return;
    const t = this.validationMessage = this.validator(e);
    this.eAutocompleteInput.getInputElement().setCustomValidity(t ?? ""), this.valid = !t, this.dispatchLocalEvent({
      type: "eventValidChanged",
      isValid: this.valid,
      validationMessage: t
    });
  }
  openList() {
    this.isListOpen = !0, this.autocompleteList = this.createBean(
      new BI({
        autocompleteEntries: this.autocompleteListParams.entries,
        onConfirmed: () => this.confirmSelection(),
        forceLastSelection: this.forceLastSelection
      })
    );
    const e = this.autocompleteList.getGui(), t = {
      ePopup: e,
      type: "autocomplete",
      eventSource: this.getGui(),
      position: "under",
      alignSide: this.gos.get("enableRtl") ? "right" : "left",
      keepWithinBounds: !0
    }, s = this.popupSvc.addPopup({
      eChild: e,
      anchorToElement: this.getGui(),
      positionCallback: () => this.popupSvc.positionPopupByComponent(t),
      ariaLabel: this.listAriaLabel
    });
    this.hidePopup = s.hideFunc, this.autocompleteList.afterGuiAttached();
  }
  closeList() {
    this.isListOpen = !1, this.hidePopup(), this.destroyBean(this.autocompleteList), this.autocompleteList = null;
  }
  onCompleted() {
    this.isListOpen && this.closeList(), this.dispatchLocalEvent({
      type: "eventValueConfirmed",
      value: this.getValue(),
      isValid: this.isValid()
    });
  }
  getValue() {
    return ge(this.eAutocompleteInput.getValue());
  }
  setInputPlaceholder(e) {
    return this.eAutocompleteInput.setInputPlaceholder(e), this;
  }
  setInputAriaLabel(e) {
    return this.eAutocompleteInput.setInputAriaLabel(e), this;
  }
  setListAriaLabel(e) {
    return this.listAriaLabel = e, this;
  }
  setListGenerator(e) {
    return this.listGenerator = e, this;
  }
  setValidator(e) {
    return this.validator = e, this;
  }
  isValid() {
    return this.valid;
  }
  setValue(e) {
    const { value: t, position: s, silent: i, updateListOnlyIfOpen: r, restoreFocus: o } = e;
    this.eAutocompleteInput.setValue(t, !0), this.setCaret(s ?? this.lastPosition, o), i || this.updateValue(t), (!r || this.isListOpen) && this.updateAutocompleteList(t);
  }
  setForceLastSelection(e) {
    return this.forceLastSelection = e, this;
  }
  setInputDisabled(e) {
    return this.eAutocompleteInput.setDisabled(e), this;
  }
}, NI = {
  selector: "AG-AUTOCOMPLETE",
  component: VI
}, Ag = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-advanced-filter" role="presentation" tabindex="-1">
                <ag-autocomplete data-ref="eAutocomplete"></ag-autocomplete>
                <button class="ag-button ag-standard-button ag-advanced-filter-apply-button" data-ref="eApplyFilterButton"></button>
                <button class="ag-button ag-advanced-filter-builder-button" data-ref="eBuilderFilterButton">
                    <span data-ref="eBuilderFilterButtonIcon" aria-hidden="true"></span>
                    <span class="ag-advanced-filter-builder-button-label" data-ref="eBuilderFilterButtonLabel"></span>
                </button>
            </div>`,
      [NI]
    ), this.eAutocomplete = S, this.eApplyFilterButton = S, this.eBuilderFilterButton = S, this.eBuilderFilterButtonIcon = S, this.eBuilderFilterButtonLabel = S, this.expressionParser = null, this.isApplyDisabled = !0, this.builderOpen = !1;
  }
  wireBeans(e) {
    this.advFilterExpSvc = e.advFilterExpSvc, this.advancedFilter = e.advancedFilter, this.filterManager = e.filterManager, this.registry = e.registry;
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getTooltipShowDelayOverride: () => 1e3,
        getLocation: () => "advancedFilter"
      })
    ), this.eAutocomplete.setListGenerator((e, t) => this.generateAutocompleteListParams(t)).setValidator(() => this.validateValue()).setForceLastSelection(
      (e, t) => this.forceLastSelection(e, t)
    ).setInputAriaLabel(this.advFilterExpSvc.translate("ariaAdvancedFilterInput")).setListAriaLabel(this.advFilterExpSvc.translate("ariaLabelAdvancedFilterAutocomplete")), this.refresh(), this.addManagedListeners(this.eAutocomplete, {
      eventValueChanged: ({ value: e }) => this.onValueChanged(e),
      eventValueConfirmed: ({ isValid: e }) => this.onValueConfirmed(e),
      eventOptionSelected: ({ position: e, updateEntry: t, autocompleteType: s }) => this.onOptionSelected(e, t, s),
      eventValidChanged: ({ isValid: e, validationMessage: t }) => this.onValidChanged(e, t)
    }), this.setupApplyButton(), this.setupBuilderButton();
  }
  refresh() {
    const e = this.advancedFilter.getExpressionDisplayValue();
    this.eAutocomplete.setValue({
      value: e ?? "",
      position: e == null ? void 0 : e.length,
      updateListOnlyIfOpen: !0
    });
  }
  setInputDisabled(e) {
    this.eAutocomplete.setInputDisabled(e), lt(this.eApplyFilterButton, e || this.isApplyDisabled);
  }
  setupApplyButton() {
    this.eApplyFilterButton.innerText = this.advFilterExpSvc.translate("advancedFilterApply"), this.activateTabIndex([this.eApplyFilterButton]), this.addManagedElementListeners(this.eApplyFilterButton, {
      click: () => this.onValueConfirmed(this.eAutocomplete.isValid())
    }), lt(this.eApplyFilterButton, this.isApplyDisabled);
  }
  setupBuilderButton() {
    this.eBuilderFilterButtonIcon.appendChild(B("advancedFilterBuilder", this.beans)), this.eBuilderFilterButtonLabel.innerText = this.advFilterExpSvc.translate("advancedFilterBuilder"), this.activateTabIndex([this.eBuilderFilterButton]), this.addManagedElementListeners(this.eBuilderFilterButton, { click: () => this.openBuilder() }), this.addManagedListeners(this.advancedFilter.getCtrl(), {
      advancedFilterBuilderClosed: () => this.closeBuilder()
    });
  }
  onValueChanged(e) {
    var s;
    e = ge(e), this.advancedFilter.setExpressionDisplayValue(e), this.expressionParser = this.advancedFilter.createExpressionParser(e);
    const t = (s = this.expressionParser) == null ? void 0 : s.parseExpression();
    t && t !== e && this.eAutocomplete.setValue({ value: t, silent: !0, restoreFocus: !0 });
  }
  onValueConfirmed(e) {
    var t;
    !e || this.isApplyDisabled || (lt(this.eApplyFilterButton, !0), this.advancedFilter.applyExpression(), (t = this.filterManager) == null || t.onFilterChanged({ source: "advancedFilter" }));
  }
  onOptionSelected(e, t, s) {
    const { updatedValue: i, updatedPosition: r, hideAutocomplete: o } = this.updateExpression(e, t, s);
    this.eAutocomplete.setValue({
      value: i,
      position: r,
      updateListOnlyIfOpen: o,
      restoreFocus: !0
    });
  }
  validateValue() {
    var e, t;
    return (e = this.expressionParser) != null && e.isValid() ? null : ((t = this.expressionParser) == null ? void 0 : t.getValidationMessage()) ?? null;
  }
  onValidChanged(e, t) {
    var s;
    this.isApplyDisabled = !e || this.advancedFilter.isCurrentExpressionApplied(), lt(this.eApplyFilterButton, this.isApplyDisabled), (s = this.tooltipFeature) == null || s.setTooltipAndRefresh(t);
  }
  generateAutocompleteListParams(e) {
    return this.expressionParser ? this.expressionParser.getAutocompleteListParams(e) : this.advFilterExpSvc.getDefaultAutocompleteListParams("");
  }
  updateExpression(e, t, s) {
    var i;
    return this.advFilterExpSvc.updateAutocompleteCache(t, s), ((i = this.expressionParser) == null ? void 0 : i.updateExpression(e, t, s)) ?? this.advancedFilter.getDefaultExpression(t);
  }
  forceLastSelection({ key: e, displayValue: t }, s) {
    return !!s.toLocaleLowerCase().match(`^${(t ?? e).toLocaleLowerCase()}\\s*$`);
  }
  openBuilder() {
    this.builderOpen || (this.builderOpen = !0, lt(this.eBuilderFilterButton, !0), this.advancedFilter.getCtrl().toggleFilterBuilder({ source: "ui", eventSource: this.eBuilderFilterButton }));
  }
  closeBuilder() {
    this.builderOpen && (this.builderOpen = !1, lt(this.eBuilderFilterButton, !1), this.eBuilderFilterButton.focus());
  }
}, HI = class extends L {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-header" role="row">
            </div>`
    ), this.enabled = e;
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.focusSvc = e.focusSvc, this.ctrlsSvc = e.ctrlsSvc;
  }
  postConstruct() {
    this.setupAdvancedFilter(this.enabled), this.addDestroyFunc(() => this.destroyBean(this.eAdvancedFilter));
    const e = () => {
      this.enabled && this.setEnabledHeight();
    };
    this.addManagedEventListeners({
      gridColumnsChanged: () => this.onGridColumnsChanged(),
      columnHeaderHeightChanged: e,
      gridStylesChanged: e
    }), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addGuiEventListener("keydown", (t) => this.onKeyDown(t)), this.addGuiEventListener("focusout", (t) => {
      this.getFocusableElement().contains(t.relatedTarget) || this.focusSvc.clearAdvancedFilterColumn();
    });
  }
  getFocusableElement() {
    var e;
    return ((e = this.eAdvancedFilter) == null ? void 0 : e.getGui()) ?? this.getGui();
  }
  setEnabled(e) {
    e !== this.enabled && this.setupAdvancedFilter(e);
  }
  refresh() {
    var e;
    (e = this.eAdvancedFilter) == null || e.refresh();
  }
  getHeight() {
    return this.height;
  }
  setInputDisabled(e) {
    var t;
    (t = this.eAdvancedFilter) == null || t.setInputDisabled(e);
  }
  setupAdvancedFilter(e) {
    const t = this.getGui();
    if (e) {
      this.eAdvancedFilter = this.createBean(new Ag());
      const s = this.eAdvancedFilter.getGui();
      this.eAdvancedFilter.addCssClass("ag-advanced-filter-header-cell"), this.setEnabledHeight(), this.setAriaRowIndex(), re(s, "gridcell"), Ja(s, 1), this.setAriaColumnCount(s), t.appendChild(s);
    } else
      X(t), this.destroyBean(this.eAdvancedFilter), this.height = 0;
    O(t, e), this.enabled = e;
  }
  setEnabledHeight() {
    const e = this.getGui();
    this.height = Pl(this.beans);
    const t = `${this.height}px`;
    e.style.height = t, e.style.minHeight = t;
  }
  setAriaColumnCount(e) {
    Ch(e, this.colModel.getCols().length);
  }
  setAriaRowIndex() {
    var e;
    Qa(this.getGui(), ((e = this.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : e.getRowCount()) ?? 0);
  }
  onGridColumnsChanged() {
    this.eAdvancedFilter && (this.setAriaColumnCount(this.eAdvancedFilter.getGui()), this.setAriaRowIndex());
  }
  onKeyDown(e) {
    switch (e.key) {
      case w.ENTER: {
        this.hasFocus() && ve(this.getFocusableElement()) && e.preventDefault();
        break;
      }
      case w.ESCAPE:
        this.hasFocus() || this.getFocusableElement().focus();
        break;
      case w.UP:
        this.navigateUpDown(!0, e);
        break;
      case w.DOWN:
        this.navigateUpDown(!1, e);
        break;
      case w.TAB:
        if (this.hasFocus())
          this.navigateLeftRight(e);
        else {
          const t = Pe(
            this.beans,
            this.getFocusableElement(),
            null,
            e.shiftKey
          );
          t ? (e.preventDefault(), t.focus()) : this.navigateLeftRight(e);
        }
        break;
    }
  }
  navigateUpDown(e, t) {
    this.hasFocus() && this.focusSvc.focusNextFromAdvancedFilter(e) && t.preventDefault();
  }
  navigateLeftRight(e) {
    (e.shiftKey ? this.focusSvc.focusLastHeader() : this.focusSvc.focusNextFromAdvancedFilter(!1, !0)) && e.preventDefault();
  }
  hasFocus() {
    return q(this.beans) === this.getFocusableElement();
  }
}, ea = "ag-list-item-hovered", Ig = class extends P {
  constructor(e, t, s) {
    super(), this.comp = e, this.virtualList = t, this.params = s, this.currentDragValue = null, this.lastHoveredListItem = null;
  }
  wireBeans(e) {
    this.dragAndDrop = e.dragAndDrop;
  }
  postConstruct() {
    this.addManagedListeners(this.params.eventSource, {
      [this.params.listItemDragStartEvent]: this.listItemDragStart.bind(this),
      [this.params.listItemDragEndEvent]: this.listItemDragEnd.bind(this)
    }), this.createDropTarget(), this.createAutoScrollService();
  }
  listItemDragStart(e) {
    this.currentDragValue = this.params.getCurrentDragValue(e), this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue);
  }
  listItemDragEnd() {
    window.setTimeout(() => {
      this.currentDragValue = null, this.moveBlocked = !1;
    }, 10);
  }
  createDropTarget() {
    var t;
    const e = {
      isInterestedIn: (s) => s === this.params.dragSourceType,
      getIconName: () => this.moveBlocked ? "pinned" : "move",
      getContainer: () => this.comp.getGui(),
      onDragging: (s) => this.onDragging(s),
      onDragStop: () => this.onDragStop(),
      onDragLeave: () => this.onDragLeave(),
      onDragCancel: () => this.onDragCancel()
    };
    (t = this.dragAndDrop) == null || t.addDropTarget(e);
  }
  createAutoScrollService() {
    const e = this.virtualList.getGui();
    this.autoScrollService = new vl({
      scrollContainer: e,
      scrollAxis: "y",
      getVerticalPosition: () => e.scrollTop,
      setVerticalPosition: (t) => e.scrollTop = t
    });
  }
  onDragging(e) {
    if (!this.currentDragValue || this.moveBlocked)
      return;
    const t = this.getListDragItem(e), s = this.virtualList.getComponentAt(t.rowIndex);
    if (!s)
      return;
    const i = s.getGui().parentElement;
    this.lastHoveredListItem && this.lastHoveredListItem.rowIndex === t.rowIndex && this.lastHoveredListItem.position === t.position || (this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredListItem = t, ho(i, ea), ho(i, `ag-item-highlight-${t.position}`));
  }
  getListDragItem(e) {
    const t = this.virtualList.getGui(), s = parseFloat(window.getComputedStyle(t).paddingTop), i = this.virtualList.getRowHeight(), r = this.virtualList.getScrollTop(), o = Math.max(0, (e.y - s + r) / i), n = this.params.getNumRows(this.comp) - 1, a = Math.min(n, o) | 0;
    return {
      rowIndex: a,
      position: Math.round(o) > o || o > n ? "bottom" : "top",
      component: this.virtualList.getComponentAt(a)
    };
  }
  onDragStop() {
    this.moveBlocked || (this.params.moveItem(this.currentDragValue, this.lastHoveredListItem), this.clearDragProperties());
  }
  onDragCancel() {
    this.clearDragProperties();
  }
  onDragLeave() {
    this.clearDragProperties();
  }
  clearDragProperties() {
    this.clearHoveredItems(), this.autoScrollService.ensureCleared();
  }
  clearHoveredItems() {
    this.virtualList.getGui().querySelectorAll(`.${ea}`).forEach((t) => {
      [ea, "ag-item-highlight-top", "ag-item-highlight-bottom"].forEach((s) => {
        t.classList.remove(s);
      });
    }), this.lastHoveredListItem = null;
  }
}, zI = class extends P {
  constructor(e, t) {
    super(), this.comp = e, this.virtualList = t;
  }
  postConstruct() {
    this.createManagedBean(
      new Ig(this.comp, this.virtualList, {
        dragSourceType: xt.AdvancedFilterBuilder,
        listItemDragStartEvent: "advancedFilterBuilderDragStarted",
        listItemDragEndEvent: "advancedFilterBuilderDragEnded",
        eventSource: this,
        getCurrentDragValue: (e) => this.getCurrentDragValue(e),
        isMoveBlocked: () => !1,
        getNumRows: (e) => e.getNumItems(),
        moveItem: (e, t) => this.moveItem(e, t)
      })
    );
  }
  getCurrentDragValue(e) {
    return e.item;
  }
  moveItem(e, t) {
    this.comp.moveItem(e, t);
  }
}, WI = class extends L {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-pill" role="option">
                <span class="ag-pill-text" data-ref="eText"></span>
                <span class="ag-button ag-pill-button" data-ref="eButton" role="presentation"></span>
            </div>
        `
    ), this.config = e, this.eText = S, this.eButton = S;
  }
  postConstruct() {
    const { config: e, eButton: t } = this, { onKeyDown: s, onButtonClick: i } = e;
    this.getGui().setAttribute("tabindex", String(this.gos.get("tabIndex"))), this.addGuiEventListener("focus", () => {
      this.eButton.focus();
    }), s && this.addGuiEventListener("keydown", s), i && this.addManagedElementListeners(t, {
      click: i
    });
  }
  toggleCloseButtonClass(e, t) {
    this.eButton.classList.toggle(e, t);
  }
  setText(e) {
    this.eText.textContent = e;
  }
  getText() {
    return this.eText.textContent;
  }
}, _I = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-pill-container" role="listbox"></div>
            `
    ), this.pills = [];
  }
  init(e) {
    this.params = e, this.refresh();
  }
  refresh() {
    this.clearPills();
    const { params: e, onPillKeyDown: t } = this, s = e.getValue();
    if (!Array.isArray(s))
      return;
    const i = s.length;
    for (let r = 0; r < i; r++) {
      const o = s[r], n = this.createBean(
        new WI({
          onButtonClick: () => this.onPillButtonClick(n),
          onKeyDown: t.bind(this)
        })
      ), a = n.getGui();
      Ko(a, r + 1), Uo(a, i), e.onPillMouseDown && n.addGuiEventListener("mousedown", e.onPillMouseDown), e.announceItemFocus && n.addGuiEventListener("focus", e.announceItemFocus), n.setText(o), n.toggleCloseButtonClass("ag-icon-cancel", !0), this.appendChild(a), this.pills.push(n);
    }
  }
  onNavigationKeyDown(e) {
    const { key: t } = e;
    if (!this.pills.length || t !== w.LEFT && t !== w.RIGHT)
      return;
    e.preventDefault();
    const { params: s, beans: i } = this, r = q(i), o = this.getGui();
    if (o.contains(r)) {
      const n = Pe(i, o, !1, t === w.LEFT);
      n ? n.focus() : s.eWrapper && s.eWrapper.focus();
    } else {
      const n = bt(o);
      n.length > 0 && n[t === w.RIGHT ? 0 : n.length - 1].focus();
    }
  }
  clearPills() {
    const e = this.getGui();
    e.contains(q(this.beans)) && this.params.eWrapper && this.params.eWrapper.focus(), X(e), this.destroyBeans(this.pills), this.pills = [];
  }
  onPillButtonClick(e) {
    this.deletePill(e);
  }
  onPillKeyDown(e) {
    const t = e.key;
    if (t !== w.DELETE && t !== w.BACKSPACE)
      return;
    e.preventDefault();
    const s = Z(this.beans), i = this.pills.findIndex((o) => o.getGui().contains(s.activeElement));
    if (i === -1)
      return;
    const r = this.pills[i];
    r && this.deletePill(r, i);
  }
  deletePill(e, t) {
    const s = e.getText(), i = (this.params.getValue() || []).filter((r) => r !== s);
    if (this.params.setValue(i), !i.length && this.params.eWrapper)
      this.params.eWrapper.focus();
    else if (t != null) {
      const r = this.pills[Math.min(t, this.pills.length - 1)];
      r && r.getFocusableElement().focus();
    }
  }
  destroy() {
    this.clearPills(), super.destroy();
  }
}, UI = (
  /*css*/
  ".ag-rich-select{cursor:default;height:100%}.ag-rich-select-value{align-items:center;background-color:var(--ag-input-background-color);display:flex;height:100%;padding:var(--ag-spacing);:where(.ag-picker-field-display){overflow:hidden;text-overflow:ellipsis;&:where(.ag-display-as-placeholder){opacity:.5}}}.ag-rich-select-list{background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);box-shadow:var(--ag-dropdown-shadow);height:auto;position:relative;width:100%;:where(.ag-loading-text){padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}}.ag-rich-select-row{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;padding:0 var(--ag-spacing);white-space:nowrap}.ag-rich-select-row-selected{background-color:var(--ag-selected-row-background-color)}.ag-rich-select-row-highlighted,.ag-rich-select-row:hover{background-image:linear-gradient(var(--ag-row-hover-color),var(--ag-row-hover-color))}.ag-rich-select-row-text-highlight{font-weight:700}.ag-rich-select-field-input{flex:1 1 auto;:where(.ag-input-field-input){border:none!important;box-shadow:none!important;padding:0!important;text-overflow:ellipsis;&::-moz-placeholder{opacity:.8}&::placeholder{opacity:.8}}}:where(.ag-ltr) .ag-rich-select-field-input{left:var(--ag-spacing)}:where(.ag-rtl) .ag-rich-select-field-input{right:var(--ag-spacing)}:where(.ag-popup-editor) .ag-rich-select-value{height:var(--ag-row-height);min-width:200px}.ag-rich-select-virtual-list-item{cursor:default;height:var(--ag-list-item-height)}.ag-pill-container{display:flex;flex-wrap:nowrap;gap:.25rem}.ag-pill{align-items:center;background:var(--ag-select-cell-background-color);border:var(--ag-select-cell-border);border-radius:var(--ag-border-radius);display:flex;padding:0 .25rem;white-space:nowrap}.ag-pill-button{border:none;padding:0;&:hover{color:var(--ag-accent-color);cursor:pointer}}:where(.ag-ltr) .ag-pill-button{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-pill-button{margin-right:var(--ag-spacing)}"
), KI = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-rich-select-row" role="presentation"></div>'
    ), this.params = e;
  }
  wireBeans(e) {
    this.userCompFactory = e.userCompFactory, this.registry = e.registry;
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        shouldDisplayTooltip: () => {
          var e;
          return ((e = this.shouldDisplayTooltip) == null ? void 0 : e.call(this)) ?? !0;
        }
      })
    );
  }
  setState(e) {
    let t = "";
    const { params: s } = this;
    s.valueFormatter && (t = s.valueFormatter(e)), this.populateWithRenderer(e, t) || this.populateWithoutRenderer(e, t), this.value = e;
  }
  highlightString(e) {
    const { parsedValue: t } = this;
    if (this.params.cellRenderer || !A(t))
      return;
    let s = A(e);
    if (s) {
      const i = t == null ? void 0 : t.toLocaleLowerCase().indexOf(e.toLocaleLowerCase());
      if (i >= 0) {
        const r = i + e.length, o = Q(t.slice(0, i), !0), n = Q(t.slice(i, r), !0), a = Q(t.slice(r));
        this.renderValueWithoutRenderer(
          /* html */
          `${o}<span class="ag-rich-select-row-text-highlight">${n}</span>${a}`
        );
      } else
        s = !1;
    }
    s || this.renderValueWithoutRenderer(t);
  }
  updateSelected(e) {
    const t = this.getGui();
    hr(t.parentElement, e), this.addOrRemoveCssClass("ag-rich-select-row-selected", e);
  }
  getValue() {
    return this.value;
  }
  toggleHighlighted(e) {
    this.addOrRemoveCssClass("ag-rich-select-row-highlighted", e);
  }
  populateWithoutRenderer(e, t) {
    var n;
    const s = Z(this.beans), i = this.getGui(), r = s.createElement("span");
    r.style.overflow = "hidden", r.style.textOverflow = "ellipsis";
    const o = Q(A(t) ? t : e, !0);
    this.parsedValue = A(o) ? o : null, i.appendChild(r), this.renderValueWithoutRenderer(o), this.shouldDisplayTooltip = Us(() => r), (n = this.tooltipFeature) == null || n.setTooltipAndRefresh(this.parsedValue);
  }
  renderValueWithoutRenderer(e) {
    const t = this.getGui().querySelector("span");
    t && (t.innerHTML = A(e) ? e : "&nbsp;");
  }
  populateWithRenderer(e, t) {
    var r;
    let s, i;
    if (this.params.cellRenderer) {
      const o = (r = this.getParentComponent()) == null ? void 0 : r.getParentComponent();
      i = vu(
        this.userCompFactory,
        this.params,
        {
          value: e,
          valueFormatted: t,
          getValue: () => o == null ? void 0 : o.getValue(),
          setValue: (n) => {
            o == null || o.setValue(n, !0);
          },
          setTooltip: (n, a) => {
            var l;
            this.gos.assertModuleRegistered("Tooltip", 3), this.shouldDisplayTooltip = a, (l = this.tooltipFeature) == null || l.setTooltipAndRefresh(n);
          }
        }
      );
    }
    return i && (s = i.newAgStackInstance()), s && Ih(s, this.getGui()), s ? (s.then((o) => {
      this.addDestroyFunc(() => {
        this.destroyBean(o);
      });
    }), !0) : !1;
  }
}, xc = "ag-rich-select-list", Fc = "ag-rich-select-row", $I = class extends Oi {
  constructor(e, t, s) {
    super({ cssIdentifier: "rich-select" }), this.params = e, this.richSelectWrapper = t, this.getSearchString = s, this.lastRowHovered = -1, this.selectedItems = /* @__PURE__ */ new Set(), this.params = e, this.setComponentCreator(this.createRowComponent.bind(this)), this.setComponentUpdater(() => {
    });
  }
  postConstruct() {
    super.postConstruct(), this.createLoadingElement();
    const { cellRowHeight: e, pickerAriaLabelKey: t, pickerAriaLabelValue: s } = this.params;
    e && this.setRowHeight(e);
    const i = this.getGui(), r = this.getAriaElement();
    this.addManagedListeners(i, {
      mousemove: this.onMouseMove.bind(this),
      mouseout: this.onMouseOut.bind(this),
      mousedown: this.onMouseDown.bind(this),
      click: this.onClick.bind(this)
    }), i.classList.add(xc);
    const o = `${xc}-${this.getCompId()}`;
    r.setAttribute("id", o);
    const a = this.getLocaleTextFunc()(t, s);
    oe(r, a), el(this.richSelectWrapper, r);
  }
  navigateToPage(e) {
    const t = super.navigateToPage(e, this.lastRowHovered);
    return t != null && pt(this.beans, () => {
      if (!this.isAlive())
        return null;
      this.highlightIndex(t);
    }), t;
  }
  drawVirtualRows(e) {
    super.drawVirtualRows(e), this.refreshSelectedItems();
  }
  highlightFilterMatch(e) {
    this.forEachRenderedRow((t) => {
      t.highlightString(e);
    });
  }
  onNavigationKeyDown(e, t) {
    pt(this.beans, () => {
      if (!this.currentList || !this.isAlive())
        return;
      const s = this.currentList.length, i = this.lastRowHovered, r = e === w.DOWN ? 1 : -1, o = Math.min(Math.max(i === -1 ? 0 : i + r, 0), s - 1);
      this.highlightIndex(o), t();
    });
  }
  selectValue(e) {
    var i, r;
    if (!this.currentList)
      return this.eLoading && this.appendChild(this.eLoading), !1;
    if ((i = this.eLoading) != null && i.offsetParent && ((r = this.eLoading.parentElement) == null || r.removeChild(this.eLoading)), e == null)
      return !1;
    const t = this.getIndicesForValues(e), s = t.length > 0;
    return s && (this.refresh(), this.ensureIndexVisible(t[0]), this.refresh(!0)), this.selectListItems(Array.isArray(e) ? e : [e]), s;
  }
  selectListItems(e, t = !1) {
    t || this.selectedItems.clear();
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      this.selectedItems.has(i) || this.selectedItems.add(i);
    }
    this.refreshSelectedItems();
  }
  getCurrentList() {
    return this.currentList;
  }
  setCurrentList(e) {
    this.currentList = e, this.setModel({
      getRowCount: () => e.length,
      getRow: (t) => e[t],
      areRowsEqual: (t, s) => t === s
    });
  }
  getSelectedItems() {
    return this.selectedItems;
  }
  getLastItemHovered() {
    return this.currentList[this.lastRowHovered];
  }
  highlightIndex(e, t) {
    this.currentList && (e < 0 || e >= this.currentList.length ? this.lastRowHovered = -1 : (this.lastRowHovered = e, this.ensureIndexVisible(e, !t) && !t && this.refresh(!0)), this.forEachRenderedRow((s, i) => {
      const r = e === i;
      if (s.toggleHighlighted(r), r) {
        const o = `${Fc}-${s.getCompId()}`;
        fh(this.richSelectWrapper, o), this.richSelectWrapper.setAttribute("data-active-option", o);
      }
    }));
  }
  getIndicesForValues(e) {
    const { currentList: t } = this;
    if (!t || t.length === 0 || e == null)
      return [];
    if (Array.isArray(e) || (e = [e]), e.length === 0)
      return [];
    const s = [];
    for (let i = 0; i < e.length; i++) {
      const r = t.indexOf(e[i]);
      r >= 0 && s.push(r);
    }
    return s;
  }
  toggleListItemSelection(e) {
    this.selectedItems.has(e) ? this.selectedItems.delete(e) : this.selectedItems.add(e), this.refreshSelectedItems(), this.dispatchValueSelected();
  }
  refreshSelectedItems() {
    this.forEachRenderedRow((e) => {
      const t = this.selectedItems.has(e.getValue());
      e.updateSelected(t);
    });
  }
  createLoadingElement() {
    const e = Z(this.beans), t = this.getLocaleTextFunc(), s = e.createElement("div");
    s.classList.add("ag-loading-text"), s.innerText = t("loadingOoo", "Loading..."), this.eLoading = s;
  }
  createRowComponent(e, t) {
    const s = new KI(this.params);
    t.setAttribute("id", `${Fc}-${s.getCompId()}`), s.setParentComponent(this), this.createBean(s), s.setState(e);
    const { highlightMatch: i, searchType: r = "fuzzy" } = this.params;
    return i && r !== "fuzzy" && s.highlightString(this.getSearchString()), s;
  }
  getRowForMouseEvent(e) {
    const s = this.getGui().getBoundingClientRect(), i = this.getScrollTop(), r = e.clientY - s.top + i;
    return Math.floor(r / this.getRowHeight());
  }
  onMouseMove(e) {
    const t = this.getRowForMouseEvent(e);
    t !== -1 && t != this.lastRowHovered && (this.lastRowHovered = t, this.highlightIndex(t, !0));
  }
  onMouseDown(e) {
    e.preventDefault();
  }
  onMouseOut(e) {
    this.getGui().contains(e.relatedTarget) || this.highlightIndex(-1);
  }
  onClick(e) {
    const { multiSelect: t } = this.params;
    if (!this.currentList)
      return;
    const s = this.getRowForMouseEvent(e), i = this.currentList[s];
    t ? this.toggleListItemSelection(i) : (this.selectListItems([i]), this.dispatchValueSelected());
  }
  dispatchValueSelected() {
    this.dispatchLocalEvent({
      type: "richSelectListRowSelected",
      fromEnterKey: !1,
      value: this.selectedItems
    });
  }
  destroy() {
    super.destroy(), this.eLoading = void 0;
  }
}, jl = class extends Al {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelRichSelectField",
      pickerAriaLabelValue: "Rich Select Field",
      pickerType: "ag-list",
      className: "ag-rich-select",
      pickerIcon: "richSelectOpen",
      ariaRole: "combobox",
      template: (e == null ? void 0 : e.template) ?? /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-rich-select-value ag-picker-collapsed">
                    <span data-ref="eDisplayField" class="ag-picker-field-display"></span>
                    <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                    <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                    <span data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></span>
                </div>
            </div>`,
      agComponents: [mt],
      modalPicker: !1,
      ...e,
      // maxPickerHeight needs to be set after expanding `config`
      maxPickerHeight: (e == null ? void 0 : e.maxPickerHeight) ?? "calc(var(--ag-row-height) * 6.5)"
    }), this.searchString = "", this.searchStringCreator = null, this.eInput = S, this.eDeselect = S, this.skipWrapperAnnouncement = !1;
    const { value: t, valueList: s, searchStringCreator: i } = e || {};
    t !== void 0 && (this.value = t), s != null && (this.values = s), i && (this.searchStringCreator = i), this.registerCSS(UI);
  }
  wireBeans(e) {
    this.userCompFactory = e.userCompFactory, this.ariaAnnounce = e.ariaAnnounce, this.registry = e.registry;
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        shouldDisplayTooltip: () => {
          var r;
          return ((r = this.shouldDisplayTooltip) == null ? void 0 : r.call(this)) ?? !0;
        }
      })
    ), super.postConstruct(), this.createListComponent(), this.eDeselect.appendChild(B("richSelectRemove", this.beans));
    const { allowTyping: e, placeholder: t, suppressDeselectAll: s } = this.config;
    this.eDeselect.classList.add("ag-hidden"), e ? (this.eInput.setAutoComplete(!1).setInputPlaceholder(t), this.eDisplayField.classList.add("ag-hidden")) : this.eInput.setDisplayed(!1), this.setupAriaProperties();
    const { searchDebounceDelay: i = 300 } = this.config;
    this.clearSearchString = Ce(this, this.clearSearchString.bind(this), i), this.renderSelectedValue(), e && this.eInput.onValueChange((r) => this.searchTextFromString(r)), this.addManagedElementListeners(this.eWrapper, { focus: this.onWrapperFocus.bind(this) }), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) }), s || this.addManagedElementListeners(this.eDeselect, {
      mousedown: this.onDeselectAllMouseDown.bind(this),
      click: this.onDeselectAllClick.bind(this)
    });
  }
  setupAriaProperties() {
    const { eWrapper: e, gos: t } = this;
    e.tabIndex = t.get("tabIndex");
    const s = this.getLocaleTextFunc();
    this.ariaDeleteSelection = s("ariaLabelRichSelectDeleteSelection", "Press DELETE to deselect item"), this.ariaDeselectAllItems = s(
      "ariaLabelRichSelectDeselectAllItems",
      "Press DELETE to deselect all items"
    ), this.ariaToggleSelection = s("ariaLabelRichSelectToggleSelection", "Press SPACE to toggle selection");
  }
  createListComponent() {
    this.listComponent = this.createBean(new $I(this.config, this.eWrapper, () => this.searchString)), this.listComponent.setParentComponent(this), this.addManagedListeners(this.listComponent, {
      richSelectListRowSelected: (e) => {
        this.onListValueSelected(e.value, e.fromEnterKey);
      }
    });
  }
  renderSelectedValue() {
    var p;
    const { value: e, eDisplayField: t, config: s, gos: i } = this, {
      allowTyping: r,
      cellRenderer: o,
      initialInputValue: n,
      multiSelect: a,
      suppressDeselectAll: l,
      suppressMultiSelectPillRenderer: d
    } = s, c = this.config.valueFormatter ? this.config.valueFormatter(e) : e;
    if (r) {
      this.eInput.setValue(n ?? c);
      return;
    }
    if (a && !l) {
      const g = e == null || Array.isArray(e) && e.length === 0;
      this.eDeselect.classList.toggle("ag-hidden", g);
    }
    let h;
    if (a && !d) {
      this.createOrUpdatePillContainer(t);
      return;
    }
    o && (h = vu(
      this.userCompFactory,
      s,
      {
        value: e,
        valueFormatted: c,
        getValue: () => this.getValue(),
        setValue: (g) => {
          this.setValue(g, !0);
        },
        setTooltip: (g, f) => {
          var m;
          i.assertModuleRegistered("Tooltip", 3), this.shouldDisplayTooltip = f, (m = this.tooltipFeature) == null || m.setTooltipAndRefresh(g);
        }
      }
    ));
    let u;
    if (h && (u = h.newAgStackInstance()), u)
      X(t), Ih(u, t), u.then((g) => {
        this.addDestroyFunc(() => this.destroyBean(g));
      });
    else {
      if (A(this.value))
        t.innerText = c, t.classList.remove("ag-display-as-placeholder");
      else {
        const { placeholder: g } = s;
        A(g) ? (t.innerHTML = `${Q(g)}`, t.classList.add("ag-display-as-placeholder")) : X(t);
      }
      this.shouldDisplayTooltip = Us(() => this.eDisplayField), (p = this.tooltipFeature) == null || p.setTooltipAndRefresh(c ?? null);
    }
  }
  createPickerComponent() {
    const { values: e } = this;
    return e && this.setValueList({ valueList: e }), this.listComponent;
  }
  setSearchStringCreator(e) {
    this.searchStringCreator = e;
  }
  setValueList(e) {
    const { valueList: t, refresh: s } = e;
    !this.listComponent || this.listComponent.getCurrentList() === t || (this.listComponent.setCurrentList(t), s && (this.values ? this.listComponent.refresh(!0) : (this.values = t, this.isPickerDisplayed && (this.listComponent.selectValue(this.value) || this.listComponent.refresh())), this.alignPickerToComponent()));
  }
  showPicker() {
    super.showPicker();
    const { listComponent: e, value: t } = this;
    if (!e)
      return;
    let s = null;
    this.value != null && (e.selectValue(this.value), s = e.getIndicesForValues(Array.isArray(t) ? t : [t])[0]), s != null ? e.highlightIndex(s) : e.refresh(), this.displayOrHidePicker();
  }
  beforeHidePicker() {
    super.beforeHidePicker();
  }
  createOrUpdatePillContainer(e) {
    if (!this.pillContainer) {
      const t = this.pillContainer = this.createBean(new _I());
      this.addDestroyFunc(() => {
        this.destroyBean(this.pillContainer), this.pillContainer = null;
      }), X(e), e.appendChild(t.getGui()), t.init({
        eWrapper: this.eWrapper,
        onPillMouseDown: (s) => {
          s.stopImmediatePropagation();
        },
        announceItemFocus: () => {
          this.announceAriaValue(this.ariaDeleteSelection);
        },
        getValue: () => this.getValue(),
        setValue: (s) => this.setValue(s, !0)
      });
    }
    this.doWhileBlockingAnnouncement(() => {
      var t;
      return (t = this.pillContainer) == null ? void 0 : t.refresh();
    });
  }
  doWhileBlockingAnnouncement(e) {
    this.skipWrapperAnnouncement = !0, e(), this.skipWrapperAnnouncement = !1;
  }
  onWrapperFocus() {
    const { eInput: e, config: t } = this, { allowTyping: s, multiSelect: i, suppressDeselectAll: r } = t;
    if (s) {
      const o = e.getFocusableElement();
      o.focus(), o.select();
    } else i && !r && !this.skipWrapperAnnouncement && this.announceAriaValue(this.ariaDeselectAllItems);
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  onDeselectAllMouseDown(e) {
    e.stopImmediatePropagation();
  }
  onDeselectAllClick() {
    this.setValue([], !0);
  }
  buildSearchStringFromKeyboardEvent(e) {
    let { key: t } = e;
    if (t === w.BACKSPACE)
      this.searchString = this.searchString.slice(0, -1), t = "";
    else if (!xl(e))
      return;
    e.preventDefault(), this.searchTextFromCharacter(t);
  }
  searchTextFromCharacter(e) {
    this.searchString += e, this.runSearch(), this.clearSearchString();
  }
  searchTextFromString(e) {
    e == null && (e = ""), this.searchString = e, this.runSearch();
  }
  buildSearchStrings(e) {
    const { valueFormatter: t = (i) => i } = this.config;
    let s;
    return typeof e[0] == "number" || typeof e[0] == "string" ? s = e.map((i) => t(i)) : typeof e[0] == "object" && this.searchStringCreator && (s = this.searchStringCreator(e)), s;
  }
  filterListModel(e) {
    const { filterList: t } = this.config;
    t && this.setValueList({ valueList: e, refresh: !0 });
  }
  runSearch() {
    var d, c, h, u, p;
    if (!this.listComponent)
      return;
    const { values: e } = this, t = this.buildSearchStrings(e);
    if (!t) {
      this.listComponent.highlightIndex(-1);
      return;
    }
    const { suggestions: s, filteredValues: i } = this.getSuggestionsAndFilteredValues(this.searchString, t), { filterList: r, highlightMatch: o, searchType: n = "fuzzy" } = this.config, a = i.length, l = !!(r && this.searchString !== "");
    if (this.filterListModel(l ? i : e), s.length) {
      const g = l ? 0 : t.indexOf(s[0]);
      (d = this.listComponent) == null || d.highlightIndex(g);
    } else if ((c = this.listComponent) == null || c.highlightIndex(-1), !l || a)
      (h = this.listComponent) == null || h.ensureIndexVisible(0);
    else if (l) {
      this.getAriaElement().removeAttribute("data-active-option");
      const g = (u = this.listComponent) == null ? void 0 : u.getAriaElement();
      g && fh(g, null);
    }
    o && n !== "fuzzy" && ((p = this.listComponent) == null || p.highlightFilterMatch(this.searchString)), this.displayOrHidePicker();
  }
  getSuggestionsAndFilteredValues(e, t) {
    let s = [];
    const i = [];
    if (!e.length)
      return { suggestions: s, filteredValues: i };
    const { searchType: r = "fuzzy", filterList: o } = this.config;
    if (r === "fuzzy") {
      const n = un({
        inputValue: e,
        allSuggestions: t,
        hideIrrelevant: !0,
        addSequentialWeight: !0
      });
      s = n.values;
      const a = n.indices;
      if (o && a.length)
        for (let l = 0; l < a.length; l++)
          i.push(this.values[a[l]]);
    } else
      s = t.filter((n, a) => {
        const l = n.toLocaleLowerCase(), d = this.searchString.toLocaleLowerCase(), c = r === "match" ? l.startsWith(d) : l.indexOf(d) !== -1;
        return o && c && i.push(this.values[a]), c;
      });
    return { suggestions: s, filteredValues: i };
  }
  displayOrHidePicker() {
    if (!this.listComponent)
      return;
    const e = this.listComponent.getGui(), t = this.listComponent.getCurrentList(), s = t ? t.length === 0 : !1;
    e.classList.toggle("ag-hidden", s);
  }
  clearSearchString() {
    this.searchString = "";
  }
  setValue(e, t, s, i) {
    var o, n;
    if (this.value === e)
      return this;
    const r = Array.isArray(e);
    if (e != null) {
      if (!r) {
        const a = (o = this.listComponent) == null ? void 0 : o.getCurrentList();
        if ((a ? a.indexOf(e) : -1) === -1)
          return this;
      }
      s || (n = this.listComponent) == null || n.selectValue(e);
    }
    return super.setValue(e, t), i || this.renderSelectedValue(), this;
  }
  onNavigationKeyDown(e, t, s) {
    var r;
    e.preventDefault();
    const i = t === w.DOWN;
    if (!this.isPickerDisplayed && i) {
      this.showPicker();
      return;
    }
    (r = this.listComponent) == null || r.onNavigationKeyDown(t, s);
  }
  onEnterKeyDown(e) {
    var t;
    if (this.isPickerDisplayed && (e.preventDefault(), (t = this.listComponent) != null && t.getCurrentList())) {
      const s = this.listComponent.getLastItemHovered();
      this.config.multiSelect || s == null ? this.dispatchPickerEventAndHidePicker(this.value, !0) : this.onListValueSelected(/* @__PURE__ */ new Set([s]), !0);
    }
  }
  onDeleteKeyDown(e) {
    const { eWrapper: t, beans: s } = this;
    q(s) === t && (e.preventDefault(), this.setValue([], !0));
  }
  onTabKeyDown() {
    const { config: e, isPickerDisplayed: t, listComponent: s } = this, { multiSelect: i } = e;
    if (!(!t || !s)) {
      if (i) {
        const r = this.getValueFromSet(s.getSelectedItems());
        r && this.setValue(r, !1, !0, !0);
      } else
        this.setValue(s.getLastItemHovered(), !1, !0);
      this.hidePicker();
    }
  }
  getValueFromSet(e) {
    const { multiSelect: t } = this.config;
    let s = null;
    for (const i of e) {
      if (e.size === 1 && !t) {
        s = i;
        break;
      }
      s || (s = []), s.push(i);
    }
    return Array.isArray(s) && s.sort(), s;
  }
  onListValueSelected(e, t) {
    const s = this.getValueFromSet(e);
    this.setValue(s, !1, !0), this.config.multiSelect || this.dispatchPickerEventAndHidePicker(s, t);
  }
  dispatchPickerEventAndHidePicker(e, t) {
    const s = {
      type: "fieldPickerValueSelected",
      fromEnterKey: t,
      value: e
    };
    this.dispatchLocalEvent(s), this.hidePicker();
  }
  getFocusableElement() {
    const { allowTyping: e } = this.config;
    return e ? this.eInput.getFocusableElement() : super.getFocusableElement();
  }
  onKeyDown(e) {
    var d;
    const { key: t } = e, { isPickerDisplayed: s, config: i, listComponent: r, pickerComponent: o } = this, { allowTyping: n, multiSelect: a, suppressDeselectAll: l } = i;
    switch (t) {
      case w.LEFT:
      case w.RIGHT:
        (!n || this.pillContainer) && (e.preventDefault(), this.pillContainer && ((d = this.listComponent) == null || d.highlightIndex(-1), this.pillContainer.onNavigationKeyDown(e)));
        break;
      case w.PAGE_HOME:
      case w.PAGE_END:
        if (n) {
          e.preventDefault();
          const c = this.eInput.getInputElement(), h = t === w.PAGE_HOME ? 0 : c.value.length;
          c.setSelectionRange(h, h);
          break;
        }
      case w.PAGE_UP:
      case w.PAGE_DOWN:
        e.preventDefault(), o && (r == null || r.navigateToPage(t));
        break;
      case w.DOWN:
      case w.UP:
        this.onNavigationKeyDown(e, t, () => {
          a && (this.doWhileBlockingAnnouncement(() => this.eWrapper.focus()), this.announceAriaValue(this.ariaToggleSelection));
        });
        break;
      case w.ESCAPE:
        s && (ke(this.listComponent.getGui()) && (e.preventDefault(), he(e)), this.hidePicker());
        break;
      case w.ENTER:
        this.onEnterKeyDown(e);
        break;
      case w.SPACE:
        if (s && a && r) {
          e.preventDefault();
          const c = r.getLastItemHovered();
          c && r.toggleListItemSelection(c);
        }
        break;
      case w.TAB:
        this.onTabKeyDown();
        break;
      case w.DELETE:
        a && !l && this.onDeleteKeyDown(e);
        break;
      default:
        n || this.buildSearchStringFromKeyboardEvent(e);
    }
  }
  announceAriaValue(e) {
    var t;
    (t = this.ariaAnnounce) == null || t.announceValue(e, "richSelect");
  }
  destroy() {
    this.listComponent && (this.listComponent = this.destroyBean(this.listComponent)), super.destroy();
  }
}, Lg = class extends jl {
  constructor(e) {
    super({
      ...e,
      template: (
        /* html */
        `
                <div class="ag-picker-field" role="presentation">
                    <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-picker-collapsed">
                        <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                        <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                        <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>`
      ),
      agComponents: [mt]
    }), this.params = e;
  }
  showPicker() {
    setTimeout(() => super.showPicker());
  }
  hidePicker() {
    setTimeout(() => super.hidePicker());
  }
  postConstruct() {
    super.postConstruct();
    const { wrapperClassName: e, ariaLabel: t } = this.params;
    O(this.eDisplayField, !1), e && this.eWrapper.classList.add(e), vs(this.eWrapper, ""), oe(this.eWrapper, t);
  }
  onEnterKeyDown(e) {
    he(e), this.isPickerDisplayed ? super.onEnterKeyDown(e) : (e.preventDefault(), this.showPicker());
  }
}, kg = class extends P {
  constructor(e, t, s) {
    super(), this.eGui = e, this.focusWrapper = t, this.eFocusableComp = s;
  }
  postConstruct() {
    this.addManagedElementListeners(this.eGui, {
      keydown: (t) => {
        switch (t.key) {
          case w.TAB:
            t.defaultPrevented || he(t);
            break;
          case w.UP:
          case w.DOWN:
            he(t);
            break;
          case w.ESCAPE:
            if (nt(t))
              return;
            this.eGui.contains(q(this.beans)) && (t.preventDefault(), he(t), this.focusWrapper.focus());
            break;
        }
      }
    });
    const e = "ag-advanced-filter-builder-virtual-list-item-highlight";
    this.addManagedListeners(this.focusWrapper, {
      keydown: (t) => {
        switch (t.key) {
          case w.ENTER:
            if (nt(t))
              return;
            q(this.beans) === this.focusWrapper && (t.preventDefault(), he(t), this.eFocusableComp.getFocusableElement().focus());
            break;
        }
      },
      focusin: () => {
        this.focusWrapper.classList.add(e);
      },
      focusout: (t) => {
        this.focusWrapper.contains(t.relatedTarget) || this.focusWrapper.classList.remove(e);
      }
    });
  }
};
function Og(e, t) {
  return {
    pickerAriaLabelKey: "ariaLabelAdvancedFilterBuilderAddField",
    pickerAriaLabelValue: "Advanced Filter Builder Add Field",
    pickerType: "ag-list",
    valueList: [
      {
        key: "condition",
        displayValue: e("advancedFilterBuilderAddCondition")
      },
      {
        key: "join",
        displayValue: e("advancedFilterBuilderAddJoin")
      }
    ],
    valueFormatter: (s) => s == null ? null : s.displayValue ?? s.key,
    pickerIcon: "advancedFilterBuilderAdd",
    maxPickerWidth: `${t ?? 120}px`,
    wrapperClassName: "ag-advanced-filter-builder-item-button",
    ariaLabel: e("advancedFilterBuilderAddButtonTooltip")
  };
}
var jI = class extends L {
  constructor(e, t) {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div data-ref="eItem" class="ag-advanced-filter-builder-item" role="presentation">
                    <div class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true">
                        <div class="ag-advanced-filter-builder-item-tree-line-vertical-top ag-advanced-filter-builder-item-tree-line-horizontal"></div>
                    </div>
                </div>
            </div>
        `
    ), this.item = e, this.focusWrapper = t, this.eItem = S;
  }
  wireBeans(e) {
    this.advFilterExpSvc = e.advFilterExpSvc, this.registry = e.registry;
  }
  postConstruct() {
    var s;
    Sr(this.focusWrapper, 2);
    const e = Og(
      (i) => this.advFilterExpSvc.translate(i),
      (s = this.gos.get("advancedFilterBuilderParams")) == null ? void 0 : s.addSelectWidth
    ), t = this.createManagedBean(new Lg(e));
    this.addManagedListeners(t, {
      fieldPickerValueSelected: ({ value: i }) => {
        this.dispatchLocalEvent({
          type: "advancedFilterBuilderAdded",
          item: this.item,
          isJoin: i.key === "join"
        });
      }
    }), this.eItem.appendChild(t.getGui()), this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => t.getGui(),
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.advFilterExpSvc.translate("advancedFilterBuilderAddButtonTooltip")
      })
    ), this.createManagedBean(
      new kg(this.getGui(), this.focusWrapper, t)
    ), oe(
      this.focusWrapper,
      this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderItem", [
        this.advFilterExpSvc.translate("advancedFilterBuilderAddButtonTooltip"),
        `${this.item.level + 1}`
      ])
    );
  }
  afterAdd() {
  }
}, qI = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `
    ), this.validationMessage = null;
  }
  wireBeans(e) {
    this.advFilterExpSvc = e.advFilterExpSvc;
  }
  init(e) {
    const { item: t, createPill: s } = e;
    this.item = t, this.createPill = s, this.filterModel = t.filterModel, this.setupColumnCondition(this.filterModel), this.validate(), this.addDestroyFunc(() => this.destroyBeans([this.eColumnPill, this.eOperatorPill, this.eOperandPill]));
  }
  getDragName() {
    return this.filterModel.colId ? this.advFilterExpSvc.parseColumnFilterModel(this.filterModel) : this.getDefaultColumnDisplayValue();
  }
  getAriaLabel() {
    return `${this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderFilterItem")} ${this.getDragName()}`;
  }
  getValidationMessage() {
    return this.validationMessage;
  }
  getFocusableElement() {
    return this.eColumnPill.getFocusableElement();
  }
  setupColumnCondition(e) {
    const t = this.advFilterExpSvc.getColumnDetails(e.colId);
    this.baseCellDataType = t.baseCellDataType, this.column = t.column, this.numOperands = this.getNumOperands(this.getOperatorKey()), this.eColumnPill = this.createPill({
      key: this.getColumnKey(),
      displayValue: this.getColumnDisplayValue() ?? this.getDefaultColumnDisplayValue(),
      cssClass: "ag-advanced-filter-builder-column-pill",
      isSelect: !0,
      getEditorParams: () => ({ values: this.advFilterExpSvc.getColumnAutocompleteEntries() }),
      update: (s) => this.setColumnKey(s),
      pickerAriaLabelKey: "ariaLabelAdvancedFilterBuilderColumnSelectField",
      pickerAriaLabelValue: "Advanced Filter Builder Column Select Field",
      ariaLabel: this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderColumn")
    }), this.getGui().appendChild(this.eColumnPill.getGui()), A(this.getColumnKey()) && (this.createOperatorPill(), this.hasOperand() && this.createOperandPill());
  }
  createOperatorPill() {
    this.eOperatorPill = this.createPill({
      key: this.getOperatorKey(),
      displayValue: this.getOperatorDisplayValue() ?? this.getDefaultOptionSelectValue(),
      cssClass: "ag-advanced-filter-builder-option-pill",
      isSelect: !0,
      getEditorParams: () => ({ values: this.getOperatorAutocompleteEntries() }),
      update: (e) => this.setOperatorKey(e),
      pickerAriaLabelKey: "ariaLabelAdvancedFilterBuilderOptionSelectField",
      pickerAriaLabelValue: "Advanced Filter Builder Option Select Field",
      ariaLabel: this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderOption")
    }), this.eColumnPill.getGui().insertAdjacentElement("afterend", this.eOperatorPill.getGui());
  }
  createOperandPill() {
    const { filter: e } = this.filterModel, t = (typeof e == "number" ? qe(e) : e) ?? "";
    this.eOperandPill = this.createPill({
      key: t,
      // Convert from the input format to display format.
      // Input format matches model format except for numbers, but these get stringified anyway
      valueFormatter: (s) => this.advFilterExpSvc.getOperandDisplayValue({ ...this.filterModel, filter: s }, !0),
      baseCellDataType: this.baseCellDataType,
      cssClass: "ag-advanced-filter-builder-value-pill",
      isSelect: !1,
      update: (s) => this.setOperand(s),
      ariaLabel: this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderValue")
    }), this.getGui().appendChild(this.eOperandPill.getGui());
  }
  getColumnKey() {
    return this.filterModel.colId;
  }
  getColumnDisplayValue() {
    return this.advFilterExpSvc.getColumnDisplayValue(this.filterModel);
  }
  getOperatorKey() {
    return this.filterModel.type;
  }
  getOperatorDisplayValue() {
    return this.advFilterExpSvc.getOperatorDisplayValue(this.filterModel);
  }
  getOperandDisplayValue() {
    return this.advFilterExpSvc.getOperandDisplayValue(this.filterModel, !0);
  }
  hasOperand() {
    return this.numOperands > 0;
  }
  getOperatorAutocompleteEntries() {
    return this.column ? this.advFilterExpSvc.getOperatorAutocompleteEntries(this.column, this.baseCellDataType) : [];
  }
  setColumnKey(e) {
    this.eOperatorPill || this.createOperatorPill();
    const t = this.advFilterExpSvc.getColumnDetails(e);
    this.column = t.column;
    const s = t.baseCellDataType;
    this.baseCellDataType !== s && (this.baseCellDataType = s, this.setOperatorKey(void 0), this.eOperatorPill && (ce(this.eOperatorPill.getGui()), this.destroyBean(this.eOperatorPill), this.createOperatorPill()), this.validate()), this.filterModel.colId = e, this.filterModel.filterType = this.baseCellDataType;
  }
  setOperatorKey(e) {
    const t = this.getNumOperands(e);
    t !== this.numOperands && (this.numOperands = t, t === 0 ? this.destroyOperandPill() : (this.createOperandPill(), this.baseCellDataType !== "number" && this.setOperand(""))), this.filterModel.type = e, this.validate();
  }
  setOperand(e) {
    let t = e;
    this.baseCellDataType === "number" && (t = A(e) ? Number(e) : ""), this.filterModel.filter = t, this.validate();
  }
  getNumOperands(e) {
    var t;
    return ((t = this.advFilterExpSvc.getExpressionOperator(this.baseCellDataType, e)) == null ? void 0 : t.numOperands) ?? 0;
  }
  destroyOperandPill() {
    delete this.filterModel.filter, this.getGui().removeChild(this.eOperandPill.getGui()), this.destroyBean(this.eOperandPill), this.eOperandPill = void 0;
  }
  validate() {
    let e = null;
    A(this.getColumnKey()) ? A(this.getOperatorKey()) ? this.numOperands > 0 && !A(this.getOperandDisplayValue()) && (e = this.advFilterExpSvc.translate("advancedFilterBuilderValidationEnterValue")) : e = this.advFilterExpSvc.translate("advancedFilterBuilderValidationSelectOption") : e = this.advFilterExpSvc.translate("advancedFilterBuilderValidationSelectColumn"), this.item.valid = !e, e !== this.validationMessage && (this.validationMessage = e, this.dispatchLocalEvent({
      type: "advancedFilterBuilderValidChanged"
    }));
  }
  getDefaultColumnDisplayValue() {
    return this.advFilterExpSvc.translate("advancedFilterBuilderSelectColumn");
  }
  getDefaultOptionSelectValue() {
    return this.advFilterExpSvc.translate("advancedFilterBuilderSelectOption");
  }
}, YI = class extends L {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-builder-pill-wrapper" role="presentation">
                <div data-ref="ePill" class="ag-advanced-filter-builder-pill" role="button">
                    <span data-ref="eLabel" class="ag-advanced-filter-builder-pill-display"></span>
                </div>
            </div>
        `
    ), this.params = e, this.ePill = S, this.eLabel = S;
    const { value: t, valueFormatter: s } = e;
    this.value = t, this.displayValue = s(t);
  }
  wireBeans(e) {
    this.advFilterExpSvc = e.advFilterExpSvc;
  }
  postConstruct() {
    const { cssClass: e, ariaLabel: t } = this.params;
    this.ePill.classList.add(e), this.activateTabIndex([this.ePill]), this.eLabel.id = `${this.getCompId()}`, _o(this.ePill, this.eLabel.id), oe(this.ePill, t), this.renderValue(), this.addManagedListeners(this.ePill, {
      click: (s) => {
        s.preventDefault(), this.showEditor();
      },
      keydown: (s) => {
        switch (s.key) {
          case w.ENTER:
            s.preventDefault(), he(s), this.showEditor();
            break;
        }
      }
    }), this.addDestroyFunc(() => this.destroyBean(this.eEditor));
  }
  getFocusableElement() {
    return this.ePill;
  }
  showEditor() {
    if (this.eEditor)
      return;
    O(this.ePill, !1), this.eEditor = this.createEditorComp(this.params.type), this.eEditor.setValue(this.value);
    const e = this.eEditor.getGui();
    this.eEditor.addManagedElementListeners(e, {
      keydown: (t) => {
        switch (t.key) {
          case w.ENTER:
            t.preventDefault(), he(t), this.updateValue(!0);
            break;
          case w.ESCAPE:
            t.preventDefault(), he(t), this.hideEditor(!0);
            break;
        }
      },
      focusout: () => this.updateValue(!1)
    }), this.getGui().appendChild(e), this.eEditor.getFocusableElement().focus();
  }
  createEditorComp(e) {
    let t;
    switch (e) {
      case "text":
        t = new Tt();
        break;
      case "number":
        t = new nn();
        break;
      case "date":
        t = new ip();
        break;
    }
    return this.createBean(t);
  }
  hideEditor(e) {
    const { eEditor: t } = this;
    t && (this.eEditor = void 0, this.getGui().removeChild(t.getGui()), this.destroyBean(t), O(this.ePill, !0), e && this.ePill.focus());
  }
  renderValue() {
    let e;
    const { displayValue: t, eLabel: s } = this, { classList: i } = s;
    i.remove(
      "ag-advanced-filter-builder-value-empty",
      "ag-advanced-filter-builder-value-number",
      "ag-advanced-filter-builder-value-text"
    ), A(t) ? this.params.type === "number" ? (e = t, i.add("ag-advanced-filter-builder-value-number")) : (e = `"${t}"`, i.add("ag-advanced-filter-builder-value-text")) : (e = this.advFilterExpSvc.translate("advancedFilterBuilderEnterValue"), i.add("ag-advanced-filter-builder-value-empty")), s.innerText = e;
  }
  updateValue(e) {
    if (!this.eEditor)
      return;
    const t = this.eEditor.getValue() ?? "";
    this.dispatchLocalEvent({
      type: "fieldValueChanged",
      value: t
    }), this.value = t, this.displayValue = this.params.valueFormatter(t), this.renderValue(), this.hideEditor(e);
  }
}, XI = class extends L {
  wireBeans(e) {
    this.advFilterExpSvc = e.advFilterExpSvc;
  }
  constructor() {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `
    );
  }
  init(e) {
    const { item: t, createPill: s } = e, i = t.filterModel;
    this.filterModel = i, this.ePill = s({
      key: i.type,
      displayValue: this.advFilterExpSvc.parseJoinOperator(i),
      cssClass: "ag-advanced-filter-builder-join-pill",
      isSelect: !0,
      getEditorParams: () => ({
        values: this.advFilterExpSvc.getJoinOperatorAutocompleteEntries()
      }),
      update: (r) => i.type = r,
      pickerAriaLabelKey: "ariaLabelAdvancedFilterBuilderJoinSelectField",
      pickerAriaLabelValue: "Advanced Filter Builder Join Operator Select Field",
      ariaLabel: this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderJoinOperator")
    }), this.getGui().appendChild(this.ePill.getGui()), this.addDestroyFunc(() => this.destroyBean(this.ePill));
  }
  getDragName() {
    return this.advFilterExpSvc.parseJoinOperator(this.filterModel);
  }
  getAriaLabel() {
    return `${this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderGroupItem")} ${this.getDragName()}`;
  }
  getValidationMessage() {
    return null;
  }
  getFocusableElement() {
    return this.ePill.getFocusableElement();
  }
}, ZI = class extends jl {
  constructor(e) {
    super({
      ...e,
      template: (
        /* html */
        `
                <div class="ag-picker-field ag-advanced-filter-builder-pill-wrapper" role="presentation">
                    <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-advanced-filter-builder-pill ag-picker-collapsed">
                        <div data-ref="eDisplayField" class="ag-picker-field-display ag-advanced-filter-builder-pill-display"></div>
                        <ag-input-text-field data-ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <span data-ref="eDeselect" class="ag-rich-select-deselect-button ag-picker-field-icon" role="presentation"></span>
                        <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>`
      ),
      agComponents: [mt]
    }), this.params = e;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  showPicker() {
    setTimeout(() => super.showPicker());
  }
  hidePicker() {
    setTimeout(() => super.hidePicker());
  }
  postConstruct() {
    super.postConstruct();
    const { wrapperClassName: e, ariaLabel: t } = this.params;
    this.eWrapper.classList.add(e), vs(this.eWrapper, ""), oe(this.eWrapper, t);
  }
  createPickerComponent() {
    if (!this.values) {
      const { values: e } = this.params.getEditorParams();
      this.values = e;
      const t = this.value.key, s = e.find((i) => i.key === t) ?? {
        key: t,
        displayValue: this.value.displayValue
      };
      this.value = s;
    }
    return super.createPickerComponent();
  }
  onEnterKeyDown(e) {
    he(e), this.isPickerDisplayed ? super.onEnterKeyDown(e) : (e.preventDefault(), this.showPicker());
  }
}, ta = class extends Nt {
  constructor(e, t, s) {
    super(
      /* html */
      `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div class="ag-advanced-filter-builder-item" role="presentation">
                    <div data-ref="eTreeLines" class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true"></div>
                    <span data-ref="eDragHandle" class="ag-drag-handle" aria-hidden="true"></span>
                    <span data-ref="eValidation" class="ag-advanced-filter-builder-item-button ag-advanced-filter-builder-invalid" aria-hidden="true"></span>
                </div>
                <div data-ref="eButtons" class="ag-advanced-filter-builder-item-buttons">
                    <span data-ref="eMoveUpButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <span data-ref="eMoveDownButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <div data-ref="eAddButton" role="presentation"></div>
                    <span data-ref="eRemoveButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                </div>
            </div>
        `
    ), this.item = e, this.dragFeature = t, this.focusWrapper = s, this.eTreeLines = S, this.eDragHandle = S, this.eButtons = S, this.eValidation = S, this.eMoveUpButton = S, this.eMoveDownButton = S, this.eAddButton = S, this.eRemoveButton = S, this.moveUpDisabled = !1, this.moveDownDisabled = !1;
  }
  wireBeans(e) {
    this.dragAndDrop = e.dragAndDrop, this.advFilterExpSvc = e.advFilterExpSvc, this.registry = e.registry;
  }
  postConstruct() {
    const { filterModel: e, level: t, showMove: s } = this.item, i = e.filterType === "join";
    if (this.ePillWrapper = this.createManagedBean(i ? new XI() : new qI()), this.ePillWrapper.init({ item: this.item, createPill: (r) => this.createPill(r) }), this.eDragHandle.insertAdjacentElement("afterend", this.ePillWrapper.getGui()), t === 0) {
      const r = document.createElement("div");
      r.classList.add("ag-advanced-filter-builder-item-tree-line-vertical-bottom"), r.classList.add("ag-advanced-filter-builder-item-tree-line-root"), this.eTreeLines.appendChild(r), O(this.eDragHandle, !1), O(this.eButtons, !1), He(this.focusWrapper, !0);
    } else
      this.setupTreeLines(t), this.eDragHandle.appendChild(B("advancedFilterBuilderDrag", this.beans)), this.setupValidation(), this.setupMoveButtons(s), this.setupAddButton(), this.setupRemoveButton(), this.setupDragging(), this.updateAriaExpanded();
    Sr(this.focusWrapper, t + 1), this.initialiseTabGuard({}), this.createManagedBean(
      new kg(this.getGui(), this.focusWrapper, this.ePillWrapper)
    ), this.updateAriaLabel(), this.addManagedListeners(this.ePillWrapper, {
      advancedFilterBuilderValueChanged: () => this.dispatchLocalEvent({
        type: "advancedFilterBuilderValueChanged"
      }),
      advancedFilterBuilderValidChanged: () => this.updateValidity()
    });
  }
  setState(e) {
    var a, l;
    const { level: t } = this.item;
    if (t === 0)
      return;
    const { showMove: s } = this.item, { disableMoveUp: i, disableMoveDown: r, treeLines: o, showStartTreeLine: n } = e;
    this.updateTreeLines(o, n), this.updateAriaExpanded(), s && (this.moveUpDisabled = !!i, this.moveDownDisabled = !!r, this.eMoveUpButton.classList.toggle("ag-advanced-filter-builder-item-button-disabled", i), this.eMoveDownButton.classList.toggle("ag-advanced-filter-builder-item-button-disabled", r), co(this.eMoveUpButton, !!i), co(this.eMoveDownButton, !!r), (a = this.moveUpTooltipFeature) == null || a.refreshTooltip(), (l = this.moveDownTooltipFeature) == null || l.refreshTooltip());
  }
  focusMoveButton(e) {
    (e ? this.eMoveUpButton : this.eMoveDownButton).focus();
  }
  afterAdd() {
    this.ePillWrapper.getFocusableElement().focus();
  }
  setupTreeLines(e) {
    for (let t = 0; t < e; t++) {
      const s = document.createElement("div");
      this.eTreeLines.appendChild(s);
    }
  }
  updateTreeLines(e, t) {
    const s = e.length - 1, { children: i } = this.eTreeLines;
    for (let o = 0; o < s; o++) {
      const n = i.item(o);
      n && n.classList.toggle("ag-advanced-filter-builder-item-tree-line-vertical", !e[o]);
    }
    const r = i.item(s);
    if (r) {
      r.classList.add("ag-advanced-filter-builder-item-tree-line-horizontal");
      const o = e[s];
      r.classList.toggle("ag-advanced-filter-builder-item-tree-line-vertical-top", o), r.classList.toggle("ag-advanced-filter-builder-item-tree-line-vertical", !o);
    }
    this.eDragHandle.classList.toggle(
      "ag-advanced-filter-builder-item-tree-line-vertical-bottom",
      t
    );
  }
  setupValidation() {
    this.eValidation.appendChild(B("advancedFilterBuilderInvalid", this.beans)), this.validationTooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eValidation,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.ePillWrapper.getValidationMessage(),
        getTooltipShowDelayOverride: () => 1e3
      })
    ), this.updateValidity();
  }
  setupAddButton() {
    var s;
    const e = Og(
      (i) => this.advFilterExpSvc.translate(i),
      (s = this.gos.get("advancedFilterBuilderParams")) == null ? void 0 : s.addSelectWidth
    ), t = this.createManagedBean(new Lg(e));
    this.addManagedListeners(t, {
      fieldPickerValueSelected: ({ value: i }) => this.dispatchLocalEvent({
        type: "advancedFilterBuilderAdded",
        item: this.item,
        isJoin: i.key === "join"
      })
    }), this.eAddButton.appendChild(t.getGui()), this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eAddButton,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.advFilterExpSvc.translate("advancedFilterBuilderAddButtonTooltip")
      })
    );
  }
  setupRemoveButton() {
    this.eRemoveButton.appendChild(B("advancedFilterBuilderRemove", this.beans)), this.addManagedListeners(this.eRemoveButton, {
      click: () => this.removeItem(),
      keydown: (e) => {
        switch (e.key) {
          case w.ENTER:
            e.preventDefault(), he(e), this.removeItem();
            break;
        }
      }
    }), this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eRemoveButton,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.advFilterExpSvc.translate("advancedFilterBuilderRemoveButtonTooltip")
      })
    ), oe(this.eRemoveButton, this.advFilterExpSvc.translate("advancedFilterBuilderRemoveButtonTooltip")), this.activateTabIndex([this.eRemoveButton]);
  }
  setupMoveButtons(e) {
    e ? (this.eMoveUpButton.appendChild(B("advancedFilterBuilderMoveUp", this.beans)), this.addManagedListeners(this.eMoveUpButton, {
      click: () => this.moveItem(!0),
      keydown: (t) => {
        switch (t.key) {
          case w.ENTER:
            t.preventDefault(), he(t), this.moveItem(!0);
            break;
        }
      }
    }), this.moveUpTooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eMoveUpButton,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.moveUpDisabled ? null : this.advFilterExpSvc.translate("advancedFilterBuilderMoveUpButtonTooltip")
      })
    ), oe(
      this.eMoveUpButton,
      this.advFilterExpSvc.translate("advancedFilterBuilderMoveUpButtonTooltip")
    ), this.eMoveDownButton.appendChild(B("advancedFilterBuilderMoveDown", this.beans)), this.addManagedListeners(this.eMoveDownButton, {
      click: () => this.moveItem(!1),
      keydown: (t) => {
        switch (t.key) {
          case w.ENTER:
            t.preventDefault(), he(t), this.moveItem(!1);
            break;
        }
      }
    }), this.moveDownTooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eMoveDownButton,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.moveDownDisabled ? null : this.advFilterExpSvc.translate("advancedFilterBuilderMoveDownButtonTooltip")
      })
    ), oe(
      this.eMoveDownButton,
      this.advFilterExpSvc.translate("advancedFilterBuilderMoveDownButtonTooltip")
    ), this.activateTabIndex([this.eMoveUpButton, this.eMoveDownButton])) : (O(this.eMoveUpButton, !1), O(this.eMoveDownButton, !1));
  }
  updateValidity() {
    var e;
    Rh(this.eValidation, !this.item.valid), (e = this.validationTooltipFeature) == null || e.refreshTooltip(), this.updateAriaLabel();
  }
  createPill(e) {
    const { key: t, cssClass: s, update: i, ariaLabel: r } = e, o = (n) => {
      n != null && (i(n), this.dispatchLocalEvent({
        type: "advancedFilterBuilderValueChanged"
      }));
    };
    if (e.isSelect) {
      const { getEditorParams: n, pickerAriaLabelKey: a, pickerAriaLabelValue: l, displayValue: d } = e, c = this.gos.get("advancedFilterBuilderParams"), h = `${(c == null ? void 0 : c.pillSelectMinWidth) ?? 140}px`, u = `${(c == null ? void 0 : c.pillSelectMaxWidth) ?? 200}px`, p = this.createBean(
        new ZI({
          pickerAriaLabelKey: a,
          pickerAriaLabelValue: l,
          pickerType: "ag-list",
          value: {
            key: t,
            displayValue: d
          },
          valueFormatter: (g) => g == null ? null : g.displayValue ?? g.key,
          variableWidth: !0,
          minPickerWidth: h,
          maxPickerWidth: u,
          getEditorParams: n,
          wrapperClassName: s,
          ariaLabel: r,
          pickerIcon: "advancedFilterBuilderSelectOpen"
        })
      );
      return this.addManagedListeners(p, {
        fieldPickerValueSelected: ({ value: g }) => o(g == null ? void 0 : g.key)
      }), p;
    } else {
      const { baseCellDataType: n, valueFormatter: a } = e, l = this.createBean(
        new YI({
          value: t,
          valueFormatter: a,
          cssClass: s,
          type: this.getInputType(n),
          ariaLabel: r
        })
      );
      return this.addManagedListeners(l, { fieldValueChanged: ({ value: d }) => o(d) }), l;
    }
  }
  getInputType(e) {
    switch (e) {
      case "text":
      case "object":
      case "boolean":
        return "text";
      case "number":
        return "number";
      case "date":
      case "dateString":
        return "date";
    }
  }
  setupDragging() {
    const e = {
      type: xt.AdvancedFilterBuilder,
      eElement: this.eDragHandle,
      dragItemName: () => this.ePillWrapper.getDragName(),
      getDefaultIconName: () => "notAllowed",
      getDragItem: () => ({}),
      onDragStarted: () => this.dragFeature.dispatchLocalEvent({
        type: "advancedFilterBuilderDragStarted",
        item: this.item
      }),
      onDragStopped: () => this.dragFeature.dispatchLocalEvent({
        type: "advancedFilterBuilderDragEnded"
      })
    };
    this.dragAndDrop.addDragSource(e, !0), this.addDestroyFunc(() => this.dragAndDrop.removeDragSource(e));
  }
  updateAriaLabel() {
    const e = this.ePillWrapper.getAriaLabel(), t = `${this.item.level + 1}`, s = this.ePillWrapper.getValidationMessage();
    let i;
    s ? i = this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderItemValidation", [
      e,
      t,
      s
    ]) : i = this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderItem", [e, t]), oe(this.focusWrapper, i);
  }
  updateAriaExpanded() {
    mh(this.focusWrapper);
    const { filterModel: e } = this.item;
    (e == null ? void 0 : e.filterType) === "join" && e.conditions.length && He(this.focusWrapper, !0);
  }
  removeItem() {
    this.dispatchLocalEvent({
      type: "advancedFilterBuilderRemoved",
      item: this.item
    });
  }
  moveItem(e) {
    this.dispatchLocalEvent({
      type: "advancedFilterBuilderMoved",
      item: this.item,
      backwards: e
    });
  }
}, QI = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div role="presentation" class="ag-advanced-filter-builder" tabindex="-1">
                <div role="presentation" class="ag-advanced-filter-builder-list" data-ref="eList"></div>
                <div role="presentation" class="ag-advanced-filter-builder-button-panel">
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-apply-button" data-ref="eApplyFilterButton"></button>
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-cancel-button" data-ref="eCancelFilterButton"></button>
                </div>
            </div>`
    ), this.eList = S, this.eApplyFilterButton = S, this.eCancelFilterButton = S, this.validationMessage = null;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.advancedFilter = e.advancedFilter, this.advFilterExpSvc = e.advFilterExpSvc, this.registry = e.registry;
  }
  postConstruct() {
    const { showMoveButtons: e } = this.gos.get("advancedFilterBuilderParams") ?? {};
    this.showMove = !!e, this.addManagedPropertyListener("advancedFilterBuilderParams", ({ currentValue: t }) => {
      this.showMove = !!(t != null && t.showMoveButtons), this.refreshList(!1);
    }), this.filterModel = this.setupFilterModel(), this.setupVirtualList(), this.dragFeature = this.createManagedBean(new zI(this, this.virtualList)), this.setupButtons();
  }
  refresh() {
    const e = this.virtualList;
    let t = e.getLastFocusedRow();
    this.setupFilterModel(), this.validateItems(), this.refreshList(!1), t != null && (e.getComponentAt(t) || (t = 0), e.focusRow(t));
  }
  getNumItems() {
    return this.items.length;
  }
  moveItem(e, t) {
    !t || !e || this.moveItemToIndex(e, t.rowIndex, t.position);
  }
  afterGuiAttached() {
    this.virtualList.awaitStable(() => this.virtualList.focusRow(0));
  }
  setupVirtualList() {
    const e = this.virtualList = this.createManagedBean(
      new Oi({
        cssIdentifier: "advanced-filter-builder",
        ariaRole: "tree",
        listName: this.advFilterExpSvc.translate("ariaAdvancedFilterBuilderList")
      })
    );
    e.setComponentCreator(this.createItemComponent.bind(this)), e.setComponentUpdater(this.updateItemComponent.bind(this)), e.setRowHeight(40), this.eList.appendChild(e.getGui()), e.setModel({
      getRowCount: () => this.items.length,
      getRow: (t) => this.items[t],
      areRowsEqual: (t, s) => t === s
    }), this.buildList(), e.refresh();
  }
  setupButtons() {
    this.eApplyFilterButton.innerText = this.advFilterExpSvc.translate("advancedFilterBuilderApply"), this.activateTabIndex([this.eApplyFilterButton]), this.addManagedElementListeners(this.eApplyFilterButton, {
      click: () => {
        var t;
        this.advancedFilter.setModel(this.filterModel), (t = this.filterManager) == null || t.onFilterChanged({ source: "advancedFilter" }), this.close();
      }
    }), this.validationTooltipFeature = this.createOptionalManagedBean(
      this.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eApplyFilterButton,
        getLocation: () => "advancedFilter",
        getTooltipValue: () => this.validationMessage,
        getTooltipShowDelayOverride: () => 1e3
      })
    ), this.validate();
    const e = (t) => this.addOrRemoveCssClass("ag-advanced-filter-builder-validation", t);
    this.addManagedListeners(this.eApplyFilterButton, {
      mouseenter: () => e(!0),
      mouseleave: () => e(!1)
    }), this.eCancelFilterButton.innerText = this.advFilterExpSvc.translate("advancedFilterBuilderCancel"), this.activateTabIndex([this.eCancelFilterButton]), this.addManagedElementListeners(this.eCancelFilterButton, { click: () => this.close() });
  }
  removeItemFromParent(e) {
    const t = e.parent.conditions.indexOf(e.filterModel);
    return e.parent.conditions.splice(t, 1), t;
  }
  moveItemToIndex(e, t, s) {
    var a;
    const i = this.items[t], r = ((a = i.filterModel) == null ? void 0 : a.filterType) === "join" && s === "bottom", o = r ? i.filterModel : i.parent;
    if (!o || this.isChildOrSelf(o, e.filterModel) || i === e)
      return;
    this.removeItemFromParent(e);
    let n;
    r ? n = 0 : (n = o.conditions.indexOf(i.filterModel), n === -1 ? n = o.conditions.length : s === "bottom" && (n += 1)), o.conditions.splice(n, 0, e.filterModel), this.refreshList(!1);
  }
  isChildOrSelf(e, t) {
    return e === t || t.filterType === "join" && t.conditions.some((s) => this.isChildOrSelf(e, s));
  }
  setupFilterModel() {
    const e = this.formatFilterModel(this.advancedFilter.getModel());
    return this.stringifiedModel = JSON.stringify(e), e;
  }
  formatFilterModel(e) {
    return e = e ?? {
      filterType: "join",
      type: "AND",
      conditions: []
    }, e.filterType !== "join" && (e = {
      filterType: "join",
      type: "AND",
      conditions: [e]
    }), e;
  }
  buildList() {
    const e = (t, s, i, r) => {
      s.push({ filterModel: t, level: i, parent: r, valid: !0, showMove: this.showMove }), t.filterType === "join" && (t.conditions.forEach(
        (o) => e(o, s, i + 1, t)
      ), i === 0 && s.push({ filterModel: null, level: i + 1, parent: t, valid: !0 }));
    };
    this.items = [], e(this.filterModel, this.items, 0);
  }
  refreshList(e) {
    if (!e) {
      const t = [];
      this.items.forEach((s) => {
        s.valid || t.push(s.filterModel);
      }), this.buildList(), t.length && this.items.forEach((s) => {
        s.filterModel && t.includes(s.filterModel) && (s.valid = !1);
      });
    }
    this.virtualList.refresh(e), this.validate();
  }
  updateItemComponent(e, t) {
    const s = this.items.indexOf(e), i = (a, l) => {
      const d = this.items.find((h) => h.filterModel === a), c = d == null ? void 0 : d.parent;
      if (c) {
        const { conditions: h } = c;
        i(c, l), l.push(h[h.length - 1] === a);
      }
    }, r = [], { filterModel: o } = e;
    o && (i(o, r), r[0] = !1);
    const n = (o == null ? void 0 : o.filterType) === "join" && !!o.conditions.length;
    t.setState({
      disableMoveUp: s === 1,
      disableMoveDown: !this.canMoveDown(e, s),
      treeLines: r,
      showStartTreeLine: n
    });
  }
  createItemComponent(e, t) {
    const s = this.createBean(
      e.filterModel ? new ta(e, this.dragFeature, t) : new jI(e, t)
    );
    return s.addManagedListeners(s, {
      advancedFilterBuilderRemoved: ({ item: i }) => this.removeItem(i),
      advancedFilterBuilderValueChanged: () => this.validate(),
      advancedFilterBuilderAdded: ({ item: i, isJoin: r }) => this.addItem(i, r),
      advancedFilterBuilderMoved: ({ item: i, backwards: r }) => this.moveItemUpDown(i, r)
    }), s instanceof ta && this.updateItemComponent(e, s), s;
  }
  addItem(e, t) {
    var h;
    const { parent: s, level: i, filterModel: r } = e, o = (r == null ? void 0 : r.filterType) === "join", n = t ? {
      filterType: "join",
      type: "AND",
      conditions: []
    } : {}, a = o ? r : s;
    let l = o ? 0 : a.conditions.indexOf(r);
    l >= 0 ? (o || (l += 1), a.conditions.splice(l, 0, n)) : a.conditions.push(n);
    let d = this.items.indexOf(e);
    const c = d >= 0;
    if (c) {
      e.filterModel && d++;
      const u = [
        {
          filterModel: n,
          level: o ? i + 1 : i,
          parent: a,
          valid: t,
          showMove: this.showMove
        }
      ];
      this.items.splice(d, 0, ...u);
    }
    this.refreshList(c), c && ((h = this.virtualList.getComponentAt(d)) == null || h.afterAdd());
  }
  removeItem(e) {
    var a;
    const t = e.parent, { filterModel: s } = e, i = t.conditions.indexOf(s);
    t.conditions.splice(i, 1);
    const r = ((a = e.filterModel) == null ? void 0 : a.filterType) === "join", o = this.items.indexOf(e), n = !r && o >= 0;
    n && this.items.splice(o, 1), this.refreshList(n), o >= 0 && this.virtualList.focusRow(o);
  }
  moveItemUpDown(e, t) {
    const s = this.items.indexOf(e), i = t ? s - 1 : s + 1;
    if (i === 0 || !t && !this.canMoveDown(e, s))
      return;
    const r = this.items[i], o = this.removeItemFromParent(e), { level: n, filterModel: a, parent: l } = e, {
      level: d,
      filterModel: c,
      parent: h
    } = r;
    if (t)
      if (d === n && c.filterType === "join")
        c.conditions.push(a);
      else if (d <= n) {
        const p = h.conditions.indexOf(c);
        h.conditions.splice(p, 0, a);
      } else
        l.conditions[o - 1].conditions.push(a);
    else if (d === n)
      if (c.filterType === "join")
        c.conditions.splice(0, 0, a);
      else {
        const p = h.conditions.indexOf(c);
        h.conditions.splice(p + 1, 0, a);
      }
    else if (o < l.conditions.length)
      l.conditions.splice(o + 1, 0, a);
    else {
      const p = this.items.find((f) => f.filterModel === l), g = p.parent.conditions.indexOf(p.filterModel) + 1;
      p.parent.conditions.splice(g, 0, a);
    }
    this.refreshList(!1);
    const u = this.items.findIndex(
      ({ filterModel: p }) => p === a
    );
    if (u >= 0) {
      const p = this.virtualList.getComponentAt(u);
      p instanceof ta && p.focusMoveButton(t);
    }
  }
  canMoveDown(e, t) {
    return !(e.level === 1 && t === this.items.length - 2 || e.level === 1 && e.parent.conditions[e.parent.conditions.length - 1] === e.filterModel);
  }
  close() {
    this.advancedFilter.getCtrl().toggleFilterBuilder({ source: "ui" });
  }
  validate() {
    var t;
    let e = !this.items.every(({ valid: s }) => s);
    e ? this.validationMessage = this.advFilterExpSvc.translate("advancedFilterBuilderValidationIncomplete") : (e = JSON.stringify(this.filterModel) === this.stringifiedModel, e ? this.validationMessage = this.advFilterExpSvc.translate(
      "advancedFilterBuilderValidationAlreadyApplied"
    ) : this.validationMessage = null), lt(this.eApplyFilterButton, e), (t = this.validationTooltipFeature) == null || t.refreshTooltip();
  }
  validateItems() {
    const e = (s) => {
      s.type = void 0;
    }, t = (s) => {
      delete s.filter;
    };
    this.items.forEach((s) => {
      if (!s.valid || !s.filterModel || s.filterModel.filterType === "join")
        return;
      const { filterModel: i } = s, { colId: r } = i, o = this.advFilterExpSvc.getColumnAutocompleteEntries().find(({ key: d }) => d === r), n = this.advFilterExpSvc.getColumnDetails(i.colId);
      if (!o || !n.column) {
        s.valid = !1, i.colId = void 0, e(i), t(i);
        return;
      }
      const l = this.advFilterExpSvc.getDataTypeExpressionOperator(n.baseCellDataType).operators[i.type];
      if (!l) {
        s.valid = !1, e(i), t(i);
        return;
      }
      if (l.numOperands > 0 && !A(i.filter)) {
        s.valid = !1;
        return;
      }
    });
  }
}, JI = class extends P {
  constructor(e) {
    super(), this.enabled = e;
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.popupSvc = e.popupSvc, this.advFilterExpSvc = e.advFilterExpSvc, this.environment = e.environment;
  }
  postConstruct() {
    this.hasAdvancedFilterParent = !!this.gos.get("advancedFilterParent"), this.ctrlsSvc.whenReady(this, () => this.setAdvancedFilterComp()), this.addManagedEventListeners({
      advancedFilterEnabledChanged: ({ enabled: e }) => this.onEnabledChanged(e)
    }), this.addManagedPropertyListener("advancedFilterParent", () => this.updateComps()), this.addDestroyFunc(() => {
      this.destroyAdvancedFilterComp(), this.destroyBean(this.eBuilderComp), this.eBuilderDialog && this.eBuilderDialog.isAlive() && this.destroyBean(this.eBuilderDialog);
    });
  }
  setupHeaderComp(e) {
    var t;
    this.eHeaderComp && ((t = this.eHeaderComp) == null || t.getGui().remove(), this.destroyBean(this.eHeaderComp)), this.eHeaderComp = this.createManagedBean(
      new HI(this.enabled && !this.hasAdvancedFilterParent)
    ), e.insertAdjacentElement("beforebegin", this.eHeaderComp.getGui());
  }
  focusHeaderComp() {
    return this.eHeaderComp ? (this.eHeaderComp.getFocusableElement().focus(), !0) : !1;
  }
  refreshComp() {
    var e, t;
    (e = this.eFilterComp) == null || e.refresh(), (t = this.eHeaderComp) == null || t.refresh();
  }
  refreshBuilderComp() {
    var e;
    (e = this.eBuilderComp) == null || e.refresh();
  }
  getHeaderHeight() {
    var e;
    return ((e = this.eHeaderComp) == null ? void 0 : e.getHeight()) ?? 0;
  }
  setInputDisabled(e) {
    var t, s;
    (t = this.eFilterComp) == null || t.setInputDisabled(e), (s = this.eHeaderComp) == null || s.setInputDisabled(e);
  }
  toggleFilterBuilder(e) {
    const { source: t, force: s, eventSource: i } = e;
    if (s && this.eBuilderDialog || s === !1 && !this.eBuilderDialog)
      return;
    if (this.eBuilderDialog) {
      this.builderDestroySource = t, this.destroyBean(this.eBuilderDialog);
      return;
    }
    this.setInputDisabled(!0);
    const { width: r, height: o, minWidth: n } = this.getBuilderDialogSize();
    this.eBuilderComp = this.createBean(new QI()), this.eBuilderDialog = this.createBean(
      new Er({
        title: this.advFilterExpSvc.translate("advancedFilterBuilderTitle"),
        component: this.eBuilderComp,
        width: r,
        height: o,
        resizable: !0,
        movable: !0,
        maximizable: !0,
        centered: !0,
        closable: !0,
        minWidth: n,
        afterGuiAttached: () => {
          var a;
          return (a = this.eBuilderComp) == null ? void 0 : a.afterGuiAttached();
        },
        postProcessPopupParams: {
          type: "advancedFilterBuilder",
          eventSource: i
        }
      })
    ), this.dispatchFilterBuilderVisibleChangedEvent(t, !0), this.eBuilderDialog.addEventListener("destroyed", () => {
      this.destroyBean(this.eBuilderComp), this.eBuilderComp = void 0, this.eBuilderDialog = void 0, this.setInputDisabled(!1), this.dispatchLocalEvent({
        type: "advancedFilterBuilderClosed"
      }), this.dispatchFilterBuilderVisibleChangedEvent(this.builderDestroySource ?? "ui", !1), this.builderDestroySource = void 0;
    });
  }
  dispatchFilterBuilderVisibleChangedEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: "advancedFilterBuilderVisibleChanged",
      source: e,
      visible: t
    });
  }
  getBuilderDialogSize() {
    var n;
    const e = ((n = this.gos.get("advancedFilterBuilderParams")) == null ? void 0 : n.minWidth) ?? 500, t = this.popupSvc.getPopupParent(), s = Math.round($s(t)) - 2, i = Math.round(jo(t) * 0.75) - 2, r = Math.min(Math.max(600, e), s), o = Math.min(600, i);
    return { width: r, height: o, minWidth: e };
  }
  onEnabledChanged(e) {
    this.enabled = e, this.updateComps();
  }
  updateComps() {
    this.setAdvancedFilterComp(), this.setHeaderCompEnabled(), this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  setAdvancedFilterComp() {
    if (this.destroyAdvancedFilterComp(), !this.enabled)
      return;
    const e = this.gos.get("advancedFilterParent");
    if (this.hasAdvancedFilterParent = !!e, e) {
      const t = this.createBean(new Ag()), s = t.getGui();
      this.environment.applyThemeClasses(s), s.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr"), e.appendChild(s), this.eFilterComp = t;
    }
  }
  setHeaderCompEnabled() {
    var e;
    (e = this.eHeaderComp) == null || e.setEnabled(this.enabled && !this.hasAdvancedFilterParent);
  }
  destroyAdvancedFilterComp() {
    this.eFilterComp && (ce(this.eFilterComp.getGui()), this.destroyBean(this.eFilterComp));
  }
}, eL = class {
  constructor(e) {
    this.params = e, this.operators = [], this.operatorStartPositions = [], this.operatorEndPositions = [], this.activeOperator = 0, this.validationError = null;
  }
  parseExpression(e) {
    this.operators.push(""), this.operatorStartPositions.push(e), this.operatorEndPositions.push(void 0);
    const { expression: t } = this.params;
    for (; e < t.length; ) {
      const s = t[e];
      if (s === " ") {
        if (this.parseOperator(e - 1))
          return this.activeOperator++, e - 1;
        this.operators[this.activeOperator] += s;
      } else
        this.operators[this.activeOperator] += s;
      e++;
    }
    return this.parseOperator(e - 1), e;
  }
  isValid() {
    return !this.validationError && (!this.operators.length || !!this.parsedOperator);
  }
  getValidationError() {
    return this.validationError;
  }
  getFunction() {
    return this.parsedOperator === "OR" ? "||" : "&&";
  }
  getModel() {
    return this.parsedOperator === "OR" ? "OR" : "AND";
  }
  getAutocompleteListParams(e, t) {
    let s;
    if (t == null)
      s = "";
    else {
      const r = this.operators[t], o = this.operatorEndPositions[t];
      s = Va(
        r,
        e,
        o == null ? this.params.expression.length : o + 1
      );
    }
    let i = this.params.advFilterExpSvc.getJoinOperatorAutocompleteEntries();
    return (t || t == null && this.activeOperator) && (i = i.filter(({ key: r }) => r === this.parsedOperator)), this.params.advFilterExpSvc.generateAutocompleteListParams(i, "join", s);
  }
  updateExpression(e, t, s) {
    let { expression: i } = this.params;
    const r = t.displayValue ?? t.key;
    if (s === 0)
      for (let a = this.operatorEndPositions.length - 1; a > 0; a--) {
        const l = this.operatorEndPositions[a];
        l != null && (i = Cs(
          i,
          this.operatorStartPositions[a],
          l,
          r
        ).updatedValue);
      }
    const o = this.operatorStartPositions.length > s ? this.operatorStartPositions[s] : e, n = (this.operatorEndPositions.length > s ? this.operatorEndPositions[s] : void 0) ?? Na(i, e, !0).endPosition;
    return Cs(i, o, n, r, !0);
  }
  getNumOperators() {
    return this.operators.length;
  }
  getLastOperatorEndPosition() {
    return this.operatorEndPositions[this.operatorEndPositions.length - 1];
  }
  parseOperator(e) {
    const t = this.operators.length > this.activeOperator ? this.operators[this.activeOperator] : "", s = this.params.advFilterExpSvc.getExpressionJoinOperators(), i = mn(t, s, (r) => r);
    if (i) {
      this.operatorEndPositions[this.activeOperator] = e;
      const r = s[i];
      if (this.activeOperator) {
        if (i !== this.parsedOperator)
          return this.validationError || (this.validationError = {
            message: this.params.advFilterExpSvc.translate(
              "advancedFilterValidationJoinOperatorMismatch"
            ),
            startPosition: e - t.length + 1,
            endPosition: e
          }), !1;
      } else
        this.parsedOperator = i;
      return t !== r && (Kl(this.params, t, r, e), this.operators[this.activeOperator] = r), !0;
    } else return i === null ? !1 : (this.validationError || (this.validationError = {
      message: this.params.advFilterExpSvc.translate("advancedFilterValidationInvalidJoinOperator"),
      startPosition: e - t.length + 1,
      endPosition: e
    }), !0);
  }
}, tL = class Gg {
  constructor(t, s) {
    this.params = t, this.startPosition = s, this.expectingExpression = !0, this.expectingOperator = !1, this.expressionParsers = [], this.operatorParser = new eL(this.params), this.missingEndBracket = !1, this.extraEndBracket = !1;
  }
  parseExpression() {
    let t = this.startPosition;
    const { expression: s } = this.params;
    for (; t < s.length; ) {
      const i = s[t];
      if (i === "(" && !this.expectingOperator) {
        const r = new Gg(this.params, t + 1);
        t = r.parseExpression(), this.expressionParsers.push(r), this.expectingExpression = !1, this.expectingOperator = !0;
      } else {
        if (i === ")")
          return this.endPosition = t - 1, this.startPosition === 0 && (this.extraEndBracket = !0), t;
        if (i !== " ") if (this.expectingExpression) {
          const r = new DI(this.params, t);
          t = r.parseExpression(), this.expressionParsers.push(r), this.expectingExpression = !1, this.expectingOperator = !0;
        } else this.expectingOperator && (t = this.operatorParser.parseExpression(t), this.expectingOperator = !1, this.expectingExpression = !0);
      }
      t++;
    }
    return this.startPosition > 0 && (this.missingEndBracket = !0), t;
  }
  isValid() {
    return !this.missingEndBracket && !this.extraEndBracket && this.expressionParsers.length === this.operatorParser.getNumOperators() + 1 && this.operatorParser.isValid() && this.expressionParsers.every((t) => t.isValid());
  }
  getValidationError() {
    const t = this.operatorParser.getValidationError();
    for (let i = 0; i < this.expressionParsers.length; i++) {
      const r = this.expressionParsers[i].getValidationError();
      if (r)
        return t && t.startPosition < r.startPosition ? t : r;
    }
    if (t)
      return t;
    if (this.extraEndBracket)
      return {
        message: this.params.advFilterExpSvc.translate("advancedFilterValidationExtraEndBracket"),
        startPosition: this.endPosition + 1,
        endPosition: this.endPosition + 1
      };
    let s;
    return this.expressionParsers.length === this.operatorParser.getNumOperators() ? s = "advancedFilterValidationMissingCondition" : this.missingEndBracket && (s = "advancedFilterValidationMissingEndBracket"), s ? {
      message: this.params.advFilterExpSvc.translate(s),
      startPosition: this.params.expression.length,
      endPosition: this.params.expression.length
    } : null;
  }
  getFunctionString(t) {
    const s = this.expressionParsers.length > 1, i = this.expressionParsers.map((r) => r.getFunctionString(t)).join(` ${this.operatorParser.getFunction()} `);
    return s ? `(${i})` : i;
  }
  getFunctionParsed(t) {
    const s = this.operatorParser.getFunction(), i = this.expressionParsers.map((o) => o.getFunctionParsed(t)), r = s === "&&" ? "every" : "some";
    return (o, n, a) => i[r]((l) => l(o, n, a));
  }
  getAutocompleteListParams(t) {
    if (this.endPosition != null && t > this.endPosition + 1)
      return;
    if (!this.expressionParsers.length)
      return this.getColumnAutocompleteListParams();
    const s = this.getExpressionParserIndex(t);
    if (s == null)
      return this.params.expression[t] === "(" ? { enabled: !1 } : this.getColumnAutocompleteListParams();
    const r = this.expressionParsers[s].getAutocompleteListParams(t);
    if (!r) {
      if (s < this.expressionParsers.length - 1)
        return this.operatorParser.getAutocompleteListParams(t, s);
      if (this.expressionParsers.length === this.operatorParser.getNumOperators()) {
        const o = this.operatorParser.getLastOperatorEndPosition();
        return o == null || t <= o + 1 ? this.operatorParser.getAutocompleteListParams(t, this.operatorParser.getNumOperators() - 1) : this.getColumnAutocompleteListParams();
      }
      return this.params.expression[t - 1] === ")" ? { enabled: !1 } : this.operatorParser.getAutocompleteListParams(t);
    }
    return r;
  }
  updateExpression(t, s, i) {
    const r = this.params.expression, o = this.getExpressionParserIndex(t);
    if (o == null) {
      const l = i === "column" ? this.params.advFilterExpSvc.getColumnValue(s) : s.displayValue ?? s.key;
      return Cs(r, this.startPosition, this.startPosition, l, !0);
    }
    const a = this.expressionParsers[o].updateExpression(t, s, i);
    return a ?? (i === "column" ? Cs(
      r,
      t,
      r.length - 1,
      this.params.advFilterExpSvc.getColumnValue(s),
      !0
    ) : this.endPosition != null && t > this.endPosition + 1 ? null : this.operatorParser.updateExpression(t, s, o));
  }
  getModel() {
    return this.expressionParsers.length > 1 ? {
      filterType: "join",
      type: this.operatorParser.getModel(),
      conditions: this.expressionParsers.map((t) => t.getModel())
    } : this.expressionParsers[0].getModel();
  }
  getColumnAutocompleteListParams() {
    return this.params.advFilterExpSvc.generateAutocompleteListParams(
      this.params.advFilterExpSvc.getColumnAutocompleteEntries(),
      "column",
      ""
    );
  }
  getExpressionParserIndex(t) {
    let s;
    for (let i = 0; i < this.expressionParsers.length && !(this.expressionParsers[i].startPosition > t); i++)
      s = i;
    return s;
  }
}, sL = class {
  constructor(e) {
    this.params = e, this.valid = !1;
  }
  parseExpression() {
    this.joinExpressionParser = new tL(this.params, 0);
    const e = this.joinExpressionParser.parseExpression();
    return this.valid = e >= this.params.expression.length - 1 && this.joinExpressionParser.isValid(), this.params.expression;
  }
  isValid() {
    return this.valid;
  }
  getValidationMessage() {
    const e = this.joinExpressionParser.getValidationError();
    if (!e)
      return null;
    const { message: t, startPosition: s, endPosition: i } = e;
    return s < this.params.expression.length ? this.params.advFilterExpSvc.translate("advancedFilterValidationMessage", [
      t,
      this.params.expression.slice(s, i + 1).trim()
    ]) : this.params.advFilterExpSvc.translate("advancedFilterValidationMessageAtEnd", [t]);
  }
  getFunctionString() {
    const e = this.createFunctionParams();
    return {
      functionString: `return ${this.joinExpressionParser.getFunctionString(e)};`,
      params: e
    };
  }
  getFunctionParsed() {
    const e = this.createFunctionParams();
    return {
      expressionFunction: this.joinExpressionParser.getFunctionParsed(e),
      params: e
    };
  }
  getAutocompleteListParams(e) {
    return this.joinExpressionParser.getAutocompleteListParams(e) ?? { enabled: !1 };
  }
  updateExpression(e, t, s) {
    return this.joinExpressionParser.updateExpression(e, t, s);
  }
  getModel() {
    return this.isValid() ? this.joinExpressionParser.getModel() : null;
  }
  createFunctionParams() {
    return {
      operands: [],
      operators: [],
      evaluatorParams: []
    };
  }
}, iL = class extends P {
  constructor() {
    super(...arguments), this.beanName = "advancedFilter", this.appliedExpression = null, this.expression = null, this.isValid = !0;
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc, this.colModel = e.colModel, this.dataTypeSvc = e.dataTypeSvc, this.advFilterExpSvc = e.advFilterExpSvc, this.filterValueSvc = e.filterValueSvc;
  }
  postConstruct() {
    this.setEnabled(this.gos.get("enableAdvancedFilter"), !0), this.ctrl = this.createManagedBean(new JI(this.enabled)), this.expressionProxy = {
      getValue: (e, t) => {
        const s = this.colModel.getColDefCol(e);
        return s ? this.filterValueSvc.getValue(s, t) : void 0;
      }
    }, this.addManagedPropertyListener("enableAdvancedFilter", (e) => this.setEnabled(!!e.currentValue)), this.addManagedEventListeners({
      newColumnsLoaded: (e) => this.onNewColumnsLoaded(e)
    }), this.addManagedPropertyListener("includeHiddenColumnsInAdvancedFilter", () => this.updateValidity());
  }
  isEnabled() {
    return this.enabled;
  }
  isFilterPresent() {
    return !!this.expressionFunction;
  }
  doesFilterPass(e) {
    return this.expressionFunction(this.expressionProxy, e, this.expressionParams);
  }
  getModel() {
    const e = this.createExpressionParser(this.appliedExpression);
    return e == null || e.parseExpression(), (e == null ? void 0 : e.getModel()) ?? null;
  }
  setModel(e) {
    const t = (i, r) => {
      if (i.filterType === "join") {
        const o = this.advFilterExpSvc.parseJoinOperator(i), n = i.conditions.map((a) => t(a)).filter((a) => A(a)).join(` ${o} `);
        return r || i.conditions.length <= 1 ? n : `(${n})`;
      } else
        return this.advFilterExpSvc.parseColumnFilterModel(i);
    }, s = e ? t(e, !0) : null;
    this.setExpressionDisplayValue(s), this.applyExpression(), this.ctrl.refreshComp(), this.ctrl.refreshBuilderComp();
  }
  getExpressionDisplayValue() {
    return this.expression;
  }
  setExpressionDisplayValue(e) {
    this.expression = e;
  }
  isCurrentExpressionApplied() {
    return this.appliedExpression === this.expression;
  }
  createExpressionParser(e) {
    return e ? new sL({
      expression: e,
      colModel: this.colModel,
      dataTypeSvc: this.dataTypeSvc,
      valueSvc: this.valueSvc,
      advFilterExpSvc: this.advFilterExpSvc
    }) : null;
  }
  getDefaultExpression(e) {
    const t = this.advFilterExpSvc.getColumnValue(e) + " ";
    return {
      updatedValue: t,
      updatedPosition: t.length
    };
  }
  isHeaderActive() {
    return !this.gos.get("advancedFilterParent");
  }
  getCtrl() {
    return this.ctrl;
  }
  setEnabled(e, t) {
    const s = this.enabled, i = J(this.gos) || Te(this.gos);
    e && !i && R(123), this.enabled = e && i, !t && this.enabled !== s && this.eventSvc.dispatchEvent({
      type: "advancedFilterEnabledChanged",
      enabled: this.enabled
    });
  }
  applyExpression() {
    const e = this.createExpressionParser(this.expression);
    e == null || e.parseExpression(), this.applyExpressionFromParser(e);
  }
  applyExpressionFromParser(e) {
    if (this.isValid = !e || e.isValid(), !e || !this.isValid) {
      this.expressionFunction = null, this.expressionParams = null, this.appliedExpression = null;
      return;
    }
    const { expressionFunction: t, params: s } = this.getFunction(e);
    this.expressionFunction = t, this.expressionParams = s, this.appliedExpression = this.expression;
  }
  getFunction(e) {
    if (this.gos.get("suppressAdvancedFilterEval"))
      return e.getFunctionParsed();
    {
      const { functionString: t, params: s } = e.getFunctionString();
      return {
        expressionFunction: new Function(
          "expressionProxy",
          "node",
          "params",
          t
        ),
        params: s
      };
    }
  }
  updateValidity() {
    this.advFilterExpSvc.resetColumnCaches();
    const e = this.createExpressionParser(this.expression);
    e == null || e.parseExpression();
    const s = (!e || e.isValid()) !== this.isValid;
    return this.applyExpressionFromParser(e), this.ctrl.refreshComp(), this.ctrl.refreshBuilderComp(), s;
  }
  onNewColumnsLoaded(e) {
    var s;
    if (e.source !== "gridInitializing" || !((s = this.dataTypeSvc) != null && s.isPendingInference))
      return;
    this.ctrl.setInputDisabled(!0);
    const [t] = this.addManagedEventListeners({
      dataTypesInferred: () => {
        t == null || t(), this.ctrl.setInputDisabled(!1);
      }
    });
  }
}, rL = {
  moduleName: "AdvancedFilter",
  version: j,
  beans: [iL, MI],
  icons: {
    // Builder button in Advanced Filter
    advancedFilterBuilder: "group",
    // drag handle used to pick up Advanced Filter Builder rows
    advancedFilterBuilderDrag: "grip",
    // Advanced Filter Builder row validation error
    advancedFilterBuilderInvalid: "not-allowed",
    // shown on Advanced Filter Builder rows to move them up
    advancedFilterBuilderMoveUp: "up",
    // shown on Advanced Filter Builder rows to move them down
    advancedFilterBuilderMoveDown: "down",
    // shown on Advanced Filter Builder rows to add new rows
    advancedFilterBuilderAdd: "plus",
    // shown on Advanced Filter Builder rows to remove row
    advancedFilterBuilderRemove: "minus",
    // shown on Advanced Filter Builder selection pills
    advancedFilterBuilderSelectOpen: "small-down",
    // remove for rich select editor pills
    richSelectRemove: "cancel"
  },
  apiFunctions: {
    getAdvancedFilterModel: vI,
    setAdvancedFilterModel: wI,
    showAdvancedFilterBuilder: yI,
    hideAdvancedFilterBuilder: bI
  },
  dependsOn: [te, pn, Li, ts, _l],
  css: [CI]
};
function oL(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.isDisplayed()) ?? !1;
}
function nL(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.setDisplayed(t);
}
function aL(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.setSideBarPosition(t);
}
function lL(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.openToolPanel(t, "api");
}
function dL(e) {
  var t;
  (t = e.sideBar) == null || t.comp.close("api");
}
function cL(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.openedItem()) ?? null;
}
function hL(e) {
  var t;
  (t = e.sideBar) == null || t.comp.refresh();
}
function uL(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.isToolPanelShowing()) ?? !1;
}
function pL(e, t) {
  var i;
  const s = (i = e.sideBar) == null ? void 0 : i.comp.getToolPanelInstance(t);
  return Ys(s);
}
function gL(e) {
  var t;
  return (t = e.sideBar) == null ? void 0 : t.comp.getDef();
}
function Wa(e, t) {
  if (!t)
    return null;
  const s = bt(e), i = s.indexOf(t);
  if (i === -1)
    return null;
  let r = -1;
  for (let o = i - 1; o >= 0; o--)
    if (s[o].classList.contains(io.TAB_GUARD_TOP)) {
      r = o;
      break;
    }
  return r <= 0 ? null : s[r - 1];
}
function Bg(e, t) {
  if (!t)
    return !1;
  const s = e.querySelectorAll(`.${Wu}`);
  if (!s.length)
    return !1;
  for (let i = 0; i < s.length; i++)
    if (s[i].contains(t))
      return !0;
  return !1;
}
var fL = (
  /*css*/
  '.ag-tool-panel-wrapper{cursor:default;display:flex;overflow:hidden auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-side-bar-panel-width)}.ag-select-agg-func-item{align-items:center;display:flex;flex:1 1 auto;flex-flow:row nowrap;height:100%;overflow:hidden;position:relative;text-overflow:ellipsis;white-space:nowrap;>*{flex:none}}.ag-tool-panel-horizontal-resize{cursor:ew-resize;height:100%;position:absolute;top:0;width:5px;z-index:1}.ag-side-bar{background-color:var(--ag-side-bar-background-color);display:flex;flex-direction:row-reverse;position:relative}:where(.ag-ltr) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{right:-3px}:where(.ag-rtl) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-ltr) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-rtl) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{right:-3px}.ag-side-bar-left{flex-direction:row;order:-1}.ag-side-buttons{background-color:var(--ag-side-button-bar-background-color);padding-top:var(--ag-side-button-bar-top-padding);position:relative}.ag-side-button{background-color:var(--ag-side-button-background-color);border-bottom:var(--ag-side-button-selected-border);border-bottom-color:transparent;border-top:var(--ag-side-button-selected-border);border-top-color:transparent;color:var(--ag-side-button-text-color);position:relative;&:before{background-color:transparent;bottom:0;content:"";display:block;position:absolute;top:0;transition:background-color var(--ag-side-button-selected-underline-transition-duration);width:var(--ag-side-button-selected-underline-width)}&:hover{background-color:var(--ag-side-button-hover-background-color);color:var(--ag-side-button-hover-text-color)}&.ag-selected{background-color:var(--ag-side-button-selected-background-color);border-bottom:var(--ag-side-button-selected-border);color:var(--ag-side-button-selected-text-color);&:where(:not(:first-of-type)){border-top:var(--ag-side-button-selected-border)}&:before{background-color:var(--ag-side-button-selected-underline-color)}}}:where(.ag-ltr) .ag-side-button{&:before{left:0}}:where(.ag-rtl) .ag-side-button{&:before{right:0}}.ag-side-button-button{align-items:center;cursor:pointer;display:flex;flex-direction:column;gap:var(--ag-spacing);position:relative;white-space:nowrap;width:100%;&:focus{box-shadow:none}}:where(.ag-ltr) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding)}:where(.ag-rtl) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding)}.ag-side-button-button:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-side-button-label{writing-mode:vertical-lr}@media (resolution <= 1.5x){.ag-side-button-label{font-family:"Segoe UI",var(--ag-font-family)}:where(.ag-ltr) .ag-side-button-label{transform:rotate(.05deg)}:where(.ag-rtl) .ag-side-button-label{transform:rotate(-.05deg)}}:where(.ag-ltr) .ag-side-bar-left,:where(.ag-rtl) .ag-side-bar-right{border-right:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-left:var(--ag-side-panel-border)}}:where(.ag-ltr) .ag-side-bar-right,:where(.ag-rtl) .ag-side-bar-left{border-left:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-right:var(--ag-side-panel-border)}}'
), mL = class extends L {
  constructor(e) {
    super(), this.toolPanelDef = e, this.eToggleButton = S, this.eIconWrapper = S, this.eLabel = S;
  }
  getToolPanelId() {
    return this.toolPanelDef.id;
  }
  postConstruct() {
    const e = this.createTemplate();
    this.setTemplate(e, []), this.setLabel(), this.setIcon(), this.addManagedElementListeners(this.eToggleButton, { click: this.onButtonPressed.bind(this) }), this.eToggleButton.setAttribute("id", `ag-${this.getCompId()}-button`);
  }
  createTemplate() {
    return (
      /* html */
      `<div class="ag-side-button" role="presentation">
                <button type="button" data-ref="eToggleButton" tabindex="-1" role="tab" aria-expanded="false" class="ag-button ag-side-button-button">
                    <div data-ref="eIconWrapper" class="ag-side-button-icon-wrapper" aria-hidden="true"></div>
                    <span data-ref="eLabel" class="ag-side-button-label"></span>
                </button>
            </div>`
    );
  }
  setLabel() {
    const e = this.getLocaleTextFunc(), t = this.toolPanelDef, s = e(t.labelKey, t.labelDefault);
    this.eLabel.innerText = s;
  }
  setIcon() {
    this.eIconWrapper.insertAdjacentElement(
      "afterbegin",
      B(this.toolPanelDef.iconKey, this.beans)
    );
  }
  onButtonPressed() {
    this.dispatchLocalEvent({ type: "toggleButtonClicked" });
  }
  setSelected(e) {
    this.addOrRemoveCssClass("ag-selected", e), He(this.eToggleButton, e);
  }
}, CL = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-side-buttons" role="tablist"></div>'
    ), this.buttonComps = [];
  }
  postConstruct() {
    this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    if (!(e.key !== w.TAB || !e.shiftKey)) {
      if (Xt(this.beans, !0)) {
        e.preventDefault();
        return;
      }
      he(e);
    }
  }
  setActiveButton(e) {
    this.buttonComps.forEach((t) => {
      t.setSelected(e === t.getToolPanelId());
    });
  }
  addButtonComp(e) {
    const t = this.createBean(new mL(e));
    return this.buttonComps.push(t), this.appendChild(t), t.addEventListener("toggleButtonClicked", () => {
      this.dispatchLocalEvent({
        type: "sideBarButtonClicked",
        toolPanelId: e.id
      });
    }), t;
  }
  clearButtons() {
    this.buttonComps = this.destroyBeans(this.buttonComps), X(this.getGui()), super.destroy();
  }
  destroy() {
    this.clearButtons(), super.destroy();
  }
}, vL = {
  selector: "AG-SIDE-BAR-BUTTONS",
  component: CL
}, Vg = {
  id: "columns",
  labelDefault: "Columns",
  labelKey: "columns",
  iconKey: "columnsToolPanel",
  toolPanel: "agColumnsToolPanel"
}, Ng = {
  id: "filters",
  labelDefault: "Filters",
  labelKey: "filters",
  iconKey: "filtersToolPanel",
  toolPanel: "agFiltersToolPanel"
}, Oo = {
  columns: Vg,
  filters: Ng
};
function _a(e) {
  if (!e)
    return;
  if (e === !0)
    return {
      toolPanels: [Vg, Ng],
      defaultToolPanel: "columns"
    };
  if (typeof e == "string")
    return _a([e]);
  if (Array.isArray(e)) {
    const s = [];
    return e.forEach((i) => {
      const r = Oo[i];
      if (!r) {
        R(215, { key: i, defaultByKey: Oo });
        return;
      }
      s.push(r);
    }), s.length === 0 ? void 0 : {
      toolPanels: s,
      defaultToolPanel: s[0].id
    };
  }
  return {
    toolPanels: wL(e.toolPanels),
    defaultToolPanel: e.defaultToolPanel,
    hiddenByDefault: e.hiddenByDefault,
    position: e.position
  };
}
function wL(e) {
  const t = [];
  return e && e.forEach((s) => {
    let i = null;
    if (typeof s == "string") {
      const r = Oo[s];
      if (!r) {
        R(215, { key: s, defaultByKey: Oo });
        return;
      }
      i = r;
    } else
      i = s;
    t.push(i);
  }), t;
}
var yL = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-tool-panel-horizontal-resize"></div>'
    ), this.minWidth = 100, this.maxWidth = null;
  }
  postConstruct() {
    const e = this.beans.horizontalResizeSvc.addResizeBar({
      eResizeBar: this.getGui(),
      dragStartPixels: 1,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this),
      onResizeEnd: this.onResizeEnd.bind(this)
    });
    this.addDestroyFunc(e), this.inverted = this.gos.get("enableRtl");
  }
  dispatchResizeEvent(e, t, s) {
    this.eventSvc.dispatchEvent({
      type: "toolPanelSizeChanged",
      width: s,
      started: e,
      ended: t
    });
  }
  onResizeStart() {
    this.startingWidth = this.elementToResize.offsetWidth, this.dispatchResizeEvent(!0, !1, this.startingWidth);
  }
  onResizeEnd(e) {
    return this.onResizing(e, !0);
  }
  onResizing(e, t = !1) {
    const s = this.inverted ? -1 : 1;
    let i = Math.max(this.minWidth, Math.floor(this.startingWidth - e * s));
    this.maxWidth != null && (i = Math.min(this.maxWidth, i)), this.elementToResize.style.width = `${i}px`, this.dispatchResizeEvent(!1, t, i);
  }
};
function bL(e, t, s) {
  return e.getCompDetails(t, SL, void 0, s, !0);
}
var SL = {
  name: "toolPanel",
  optionalMethods: ["refresh", "getState"]
}, xL = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-tool-panel-wrapper" role="tabpanel"/>'
    );
  }
  postConstruct() {
    const e = this.getGui(), t = this.resizeBar = this.createManagedBean(new yL());
    e.setAttribute("id", `ag-${this.getCompId()}`), t.elementToResize = e, this.appendChild(t);
  }
  getToolPanelId() {
    return this.toolPanelId;
  }
  setToolPanelDef(e, t) {
    const { id: s, minWidth: i, maxWidth: r, width: o } = e;
    this.toolPanelId = s, this.width = o;
    const n = bL(this.beans.userCompFactory, e, t);
    if (n == null)
      return !1;
    const a = n.newAgStackInstance();
    this.params = n.params, a.then(this.setToolPanelComponent.bind(this));
    const l = this.resizeBar;
    return i != null && (l.minWidth = i), r != null && (l.maxWidth = r), !0;
  }
  setToolPanelComponent(e) {
    this.toolPanelCompInstance = e, this.appendChild(e.getGui()), this.addDestroyFunc(() => {
      this.destroyBean(e);
    });
    const t = this.width;
    t && (this.getGui().style.width = `${t}px`);
  }
  getToolPanelInstance() {
    return this.toolPanelCompInstance;
  }
  setResizerSizerSide(e) {
    const t = this.gos.get("enableRtl"), s = e === "left", i = t ? s : !s;
    this.resizeBar.inverted = i;
  }
  refresh() {
    var e;
    (e = this.toolPanelCompInstance) == null || e.refresh(this.params);
  }
}, FL = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-side-bar ag-unselectable">
                <ag-side-bar-buttons data-ref="sideBarButtons"></ag-side-bar-buttons>
            </div>`,
      [vL]
    ), this.sideBarButtons = S, this.toolPanelWrappers = [], this.registerCSS(fL);
  }
  postConstruct() {
    this.sideBarButtons.addEventListener("sideBarButtonClicked", this.onToolPanelButtonClicked.bind(this));
    const { beans: e, gos: t } = this, { sideBar: s } = t.get("initialState") ?? {};
    this.setSideBarDef({
      sideBarDef: _a(t.get("sideBar")),
      sideBarState: s
    }), this.addManagedPropertyListener("sideBar", this.onSideBarUpdated.bind(this)), e.sideBar.comp = this;
    const i = this.getFocusableElement();
    this.createManagedBean(
      new Ps(i, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), Du(e, this, i);
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented)
      return;
    const { beans: t, sideBarButtons: s } = this, i = this.getGui(), r = s.getGui(), o = q(t), n = i.querySelector(".ag-tool-panel-wrapper:not(.ag-hidden)"), a = e.target;
    if (!n)
      return Xt(t, e.shiftKey, !0);
    if (r.contains(o)) {
      ve(n, e.shiftKey) && e.preventDefault();
      return;
    }
    if (!e.shiftKey)
      return;
    let l = null;
    n.contains(o) ? l = Pe(t, n, void 0, !0) : Bg(n, a) && e.shiftKey && (l = Wa(n, a)), l || (l = r.querySelector(".ag-selected button")), l && l !== e.target && (e.preventDefault(), l.focus());
  }
  handleKeyDown(e) {
    const t = q(this.beans), s = this.sideBarButtons;
    if (!s.getGui().contains(t))
      return;
    const i = s.getGui(), r = Array.prototype.slice.call(i.querySelectorAll(".ag-side-button")), o = r.findIndex((l) => l.contains(t));
    let n = null;
    switch (e.key) {
      case w.LEFT:
      case w.UP:
        n = Math.max(0, o - 1);
        break;
      case w.RIGHT:
      case w.DOWN:
        n = Math.min(o + 1, r.length - 1);
        break;
    }
    if (n === null)
      return;
    const a = r[n].querySelector("button");
    a && (a.focus(), e.preventDefault());
  }
  onToolPanelButtonClicked(e) {
    const t = e.toolPanelId;
    this.openedItem() === t ? this.openToolPanel(void 0, "sideBarButtonClicked") : this.openToolPanel(t, "sideBarButtonClicked");
  }
  clearDownUi() {
    this.sideBarButtons.clearButtons(), this.destroyToolPanelWrappers();
  }
  setSideBarDef({
    sideBarDef: e,
    sideBarState: t,
    existingToolPanelWrappers: s
  }) {
    if (this.setDisplayed(!1), this.sideBar = e, e && e.toolPanels) {
      const i = e.toolPanels;
      if (this.createToolPanelsAndSideButtons(i, t, s), !this.toolPanelWrappers.length)
        return;
      const r = t ? t.visible : !e.hiddenByDefault;
      if (this.setDisplayed(r), this.setSideBarPosition(t ? t.position : e.position), r)
        if (t) {
          const { openToolPanel: o } = t;
          o && this.openToolPanel(o, "sideBarInitializing");
        } else
          this.openToolPanel(e.defaultToolPanel, "sideBarInitializing");
    }
  }
  getDef() {
    return this.sideBar;
  }
  setSideBarPosition(e) {
    e || (e = "right"), this.position = e;
    const t = e === "left", s = t ? "right" : "left";
    return this.addOrRemoveCssClass("ag-side-bar-left", t), this.addOrRemoveCssClass("ag-side-bar-right", !t), this.toolPanelWrappers.forEach((i) => {
      i.setResizerSizerSide(s);
    }), this.dispatchSideBarUpdated(), this;
  }
  setDisplayed(e, t) {
    super.setDisplayed(e, t), this.dispatchSideBarUpdated();
  }
  getState() {
    const e = {};
    return this.toolPanelWrappers.forEach((t) => {
      var s, i;
      e[t.getToolPanelId()] = (i = (s = t.getToolPanelInstance()) == null ? void 0 : s.getState) == null ? void 0 : i.call(s);
    }), {
      visible: this.isDisplayed(),
      position: this.position,
      openToolPanel: this.openedItem(),
      toolPanels: e
    };
  }
  createToolPanelsAndSideButtons(e, t, s) {
    var i;
    for (const r of e)
      this.createToolPanelAndSideButton(
        r,
        (i = t == null ? void 0 : t.toolPanels) == null ? void 0 : i[r.id],
        s == null ? void 0 : s[r.id]
      );
  }
  validateDef(e) {
    var t;
    return e.id == null ? (R(212), !1) : e.toolPanel === "agFiltersToolPanel" && (t = this.beans.filterManager) != null && t.isAdvFilterEnabled() ? (R(213), !1) : !0;
  }
  createToolPanelAndSideButton(e, t, s) {
    if (!this.validateDef(e))
      return;
    let i;
    if (s)
      i = s;
    else if (i = this.createBean(new xL()), !i.setToolPanelDef(e, {
      initialState: t,
      onStateUpdated: () => this.dispatchSideBarUpdated()
    }))
      return;
    i.setDisplayed(!1);
    const r = i.getGui();
    this.appendChild(r), this.toolPanelWrappers.push(i);
    const o = this.sideBarButtons.addButtonComp(e);
    el(o.eToggleButton, r);
  }
  refresh() {
    this.toolPanelWrappers.forEach((e) => e.refresh());
  }
  openToolPanel(e, t = "api") {
    const s = this.openedItem();
    if (s === e)
      return;
    this.toolPanelWrappers.forEach((o) => {
      const n = e === o.getToolPanelId();
      o.setDisplayed(n);
    });
    const i = this.openedItem();
    s !== i && (this.sideBarButtons.setActiveButton(e), this.raiseToolPanelVisibleEvent(e, s ?? void 0, t));
  }
  getToolPanelInstance(e) {
    const t = this.toolPanelWrappers.filter((s) => s.getToolPanelId() === e)[0];
    if (!t) {
      R(214, { key: e });
      return;
    }
    return t.getToolPanelInstance();
  }
  raiseToolPanelVisibleEvent(e, t, s) {
    const i = !!e && !!t, r = this.eventSvc;
    t && r.dispatchEvent({
      type: "toolPanelVisibleChanged",
      source: s,
      key: t,
      visible: !1,
      switchingToolPanel: i
    }), e && r.dispatchEvent({
      type: "toolPanelVisibleChanged",
      source: s,
      key: e,
      visible: !0,
      switchingToolPanel: i
    });
  }
  close(e = "api") {
    this.openToolPanel(void 0, e);
  }
  isToolPanelShowing() {
    return !!this.openedItem();
  }
  openedItem() {
    let e = null;
    return this.toolPanelWrappers.forEach((t) => {
      t.isDisplayed() && (e = t.getToolPanelId());
    }), e;
  }
  onSideBarUpdated() {
    var s;
    const e = _a(this.gos.get("sideBar")), t = {};
    e && this.sideBar && ((s = e.toolPanels) == null || s.forEach((i) => {
      var d, c;
      const { id: r } = i;
      if (!r)
        return;
      const o = (d = this.sideBar.toolPanels) == null ? void 0 : d.find(
        (h) => h.id === r
      );
      if (!o || i.toolPanel !== o.toolPanel)
        return;
      const n = this.toolPanelWrappers.find((h) => h.getToolPanelId() === r);
      if (!n)
        return;
      const a = this.gos.addGridCommonParams({
        ...i.toolPanelParams ?? {},
        onStateUpdated: () => this.dispatchSideBarUpdated()
      });
      ((c = n.getToolPanelInstance()) == null ? void 0 : c.refresh(a)) === !0 && (this.toolPanelWrappers = this.toolPanelWrappers.filter((h) => h !== n), ce(n.getGui()), t[r] = n);
    })), this.clearDownUi(), this.setSideBarDef({ sideBarDef: e, existingToolPanelWrappers: t });
  }
  dispatchSideBarUpdated() {
    this.eventSvc.dispatchEvent({ type: "sideBarUpdated" });
  }
  destroyToolPanelWrappers() {
    this.toolPanelWrappers.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    }), this.toolPanelWrappers.length = 0;
  }
  destroy() {
    this.destroyToolPanelWrappers(), super.destroy();
  }
}, RL = {
  selector: "AG-SIDE-BAR",
  component: FL
}, PL = class extends P {
  constructor() {
    super(...arguments), this.beanName = "sideBar";
  }
  getSelector() {
    return RL;
  }
}, ql = {
  moduleName: "SideBar",
  version: j,
  beans: [PL],
  apiFunctions: {
    isSideBarVisible: oL,
    setSideBarVisible: nL,
    setSideBarPosition: aL,
    openToolPanel: lL,
    closeToolPanel: dL,
    getOpenedToolPanel: cL,
    refreshToolPanel: hL,
    isToolPanelShowing: uL,
    getToolPanelInstance: pL,
    getSideBar: gL
  },
  dependsOn: [te, cp]
}, Hg = class extends L {
  constructor() {
    super(), this.setTemplate(
      /* html */
      "<div></div>"
    );
  }
  init(e) {
    this.params = e, this.cssClassPrefix = this.params.cssClassPrefix ?? "ag-menu-option", this.addAriaAttributes(), this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu();
  }
  configureDefaults() {
    return !0;
  }
  addAriaAttributes() {
    const { checked: e, subMenu: t } = this.params, s = this.getGui();
    e && vh(s, e), t && He(s, !1);
  }
  addIcon() {
    if (this.params.isCompact)
      return;
    const e = Be(
      /* html */
      `<span data-ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`
    ), { checked: t, icon: s } = this.params;
    t ? e.appendChild(B("check", this.beans)) : s && (qo(s) ? e.appendChild(s) : typeof s == "string" ? e.innerHTML = s : R(227)), this.getGui().appendChild(e);
  }
  addName() {
    const e = Be(
      /* html */
      `<span data-ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addShortcut() {
    if (this.params.isCompact)
      return;
    const e = Be(
      /* html */
      `<span data-ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addSubMenu() {
    const e = Be(
      /* html */
      `<span data-ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`
    ), t = this.getGui();
    if (this.params.subMenu) {
      const s = this.gos.get("enableRtl") ? "subMenuOpenRtl" : "subMenuOpen";
      e.appendChild(B(s, this.beans));
    }
    t.appendChild(e);
  }
  getClassName(e) {
    return `${this.cssClassPrefix}-${e}`;
  }
}, TL = (
  /*css*/
  '.ag-menu-list{cursor:default;display:table;padding:var(--ag-spacing) 0;width:100%}.ag-menu-option,.ag-menu-separator{display:table-row}.ag-menu-option-part,.ag-menu-separator-part{display:table-cell;vertical-align:middle}.ag-menu-option{cursor:pointer;font-weight:500}:where(.ag-ltr) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:right}:where(.ag-rtl) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:left}.ag-menu-option-text{white-space:nowrap}.ag-menu-option-custom{display:contents}.ag-compact-menu-option{display:flex;flex-wrap:nowrap;width:100%}.ag-compact-menu-option-text{flex:1 1 auto;white-space:nowrap}.ag-menu-separator{height:calc(var(--ag-spacing)*2 + 1px)}.ag-menu-separator-part:after{border-top:1px solid var(--ag-menu-separator-color);content:"";display:block}.ag-compact-menu-option-active,.ag-menu-option-active{background-color:var(--ag-row-hover-color)}.ag-compact-menu-option-part,.ag-menu-option-part{line-height:var(--ag-icon-size);padding:calc(var(--ag-spacing) + 2px) 0}.ag-compact-menu-option-disabled,.ag-menu-option-disabled{cursor:not-allowed;opacity:.5}.ag-compact-menu-option-icon,.ag-menu-option-icon{width:var(--ag-icon-size)}:where(.ag-ltr) .ag-compact-menu-option-icon,:where(.ag-ltr) .ag-menu-option-icon{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-compact-menu-option-icon,:where(.ag-rtl) .ag-menu-option-icon{padding-right:calc(var(--ag-spacing)*2)}.ag-compact-menu-option-text,.ag-menu-option-text{padding-left:calc(var(--ag-spacing)*2);padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-compact-menu-option-shortcut,:where(.ag-ltr) .ag-menu-option-shortcut{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-shortcut,:where(.ag-rtl) .ag-menu-option-shortcut{padding-left:var(--ag-spacing)}:where(.ag-ltr) .ag-compact-menu-option-popup-pointer,:where(.ag-ltr) .ag-menu-option-popup-pointer{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-popup-pointer,:where(.ag-rtl) .ag-menu-option-popup-pointer{padding-left:var(--ag-spacing)}.ag-menu-column-select-wrapper{height:265px;overflow:auto;:where(.ag-column-select){height:100%}}.ag-menu:where(.ag-tabs){min-width:290px}.ag-context-menu-loading-icon{pointer-events:none;position:absolute}'
), Cn = {
  moduleName: "MenuItem",
  version: j,
  userComponents: {
    agMenuItem: Hg
  },
  icons: {
    // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
    check: "tick",
    // icon for sub menu item
    subMenuOpen: "small-right",
    // version of subMenuOpen used in RTL mode
    subMenuOpenRtl: "small-left"
  },
  css: [TL]
}, DL = (
  /*css*/
  ".ag-column-select{display:flex;flex:3 1 0px;flex-direction:column;overflow:hidden;position:relative}.ag-column-select-header{align-items:center;display:flex;flex:none;gap:var(--ag-widget-horizontal-spacing);height:var(--ag-header-height);padding-left:var(--ag-widget-container-horizontal-padding);padding-right:var(--ag-widget-container-horizontal-padding);position:relative}.ag-column-select-column,.ag-column-select-column-group{align-items:center;display:flex;gap:var(--ag-widget-horizontal-spacing);height:100%;position:relative;&:where(:not(:last-child)){margin-bottom:var(--ag-widget-vertical-spacing)}}:where(.ag-ltr) .ag-column-select-column,:where(.ag-ltr) .ag-column-select-column-group{padding-left:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}:where(.ag-rtl) .ag-column-select-column,:where(.ag-rtl) .ag-column-select-column-group{padding-right:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}.ag-column-select-header-icon{border-radius:var(--ag-border-radius);cursor:pointer;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-column-select-header-filter-wrapper{flex:1 1 auto}.ag-column-select-header-filter{width:100%}.ag-column-select-list{flex:1 1 0px;overflow:hidden}:where(.ag-ltr) .ag-column-select-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}:where(.ag-rtl) .ag-column-select-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly{opacity:.5;pointer-events:none}.ag-column-select-virtual-list-viewport{padding:calc(var(--ag-widget-container-vertical-padding)*.5) 0}.ag-column-select-virtual-list-item{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-column-select-column-label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-select-checkbox{display:flex}"
), EL = 300, ML = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-column-select-header" role="presentation">
            <div data-ref="eExpand" class="ag-column-select-header-icon"></div>
            <ag-checkbox data-ref="eSelect" class="ag-column-select-header-checkbox"></ag-checkbox>
            <ag-input-text-field class="ag-column-select-header-filter-wrapper" data-ref="eFilterTextField"></ag-input-text-field>
        </div>`,
      [Pt, mt]
    ), this.eExpand = S, this.eSelect = S, this.eFilterTextField = S;
  }
  postConstruct() {
    this.createExpandIcons(), this.addManagedListeners(this.eExpand, {
      click: this.onExpandClicked.bind(this),
      keydown: (t) => {
        t.key === w.SPACE && (t.preventDefault(), this.onExpandClicked());
      }
    }), this.addManagedElementListeners(this.eSelect.getInputElement(), { click: this.onSelectClicked.bind(this) }), this.addManagedPropertyListener("functionsReadOnly", () => this.onFunctionsReadOnlyPropChanged()), this.eFilterTextField.setAutoComplete(!1).onValueChange(() => this.onFilterTextChanged()), this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
    const e = this.getLocaleTextFunc();
    this.eSelect.setInputAriaLabel(e("ariaColumnSelectAll", "Toggle All Columns Visibility")), this.eFilterTextField.setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")), this.activateTabIndex([this.eExpand]);
  }
  onFunctionsReadOnlyPropChanged() {
    const e = this.gos.get("functionsReadOnly");
    this.eSelect.setReadOnly(e), this.eSelect.addOrRemoveCssClass("ag-column-select-column-readonly", e);
  }
  init(e) {
    this.params = e;
    const t = this.gos.get("functionsReadOnly");
    this.eSelect.setReadOnly(t), this.eSelect.addOrRemoveCssClass("ag-column-select-column-readonly", t), this.beans.colModel.ready && this.showOrHideOptions();
  }
  createExpandIcons() {
    const e = this.beans;
    this.eExpand.appendChild(this.eExpandChecked = B("columnSelectOpen", e)), this.eExpand.appendChild(this.eExpandUnchecked = B("columnSelectClosed", e)), this.eExpand.appendChild(this.eExpandIndeterminate = B("columnSelectIndeterminate", e)), this.setExpandState(
      0
      /* EXPANDED */
    );
  }
  // we only show expand / collapse if we are showing columns
  showOrHideOptions() {
    var n;
    const e = this.params, t = !e.suppressColumnFilter, s = !e.suppressColumnSelectAll, i = !e.suppressColumnExpandAll, r = !!((n = this.beans.colModel.colDefCols) != null && n.treeDepth), o = this.getLocaleTextFunc();
    this.eFilterTextField.setInputPlaceholder(o("searchOoo", "Search...")), O(this.eFilterTextField.getGui(), t), O(this.eSelect.getGui(), s), O(this.eExpand, i && r);
  }
  onFilterTextChanged() {
    this.onFilterTextChangedDebounced || (this.onFilterTextChangedDebounced = Ce(
      this,
      () => {
        const e = this.eFilterTextField.getValue();
        this.dispatchLocalEvent({ type: "filterChanged", filterText: e });
      },
      EL
    )), this.onFilterTextChangedDebounced();
  }
  onSelectClicked() {
    this.dispatchLocalEvent({ type: this.selectState ? "unselectAll" : "selectAll" });
  }
  onExpandClicked() {
    this.dispatchLocalEvent({ type: this.expandState === 0 ? "collapseAll" : "expandAll" });
  }
  setExpandState(e) {
    this.expandState = e, O(
      this.eExpandChecked,
      e === 0
      /* EXPANDED */
    ), O(
      this.eExpandUnchecked,
      e === 1
      /* COLLAPSED */
    ), O(
      this.eExpandIndeterminate,
      e === 2
      /* INDETERMINATE */
    );
  }
  setSelectionState(e) {
    this.selectState = e, this.eSelect.setValue(this.selectState);
  }
}, AL = {
  selector: "AG-PRIMARY-COLS-HEADER",
  component: ML
};
function vi(e) {
  return !!e && typeof e.children < "u";
}
function ls(e) {
  return vi(e) ? e.groupId : e.colId;
}
function zg(e, t, s) {
  const i = (n, a) => {
    const d = n.children.map(ls).includes(ls(a)), c = V(n.children), h = c && ls(c) !== ls(a);
    return d && h;
  };
  if (!vi(e))
    return !0;
  const r = e, o = s;
  if (i(r, o) || r.groupId === t && !r.children.map(ls).includes(ls(o)))
    return r.children.push(o), !0;
  for (let n = r.children.length - 1; n >= 0 && !zg(r.children[n], t, s); n--)
    ;
  return !1;
}
function IL(e) {
  const t = (r, o) => vi(r) && vi(o) && ls(r) === ls(o), s = (r, o) => {
    if (!vi(o))
      return r;
    const n = r, a = o;
    return a.children && a.groupId && zg(n, a.groupId, a.children[0]) || a.children.forEach((l) => s(n, l)), n;
  }, i = [];
  for (let r = 1; r <= e.length; r++) {
    const o = e[r - 1], n = e[r];
    t(o, n) ? e[r] = s(o, n) : i.push(o);
  }
  return i;
}
function Wg(e, t) {
  const s = [], i = (o, n) => {
    if (vi(o)) {
      const a = o, l = typeof a.groupId < "u" ? a.groupId : a.headerName, d = new er(a, l, !1, n), c = [];
      return a.children.forEach((h) => {
        const u = i(h, n + 1);
        u && c.push(u);
      }), d.setChildren(c), d;
    } else {
      const a = o, l = a.colId ? a.colId : a.field, d = e.getColDefCol(l);
      return d || s.push(a), d;
    }
  }, r = [];
  return t.forEach((o) => {
    const n = i(o, 0);
    n && r.push(n);
  }), s.length > 0 && R(217, { invalidColIds: s }), r;
}
function _g(e, t) {
  const s = LL(e), i = IL(s);
  t(i);
}
function LL(e) {
  const t = (r, o) => {
    let n;
    if (ae(r))
      if (r.isPadding())
        n = o;
      else {
        const l = Object.assign({}, r.getColGroupDef());
        l.groupId = r.getGroupId(), l.children = [o], n = l;
      }
    else {
      const l = Object.assign({}, r.getColDef());
      l.colId = r.getColId(), n = l;
    }
    const a = r.getOriginalParent();
    return a ? t(a, n) : n;
  };
  return e.getCols().filter((r) => {
    const o = r.getColDef();
    return r.isPrimary() && !o.showRowGroup;
  }).map((r) => t(r, r.getColDef()));
}
var Rc = class {
  constructor(e, t, s, i = !1, r) {
    this.displayName = e, this.depth = s, this.group = i, this.localEventService = new Rs(), i ? (this.columnGroup = t, this._expanded = r, this.children = []) : this.column = t;
  }
  get expanded() {
    return !!this._expanded;
  }
  set expanded(e) {
    e !== this._expanded && (this._expanded = e, this.localEventService.dispatchEvent({ type: "expandedChanged" }));
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
};
function Ug(e, t, s, i) {
  const r = kL(t);
  Kg(e, r, s, i);
}
function Kg(e, t, s, i) {
  e.colModel.isPivotMode() ? GL(e, t, s, i) : OL(e, t, s, i);
}
function kL(e) {
  const t = [], s = (i) => {
    i.forEach((r) => {
      r.passesFilter && (r.group ? s(r.children) : t.push(r.column));
    });
  };
  return s(e), t;
}
function OL(e, t, s, i) {
  var o;
  const r = [];
  t.forEach((n) => {
    n.getColDef().lockVisible || n.isVisible() != s && r.push({
      colId: n.getId(),
      hide: !s
    });
  }), r.length > 0 && Xe(e, { state: r }, i), (o = e.selectionColSvc) == null || o.refreshVisibility(i);
}
function GL(e, t, s, i) {
  BL(e, t, s, i);
}
function BL(e, t, s, i) {
  const r = [], a = s ? (l) => {
    var d;
    if (!l.isAnyFunctionActive())
      if (l.isAllowValue()) {
        const c = typeof l.getAggFunc() == "string" ? l.getAggFunc() : (d = e.aggFuncSvc) == null ? void 0 : d.getDefaultAggFunc(l);
        r.push({
          colId: l.getId(),
          aggFunc: c
        });
      } else l.isAllowRowGroup() ? r.push({
        colId: l.getId(),
        rowGroup: !0
      }) : l.isAllowPivot() && r.push({
        colId: l.getId(),
        pivot: !0
      });
  } : (l) => {
    (l.isPivotActive() || l.isRowGroupActive() || l.isValueActive()) && r.push({
      colId: l.getId(),
      pivot: !1,
      rowGroup: !1,
      aggFunc: null
    });
  };
  t.forEach(a), r.length > 0 && Xe(e, { state: r }, i);
}
function $g(e, t) {
  const { columns: s, visibleState: i, pivotState: r, eventType: o } = t, n = s.map((a) => {
    const l = a.getColId();
    if (e.colModel.isPivotMode()) {
      const d = r == null ? void 0 : r[l];
      return {
        colId: l,
        pivot: d == null ? void 0 : d.pivot,
        rowGroup: d == null ? void 0 : d.rowGroup,
        aggFunc: d == null ? void 0 : d.aggFunc
      };
    } else
      return {
        colId: l,
        hide: !(i != null && i[l])
      };
  });
  Xe(e, { state: n }, o);
}
function jg(e) {
  return {
    pivot: e.isPivotActive(),
    rowGroup: e.isRowGroupActive(),
    aggFunc: e.isValueActive() ? e.getAggFunc() : void 0
  };
}
function Go(e, t, s, i) {
  const r = t.getCol(s);
  e.groupData || (e.groupData = {});
  const o = r.getColId(), n = e.groupData[o];
  n !== i && (e.groupData[o] = i, e.dispatchCellChangedEvent(r, i, n));
}
function qg(e, t, s) {
  var i;
  e.group !== s && (e.group && !s && (e.expanded = !1), e.group = s, e.updateHasChildren(), (i = t.selectionSvc) == null || i.updateRowSelectable(e), e.dispatchRowEvent("groupChanged"));
}
function wr(e, t) {
  const { gos: s, rowGroupColsSvc: i } = t;
  if (!i || !e)
    return !1;
  const r = s.get("groupLockGroupColumns");
  if (!e.isRowGroupActive() || r === 0)
    return !1;
  if (r === -1)
    return !0;
  const o = i.columns.findIndex((n) => n.getColId() === e.getColId());
  return r > o;
}
var VL = class extends Nt {
  constructor(e) {
    super(), this.setTemplateFromElement(e.getGui(), void 0, void 0, !0);
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  handleKeyDown(e) {
    e.key === w.ESCAPE && this.closePanel();
  }
  onTabKeyDown(e) {
    e.defaultPrevented || (this.closePanel(), e.preventDefault());
  }
  closePanel() {
    const e = this.parentComponent;
    e.closeSubMenu(), setTimeout(() => e.getGui().focus(), 0);
  }
};
function NL(e, t, s) {
  return e.getCompDetails(t, HL, "agMenuItem", s, !0);
}
var HL = {
  name: "menuItem",
  optionalMethods: ["setActive", "select", "setExpanded", "configureDefaults"]
}, Ua = class extends P {
  constructor() {
    super(...arguments), this.ACTIVATION_DELAY = 80, this.isActive = !1, this.subMenuIsOpen = !1, this.subMenuIsOpening = !1, this.suppressRootStyles = !0, this.suppressAria = !0, this.suppressFocus = !0;
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.userCompFactory = e.userCompFactory, this.registry = e.registry;
  }
  init(e) {
    var a;
    const { menuItemDef: t, isAnotherSubMenuOpen: s, level: i, childComponent: r, contextParams: o } = e;
    this.params = e.menuItemDef, this.level = i, this.isAnotherSubMenuOpen = s, this.childComponent = r, this.contextParams = o, this.cssClassPrefix = ((a = this.params.menuItemParams) == null ? void 0 : a.cssClassPrefix) ?? "ag-menu-option";
    const n = NL(this.userCompFactory, this.params, {
      ...t,
      level: i,
      isAnotherSubMenuOpen: s,
      openSubMenu: (l) => this.openSubMenu(l),
      closeSubMenu: () => this.closeSubMenu(),
      closeMenu: (l) => this.closeMenu(l),
      updateTooltip: (l, d) => this.refreshTooltip(l, d),
      onItemActivated: () => this.onItemActivated()
    });
    return (n == null ? void 0 : n.newAgStackInstance().then((l) => {
      var c;
      this.menuItemComp = l;
      const d = (c = l.configureDefaults) == null ? void 0 : c.call(l);
      d && this.configureDefaults(d === !0 ? void 0 : d);
    })) ?? U.resolve();
  }
  addListeners(e, t) {
    t != null && t.suppressClick || this.addManagedElementListeners(e, { click: (s) => this.onItemSelected(s) }), t != null && t.suppressKeyboardSelect || this.addManagedElementListeners(e, {
      keydown: (s) => {
        (s.key === w.ENTER || s.key === w.SPACE) && (s.preventDefault(), this.onItemSelected(s));
      }
    }), t != null && t.suppressMouseDown || this.addManagedElementListeners(e, {
      mousedown: (s) => {
        s.stopPropagation(), s.preventDefault();
      }
    }), t != null && t.suppressMouseOver || this.addManagedElementListeners(e, {
      mouseenter: () => this.onMouseEnter(),
      mouseleave: () => this.onMouseLeave()
    });
  }
  isDisabled() {
    return !!this.params.disabled;
  }
  openSubMenu(e = !1, t) {
    var d, c;
    if (this.closeSubMenu(), !this.params.subMenu)
      return;
    this.subMenuIsOpening = !0;
    const s = Be(
      /* html */
      '<div class="ag-menu" role="presentation"></div>'
    );
    this.eSubMenuGui = s;
    let i, r = () => {
      this.subMenuIsOpening = !1;
    };
    if (this.childComponent) {
      const h = this.createBean(new VL(this.childComponent));
      h.setParentComponent(this);
      const u = h.getGui(), p = "mouseenter", g = () => this.cancelDeactivate();
      u.addEventListener(p, g), i = () => u.removeEventListener(p, g), s.appendChild(u), this.childComponent.afterGuiAttached && (r = () => {
        this.childComponent.afterGuiAttached(), this.subMenuIsOpening = !1;
      });
    } else if (this.params.subMenu) {
      const h = this.createBean(new Mr(this.level + 1, this.contextParams));
      h.setParentComponent(this), h.addMenuItems(this.params.subMenu), s.appendChild(h.getGui()), this.addManagedListeners(h, { closeMenu: (u) => this.dispatchLocalEvent(u) }), h.addGuiEventListener("mouseenter", () => this.cancelDeactivate()), i = () => this.destroyBean(h), e && (r = () => {
        h.activateFirstItem(), this.subMenuIsOpening = !1;
      });
    }
    const { popupSvc: o } = this, n = () => {
      const h = this.eGui;
      o == null || o.positionPopupForMenu({
        eventSource: h,
        ePopup: s
      });
      const { column: u, node: p } = this.contextParams;
      o == null || o.callPostProcessPopup(
        "subMenu",
        s,
        h,
        t instanceof MouseEvent ? t : void 0,
        u,
        p
      );
    }, a = this.getLocaleTextFunc(), l = o == null ? void 0 : o.addPopup({
      modal: !0,
      eChild: s,
      positionCallback: n,
      anchorToElement: this.eGui,
      ariaLabel: a("ariaLabelSubMenu", "SubMenu"),
      afterGuiAttached: r
    });
    this.subMenuIsOpen = !0, this.setAriaExpanded(!0), this.hideSubMenu = () => {
      var h, u;
      l && l.hideFunc(), this.subMenuIsOpen = !1, this.setAriaExpanded(!1), i(), (u = (h = this.menuItemComp).setExpanded) == null || u.call(h, !1), this.eSubMenuGui = void 0;
    }, (c = (d = this.menuItemComp).setExpanded) == null || c.call(d, !0);
  }
  setAriaExpanded(e) {
    this.suppressAria || He(this.eGui, e);
  }
  closeSubMenu() {
    this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, this.setAriaExpanded(!1));
  }
  isSubMenuOpen() {
    return this.subMenuIsOpen;
  }
  isSubMenuOpening() {
    return this.subMenuIsOpening;
  }
  activate(e) {
    var t, s;
    this.cancelActivate(), !this.params.disabled && (this.isActive = !0, this.suppressRootStyles || this.eGui.classList.add(`${this.cssClassPrefix}-active`), (s = (t = this.menuItemComp).setActive) == null || s.call(t, !0), this.suppressFocus || this.eGui.focus({ preventScroll: !0 }), e && this.params.subMenu && window.setTimeout(() => {
      this.isAlive() && this.isActive && this.openSubMenu();
    }, 300), this.onItemActivated());
  }
  deactivate() {
    var e, t;
    this.cancelDeactivate(), this.suppressRootStyles || this.eGui.classList.remove(`${this.cssClassPrefix}-active`), (t = (e = this.menuItemComp).setActive) == null || t.call(e, !1), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu();
  }
  getGui() {
    return this.menuItemComp.getGui();
  }
  getParentComponent() {
    return this.parentComponent;
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getSubMenuGui() {
    return this.eSubMenuGui;
  }
  onItemSelected(e) {
    var t, s;
    (s = (t = this.menuItemComp).select) == null || s.call(t), this.params.action ? this.beans.frameworkOverrides.wrapOutgoing(
      () => this.params.action(
        this.gos.addGridCommonParams({
          ...this.contextParams
        })
      )
    ) : this.openSubMenu(e && e.type === "keydown", e), !(this.params.subMenu && !this.params.action || this.params.suppressCloseOnSelect) && this.closeMenu(e);
  }
  closeMenu(e) {
    const t = {
      type: "closeMenu"
    };
    e && (e instanceof MouseEvent ? t.mouseEvent = e : t.keyboardEvent = e), this.dispatchLocalEvent(t);
  }
  onItemActivated() {
    const e = {
      type: "menuItemActivated",
      menuItem: this
    };
    this.dispatchLocalEvent(e);
  }
  cancelActivate() {
    this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
  }
  cancelDeactivate() {
    this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
  }
  onMouseEnter() {
    this.cancelDeactivate(), this.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(() => this.activate(!0), this.ACTIVATION_DELAY) : this.activate(!0);
  }
  onMouseLeave() {
    this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), this.ACTIVATION_DELAY) : this.deactivate();
  }
  configureDefaults(e) {
    var l, d, c;
    if (!this.menuItemComp) {
      setTimeout(() => this.configureDefaults(e));
      return;
    }
    let t = this.menuItemComp.getGui();
    const { suppressRootStyles: s, suppressTooltip: i, suppressAria: r, suppressTabIndex: o, suppressFocus: n } = e || {}, a = (d = (l = this.menuItemComp).getRootElement) == null ? void 0 : d.call(l);
    a && (s || t.classList.add("ag-menu-option-custom"), t = a), this.eGui = t, this.suppressRootStyles = !!s, this.suppressRootStyles || (t.classList.add(this.cssClassPrefix), (c = this.params.cssClasses) == null || c.forEach((h) => t.classList.add(h)), this.params.disabled && t.classList.add(`${this.cssClassPrefix}-disabled`)), i || this.refreshTooltip(this.params.tooltip), this.suppressAria = !!r, this.suppressAria || (re(t, "treeitem"), Sr(t, this.level + 1), this.params.disabled && co(t, !0)), o || t.setAttribute("tabindex", "-1"), this.params.disabled || this.addListeners(t, e), this.suppressFocus = !!n;
  }
  refreshTooltip(e, t) {
    if (this.tooltip = e, this.tooltipFeature = this.destroyBean(this.tooltipFeature), !e || !this.menuItemComp)
      return;
    const s = this.registry.createDynamicBean("tooltipFeature", !1, {
      getGui: () => this.getGui(),
      getTooltipValue: () => this.tooltip,
      getLocation: () => "menu",
      shouldDisplayTooltip: t
    });
    s && (this.tooltipFeature = this.createBean(s));
  }
  destroy() {
    var e, t;
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), (t = (e = this.menuItemComp) == null ? void 0 : e.destroy) == null || t.call(e), super.destroy();
  }
}, Mr = class extends Nt {
  constructor(e = 0, t) {
    super(
      /* html */
      '<div class="ag-menu-list" role="tree"></div>'
    ), this.level = e, this.menuItems = [], this.params = t ?? {
      column: null,
      node: null,
      value: null
    };
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e),
      onFocusIn: (e) => this.handleFocusIn(e),
      onFocusOut: (e) => this.handleFocusOut(e)
    });
  }
  onTabKeyDown(e) {
    const t = this.getParentComponent(), s = t && t.getGui();
    s && s.classList.contains("ag-focus-managed") || e.preventDefault(), e.shiftKey && this.closeIfIsChild(e);
  }
  handleKeyDown(e) {
    switch (e.key) {
      case w.UP:
      case w.RIGHT:
      case w.DOWN:
      case w.LEFT:
        e.preventDefault(), this.handleNavKey(e.key);
        break;
      case w.ESCAPE:
        this.closeIfIsChild() && he(e);
        break;
    }
  }
  handleFocusIn(e) {
    var s, i;
    const t = e.relatedTarget;
    !this.tabGuardFeature.getTabGuardCtrl().isTabGuard(t) && (this.getGui().contains(t) || (i = (s = this.activeMenuItem) == null ? void 0 : s.getSubMenuGui()) != null && i.contains(t)) || (this.activeMenuItem ? this.activeMenuItem.activate() : this.activateFirstItem());
  }
  handleFocusOut(e) {
    var s;
    const t = e.relatedTarget;
    !this.activeMenuItem || this.getGui().contains(t) || (s = this.activeMenuItem.getSubMenuGui()) != null && s.contains(t) || this.activeMenuItem.isSubMenuOpening() || this.activeMenuItem.deactivate();
  }
  clearActiveItem() {
    this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
  }
  addMenuItems(e) {
    e != null && U.all(
      e.map((t) => t === "separator" ? U.resolve({ eGui: this.createSeparator() }) : typeof t == "string" ? (R(228, { menuItemOrString: t }), U.resolve({ eGui: null })) : this.addItem(t))
    ).then((t) => {
      (t ?? []).forEach((s) => {
        s != null && s.eGui && (this.appendChild(s.eGui), s.comp && this.menuItems.push(s.comp));
      });
    });
  }
  addItem(e) {
    const t = this.createManagedBean(new Ua());
    return t.init({
      menuItemDef: e,
      isAnotherSubMenuOpen: () => this.menuItems.some((s) => s.isSubMenuOpen()),
      level: this.level,
      contextParams: this.params
    }).then(() => (t.setParentComponent(this), this.addManagedListeners(t, {
      closeMenu: (s) => {
        this.dispatchLocalEvent(s);
      },
      menuItemActivated: (s) => {
        this.activeMenuItem && this.activeMenuItem !== s.menuItem && this.activeMenuItem.deactivate(), this.activeMenuItem = s.menuItem;
      }
    }), {
      comp: t,
      eGui: t.getGui()
    }));
  }
  activateFirstItem() {
    const e = this.menuItems.filter((t) => !t.isDisabled())[0];
    e && e.activate();
  }
  createSeparator() {
    return Be(
      /* html */
      `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
    );
  }
  handleNavKey(e) {
    switch (e) {
      case w.UP:
      case w.DOWN: {
        const s = this.findNextItem(e === w.UP);
        s && s !== this.activeMenuItem && s.activate();
        return;
      }
    }
    const t = this.gos.get("enableRtl") ? w.RIGHT : w.LEFT;
    e === t ? this.closeIfIsChild() : this.openChild();
  }
  closeIfIsChild(e) {
    const t = this.getParentComponent();
    return t && t instanceof Ua ? (e && e.preventDefault(), t.closeSubMenu(), t.getGui().focus(), !0) : !1;
  }
  openChild() {
    this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
  }
  findNextItem(e) {
    const t = this.menuItems.filter((r) => !r.isDisabled());
    if (!t.length)
      return;
    if (!this.activeMenuItem)
      return e ? V(t) : t[0];
    e && t.reverse();
    let s, i = !1;
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      if (!i) {
        o === this.activeMenuItem && (i = !0);
        continue;
      }
      s = o;
      break;
    }
    return i && !s ? t[0] : s || this.activeMenuItem;
  }
  destroy() {
    this.clearActiveItem(), super.destroy();
  }
}, Yg = class extends L {
  constructor(e, t, s) {
    super(
      /* html */
      '<div class="ag-menu"></div>'
    ), this.column = e, this.mouseEvent = t, this.parentEl = s, this.displayName = null;
  }
  postConstruct() {
    const {
      column: e,
      beans: { colNames: t }
    } = this;
    this.initializeProperties(e);
    let s;
    if (Bt(e) ? s = t.getDisplayNameForColumn(e, "columnToolPanel") : s = t.getDisplayNameForProvidedColumnGroup(null, e, "columnToolPanel"), this.displayName = s, this.buildMenuItemMap(), this.isActive()) {
      this.mouseEvent.preventDefault();
      const i = this.getMappedMenuItems();
      if (i.length === 0)
        return;
      this.displayContextMenu(i);
    }
  }
  initializeProperties(e) {
    let t;
    ae(e) ? t = e.getLeafColumns() : t = [e], this.columns = t, this.allowGrouping = t.some((s) => s.isPrimary() && s.isAllowRowGroup()), this.allowValues = t.some((s) => s.isPrimary() && s.isAllowValue()), this.allowPivoting = this.beans.colModel.isPivotMode() && t.some((s) => s.isPrimary() && s.isAllowPivot());
  }
  buildMenuItemMap() {
    const e = this.getLocaleTextFunc(), { beans: t, displayName: s } = this, { rowGroupColsSvc: i, valueColsSvc: r, pivotColsSvc: o, colModel: n } = t, a = /* @__PURE__ */ new Map();
    this.menuItemMap = a, a.set("rowGroup", {
      allowedFunction: (l) => l.isPrimary() && l.isAllowRowGroup() && !wr(l, t),
      activeFunction: (l) => l.isRowGroupActive(),
      activateLabel: () => `${e("groupBy", "Group by")} ${s}`,
      deactivateLabel: () => `${e("ungroupBy", "Un-Group by")} ${s}`,
      activateFunction: () => i == null ? void 0 : i.setColumns(this.addColumnsToList(i.columns), "toolPanelUi"),
      deActivateFunction: () => i == null ? void 0 : i.setColumns(this.removeColumnsFromList(i.columns), "toolPanelUi"),
      addIcon: "menuAddRowGroup",
      removeIcon: "menuRemoveRowGroup"
    }), a.set("value", {
      allowedFunction: (l) => l.isPrimary() && l.isAllowValue(),
      activeFunction: (l) => l.isValueActive(),
      activateLabel: () => e("addToValues", `Add ${s} to values`, [s]),
      deactivateLabel: () => e("removeFromValues", `Remove ${s} from values`, [s]),
      activateFunction: () => r == null ? void 0 : r.setColumns(this.addColumnsToList(r.columns), "toolPanelUi"),
      deActivateFunction: () => r == null ? void 0 : r.setColumns(this.removeColumnsFromList(r.columns), "toolPanelUi"),
      addIcon: "valuePanel",
      removeIcon: "valuePanel"
    }), a.set("pivot", {
      allowedFunction: (l) => n.isPivotMode() && l.isPrimary() && l.isAllowPivot(),
      activeFunction: (l) => l.isPivotActive(),
      activateLabel: () => e("addToLabels", `Add ${s} to labels`, [s]),
      deactivateLabel: () => e("removeFromLabels", `Remove ${s} from labels`, [s]),
      activateFunction: () => o == null ? void 0 : o.setColumns(this.addColumnsToList(o.columns), "toolPanelUi"),
      deActivateFunction: () => o == null ? void 0 : o.setColumns(this.removeColumnsFromList(o.columns), "toolPanelUi"),
      addIcon: "pivotPanel",
      removeIcon: "pivotPanel"
    });
  }
  addColumnsToList(e) {
    return [...e].concat(this.columns.filter((t) => e.indexOf(t) === -1));
  }
  removeColumnsFromList(e) {
    return e.filter((t) => this.columns.indexOf(t) === -1);
  }
  displayContextMenu(e) {
    const t = this.getGui(), s = this.createBean(new Mr()), i = this.getLocaleTextFunc();
    let r = () => {
    };
    t.appendChild(s.getGui()), s.addMenuItems(e), s.addManagedListeners(s, {
      closeMenu: () => {
        this.parentEl.focus(), r();
      }
    });
    const o = this.beans.popupSvc, n = o.addPopup({
      modal: !0,
      eChild: t,
      closeOnEsc: !0,
      afterGuiAttached: () => ve(s.getGui()),
      ariaLabel: i("ariaLabelContextMenu", "Context Menu"),
      closedCallback: (a) => {
        a instanceof KeyboardEvent && this.parentEl.focus(), this.destroyBean(s);
      }
    });
    n && (r = n.hideFunc), o.positionPopupUnderMouseEvent({
      type: "columnContextMenu",
      mouseEvent: this.mouseEvent,
      ePopup: t
    });
  }
  isActive() {
    return this.allowGrouping || this.allowValues || this.allowPivoting;
  }
  getMappedMenuItems() {
    const e = [], { menuItemMap: t, columns: s, displayName: i, beans: r } = this;
    for (const o of t.values()) {
      const n = s.some((l) => o.allowedFunction(l) && !o.activeFunction(l)), a = s.some((l) => o.allowedFunction(l) && o.activeFunction(l));
      n && e.push({
        name: o.activateLabel(i),
        icon: B(o.addIcon, r, null),
        action: () => o.activateFunction()
      }), a && e.push({
        name: o.deactivateLabel(i),
        icon: B(o.removeIcon, r, null),
        action: () => o.deActivateFunction()
      });
    }
    return e;
  }
}, Xg = class extends L {
  constructor(e, t, s, i) {
    super(), this.modelItem = e, this.allowDragging = t, this.eventType = s, this.focusWrapper = i, this.cbSelect = S, this.eLabel = S, this.eGroupOpenedIcon = S, this.eGroupClosedIcon = S, this.eColumnGroupIcons = S, this.processingColumnStateChange = !1;
    const { columnGroup: r, depth: o, displayName: n } = e;
    this.columnGroup = r, this.columnDepth = o, this.displayName = n;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `<div class="ag-column-select-column-group">
                <span class="ag-column-group-icons" data-ref="eColumnGroupIcons" >
                    <span class="ag-column-group-closed-icon" data-ref="eGroupClosedIcon"></span>
                    <span class="ag-column-group-opened-icon" data-ref="eGroupOpenedIcon"></span>
                </span>
                <ag-checkbox data-ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
                <span class="ag-column-select-column-label" data-ref="eLabel"></span>
            </div>`,
      [Pt]
    );
    const {
      beans: e,
      cbSelect: t,
      eLabel: s,
      displayName: i,
      columnDepth: r,
      modelItem: o,
      focusWrapper: n,
      columnGroup: a
    } = this, { registry: l, gos: d } = e, c = B("columnDrag", e);
    this.eDragHandle = c, c.classList.add("ag-drag-handle", "ag-column-select-column-group-drag-handle");
    const h = t.getGui(), u = t.getInputElement();
    h.insertAdjacentElement("afterend", c), u.setAttribute("tabindex", "-1"), s.innerHTML = i ?? "", this.setupExpandContract(), this.addCssClass("ag-column-select-indent-" + r), this.getGui().style.setProperty("--ag-indentation-level", String(r)), this.tooltipFeature = this.createOptionalManagedBean(
      l.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "columnToolPanelColumnGroup",
        shouldDisplayTooltip: ln(d, () => s)
      })
    ), this.addManagedEventListeners({ columnPivotModeChanged: this.onColumnStateChanged.bind(this) }), this.addManagedElementListeners(s, { click: this.onLabelClicked.bind(this) }), this.addManagedListeners(t, { fieldValueChanged: this.onCheckboxChanged.bind(this) }), this.addManagedListeners(o, { expandedChanged: this.onExpandChanged.bind(this) }), this.addManagedListeners(n, {
      keydown: this.handleKeyDown.bind(this),
      contextmenu: this.onContextMenu.bind(this)
    }), this.setOpenClosedIcons(), this.setupDragging(), this.onColumnStateChanged(), this.addVisibilityListenersToAllChildren(), this.refreshAriaExpanded(), this.refreshAriaLabel(), this.setupTooltip(), Ru(a.getColGroupDef(), d, null, a).forEach((g) => this.addOrRemoveCssClass(g, !0));
  }
  getColumns() {
    return this.columnGroup.getLeafColumns();
  }
  setupTooltip() {
    const e = this.columnGroup.getColGroupDef();
    if (!e)
      return;
    const t = () => {
      var s;
      return (s = this.tooltipFeature) == null ? void 0 : s.setTooltipAndRefresh(e.headerTooltip);
    };
    t(), this.addManagedEventListeners({ newColumnsLoaded: t });
  }
  handleKeyDown(e) {
    switch (e.key) {
      case w.LEFT:
        e.preventDefault(), this.modelItem.expanded = !1;
        break;
      case w.RIGHT:
        e.preventDefault(), this.modelItem.expanded = !0;
        break;
      case w.SPACE:
        e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected());
        break;
    }
  }
  onContextMenu(e) {
    const { columnGroup: t, gos: s } = this;
    if (s.get("functionsReadOnly"))
      return;
    const i = this.createBean(new Yg(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      i.isAlive() && this.destroyBean(i);
    });
  }
  addVisibilityListenersToAllChildren() {
    const e = this.onColumnStateChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      this.addManagedListeners(t, {
        visibleChanged: e,
        columnValueChanged: e,
        columnPivotChanged: e,
        columnRowGroupChanged: e
      });
    });
  }
  setupDragging() {
    if (!this.allowDragging) {
      O(this.eDragHandle, !1);
      return;
    }
    const e = this.beans, { gos: t, eventSvc: s, dragAndDrop: i } = e;
    let r = !t.get("suppressDragLeaveHidesColumns");
    const o = {
      type: xt.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      getDefaultIconName: () => r ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        r = !t.get("suppressDragLeaveHidesColumns"), s.dispatchEvent({
          type: "columnPanelItemDragStart",
          column: this.columnGroup
        });
      },
      onDragStopped: () => {
        s.dispatchEvent({
          type: "columnPanelItemDragEnd"
        });
      },
      onGridEnter: (n) => {
        r && $g(e, {
          columns: this.columnGroup.getLeafColumns(),
          visibleState: n == null ? void 0 : n.visibleState,
          pivotState: n == null ? void 0 : n.pivotState,
          eventType: this.eventType
        });
      },
      onGridExit: () => {
        r && this.onChangeCommon(!1);
      }
    };
    i.addDragSource(o, !0), this.addDestroyFunc(() => i.removeDragSource(o));
  }
  createDragItem() {
    const e = this.columnGroup.getLeafColumns(), t = {}, s = {};
    return e.forEach((i) => {
      const r = i.getId();
      t[r] = i.isVisible(), s[r] = jg(i);
    }), {
      columns: e,
      visibleState: t,
      pivotState: s
    };
  }
  setupExpandContract() {
    const { beans: e, eGroupClosedIcon: t, eGroupOpenedIcon: s, eColumnGroupIcons: i } = this;
    t.appendChild(ms("columnSelectClosed", e, null)), s.appendChild(ms("columnSelectOpen", e, null));
    const r = this.onExpandOrContractClicked.bind(this);
    this.addManagedElementListeners(t, { click: r }), this.addManagedElementListeners(s, { click: r });
    const o = new hs(i, !0);
    this.addManagedListeners(o, { tap: r }), this.addDestroyFunc(o.destroy.bind(o));
  }
  onLabelClicked() {
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  getVisibleLeafColumns() {
    const e = [], t = (s) => {
      s.forEach((i) => {
        i.passesFilter && (i.group ? t(i.children) : e.push(i.column));
      });
    };
    return t(this.modelItem.children), e;
  }
  onChangeCommon(e) {
    this.refreshAriaLabel(), !this.processingColumnStateChange && Ug(this.beans, this.modelItem.children, e, this.eventType);
  }
  refreshAriaLabel() {
    const { cbSelect: e, focusWrapper: t, displayName: s } = this, i = this.getLocaleTextFunc(), r = i("ariaColumnGroup", "Column Group"), o = e.getValue(), n = o === void 0 ? i("ariaIndeterminate", "indeterminate") : o ? i("ariaVisible", "visible") : i("ariaHidden", "hidden"), a = i("ariaToggleVisibility", "Press SPACE to toggle visibility");
    oe(t, `${s} ${r}`), e.setInputAriaLabel(`${a} (${n})`), _o(t, e.getInputElement().id);
  }
  onColumnStateChanged() {
    const e = this.workOutSelectedValue(), t = this.workOutReadOnlyValue();
    this.processingColumnStateChange = !0;
    const s = this.cbSelect;
    s.setValue(e), s.setReadOnly(t), this.addOrRemoveCssClass("ag-column-select-column-group-readonly", t), this.processingColumnStateChange = !1;
  }
  workOutSelectedValue() {
    const e = this.beans.colModel.isPivotMode(), t = this.getVisibleLeafColumns();
    let s = 0, i = 0;
    if (t.forEach((r) => {
      !e && r.getColDef().lockVisible || (this.isColumnChecked(r, e) ? s++ : i++);
    }), !(s > 0 && i > 0))
      return s > 0;
  }
  workOutReadOnlyValue() {
    const e = this.beans.colModel.isPivotMode();
    let t = 0;
    return this.columnGroup.getLeafColumns().forEach((s) => {
      e ? s.isAnyFunctionAllowed() && t++ : s.getColDef().lockVisible || t++;
    }), t === 0;
  }
  isColumnChecked(e, t) {
    if (t) {
      const s = e.isPivotActive(), i = e.isRowGroupActive(), r = e.isValueActive();
      return s || i || r;
    }
    return e.isVisible();
  }
  onExpandOrContractClicked() {
    const e = this.modelItem, t = e.expanded;
    e.expanded = !t;
  }
  onExpandChanged() {
    this.setOpenClosedIcons(), this.refreshAriaExpanded();
  }
  setOpenClosedIcons() {
    const e = this.modelItem.expanded;
    O(this.eGroupClosedIcon, !e), O(this.eGroupOpenedIcon, e);
  }
  refreshAriaExpanded() {
    He(this.focusWrapper, this.modelItem.expanded);
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    const t = this.cbSelect, s = t.getValue();
    !t.isReadOnly() && (e && !s || !e && s) && t.toggle();
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  setSelected(e) {
    this.cbSelect.setValue(e, !0);
  }
}, zL = class extends P {
  constructor(e, t) {
    super(), this.comp = e, this.virtualList = t;
  }
  postConstruct() {
    this.createManagedBean(
      new Ig(this.comp, this.virtualList, {
        dragSourceType: xt.ToolPanel,
        listItemDragStartEvent: "columnPanelItemDragStart",
        listItemDragEndEvent: "columnPanelItemDragEnd",
        eventSource: this.eventSvc,
        getCurrentDragValue: (e) => this.getCurrentDragValue(e),
        isMoveBlocked: (e) => this.isMoveBlocked(e),
        getNumRows: (e) => e.getDisplayedColsList().length,
        moveItem: (e, t) => this.moveItem(this.getCurrentColumnsBeingMoved(e), t)
      })
    );
  }
  getCurrentDragValue(e) {
    return e.column;
  }
  getCurrentColumnsBeingMoved(e) {
    return ae(e) ? e.getLeafColumns() : e ? [e] : [];
  }
  isMoveBlocked(e) {
    return this.gos.get("suppressMovableColumns") ? !0 : !!this.getCurrentColumnsBeingMoved(e).find((r) => {
      const o = r.getColDef();
      return !!o.suppressMovable || !!o.lockPosition;
    });
  }
  moveItem(e, t) {
    var n;
    if (!t)
      return;
    const { component: s } = t;
    let i = null, r = t.position === "top";
    if (s instanceof Xg ? (i = s.getColumns()[0], r = !0) : s && (i = s.column), !i)
      return;
    const o = this.getMoveTargetIndex({
      currentColumns: e,
      lastHoveredColumn: i,
      isBefore: r
    });
    o != null && ((n = this.beans.colMoves) == null || n.moveColumns(e, o, "toolPanelUi"));
  }
  getMoveTargetIndex(e) {
    const { currentColumns: t, lastHoveredColumn: s, isBefore: i } = e;
    if (!s || !t)
      return null;
    const r = this.beans.colModel.getCols(), o = r.indexOf(s), n = i ? o : o + 1, a = this.getMoveDiff(r, t, n);
    return n - a;
  }
  getMoveDiff(e, t, s) {
    if (!t)
      return 0;
    const i = t[0], r = t.length;
    return e.indexOf(i) < s ? r : 0;
  }
}, WL = class extends L {
  constructor(e, t, s, i) {
    super(), this.allowDragging = t, this.groupsExist = s, this.focusWrapper = i, this.eLabel = S, this.cbSelect = S, this.processingColumnStateChange = !1;
    const { column: r, depth: o, displayName: n } = e;
    this.column = r, this.columnDept = o, this.displayName = n;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `<div class="ag-column-select-column">
                <ag-checkbox data-ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
                <span class="ag-column-select-column-label" data-ref="eLabel"></span>
            </div>`,
      [Pt]
    );
    const {
      beans: e,
      cbSelect: t,
      displayName: s,
      eLabel: i,
      columnDept: r,
      groupsExist: o,
      column: n,
      gos: a,
      focusWrapper: l
    } = this, d = B("columnDrag", e);
    this.eDragHandle = d, d.classList.add("ag-drag-handle", "ag-column-select-column-drag-handle");
    const c = t.getGui(), h = t.getInputElement();
    c.insertAdjacentElement("afterend", d), h.setAttribute("tabindex", "-1");
    const u = Q(s);
    i.innerHTML = u, o && this.addCssClass("ag-column-select-add-group-indent"), this.addCssClass(`ag-column-select-indent-${r}`), this.getGui().style.setProperty("--ag-indentation-level", String(r)), this.tooltipFeature = this.createOptionalManagedBean(
      e.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "columnToolPanelColumn",
        getColDef: () => n.getColDef(),
        shouldDisplayTooltip: ln(a, () => i)
      })
    ), this.setupDragging();
    const p = this.onColumnStateChanged.bind(this);
    this.addManagedEventListeners({ columnPivotModeChanged: p }), this.addManagedListeners(n, {
      columnValueChanged: p,
      columnPivotChanged: p,
      columnRowGroupChanged: p,
      visibleChanged: p
    }), this.addManagedListeners(l, {
      keydown: this.handleKeyDown.bind(this),
      contextmenu: this.onContextMenu.bind(this)
    }), this.addManagedPropertyListener("functionsReadOnly", this.onColumnStateChanged.bind(this)), this.addManagedListeners(t, { fieldValueChanged: this.onCheckboxChanged.bind(this) }), this.addManagedElementListeners(i, { click: this.onLabelClicked.bind(this) }), this.onColumnStateChanged(), this.refreshAriaLabel(), this.setupTooltip(), Ru(n.getColDef(), a, n, null).forEach((f) => this.addOrRemoveCssClass(f, !0));
  }
  getColumn() {
    return this.column;
  }
  setupTooltip() {
    const e = () => {
      var t;
      return (t = this.tooltipFeature) == null ? void 0 : t.setTooltipAndRefresh(this.column.getColDef().headerTooltip);
    };
    e(), this.addManagedEventListeners({ newColumnsLoaded: e });
  }
  onContextMenu(e) {
    const { column: t, gos: s } = this;
    if (s.get("functionsReadOnly"))
      return;
    const i = this.createBean(new Yg(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      i.isAlive() && this.destroyBean(i);
    });
  }
  handleKeyDown(e) {
    e.key === w.SPACE && (e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected()));
  }
  onLabelClicked() {
    if (this.gos.get("functionsReadOnly"))
      return;
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  onChangeCommon(e) {
    this.cbSelect.isReadOnly() || (this.refreshAriaLabel(), !this.processingColumnStateChange && Kg(this.beans, [this.column], e, "toolPanelUi"));
  }
  refreshAriaLabel() {
    const { cbSelect: e, focusWrapper: t, displayName: s } = this, i = this.getLocaleTextFunc(), r = i("ariaColumn", "Column"), o = e.getValue() ? i("ariaVisible", "visible") : i("ariaHidden", "hidden"), n = i("ariaToggleVisibility", "Press SPACE to toggle visibility");
    oe(t, `${s} ${r}`), this.cbSelect.setInputAriaLabel(`${n} (${o})`), _o(t, e.getInputElement().id);
  }
  setupDragging() {
    const e = this.eDragHandle;
    if (!this.allowDragging) {
      O(e, !1);
      return;
    }
    const t = this.beans, { gos: s, eventSvc: i, dragAndDrop: r } = t;
    let o = !s.get("suppressDragLeaveHidesColumns");
    const n = {
      type: xt.ToolPanel,
      eElement: e,
      dragItemName: this.displayName,
      getDefaultIconName: () => o ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        o = !s.get("suppressDragLeaveHidesColumns"), i.dispatchEvent({
          type: "columnPanelItemDragStart",
          column: this.column
        });
      },
      onDragStopped: () => {
        i.dispatchEvent({
          type: "columnPanelItemDragEnd"
        });
      },
      onGridEnter: (a) => {
        o && $g(t, {
          columns: [this.column],
          visibleState: a == null ? void 0 : a.visibleState,
          pivotState: a == null ? void 0 : a.pivotState,
          eventType: "toolPanelUi"
        });
      },
      onGridExit: () => {
        o && this.onChangeCommon(!1);
      }
    };
    r.addDragSource(n, !0), this.addDestroyFunc(() => r.removeDragSource(n));
  }
  createDragItem() {
    const e = this.column.getColId(), t = { [e]: this.column.isVisible() }, s = { [e]: jg(this.column) };
    return {
      columns: [this.column],
      visibleState: t,
      pivotState: s
    };
  }
  onColumnStateChanged() {
    this.processingColumnStateChange = !0;
    const e = this.beans.colModel.isPivotMode();
    if (e) {
      const i = this.column.isAnyFunctionActive();
      this.cbSelect.setValue(i);
    } else
      this.cbSelect.setValue(this.column.isVisible());
    let t = !0, s = !0;
    if (e) {
      const i = this.gos.get("functionsReadOnly"), r = !this.column.isAnyFunctionAllowed();
      t = !i && !r, s = t;
    } else {
      const { enableRowGroup: i, enableValue: r, lockPosition: o, suppressMovable: n, lockVisible: a } = this.column.getColDef(), l = !!i || !!r, d = !!o || !!n;
      t = !a, s = l || !d;
    }
    this.cbSelect.setReadOnly(!t), this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !s), this.addOrRemoveCssClass("ag-column-select-column-readonly", !s && !t), this.cbSelect.setPassive(!1), this.processingColumnStateChange = !1;
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    const t = this.cbSelect;
    e !== t.getValue() && (t.isReadOnly() || t.toggle());
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  isExpandable() {
    return !1;
  }
  setExpanded(e) {
    R(158);
  }
}, _L = class {
  constructor(e) {
    this.items = e;
  }
  getRowCount() {
    return this.items.length;
  }
  getRow(e) {
    return this.items[e];
  }
}, UL = "ag-column-select-list", KL = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="${UL}" role="presentation"></div>`
    ), this.destroyColumnItemFuncs = [], this.hasLoadedInitialState = !1, this.isInitialState = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  destroy() {
    this.destroyColumnTree(), super.destroy();
  }
  destroyColumnTree() {
    this.allColsTree = [], this.destroyColumnItemFuncs.forEach((e) => e()), this.destroyColumnItemFuncs = [];
  }
  init(e, t, s) {
    this.params = e, this.allowDragging = t, this.eventType = s, e.suppressSyncLayoutWithGrid || this.addManagedEventListeners({ columnMoved: this.onColumnsChanged.bind(this) }), this.addManagedEventListeners({
      newColumnsLoaded: this.onColumnsChanged.bind(this)
    });
    const i = this.fireSelectionChangedEvent.bind(this);
    this.addManagedEventListeners({
      columnPivotChanged: i,
      columnPivotModeChanged: i,
      columnRowGroupChanged: i,
      columnValueChanged: i,
      columnVisible: i,
      newColumnsLoaded: i
    }), this.expandGroupsByDefault = !e.contractColumnSelection;
    const r = this.createManagedBean(
      new Oi({
        cssIdentifier: "column-select",
        ariaRole: "tree"
      })
    );
    this.virtualList = r, this.appendChild(r.getGui()), r.setComponentCreator((o, n) => (Sr(n, o.depth + 1), this.createComponentFromItem(o, n))), this.colModel.ready && this.onColumnsChanged(), !e.suppressColumnMove && this.createManagedBean(new zL(this, r));
  }
  createComponentFromItem(e, t) {
    const s = this.allowDragging;
    if (e.group) {
      const r = new Xg(e, s, this.eventType, t);
      return this.createBean(r), r;
    }
    const i = new WL(e, s, this.groupsExist, t);
    return this.createBean(i), i;
  }
  onColumnsChanged() {
    const e = this.params;
    this.hasLoadedInitialState || (this.hasLoadedInitialState = !0, this.isInitialState = !!e.initialState);
    const t = this.getExpandedStates(), s = this.colModel.isPivotMode();
    !e.suppressSyncLayoutWithGrid && !s ? this.buildTreeFromWhatGridIsDisplaying() : this.buildTreeFromProvidedColumnDefs(), this.setExpandedStates(t), this.markFilteredColumns(), this.flattenAndFilterModel(), this.isInitialState = !1;
  }
  getDisplayedColsList() {
    return this.displayedColsList;
  }
  getExpandedStates() {
    const e = {};
    if (this.isInitialState) {
      const { expandedGroupIds: t } = this.params.initialState;
      return t.forEach((s) => {
        e[s] = !0;
      }), e;
    }
    return this.allColsTree ? (this.forEachItem((t) => {
      if (!t.group)
        return;
      const s = t.columnGroup;
      s && (e[s.getId()] = t.expanded);
    }), e) : {};
  }
  setExpandedStates(e) {
    if (!this.allColsTree)
      return;
    const { isInitialState: t } = this;
    this.forEachItem((s) => {
      if (!s.group)
        return;
      const i = s.columnGroup;
      if (i) {
        const r = e[i.getId()];
        (r != null || t) && (s.expanded = !!r);
      }
    });
  }
  buildTreeFromWhatGridIsDisplaying() {
    _g(this.colModel, this.setColumnLayout.bind(this));
  }
  setColumnLayout(e) {
    const t = Wg(this.colModel, e);
    this.buildListModel(t), this.groupsExist = e.some((s) => s && typeof s.children < "u"), this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  buildTreeFromProvidedColumnDefs() {
    var t;
    const e = this.colModel;
    this.buildListModel(e.getColDefColTree()), this.groupsExist = !!((t = e.colDefCols) != null && t.treeDepth);
  }
  buildListModel(e) {
    const t = this.onColumnExpanded.bind(this), s = (a) => {
      a.addEventListener("expandedChanged", t);
      const l = a.removeEventListener.bind(a, "expandedChanged", t);
      this.destroyColumnItemFuncs.push(l);
    }, i = this.beans.colNames, r = (a, l, d) => {
      a.forEach((c) => {
        ae(c) ? o(c, l, d) : n(c, l, d);
      });
    }, o = (a, l, d) => {
      const c = a.getColGroupDef();
      if (c && c.suppressColumnsToolPanel)
        return;
      if (a.isPadding()) {
        r(a.getChildren(), l, d);
        return;
      }
      const u = i.getDisplayNameForProvidedColumnGroup(null, a, "columnToolPanel"), p = new Rc(
        u,
        a,
        l,
        !0,
        this.expandGroupsByDefault
      );
      d.push(p), s(p), r(a.getChildren(), l + 1, p.children);
    }, n = (a, l, d) => {
      if (a.getColDef() && a.getColDef().suppressColumnsToolPanel)
        return;
      const h = i.getDisplayNameForColumn(a, "columnToolPanel");
      d.push(new Rc(h, a, l));
    };
    this.destroyColumnTree(), r(e, 0, this.allColsTree);
  }
  onColumnExpanded() {
    this.flattenAndFilterModel();
  }
  flattenAndFilterModel() {
    this.displayedColsList = [];
    const e = (i) => {
      i.passesFilter && (this.displayedColsList.push(i), i.group && i.expanded && i.children.forEach(e));
    }, t = this.virtualList;
    this.allColsTree.forEach(e), t.setModel(new _L(this.displayedColsList));
    const s = t.getLastFocusedRow();
    t.refresh(), s != null && this.focusRowIfAlive(s), this.notifyListeners(), this.refreshAriaLabel();
  }
  refreshAriaLabel() {
    const e = this.getLocaleTextFunc(), t = e("ariaColumnPanelList", "Column List"), s = e("columns", "Columns"), i = this.displayedColsList.length;
    oe(this.virtualList.getAriaElement(), `${t} ${i} ${s}`);
  }
  focusRowIfAlive(e) {
    window.setTimeout(() => {
      this.isAlive() && this.virtualList.focusRow(e);
    }, 0);
  }
  forEachItem(e) {
    const t = (i) => {
      i.forEach((r) => {
        e(r), r.group && t(r.children);
      });
    }, s = this.allColsTree;
    s && t(s);
  }
  doSetExpandedAll(e) {
    this.forEachItem((t) => {
      t.group && (t.expanded = e);
    });
  }
  setGroupsExpanded(e, t) {
    if (!t) {
      this.doSetExpandedAll(e);
      return;
    }
    const s = [];
    this.forEachItem((r) => {
      if (!r.group)
        return;
      const o = r.columnGroup.getId();
      t.indexOf(o) >= 0 && (r.expanded = e, s.push(o));
    });
    const i = t.filter((r) => !s.includes(r));
    i.length > 0 && R(157, { unrecognisedGroupIds: i });
  }
  getExpandState() {
    let e = 0, t = 0;
    return this.forEachItem((s) => {
      s.group && (s.expanded ? e++ : t++);
    }), e > 0 && t > 0 ? 2 : t > 0 ? 1 : 0;
  }
  doSetSelectedAll(e) {
    Ug(this.beans, this.allColsTree, e, this.eventType);
  }
  getSelectionState() {
    let e = 0, t = 0;
    const s = this.colModel.isPivotMode();
    if (this.forEachItem((i) => {
      if (i.group || !i.passesFilter)
        return;
      const r = i.column, o = r.getColDef();
      let n;
      if (s) {
        if (!r.isAllowPivot() && !r.isAllowRowGroup() && !r.isAllowValue())
          return;
        n = r.isValueActive() || r.isPivotActive() || r.isRowGroupActive();
      } else {
        if (o.lockVisible)
          return;
        n = r.isVisible();
      }
      n ? e++ : t++;
    }), !(e > 0 && t > 0))
      return !(e === 0 || t > 0);
  }
  setFilterText(e) {
    this.filterText = A(e) ? e.toLowerCase() : null, this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  markFilteredColumns() {
    const e = (s) => {
      if (!A(this.filterText))
        return !0;
      const i = s.displayName;
      return i == null || i.toLowerCase().indexOf(this.filterText) !== -1;
    }, t = (s, i) => {
      let r = !1;
      if (s.group) {
        const n = e(s);
        s.children.forEach((a) => {
          const l = t(a, n || i);
          l && (r = l);
        });
      }
      const o = i || r ? !0 : e(s);
      return s.passesFilter = o, o;
    };
    this.allColsTree.forEach((s) => t(s, !1));
  }
  notifyListeners() {
    this.fireGroupExpandedEvent(), this.fireSelectionChangedEvent();
  }
  fireGroupExpandedEvent() {
    const e = this.getExpandState();
    this.dispatchLocalEvent({ type: "groupExpanded", state: e });
  }
  fireSelectionChangedEvent() {
    if (!this.allColsTree)
      return;
    const e = this.getSelectionState();
    this.dispatchLocalEvent({ type: "selectionChanged", state: e });
  }
  getExpandedGroups() {
    const e = [];
    return this.allColsTree && this.forEachItem((t) => {
      t.group && t.expanded && e.push(t.columnGroup.getId());
    }), e;
  }
}, $L = {
  selector: "AG-PRIMARY-COLS-LIST",
  component: KL
}, Zg = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-column-select">
            <ag-primary-cols-header data-ref="primaryColsHeaderPanel"></ag-primary-cols-header>
            <ag-primary-cols-list data-ref="primaryColsListPanel"></ag-primary-cols-list>
        </div>`,
      [AL, $L]
    ), this.primaryColsHeaderPanel = S, this.primaryColsListPanel = S, this.registerCSS(DL);
  }
  // we allow dragging in the toolPanel, but not when this component appears in the column menu
  init(e, t, s) {
    const { primaryColsHeaderPanel: i, primaryColsListPanel: r } = this;
    i.init(t);
    const o = t.suppressColumnFilter, n = t.suppressColumnSelectAll;
    t.suppressColumnExpandAll && o && n && i.setDisplayed(!1), this.addManagedListeners(r, {
      groupExpanded: (l) => {
        i.setExpandState(l.state), t.onStateUpdated();
      },
      selectionChanged: (l) => i.setSelectionState(l.state)
    }), r.init(t, e, s), this.addManagedListeners(i, {
      expandAll: r.doSetExpandedAll.bind(r, !0),
      collapseAll: r.doSetExpandedAll.bind(r, !1),
      selectAll: r.doSetSelectedAll.bind(r, !0),
      unselectAll: r.doSetSelectedAll.bind(r, !1),
      filterChanged: (l) => r.setFilterText(l.filterText)
    }), this.positionableFeature = this.createManagedBean(new rn(this.getGui(), { minHeight: 100 }));
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1);
  }
  expandGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!0, e);
  }
  collapseGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!1, e);
  }
  setColumnLayout(e) {
    this.primaryColsListPanel.setColumnLayout(e);
  }
  syncLayoutWithGrid() {
    this.primaryColsListPanel.onColumnsChanged();
  }
  getExpandedGroups() {
    return this.primaryColsListPanel.getExpandedGroups();
  }
}, jL = (
  /*css*/
  ".ag-column-panel{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.ag-pivot-mode-panel{display:flex;height:var(--ag-header-height)}.ag-pivot-mode-select{align-items:center;display:flex}:where(.ag-ltr) .ag-pivot-mode-select{margin-left:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-pivot-mode-select{margin-right:var(--ag-widget-container-horizontal-padding)}.ag-column-panel-column-select{border-bottom:var(--ag-tool-panel-separator-border)}.ag-column-panel-column-select:where(:nth-child(n+2 of :not(.ag-hidden))){border-top:var(--ag-tool-panel-separator-border)}:where(.ag-column-panel) .ag-column-drop-vertical{flex:1 1 0px;min-height:50px;&:where(:not(.ag-last-column-drop)){border-bottom:var(--ag-tool-panel-separator-border)}}"
), qL = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-column-panel"></div>'
    ), this.initialised = !1, this.childDestroyFuncs = [], this.registerCSS(jL);
  }
  wireBeans(e) {
    this.colToolPanelFactory = e.colToolPanelFactory;
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  init(e) {
    const s = {
      ...this.gos.addGridCommonParams({
        suppressColumnMove: !1,
        suppressColumnSelectAll: !1,
        suppressColumnFilter: !1,
        suppressColumnExpandAll: !1,
        contractColumnSelection: !1,
        suppressPivotMode: !1,
        suppressRowGroups: !1,
        suppressValues: !1,
        suppressPivots: !1,
        suppressSyncLayoutWithGrid: !1
      }),
      ...e
    };
    this.params = s;
    const { childDestroyFuncs: i, colToolPanelFactory: r, gos: o } = this, n = o.isModuleRegistered("SharedPivot"), a = n || o.isModuleRegistered("SharedRowGrouping");
    !s.suppressPivotMode && r && n && (this.pivotModePanel = r.createPivotModePanel(this, i));
    const l = this.createBean(new Zg());
    if (this.primaryColsPanel = l, i.push(() => this.destroyBean(this.primaryColsPanel)), l.init(!0, s, "toolPanelUi"), l.addCssClass("ag-column-panel-column-select"), this.appendChild(l), r) {
      !s.suppressRowGroups && a && (this.rowGroupDropZonePanel = r.createRowGroupPanel(this, i)), !s.suppressValues && a && (this.valuesDropZonePanel = r.createValuesPanel(this, i)), !s.suppressPivots && n && (this.pivotDropZonePanel = r.createPivotPanel(this, i)), this.setLastVisible();
      const [d] = this.addManagedEventListeners({
        columnPivotModeChanged: () => {
          this.resetChildrenHeight(), this.setLastVisible();
        }
      });
      i.push(() => d());
    }
    this.initialised = !0;
  }
  setPivotModeSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.pivotModePanel = t.setPanelVisible(
      this.pivotModePanel,
      e,
      t.createPivotModePanel.bind(t, this, this.childDestroyFuncs, !0)
    ), this.setLastVisible());
  }
  setRowGroupsSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.rowGroupDropZonePanel = t.setPanelVisible(
      this.rowGroupDropZonePanel,
      e,
      t.createRowGroupPanel.bind(t, this, this.childDestroyFuncs)
    ), this.setLastVisible());
  }
  setValuesSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.valuesDropZonePanel = t.setPanelVisible(
      this.valuesDropZonePanel,
      e,
      t.createValuesPanel.bind(t, this, this.childDestroyFuncs)
    ), this.setLastVisible());
  }
  setPivotSectionVisible(e) {
    var s;
    const t = this.colToolPanelFactory;
    t && (this.pivotDropZonePanel = t.setPanelVisible(
      this.pivotDropZonePanel,
      e,
      t.createPivotPanel.bind(t, this, this.childDestroyFuncs)
    ), (s = this.pivotDropZonePanel) == null || s.setDisplayed(e), this.setLastVisible());
  }
  setResizers() {
    [this.primaryColsPanel, this.rowGroupDropZonePanel, this.valuesDropZonePanel, this.pivotDropZonePanel].forEach(
      (e) => {
        if (!e)
          return;
        const t = e.getGui();
        e.toggleResizable(
          !t.classList.contains("ag-last-column-drop") && !t.classList.contains("ag-hidden")
        );
      }
    );
  }
  setLastVisible() {
    const e = this.getGui();
    Array.prototype.slice.call(e.querySelectorAll(".ag-column-drop")).forEach((r) => r.classList.remove("ag-last-column-drop"));
    const s = e.querySelectorAll(".ag-column-drop:not(.ag-hidden)"), i = V(s);
    i && i.classList.add("ag-last-column-drop"), this.setResizers();
  }
  resetChildrenHeight() {
    const t = this.getGui().children;
    for (let s = 0; s < t.length; s++) {
      const { style: i } = t[s];
      i.removeProperty("height"), i.removeProperty("flex");
    }
  }
  expandColumnGroups(e) {
    this.primaryColsPanel.expandGroups(e);
  }
  collapseColumnGroups(e) {
    this.primaryColsPanel.collapseGroups(e);
  }
  setColumnLayout(e) {
    this.primaryColsPanel.setColumnLayout(e);
  }
  syncLayoutWithGrid() {
    this.primaryColsPanel.syncLayoutWithGrid();
  }
  destroyChildren() {
    const e = this.childDestroyFuncs;
    e.forEach((t) => t()), e.length = 0, X(this.getGui());
  }
  refresh(e) {
    return this.destroyChildren(), this.init(e), !0;
  }
  getState() {
    return {
      expandedGroupIds: this.primaryColsPanel.getExpandedGroups()
    };
  }
  destroy() {
    this.destroyChildren(), super.destroy();
  }
}, YL = (
  /*css*/
  ".ag-column-drop{align-items:center;display:inline-flex;overflow:auto;position:relative;width:100%}.ag-column-drop-list{align-items:center;display:flex}.ag-column-drop-cell{align-items:center;background-color:var(--ag-column-drop-cell-background-color);border:var(--ag-column-drop-cell-border);border-radius:500px;color:var(--ag-column-drop-cell-text-color);display:flex;padding:calc(var(--ag-spacing)*.25);position:relative;&:focus-visible{box-shadow:var(--ag-focus-shadow)}:where(.ag-drag-handle){color:var(--ag-column-drop-cell-drag-handle-color)}}:where(.ag-ltr) .ag-column-drop-cell{padding-left:calc(var(--ag-spacing)*.75)}:where(.ag-rtl) .ag-column-drop-cell{padding-right:calc(var(--ag-spacing)*.75)}.ag-column-drop-cell-text{flex:1 1 auto;margin:0 var(--ag-spacing);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-drop-vertical{align-items:stretch;display:flex;flex-direction:column;min-height:75px;overflow:hidden}.ag-column-drop-vertical-title-bar{align-items:center;display:flex;flex:none;padding:var(--ag-widget-container-vertical-padding) calc(var(--ag-spacing)*2) 0}.ag-column-drop-vertical-list{align-items:stretch;flex-direction:column;flex-grow:1;overflow-x:auto;padding-bottom:var(--ag-spacing);padding-left:var(--ag-spacing);padding-right:var(--ag-spacing);position:relative;>*{flex:none}}:where(.ag-column-drop-empty) .ag-column-drop-vertical-list{overflow:hidden}.ag-column-drop-vertical-empty-message{align-items:center;border:1px dashed;border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}.ag-column-drop-cell-button{cursor:pointer;min-width:0;opacity:.75;&:hover{opacity:1}}.ag-column-drop-wrapper{display:flex}.ag-column-drop-horizontal-half-width{width:50%!important}.ag-column-drop-cell-ghost{opacity:.5}.ag-column-drop-horizontal{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;white-space:nowrap}:where(.ag-ltr) .ag-column-drop-horizontal{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-column-drop-horizontal{padding-right:var(--ag-cell-horizontal-padding)}.ag-column-drop-horizontal-list{gap:var(--ag-cell-widget-spacing)}.ag-column-drop-vertical-cell{margin-top:var(--ag-spacing)}:where(.ag-ltr) .ag-column-drop-vertical-icon{margin-right:var(--ag-widget-horizontal-spacing)}:where(.ag-rtl) .ag-column-drop-vertical-icon{margin-left:var(--ag-widget-horizontal-spacing)}.ag-select-agg-func-popup{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);height:calc(var(--ag-spacing)*5*3.5);padding:0;position:absolute}.ag-select-agg-func-virtual-list-item{cursor:default;&:hover{background-color:var(--ag-selected-row-background-color)}}:where(.ag-ltr) .ag-select-agg-func-virtual-list-item{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-select-agg-func-virtual-list-item{padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-left:1px solid var(--ag-border-color)}"
);
function Pc(e, t, s) {
  e == null || t == null || e.splice(s, 0, ...t);
}
var Qg = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-unselectable" role="presentation"></div>'
    ), this.horizontal = e, this.state = "notDragging", this.guiDestroyFunctions = [], this.childPillComponents = [], this.resizeEnabled = !1, this.addElementClasses(this.getGui()), this.ePillDropList = document.createElement("div"), this.addElementClasses(this.ePillDropList, "list"), re(this.ePillDropList, "listbox"), this.registerCSS(YL);
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1), this.resizeEnabled = e;
  }
  isSourceEventFromTarget(e) {
    const { dropZoneTarget: t, dragSource: s } = e;
    return t.contains(s.eElement);
  }
  destroy() {
    this.destroyGui(), super.destroy();
  }
  destroyGui() {
    this.guiDestroyFunctions.forEach((e) => e()), this.guiDestroyFunctions.length = 0, this.childPillComponents.length = 0, X(this.getGui()), X(this.ePillDropList);
  }
  init(e) {
    this.params = e ?? {}, this.createManagedBean(
      new Ps(this.getFocusableElement(), {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.onKeyDown.bind(this)
      })
    ), this.setupDropTarget(), this.positionableFeature = new rn(this.getGui()), this.createManagedBean(this.positionableFeature), this.refreshGui(), oe(this.ePillDropList, this.getAriaLabel());
  }
  onTabKeyDown(e) {
    const t = bt(this.getFocusableElement(), null, !0), s = t.length;
    if (s === 0)
      return;
    const { shiftKey: i } = e, r = q(this.beans), o = r === t[0], n = r === V(t);
    s === 1 || o && i || n && !i || t[i ? 0 : s - 1].focus();
  }
  onKeyDown(e) {
    const { key: t } = e, s = !this.horizontal;
    let i = t === w.DOWN, r = t === w.UP;
    if (!s) {
      const n = this.gos.get("enableRtl");
      i = !n && t === w.RIGHT || n && t === w.LEFT, r = !n && t === w.LEFT || n && t === w.RIGHT;
    }
    if (!i && !r)
      return;
    const o = Pe(this.beans, this.getFocusableElement(), !1, r);
    o && (e.preventDefault(), o.focus());
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const s = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop${t}`, `ag-column-drop-${s}${t}`);
  }
  setupDropTarget() {
    var e;
    this.dropTarget = {
      getContainer: this.getGui.bind(this),
      getIconName: this.getIconName.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragEnter: this.onDragEnter.bind(this),
      onDragLeave: this.onDragLeave.bind(this),
      onDragStop: this.onDragStop.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      isInterestedIn: this.isInterestedIn.bind(this)
    }, (e = this.beans.dragAndDrop) == null || e.addDropTarget(this.dropTarget);
  }
  minimumAllowedNewInsertIndex() {
    return 0;
  }
  checkInsertIndex(e) {
    const t = this.getNewInsertIndex(e);
    if (t < 0)
      return !1;
    const s = this.minimumAllowedNewInsertIndex(), i = Math.max(s, t), r = i !== this.insertIndex;
    return r && (this.insertIndex = i), r;
  }
  getNewInsertIndex(e) {
    const t = e.event, s = this.horizontal ? t.clientX : t.clientY, i = this.childPillComponents.map((o) => o.getGui().getBoundingClientRect()), r = i.findIndex(
      (o) => this.horizontal ? o.right > s && o.left < s : o.top < s && o.bottom > s
    );
    if (r === -1) {
      const o = this.gos.get("enableRtl");
      return i.every((l) => s > (this.horizontal ? l.right : l.bottom)) ? o && this.horizontal ? 0 : this.childPillComponents.length : i.every((l) => s < (this.horizontal ? l.left : l.top)) ? o && this.horizontal ? this.childPillComponents.length : 0 : this.insertIndex;
    }
    return this.insertIndex <= r ? r + 1 : r;
  }
  checkDragStartedBySelf(e) {
    this.state === "notDragging" && (this.state = "rearrangeItems", this.potentialDndItems = this.getItems(e.dragSource.getDragItem()), this.refreshGui(), this.checkInsertIndex(e), this.refreshGui());
  }
  onDragging(e) {
    this.checkDragStartedBySelf(e), this.checkInsertIndex(e) && this.refreshGui();
  }
  handleDragEnterEnd(e) {
  }
  onDragEnter(e) {
    const t = this.getItems(e.dragSource.getDragItem());
    this.state = "newItemsIn";
    const s = t.filter((r) => this.isItemDroppable(r, e)), i = s.every(
      (r) => this.childPillComponents.map((o) => o.getItem()).indexOf(r) !== -1
    );
    if (s.length !== 0) {
      if (this.potentialDndItems = s, i) {
        this.state = "notDragging";
        return;
      }
      this.handleDragEnterEnd(e), this.checkInsertIndex(e), this.refreshGui();
    }
  }
  isPotentialDndItems() {
    var e;
    return !!((e = this.potentialDndItems) != null && e.length);
  }
  handleDragLeaveEnd(e) {
  }
  onDragLeave(e) {
    if (this.state === "rearrangeItems") {
      const t = this.getItems(e.dragSource.getDragItem());
      this.removeItems(t);
    }
    this.isPotentialDndItems() && (this.handleDragLeaveEnd(e), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  onDragCancel(e) {
    this.isPotentialDndItems() && (this.state === "newItemsIn" && this.handleDragLeaveEnd(e), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  onDragStop() {
    this.isPotentialDndItems() && (this.state === "newItemsIn" ? this.addItems(this.potentialDndItems) : this.rearrangeItems(this.potentialDndItems), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  removeItems(e) {
    const t = this.getExistingItems().filter((s) => !e.includes(s));
    this.updateItems(t);
  }
  addItems(e) {
    if (!e)
      return;
    const t = this.getExistingItems().slice(), s = e.filter((i) => t.indexOf(i) < 0);
    Pc(t, s, this.insertIndex), this.updateItems(t);
  }
  addItem(e) {
    this.insertIndex = this.getExistingItems().length, this.addItems([e]), this.refreshGui();
  }
  rearrangeItems(e) {
    const t = this.getNonGhostItems().slice();
    return Pc(t, e, this.insertIndex), Re(t, this.getExistingItems()) ? !1 : (this.updateItems(t), !0);
  }
  refreshGui() {
    const e = this.ePillDropList.scrollTop, t = this.resizeEnabled, s = this.getFocusedItem(), { eGridDiv: i } = this.beans;
    let r = Pe(this.beans, i);
    r || (r = Pe(this.beans, i, !1, !0)), this.toggleResizable(!1), this.destroyGui(), this.addIconAndTitleToGui(), this.addEmptyMessageToGui(), this.addItemsToGui(), this.horizontal || (this.ePillDropList.scrollTop = e), t && this.toggleResizable(t), tn() && this.restoreFocus(s, r);
  }
  getFocusedItem() {
    const e = this.getGui(), t = q(this.beans);
    return e.contains(t) ? Array.from(e.querySelectorAll(".ag-column-drop-cell")).indexOf(t) : -1;
  }
  restoreFocus(e, t) {
    const s = this.getGui(), i = Array.from(s.querySelectorAll(".ag-column-drop-cell"));
    if (e === -1)
      return;
    i.length === 0 && t.focus();
    const r = Math.min(i.length - 1, e), o = i[r];
    o && o.focus();
  }
  focusList(e) {
    const t = e ? this.childPillComponents.length - 1 : 0;
    this.restoreFocus(t, this.getFocusableElement());
  }
  getNonGhostItems() {
    const e = this.getExistingItems();
    return this.isPotentialDndItems() ? e.filter((t) => !this.potentialDndItems.includes(t)) : e;
  }
  addItemsToGui() {
    const t = this.getNonGhostItems().map((s) => this.createItemComponent(s, !1));
    if (this.isPotentialDndItems()) {
      const s = this.potentialDndItems.map((i) => this.createItemComponent(i, !0));
      this.insertIndex >= t.length ? t.push(...s) : t.splice(this.insertIndex, 0, ...s);
    }
    this.appendChild(this.ePillDropList), t.forEach((s, i) => {
      i > 0 && this.addArrow(this.ePillDropList), this.ePillDropList.appendChild(s.getGui());
    }), this.addAriaLabelsToComponents();
  }
  addAriaLabelsToComponents() {
    this.childPillComponents.forEach((e, t) => {
      const s = e.getGui();
      Ko(s, t + 1), Uo(s, this.childPillComponents.length);
    });
  }
  createItemComponent(e, t) {
    const s = this.createPillComponent(e, this.dropTarget, t, this.horizontal);
    return s.addEventListener("columnRemove", this.removeItems.bind(this, [e])), this.createBean(s), this.guiDestroyFunctions.push(() => this.destroyBean(s)), t || this.childPillComponents.push(s), s;
  }
  addIconAndTitleToGui() {
    const { title: e, icon: t } = this.params;
    if (!e || !t)
      return;
    const s = document.createElement("div");
    if (Za(s, !0), this.addElementClasses(s, "title-bar"), this.addElementClasses(t, "icon"), this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingItemsEmpty()), s.appendChild(t), !this.horizontal) {
      const i = document.createElement("span");
      this.addElementClasses(i, "title"), i.innerHTML = e, s.appendChild(i);
    }
    this.appendChild(s);
  }
  isExistingItemsEmpty() {
    return this.getExistingItems().length === 0;
  }
  addEmptyMessageToGui() {
    const { emptyMessage: e } = this.params;
    if (!e || !this.isExistingItemsEmpty() || this.isPotentialDndItems())
      return;
    const t = document.createElement("span");
    t.innerHTML = e, this.addElementClasses(t, "empty-message"), this.ePillDropList.appendChild(t);
  }
  addArrow(e) {
    if (this.horizontal) {
      const t = this.gos.get("enableRtl"), s = B(t ? "panelDelimiterRtl" : "panelDelimiter", this.beans);
      this.addElementClasses(s, "cell-separator"), e.appendChild(s);
    }
  }
}, Jg = class extends L {
  constructor(e, t, s, i, r) {
    super(), this.dragSourceDropTarget = e, this.ghost = t, this.horizontal = s, this.template = i, this.agComponents = r, this.eText = S, this.eDragHandle = S, this.eButton = S;
  }
  postConstruct() {
    this.setTemplate(
      this.template ?? /* html */
      `
            <span role="option">
              <span data-ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
              <span data-ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
              <span data-ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
            </span>`,
      this.agComponents
    );
    const e = this.getGui(), { beans: t, eDragHandle: s, eText: i, eButton: r } = this;
    this.addElementClasses(e), this.addElementClasses(s, "drag-handle"), this.addElementClasses(i, "text"), this.addElementClasses(r, "button"), s.appendChild(B("columnDrag", t)), r.appendChild(B("cancel", t)), this.tooltipFeature = this.createOptionalManagedBean(
      t.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui()
      })
    ), this.setupComponents(), !this.ghost && this.isDraggable() && this.addDragSource(), this.setupAria(), this.setupTooltip(), this.activateTabIndex(), this.refreshDraggable();
  }
  isDraggable() {
    return !0;
  }
  refreshDraggable() {
    this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !this.isDraggable());
  }
  setupAria() {
    const e = this.getLocaleTextFunc(), t = [this.getAriaDisplayName()];
    this.addAdditionalAriaInstructions(t, e), oe(this.getGui(), t.join(". "));
  }
  addAdditionalAriaInstructions(e, t) {
    if (this.isRemovable()) {
      const s = t("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
      e.push(s);
    }
  }
  setupTooltip() {
    const e = () => {
      var t;
      return (t = this.tooltipFeature) == null ? void 0 : t.setTooltipAndRefresh(this.getTooltip());
    };
    e(), this.addManagedEventListeners({ newColumnsLoaded: e });
  }
  getDragSourceId() {
  }
  getDefaultIconName() {
    return "notAllowed";
  }
  addDragSource() {
    const {
      beans: { dragAndDrop: e },
      eDragHandle: t
    } = this, s = this.createGetDragItem(), i = this.getDefaultIconName(), r = {
      type: this.getDragSourceType(),
      sourceId: this.getDragSourceId(),
      eElement: t,
      getDefaultIconName: () => i,
      getDragItem: s,
      dragItemName: this.getDisplayName()
    };
    e == null || e.addDragSource(r, !0), this.addDestroyFunc(() => e == null ? void 0 : e.removeDragSource(r));
  }
  setupComponents() {
    this.setTextValue(), this.setupRemove(), this.ghost && this.addCssClass("ag-column-drop-cell-ghost");
  }
  isRemovable() {
    return !0;
  }
  refreshRemove() {
    O(this.eButton, this.isRemovable());
  }
  setupRemove() {
    this.refreshRemove();
    const e = { type: "columnRemove" };
    this.addGuiEventListener("keydown", (s) => this.onKeyDown(s)), this.addManagedElementListeners(this.eButton, {
      click: (s) => {
        this.dispatchLocalEvent(e), s.stopPropagation();
      }
    });
    const t = new hs(this.eButton);
    this.addManagedListeners(t, {
      tap: () => this.dispatchLocalEvent(e)
    }), this.addDestroyFunc(t.destroy.bind(t));
  }
  onKeyDown(e) {
    e.key === w.DELETE && this.isRemovable() && (e.preventDefault(), this.dispatchLocalEvent({ type: "columnRemove" }));
  }
  getDisplayValue() {
    return this.getDisplayName();
  }
  setTextValue() {
    const e = this.getDisplayValue(), t = Q(e);
    this.eText.innerHTML = t;
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const s = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop-cell${t}`, `ag-column-drop-${s}-cell${t}`);
  }
  destroy() {
    super.destroy(), this.dragSourceDropTarget = null;
  }
}, XL = class extends Jg {
  constructor(e, t, s, i, r) {
    super(t, s, r), this.column = e, this.dropZonePurpose = i, this.eSortIndicator = S, this.popupShowing = !1;
  }
  postConstruct() {
    const { sortSvc: e, colNames: t } = this.beans;
    this.template = /* html */
    `
            <span role="option">
                <span data-ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
                <span data-ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
                ${e ? '<ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>' : ""}
                <span data-ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
            </span>
        `, e && (this.agComponents = [e.getSortIndicatorSelector()]), this.displayName = t.getDisplayNameForColumn(this.column, "columnDrop"), super.postConstruct(), e && (this.setupSort(), this.addManagedEventListeners({
      sortChanged: () => {
        this.setupAria();
      }
    })), this.isGroupingZone() && this.addManagedPropertyListener("groupLockGroupColumns", () => {
      this.refreshRemove(), this.refreshDraggable(), this.setupAria();
    });
  }
  getItem() {
    return this.column;
  }
  getDisplayName() {
    return this.displayName;
  }
  getTooltip() {
    return this.column.getColDef().headerTooltip;
  }
  addAdditionalAriaInstructions(e, t) {
    const s = this.gos.get("rowGroupPanelSuppressSort"), i = this.gos.get("functionsReadOnly");
    if (this.isAggregationZone() && !i) {
      const r = t(
        "ariaDropZoneColumnValueItemDescription",
        "Press ENTER to change the aggregation type"
      );
      e.push(r);
    }
    if (this.isGroupingZone() && this.column.isSortable() && !s) {
      const r = t("ariaDropZoneColumnGroupItemDescription", "Press ENTER to sort");
      e.push(r);
    }
    super.addAdditionalAriaInstructions(e, t);
  }
  isDraggable() {
    return this.isReadOnly();
  }
  isRemovable() {
    return this.isReadOnly();
  }
  isReadOnly() {
    return !this.isGroupingAndLocked() && !this.gos.get("functionsReadOnly");
  }
  getAriaDisplayName() {
    const e = this.getLocaleTextFunc(), { name: t, aggFuncName: s } = this.getColumnAndAggFuncName(), i = e("ariaDropZoneColumnComponentAggFuncSeparator", " of "), r = {
      asc: e("ariaDropZoneColumnComponentSortAscending", "ascending"),
      desc: e("ariaDropZoneColumnComponentSortDescending", "descending")
    }, o = this.column.getSort(), n = this.gos.get("rowGroupPanelSuppressSort");
    return [
      s && `${s}${i}`,
      t,
      this.isGroupingZone() && !n && o && `, ${r[o]}`
    ].filter((a) => !!a).join("");
  }
  getColumnAndAggFuncName() {
    const e = this.displayName;
    let t = "";
    if (this.isAggregationZone()) {
      const s = this.column.getAggFunc(), i = typeof s == "string" ? s : "agg";
      t = this.getLocaleTextFunc()(i, i);
    }
    return { name: e, aggFuncName: t };
  }
  setupSort() {
    if (!(!this.column.isSortable() || !this.isGroupingZone()) && !this.gos.get("rowGroupPanelSuppressSort")) {
      this.eSortIndicator.setupSort(this.column, !0);
      const e = (t) => {
        t.preventDefault(), this.beans.sortSvc.progressSortFromEvent(this.column, t);
      };
      this.addGuiEventListener("click", e), this.addGuiEventListener("keydown", (t) => {
        t.key === w.ENTER && this.isGroupingZone() && e(t);
      });
    }
  }
  getDefaultIconName() {
    return "hide";
  }
  createGetDragItem() {
    const { column: e } = this;
    return () => {
      const t = {};
      return t[e.getId()] = e.isVisible(), {
        columns: [e],
        visibleState: t
      };
    };
  }
  setupComponents() {
    super.setupComponents(), this.isAggregationZone() && !this.gos.get("functionsReadOnly") && this.addGuiEventListener("click", this.onShowAggFuncSelection.bind(this));
  }
  onKeyDown(e) {
    super.onKeyDown(e), e.key === w.ENTER && this.isAggregationZone() && !this.gos.get("functionsReadOnly") && (e.preventDefault(), this.onShowAggFuncSelection());
  }
  getDisplayValue() {
    const { name: e, aggFuncName: t } = this.getColumnAndAggFuncName();
    return this.isAggregationZone() ? `${t}(${e})` : e;
  }
  onShowAggFuncSelection() {
    if (this.popupShowing)
      return;
    this.popupShowing = !0;
    const { aggFuncSvc: e, popupSvc: t } = this.beans, s = new Oi({ cssIdentifier: "select-agg-func" }), i = e.getFuncNames(this.column), r = this.getGui(), o = s.getGui();
    s.setModel({
      getRow: function(u) {
        return i[u];
      },
      getRowCount: function() {
        return i.length;
      }
    }), this.createBean(s);
    const n = Be(
      /* html*/
      '<div class="ag-select-agg-func-popup"></div>'
    );
    n.style.top = "0px", n.style.left = "0px", n.appendChild(o), n.style.width = `${r.clientWidth}px`;
    const [a] = this.addManagedElementListeners(n, {
      focusout: (u) => {
        !n.contains(u.relatedTarget) && c && c.hideFunc();
      }
    }), l = (u) => {
      this.destroyBean(s), this.popupShowing = !1, (u == null ? void 0 : u.key) === "Escape" && r.focus(), a && a();
    }, d = this.getLocaleTextFunc(), c = t.addPopup({
      modal: !0,
      eChild: n,
      closeOnEsc: !0,
      closedCallback: l,
      ariaLabel: d("ariaLabelAggregationFunction", "Aggregation Function")
    });
    c && s.setComponentCreator(this.createAggSelect.bind(this, c.hideFunc)), s.addGuiEventListener("keydown", (u) => {
      if (u.key === w.ENTER || u.key === w.SPACE) {
        const p = s.getLastFocusedRow();
        if (p == null)
          return;
        const g = s.getComponentAt(p);
        g && g.selectItem();
      }
    }), t.positionPopupByComponent({
      type: "aggFuncSelect",
      eventSource: r,
      ePopup: n,
      keepWithinBounds: !0,
      column: this.column,
      position: "under"
    }), s.refresh();
    let h = i.findIndex((u) => u === this.column.getAggFunc());
    h === -1 && (h = 0), s.focusRow(h);
  }
  createAggSelect(e, t) {
    const s = () => {
      var a, l;
      e(), this.getGui().focus(), (l = (a = this.beans.valueColsSvc) == null ? void 0 : a.setColumnAggFunc) == null || l.call(a, this.column, t, "toolPanelDragAndDrop");
    }, i = this.getLocaleTextFunc(), r = t.toString(), o = i(r, r);
    return new ZL(s, o);
  }
  isGroupingAndLocked() {
    return this.isGroupingZone() && wr(this.column, this.beans);
  }
  isAggregationZone() {
    return this.dropZonePurpose === "aggregation";
  }
  isGroupingZone() {
    return this.dropZonePurpose === "rowGroup";
  }
  getDragSourceType() {
    return xt.ToolPanel;
  }
  destroy() {
    super.destroy(), this.column = null;
  }
}, ZL = class extends L {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-select-agg-func-item"/>'
    ), this.selectItem = e, this.getGui().innerText = t, this.addGuiEventListener("click", this.selectItem);
  }
}, Yl = class extends Qg {
  constructor(e, t) {
    super(e), this.dropZonePurpose = t, this.addElementClasses(this.getGui(), this.dropZonePurpose.toLowerCase());
  }
  init(e) {
    super.init(e), this.addManagedEventListeners({ newColumnsLoaded: this.refreshGui.bind(this) }), this.addManagedPropertyListeners(
      ["functionsReadOnly", "rowGroupPanelSuppressSort", "groupLockGroupColumns"],
      this.refreshGui.bind(this)
    );
  }
  getItems(e) {
    return e.columns ?? [];
  }
  isInterestedIn(e) {
    return e === xt.HeaderCell || e === xt.ToolPanel;
  }
  minimumAllowedNewInsertIndex() {
    const { gos: e, rowGroupColsSvc: t } = this.beans, s = e.get("groupLockGroupColumns"), i = (t == null ? void 0 : t.columns.length) ?? 0;
    return s === -1 ? i : Math.min(s, i);
  }
  showOrHideColumnOnExit(e) {
    return this.isRowGroupPanel() && _h(this.gos, !0) && !e.fromNudge;
  }
  handleDragEnterEnd(e) {
    if (this.showOrHideColumnOnExit(e)) {
      const i = e.dragSource.getDragItem().columns;
      this.setColumnsVisible(i, !1, "uiColumnDragged");
    }
  }
  handleDragLeaveEnd(e) {
    if (this.showOrHideColumnOnExit(e)) {
      const s = e.dragSource.getDragItem();
      this.setColumnsVisible(s.columns, !0, "uiColumnDragged");
    }
  }
  setColumnsVisible(e, t, s) {
    if (e) {
      const i = e.filter((r) => !r.getColDef().lockVisible);
      this.beans.colModel.setColsVisible(i, t, s);
    }
  }
  isRowGroupPanel() {
    return this.dropZonePurpose === "rowGroup";
  }
  createPillComponent(e, t, s, i) {
    return new XL(e, t, s, this.dropZonePurpose, i);
  }
}, ef = class extends Yl {
  constructor(e) {
    super(e, "pivot");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("pivotColumnsEmptyMessage", "Drag here to set column labels"), s = e("pivots", "Column Labels");
    super.init({
      icon: B("pivotPanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({
      newColumnsLoaded: this.refresh.bind(this),
      columnPivotChanged: this.refresh.bind(this),
      columnPivotModeChanged: this.checkVisibility.bind(this)
    }), this.refresh();
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaPivotDropZonePanelLabel", "Column Labels");
  }
  refresh() {
    this.checkVisibility(), this.refreshGui();
  }
  checkVisibility() {
    const e = this.beans.colModel, t = e.isPivotMode();
    if (this.horizontal)
      switch (this.gos.get("pivotPanelShow")) {
        case "always":
          this.setDisplayed(t);
          break;
        case "onlyWhenPivoting": {
          const s = e.isPivotActive();
          this.setDisplayed(t && s);
          break;
        }
        default:
          this.setDisplayed(!1);
          break;
      }
    else
      this.setDisplayed(t);
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowPivot() && (!e.isPivotActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.pivotColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "pivot" : "notAllowed";
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.pivotColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, tf = class extends Yl {
  constructor(e) {
    super(e, "rowGroup");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("rowGroupColumnsEmptyMessage", "Drag here to set row groups"), s = e("groups", "Row Groups");
    super.init({
      icon: B("rowGroupPanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({ columnRowGroupChanged: this.refreshGui.bind(this) });
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaRowGroupDropZonePanelLabel", "Row Groups");
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowRowGroup() && (!e.isRowGroupActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.rowGroupColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "group" : "notAllowed";
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.rowGroupColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, QL = class extends Yl {
  constructor(e) {
    super(e, "aggregation");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("valueColumnsEmptyMessage", "Drag here to aggregate"), s = e("values", "Values");
    super.init({
      icon: B("valuePanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({ columnValueChanged: this.refreshGui.bind(this) });
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaValuesDropZonePanelLabel", "Values");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "aggregate" : "notAllowed";
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowValue() && (!e.isValueActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.valueColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.valueColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, JL = class extends L {
  constructor() {
    super(...arguments), this.cbPivotMode = S;
  }
  createTemplate() {
    return (
      /* html */
      `<div class="ag-pivot-mode-panel">
                <ag-toggle-button data-ref="cbPivotMode" class="ag-pivot-mode-select"></ag-toggle-button>
            </div>`
    );
  }
  postConstruct() {
    this.setTemplate(this.createTemplate(), [ky]);
    const e = this.cbPivotMode, { colModel: t, ctrlsSvc: s, gos: i } = this.beans;
    e.setValue(t.isPivotMode());
    const r = this.getLocaleTextFunc();
    e.setLabel(r("pivotMode", "Pivot Mode"));
    const o = () => {
      const a = !!e.getValue();
      a !== t.isPivotMode() && (i.updateGridOptions({ options: { pivotMode: a }, source: "toolPanelUi" }), s.getHeaderRowContainerCtrls().forEach((l) => l.refresh()));
    }, n = () => {
      const a = t.isPivotMode();
      e.setValue(a);
    };
    this.addManagedListeners(e, { fieldValueChanged: o }), this.addManagedEventListeners({
      newColumnsLoaded: n,
      columnPivotModeChanged: n
    });
  }
}, ek = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colToolPanelFactory";
  }
  setPanelVisible(e, t, s) {
    return e ? e.setDisplayed(t) : t && (e = s()), e;
  }
  createRowGroupPanel(e, t) {
    return this.createPanel(e, t, new tf(!1));
  }
  createValuesPanel(e, t) {
    return this.createPanel(e, t, new QL(!1));
  }
  createPivotPanel(e, t) {
    return this.createPanel(e, t, new ef(!1));
  }
  createPivotModePanel(e, t, s) {
    return this.createPanel(e, t, new JL(), s);
  }
  createPanel(e, t, s, i) {
    return s = e.createBean(s), t.push(() => e.destroyBean(s)), i ? e.prependChild(s) : e.appendChild(s), s;
  }
}, tk = {
  moduleName: "ColumnsToolPanel",
  version: j,
  beans: [ek],
  userComponents: { agColumnsToolPanel: qL },
  icons: {
    // column tool panel tab
    columnsToolPanel: "columns",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // identifies the pivot drop zone
    pivotPanel: "pivot",
    // "Row groups" drop zone in column tool panel
    rowGroupPanel: "group",
    // columns tool panel Values drop zone
    valuePanel: "aggregation",
    // column tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // column tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate"
  },
  dependsOn: [
    te,
    ql,
    Ll,
    Li,
    ts,
    Cn
  ]
}, sk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartMenuItemMapper";
  }
  getChartItems(e) {
    var d, c;
    const t = this.beans, s = t.chartSvc, i = e === "pivotChart";
    if (!s)
      return null;
    const r = this.getLocaleTextFunc.bind(this), o = i ? new ik(t, s, r) : new rk(t, s, r), n = s.isEnterprise();
    let a = o.getMenuItem();
    if (a && a.subMenu && !n) {
      const h = (u) => {
        var p;
        return {
          ...u,
          subMenu: (p = u.subMenu) == null ? void 0 : p.filter((g) => !g._enterprise).map((g) => h(g))
        };
      };
      a = h(a);
    }
    const l = (c = (d = this.gos.get("chartToolPanelsDef")) == null ? void 0 : d.settingsPanel) == null ? void 0 : c.chartGroupsDef;
    return l && (a = this.filterAndOrderChartMenu(
      a,
      l,
      o.getConfigLookup()
    )), this.cleanInternals(a);
  }
  // Remove our internal _key and _enterprise properties so this does not leak out of the class on the menu items.
  cleanInternals(e) {
    if (!e)
      return e;
    const t = (s) => {
      var i;
      return s == null || delete s._key, s == null || delete s._enterprise, (i = s == null ? void 0 : s.subMenu) == null || i.forEach((r) => t(r)), s;
    };
    return t(e);
  }
  buildLookup(e) {
    const t = {}, s = (i) => {
      t[i._key] = i, i.subMenu && i.subMenu.forEach((r) => s(r));
    };
    return s(e), t;
  }
  /**
   * Make the MenuItem match the charts provided and their ordering on the ChartGroupsDef config object as provided by the user.
   */
  filterAndOrderChartMenu(e, t, s) {
    var o;
    const i = this.buildLookup(e), r = { ...e, subMenu: [] };
    return Object.entries(t).forEach(([n, a]) => {
      var c, h;
      const l = s[n];
      if (l === null)
        return;
      if (l == null) {
        R(173, { group: n });
        return;
      }
      const d = i[l._key];
      if (d)
        if (d.subMenu) {
          const u = a.map((p) => {
            const g = l[p];
            if (g == null) {
              R(174, { group: n, chartType: p });
              return;
            }
            return i[g];
          }).filter((p) => p !== void 0);
          u.length > 0 && (d.subMenu = u, (c = r.subMenu) == null || c.push(d));
        } else
          (h = r.subMenu) == null || h.push(d);
    }), ((o = r.subMenu) == null ? void 0 : o.length) == 0 ? null : r;
  }
}, ik = class {
  constructor(e, t, s) {
    this.beans = e, this.chartSvc = t, this.getLocaleTextFunc = s;
  }
  getMenuItem() {
    const e = this.getLocaleTextFunc(), t = (s, i, r, o, n = !1) => ({
      name: e(s, i),
      action: () => this.chartSvc.createPivotChart({ chartType: r }),
      _key: o,
      _enterprise: n
    });
    return {
      name: e("pivotChart", "Pivot Chart"),
      _key: "pivotChart",
      subMenu: [
        {
          _key: "pivotColumnChart",
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped&lrm;", "groupedColumn", "pivotGroupedColumn"),
            t("stackedColumn", "Stacked&lrm;", "stackedColumn", "pivotStackedColumn"),
            t(
              "normalizedColumn",
              "100% Stacked&lrm;",
              "normalizedColumn",
              "pivotNormalizedColumn"
            )
          ]
        },
        {
          _key: "pivotBarChart",
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped&lrm;", "groupedBar", "pivotGroupedBar"),
            t("stackedBar", "Stacked&lrm;", "stackedBar", "pivotStackedBar"),
            t("normalizedBar", "100% Stacked&lrm;", "normalizedBar", "pivotNormalizedBar")
          ]
        },
        {
          _key: "pivotPieChart",
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie&lrm;", "pie", "pivotPie"),
            t("donut", "Donut&lrm;", "donut", "pivotDonut")
          ]
        },
        {
          _key: "pivotLineChart",
          name: e("lineChart", "Line"),
          subMenu: [
            t("lineChart", "Line&lrm;", "line", "pivotLineChart"),
            t("stackedLine", "Stacked&lrm;", "stackedLine", "pivotStackedLine"),
            t("normalizedLine", "100% Stacked&lrm;", "normalizedLine", "pivotNormalizedLine")
          ]
        },
        {
          _key: "pivotAreaChart",
          name: e("areaChart", "Area"),
          subMenu: [
            t("areaChart", "Area&lrm;", "area", "pivotArea"),
            t("stackedArea", "Stacked&lrm;", "stackedArea", "pivotStackedArea"),
            t("normalizedArea", "100% Stacked&lrm;", "normalizedArea", "pivotNormalizedArea")
          ]
        },
        {
          _key: "pivotXYChart",
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter&lrm;", "scatter", "pivotScatter"),
            t("bubble", "Bubble&lrm;", "bubble", "pivotBubble")
          ]
        },
        {
          _key: "pivotStatisticalChart",
          _enterprise: !1,
          // histogram chart is available in both community and enterprise distributions
          name: e("statisticalChart", "Statistical"),
          subMenu: [t("histogramChart", "Histogram&lrm;", "histogram", "pivotHistogram", !1)]
        },
        {
          _key: "pivotHierarchicalChart",
          _enterprise: !0,
          name: e("hierarchicalChart", "Hierarchical"),
          subMenu: [
            t("treemapChart", "Treemap&lrm;", "treemap", "pivotTreemap", !0),
            t("sunburstChart", "Sunburst&lrm;", "sunburst", "pivotSunburst", !0)
          ]
        },
        {
          _key: "pivotCombinationChart",
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line&lrm;", "columnLineCombo", "pivotColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column&lrm;", "areaColumnCombo", "pivotAreaColumnCombo")
          ]
        }
      ],
      icon: B("chart", this.beans, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "pivotColumnChart",
        column: "pivotGroupedColumn",
        stackedColumn: "pivotStackedColumn",
        normalizedColumn: "pivotNormalizedColumn"
      },
      barGroup: {
        _key: "pivotBarChart",
        bar: "pivotGroupedBar",
        stackedBar: "pivotStackedBar",
        normalizedBar: "pivotNormalizedBar"
      },
      pieGroup: {
        _key: "pivotPieChart",
        pie: "pivotPie",
        donut: "pivotDonut",
        doughnut: "pivotDonut"
      },
      lineGroup: {
        _key: "pivotLineChart",
        line: "pivotLineChart",
        stackedLine: "pivotStackedLine",
        normalizedLine: "pivotNormalizedLine"
      },
      areaGroup: {
        _key: "pivotAreaChart",
        area: "pivotArea",
        stackedArea: "pivotStackedArea",
        normalizedArea: "pivotNormalizedArea"
      },
      scatterGroup: {
        _key: "pivotXYChart",
        bubble: "pivotBubble",
        scatter: "pivotScatter"
      },
      combinationGroup: {
        _key: "pivotCombinationChart",
        columnLineCombo: "pivotColumnLineCombo",
        areaColumnCombo: "pivotAreaColumnCombo",
        customCombo: null
        // Not currently supported
      },
      hierarchicalGroup: {
        _key: "pivotHierarchicalChart",
        treemap: "pivotTreemap",
        sunburst: "pivotSunburst"
      },
      statisticalGroup: {
        _key: "pivotStatisticalChart",
        histogram: "pivotHistogram",
        // Some statistical charts do not currently support pivot mode
        rangeBar: null,
        rangeArea: null,
        boxPlot: null
      },
      // Polar charts do not support pivot mode
      polarGroup: null,
      // Specialized charts do not currently support pivot mode
      specializedGroup: null
    };
  }
}, rk = class {
  constructor(e, t, s) {
    this.beans = e, this.chartSvc = t, this.getLocaleTextFunc = s;
  }
  getMenuItem() {
    const e = this.getLocaleTextFunc(), t = (s, i, r, o, n = !1) => ({
      name: e(s, i),
      action: () => this.chartSvc.createChartFromCurrentRange(r),
      _key: o,
      _enterprise: n
    });
    return {
      name: e("chartRange", "Chart Range"),
      _key: "chartRange",
      subMenu: [
        {
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped&lrm;", "groupedColumn", "rangeGroupedColumn"),
            t("stackedColumn", "Stacked&lrm;", "stackedColumn", "rangeStackedColumn"),
            t(
              "normalizedColumn",
              "100% Stacked&lrm;",
              "normalizedColumn",
              "rangeNormalizedColumn"
            )
          ],
          _key: "rangeColumnChart"
        },
        {
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped&lrm;", "groupedBar", "rangeGroupedBar"),
            t("stackedBar", "Stacked&lrm;", "stackedBar", "rangeStackedBar"),
            t("normalizedBar", "100% Stacked&lrm;", "normalizedBar", "rangeNormalizedBar")
          ],
          _key: "rangeBarChart"
        },
        {
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie&lrm;", "pie", "rangePie"),
            t("donut", "Donut&lrm;", "donut", "rangeDonut")
          ],
          _key: "rangePieChart"
        },
        {
          name: e("lineChart", "Line"),
          subMenu: [
            t("lineChart", "Line&lrm;", "line", "rangeLineChart"),
            t("stackedLine", "Stacked&lrm;", "stackedLine", "rangeStackedLine"),
            t("normalizedLine", "100% Stacked&lrm;", "normalizedLine", "rangeNormalizedLine")
          ],
          _key: "rangeLineChart"
        },
        {
          name: e("areaChart", "Area"),
          subMenu: [
            t("areaChart", "Area&lrm;", "area", "rangeArea"),
            t("stackedArea", "Stacked&lrm;", "stackedArea", "rangeStackedArea"),
            t("normalizedArea", "100% Stacked&lrm;", "normalizedArea", "rangeNormalizedArea")
          ],
          _key: "rangeAreaChart"
        },
        {
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter&lrm;", "scatter", "rangeScatter"),
            t("bubble", "Bubble&lrm;", "bubble", "rangeBubble")
          ],
          _key: "rangeXYChart"
        },
        {
          name: e("polarChart", "Polar"),
          subMenu: [
            t("radarLine", "Radar Line&lrm;", "radarLine", "rangeRadarLine"),
            t("radarArea", "Radar Area&lrm;", "radarArea", "rangeRadarArea"),
            t("nightingale", "Nightingale&lrm;", "nightingale", "rangeNightingale"),
            t("radialColumn", "Radial Column&lrm;", "radialColumn", "rangeRadialColumn"),
            t("radialBar", "Radial Bar&lrm;", "radialBar", "rangeRadialBar")
          ],
          _key: "rangePolarChart",
          _enterprise: !0
        },
        {
          name: e("statisticalChart", "Statistical"),
          subMenu: [
            t("boxPlot", "Box Plot&lrm;", "boxPlot", "rangeBoxPlot", !0),
            t("histogramChart", "Histogram&lrm;", "histogram", "rangeHistogram", !1),
            t("rangeBar", "Range Bar&lrm;", "rangeBar", "rangeRangeBar", !0),
            t("rangeArea", "Range Area&lrm;", "rangeArea", "rangeRangeArea", !0)
          ],
          _key: "rangeStatisticalChart",
          _enterprise: !1
          // histogram chart is available in both community and enterprise distributions
        },
        {
          name: e("hierarchicalChart", "Hierarchical"),
          subMenu: [
            t("treemap", "Treemap&lrm;", "treemap", "rangeTreemap"),
            t("sunburst", "Sunburst&lrm;", "sunburst", "rangeSunburst")
          ],
          _key: "rangeHierarchicalChart",
          _enterprise: !0
        },
        {
          name: e("specializedChart", "Specialized"),
          subMenu: [
            t("heatmap", "Heatmap&lrm;", "heatmap", "rangeHeatmap"),
            t("waterfall", "Waterfall&lrm;", "waterfall", "rangeWaterfall")
          ],
          _key: "rangeSpecializedChart",
          _enterprise: !0
        },
        {
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line&lrm;", "columnLineCombo", "rangeColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column&lrm;", "areaColumnCombo", "rangeAreaColumnCombo")
          ],
          _key: "rangeCombinationChart"
        }
      ],
      icon: B("chart", this.beans, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "rangeColumnChart",
        column: "rangeGroupedColumn",
        stackedColumn: "rangeStackedColumn",
        normalizedColumn: "rangeNormalizedColumn"
      },
      barGroup: {
        _key: "rangeBarChart",
        bar: "rangeGroupedBar",
        stackedBar: "rangeStackedBar",
        normalizedBar: "rangeNormalizedBar"
      },
      pieGroup: {
        _key: "rangePieChart",
        pie: "rangePie",
        donut: "rangeDonut",
        doughnut: "rangeDonut"
      },
      lineGroup: {
        _key: "rangeLineChart",
        line: "rangeLineChart",
        stackedLine: "rangeStackedLine",
        normalizedLine: "rangeNormalizedLine"
      },
      areaGroup: {
        _key: "rangeAreaChart",
        area: "rangeArea",
        stackedArea: "rangeStackedArea",
        normalizedArea: "rangeNormalizedArea"
      },
      scatterGroup: {
        _key: "rangeXYChart",
        bubble: "rangeBubble",
        scatter: "rangeScatter"
      },
      polarGroup: {
        _key: "rangePolarChart",
        radarLine: "rangeRadarLine",
        radarArea: "rangeRadarArea",
        nightingale: "rangeNightingale",
        radialColumn: "rangeRadialColumn",
        radialBar: "rangeRadialBar"
      },
      statisticalGroup: {
        _key: "rangeStatisticalChart",
        boxPlot: "rangeBoxPlot",
        histogram: "rangeHistogram",
        rangeBar: "rangeRangeBar",
        rangeArea: "rangeRangeArea"
      },
      hierarchicalGroup: {
        _key: "rangeHierarchicalChart",
        treemap: "rangeTreemap",
        sunburst: "rangeSunburst"
      },
      specializedGroup: {
        _key: "rangeSpecializedChart",
        heatmap: "rangeHeatmap",
        waterfall: "rangeWaterfall"
      },
      combinationGroup: {
        _key: "rangeCombinationChart",
        columnLineCombo: "rangeColumnLineCombo",
        areaColumnCombo: "rangeAreaColumnCombo",
        customCombo: null
        // Not currently supported
      }
    };
  }
}, ok = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colChooserFactory";
  }
  createColumnSelectPanel(e, t, s, i) {
    const r = e.createManagedBean(new Zg()), o = i ?? (t == null ? void 0 : t.getColDef().columnChooserParams) ?? {}, {
      contractColumnSelection: n,
      suppressColumnExpandAll: a,
      suppressColumnFilter: l,
      suppressColumnSelectAll: d,
      suppressSyncLayoutWithGrid: c,
      columnLayout: h
    } = o;
    return r.init(
      !!s,
      this.gos.addGridCommonParams({
        suppressColumnMove: !1,
        suppressValues: !1,
        suppressPivots: !1,
        suppressRowGroups: !1,
        suppressPivotMode: !1,
        contractColumnSelection: !!n,
        suppressColumnExpandAll: !!a,
        suppressColumnFilter: !!l,
        suppressColumnSelectAll: !!d,
        suppressSyncLayoutWithGrid: !!h || !!c,
        onStateUpdated: () => {
        }
      }),
      "columnMenu"
    ), h && r.setColumnLayout(h), r;
  }
  showColumnChooser({ column: e, chooserParams: t, eventSource: s }) {
    this.hideActiveColumnChooser();
    const i = this.createColumnSelectPanel(this, e, !0, t), r = this.getLocaleTextFunc(), o = this.beans, { visibleCols: n, focusSvc: a, menuUtils: l } = o, d = n.allCols.indexOf(e), c = e ? a.focusedHeader : null;
    this.activeColumnChooserDialog = this.createBean(
      new Er({
        title: r("chooseColumns", "Choose Columns"),
        component: i,
        width: 300,
        height: 300,
        resizable: !0,
        movable: !0,
        centered: !0,
        closable: !0,
        afterGuiAttached: () => {
          var h;
          (h = Pe(o, i.getGui())) == null || h.focus({
            preventScroll: !0
          }), this.dispatchVisibleChangedEvent(!0, e);
        },
        closedCallback: (h) => {
          const u = this.activeColumnChooser.getGui();
          this.destroyBean(this.activeColumnChooser), this.activeColumnChooser = void 0, this.activeColumnChooserDialog = void 0, this.dispatchVisibleChangedEvent(!1, e), e && l.restoreFocusOnClose(
            { column: e, headerPosition: c, columnIndex: d, eventSource: s },
            u,
            h,
            !0
          );
        },
        postProcessPopupParams: {
          type: "columnChooser",
          column: e,
          eventSource: s
        }
      })
    ), this.activeColumnChooser = i;
  }
  hideActiveColumnChooser() {
    this.destroyBean(this.activeColumnChooserDialog);
  }
  dispatchVisibleChangedEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: "columnChooser",
      column: t ?? null
    });
  }
}, Ls = "separator";
function sf(e, t) {
  if (e)
    for (let s = e.length - 2; s >= 0; s--) {
      const i = e[s] === t, r = e[s + 1] === t;
      i && r && e.splice(s + 1, 1);
    }
}
var nk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "menuItemMapper";
  }
  mapWithStockItems(e, t, s, i) {
    if (!e)
      return [];
    const r = [], o = this.getLocaleTextFunc(), { beans: n, gos: a } = this, {
      validation: l,
      pinnedCols: d,
      colAutosize: c,
      aggFuncSvc: h,
      rowGroupColsSvc: u,
      colNames: p,
      colModel: g,
      clipboardSvc: f,
      expansionSvc: m,
      focusSvc: C,
      csvCreator: v,
      excelCreator: b,
      menuSvc: y,
      colChooserFactory: F,
      sortSvc: D,
      chartMenuItemMapper: x,
      valueColsSvc: T
    } = n, I = (E, M, N, _) => {
      switch (l == null || l.validateMenuItem(E), E) {
        case "pinSubMenu":
          return d && M ? {
            name: o("pinColumn", "Pin Column"),
            icon: B("menuPin", n, null),
            subMenu: ["clearPinned", "pinLeft", "pinRight"]
          } : null;
        case "pinLeft":
          return d && M ? {
            name: o("pinLeft", "Pin Left"),
            action: () => d.setColsPinned([M], "left", _),
            checked: !!M && M.isPinnedLeft()
          } : null;
        case "pinRight":
          return d && M ? {
            name: o("pinRight", "Pin Right"),
            action: () => d.setColsPinned([M], "right", _),
            checked: !!M && M.isPinnedRight()
          } : null;
        case "clearPinned":
          return d && M ? {
            name: o("noPin", "No Pin"),
            action: () => d.setColsPinned([M], null, _),
            checked: !!M && !M.isPinned()
          } : null;
        case "valueAggSubMenu":
          return h && T && (M != null && M.isPrimary() || M != null && M.getColDef().pivotValueColumn) ? {
            name: o("valueAggregation", "Value Aggregation"),
            icon: B("menuValue", n, null),
            subMenu: ak(M, h, T, o),
            disabled: a.get("functionsReadOnly")
          } : null;
        case "autoSizeThis":
          return c ? {
            name: o("autosizeThisColumn", "Autosize This Column"),
            action: () => c.autoSizeColumn(M, _, a.get("skipHeaderOnAutoSize"))
          } : null;
        case "autoSizeAll":
          return c ? {
            name: o("autosizeAllColumns", "Autosize All Columns"),
            action: () => c.autoSizeAllColumns(_, a.get("skipHeaderOnAutoSize"))
          } : null;
        case "rowGroup":
          return u ? {
            name: o("groupBy", "Group by") + " " + Q(p.getDisplayNameForColumn(M, "header")),
            disabled: a.get("functionsReadOnly") || (M == null ? void 0 : M.isRowGroupActive()) || !(M != null && M.getColDef().enableRowGroup),
            action: () => u.addColumns([M], _),
            icon: B("menuAddRowGroup", n, null)
          } : null;
        case "rowUnGroup":
          if (u && a.isModuleRegistered("SharedRowGrouping")) {
            const H = M == null ? void 0 : M.getColDef().showRowGroup, W = a.get("groupLockGroupColumns");
            let K, se, Se;
            if (H === !0)
              K = o("ungroupAll", "Un-Group All"), se = a.get("functionsReadOnly") || W === -1 || W >= (u.columns.length ?? 0), Se = () => u.setColumns(u.columns.slice(0, W), _);
            else if (typeof H == "string") {
              const et = g.getColDefCol(H), _e = et != null ? Q(p.getDisplayNameForColumn(et, "header")) : H;
              K = o("ungroupBy", "Un-Group by") + " " + _e, se = a.get("functionsReadOnly") || wr(et, n), Se = () => {
                u.removeColumns([H], _);
              };
            } else
              K = o("ungroupBy", "Un-Group by") + " " + Q(p.getDisplayNameForColumn(M, "header")), se = a.get("functionsReadOnly") || !(M != null && M.isRowGroupActive()) || !(M != null && M.getColDef().enableRowGroup) || wr(M, n), Se = () => u.removeColumns([M], _);
            return {
              name: K,
              disabled: se,
              action: Se,
              icon: B("menuRemoveRowGroup", n, null)
            };
          } else
            return null;
        case "resetColumns":
          return {
            name: o("resetColumns", "Reset Columns"),
            action: () => ru(n, _)
          };
        case "expandAll":
          return m ? {
            name: o("expandAll", "Expand All Row Groups"),
            action: () => m.expandAll(!0)
          } : null;
        case "contractAll":
          return m ? {
            name: o("collapseAll", "Collapse All Row Groups"),
            action: () => m.expandAll(!1)
          } : null;
        case "copy":
          return f ? {
            name: o("copy", "Copy"),
            shortcut: o("ctrlC", "Ctrl+C"),
            icon: B("clipboardCopy", n, null),
            action: () => f.copyToClipboard()
          } : null;
        case "copyWithHeaders":
          return f ? {
            name: o("copyWithHeaders", "Copy with Headers"),
            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
            icon: B("clipboardCopy", n, null),
            action: () => f.copyToClipboard({ includeHeaders: !0 })
          } : null;
        case "copyWithGroupHeaders":
          return f ? {
            name: o("copyWithGroupHeaders", "Copy with Group Headers"),
            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
            icon: B("clipboardCopy", n, null),
            action: () => f.copyToClipboard({ includeHeaders: !0, includeGroupHeaders: !0 })
          } : null;
        case "cut":
          if (f) {
            const H = C.getFocusedCell(), W = H ? St(n, H) : null, K = W ? H == null ? void 0 : H.column.isCellEditable(W) : !1;
            return {
              name: o("cut", "Cut"),
              shortcut: o("ctrlX", "Ctrl+X"),
              icon: B("clipboardCut", n, null),
              disabled: !K || a.get("suppressCutToClipboard"),
              action: () => f.cutToClipboard(void 0, "contextMenu")
            };
          } else
            return null;
        case "paste":
          return f ? {
            name: o("paste", "Paste"),
            shortcut: o("ctrlV", "Ctrl+V"),
            disabled: !0,
            icon: B("clipboardPaste", n, null),
            action: () => f.pasteFromClipboard()
          } : null;
        case "export": {
          const H = [];
          return !a.get("suppressCsvExport") && v && H.push("csvExport"), !a.get("suppressExcelExport") && b && H.push("excelExport"), H.length ? {
            name: o("export", "Export"),
            subMenu: H,
            icon: B("save", n, null)
          } : null;
        }
        case "csvExport":
          return v ? {
            name: o("csvExport", "CSV Export"),
            icon: B("csvExport", n, null),
            action: () => v.exportDataAsCsv()
          } : null;
        case "excelExport":
          return b ? {
            name: o("excelExport", "Excel Export"),
            icon: B("excelExport", n, null),
            action: () => b.exportDataAsExcel()
          } : null;
        case "separator":
          return "separator";
        case "pivotChart":
        case "chartRange":
          return x.getChartItems(E);
        case "columnFilter":
          return y && M ? {
            name: o("columnFilter", "Column Filter"),
            icon: B("filter", n, null),
            action: () => y.showFilterMenu({
              column: M,
              buttonElement: N(),
              containerType: "columnFilter",
              positionBy: "button"
            })
          } : null;
        case "columnChooser":
          return F ? {
            name: o("columnChooser", "Choose Columns"),
            icon: B("columns", n, null),
            action: () => F.showColumnChooser({
              column: M,
              eventSource: N()
            })
          } : null;
        case "sortAscending":
          return D ? {
            name: o("sortAscending", "Sort Ascending"),
            icon: B("sortAscending", n, null),
            action: () => D.setSortForColumn(M, "asc", !1, _)
          } : null;
        case "sortDescending":
          return D ? {
            name: o("sortDescending", "Sort Descending"),
            icon: B("sortDescending", n, null),
            action: () => D.setSortForColumn(M, "desc", !1, _)
          } : null;
        case "sortUnSort":
          return D ? {
            name: o("sortUnSort", "Clear Sort"),
            icon: B("sortUnSort", n, null),
            action: () => D.setSortForColumn(M, null, !1, _)
          } : null;
        default:
          return R(176, { key: E }), null;
      }
    };
    return e.forEach((E) => {
      let M;
      if (typeof E == "string" ? M = I(E, t, s, i) : M = { ...E }, !M)
        return;
      const N = M, { subMenu: _ } = N;
      _ && _ instanceof Array && (N.subMenu = this.mapWithStockItems(
        _,
        t,
        s,
        i
      )), M != null && r.push(M);
    }), sf(r, Ls), r;
  }
};
function ak(e, t, s, i) {
  let r;
  if (e.isPrimary())
    r = e;
  else {
    const n = e.getColDef().pivotValueColumn;
    r = A(n) ? n : void 0;
  }
  const o = [];
  if (r) {
    const n = r.isValueActive(), a = t.getFuncNames(r);
    o.push({
      name: i("noAggregation", "None"),
      action: () => {
        s.removeColumns([r], "contextMenu"), s.setColumnAggFunc(r, void 0, "contextMenu");
      },
      checked: !n
    }), a.forEach((l) => {
      o.push({
        name: i(l, t.getDefaultFuncLabel(l)),
        action: () => {
          s.setColumnAggFunc(r, l, "contextMenu"), s.addColumns([r], "contextMenu");
        },
        checked: n && r.getAggFunc() === l
      });
    });
  }
  return o;
}
var lk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "colMenuFactory";
  }
  createMenu(e, t, s, i) {
    const r = e.createManagedBean(
      new Mr(0, {
        column: s ?? null,
        node: null,
        value: null
      })
    ), o = this.beans.menuItemMapper.mapWithStockItems(
      t,
      s ?? null,
      i,
      "columnMenu"
    );
    return r.addMenuItems(o), r;
  }
  getMenuItems(e = null, t = null) {
    var o;
    const s = this.getDefaultMenuOptions(e);
    let i;
    const r = (o = (e == null ? void 0 : e.getColDef()) ?? (t == null ? void 0 : t.getColGroupDef())) == null ? void 0 : o.mainMenuItems;
    if (Array.isArray(r))
      i = r;
    else if (typeof r == "function")
      i = r(
        this.gos.addGridCommonParams({
          column: e,
          columnGroup: t,
          defaultItems: s
        })
      );
    else {
      const n = this.gos.getCallback("getMainMenuItems");
      n ? i = n({
        column: e,
        columnGroup: t,
        defaultItems: s
      }) : i = s;
    }
    return sf(i, Ls), i;
  }
  getDefaultMenuOptions(e) {
    const t = [], { beans: s, gos: i } = this, {
      colChooserFactory: r,
      rowGroupColsSvc: o,
      colModel: n,
      expansionSvc: a,
      sortSvc: l,
      menuSvc: d,
      pinnedCols: c,
      aggFuncSvc: h,
      colAutosize: u
    } = s, p = we(i), g = () => {
      !p && r && t.push("columnChooser"), t.push("resetColumns");
    };
    if (!e)
      return g(), t;
    const { colDef: f } = e, m = c && !f.lockPinned, C = (o == null ? void 0 : o.columns.length) ?? 0, v = C > 0, b = e.isPrimary(), y = h && // if primary, then only allow aggValue if grouping and it's a value columns
    b && v && e.isAllowValue() || // secondary columns can always have aggValue, as it means it's a pivot value column
    !b;
    if (l && !p && e.isSortable()) {
      const F = e.getSort();
      F !== "asc" && t.push("sortAscending"), F !== "desc" && t.push("sortDescending"), F && t.push("sortUnSort"), t.push(Ls);
    }
    if (d != null && d.isFilterMenuItemEnabled(e) && (t.push("columnFilter"), t.push(Ls)), m && t.push("pinSubMenu"), y && t.push("valueAggSubMenu"), (m || y) && t.push(Ls), u && (t.push("autoSizeThis"), t.push("autoSizeAll"), t.push(Ls)), o && i.isModuleRegistered("SharedRowGrouping")) {
      const F = t.length;
      f.showRowGroup ? t.push("rowUnGroup") : e.isAllowRowGroup() && b && (e.isRowGroupActive() ? wr(e, s) || t.push("rowUnGroup") : t.push("rowGroup")), t.length > F && t.push(Ls);
    }
    return g(), a && J(i) && (i.get("treeData") || C > (n.isPivotMode() ? 1 : 0)) && (t.push("expandAll"), t.push("contractAll")), t;
  }
}, dk = "ag-menu", Tc = "ag-context-menu-open", ck = "ag-context-menu-loading-icon", hk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "contextMenuSvc", this.destroyLoadingSpinner = null, this.lastPromise = 0;
  }
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  getMenuItems(e, t, s, i) {
    const r = [], { clipboardSvc: o, chartSvc: n, csvCreator: a, excelCreator: l, colModel: d, rangeSvc: c, gos: h } = this.beans;
    if (A(e) && o && t && (h.get("suppressCutToClipboard") || r.push("cut"), r.push("copy", "copyWithHeaders", "copyWithGroupHeaders", "paste", "separator")), h.get("enableCharts") && n && (d.isPivotMode() && r.push("pivotChart"), c && !c.isEmpty() && r.push("chartRange")), A(e)) {
      const f = h.get("suppressExcelExport") || !l, m = h.get("suppressCsvExport") || !a;
      !fs() && (!f || !m) && r.push("export");
    }
    const u = r.length ? r : void 0, p = t == null ? void 0 : t.getColDef().contextMenuItems;
    if (Array.isArray(p))
      return p;
    if (typeof p == "function")
      return p(
        h.addGridCommonParams({
          column: t,
          node: e,
          value: s,
          defaultItems: u,
          event: i
        })
      );
    const g = h.getCallback("getContextMenuItems");
    return g ? g({ column: t, node: e, value: s, defaultItems: u, event: i }) : r;
  }
  getContextMenuPosition(e, t) {
    const s = this.getRowCtrl(e), i = this.getCellGui(s, t);
    if (!i)
      return s ? { x: 0, y: s.getRowYPosition() } : { x: 0, y: 0 };
    const r = i.getBoundingClientRect();
    return {
      x: r.x + r.width / 2,
      y: r.y + r.height / 2
    };
  }
  showContextMenu(e) {
    const t = e.rowNode, s = e.column;
    let { anchorToElement: i, value: r } = e;
    t && s && r == null && (r = this.beans.valueSvc.getValueForDisplay(s, t)), i == null && (i = this.getContextMenuAnchorElement(t, s)), this.onContextMenu(
      e.mouseEvent ?? null,
      e.touchEvent ?? null,
      t ?? null,
      s ?? null,
      r,
      i
    );
  }
  handleContextMenuMouseEvent(e, t, s, i) {
    const r = (s == null ? void 0 : s.rowNode) ?? null, o = (i == null ? void 0 : i.column) ?? null;
    let n = null;
    const { valueSvc: a, ctrlsSvc: l } = this.beans;
    if (o) {
      const h = e || t;
      i.dispatchCellContextMenuEvent(h ?? null), n = a.getValue(o, r);
    }
    const d = l.getGridBodyCtrl(), c = i ? i.eGui : d.eGridBody;
    this.showContextMenu({
      mouseEvent: e,
      touchEvent: t,
      rowNode: r,
      column: o,
      value: n,
      anchorToElement: c
    });
  }
  onContextMenu(e, t, s, i, r, o) {
    this.beans.menuUtils.onContextMenu(
      e,
      t,
      (n) => this.showMenu(s, i, r, n, o)
    );
  }
  showMenu(e, t, s, i, r) {
    const o = this.getMenuItems(e, t, s, i);
    if (hv(o)) {
      const n = this.lastPromise + 1;
      return this.lastPromise = n, this.destroyLoadingSpinner || this.createLoadingIcon(i), o.then((a) => {
        var d;
        if (this.lastPromise !== n)
          return;
        // check if there are actual menu items to be displayed
        a && a.length && // check if the element that triggered the context menu was removed from the DOM
        ke(i.target) && // overlay was displayed
        !((d = this.beans.overlays) != null && d.isExclusive()) && this.createContextMenu({ menuItems: a, node: e, column: t, value: s, mouseEvent: i, anchorToElement: r }), this.destroyLoadingSpinner && this.destroyLoadingSpinner();
      }), !0;
    }
    return o === void 0 || !(o != null && o.length) ? !1 : (this.createContextMenu({ menuItems: o, node: e, column: t, value: s, mouseEvent: i, anchorToElement: r }), !0);
  }
  createLoadingIcon(e) {
    var l;
    const { beans: t } = this, s = this.getLocaleTextFunc(), i = B("loadingMenuItems", t), r = document.createElement("div");
    r.classList.add(ck), r.appendChild(i);
    const o = xi(t), n = Yo(t);
    if (!n) {
      R(54);
      return;
    }
    n.appendChild(r), (l = t.ariaAnnounce) == null || l.announceValue(
      s("ariaLabelLoadingContextMenu", "Loading Context Menu"),
      "contextmenu"
    ), t.environment.applyThemeClasses(r), Ca(r, e, t);
    const a = (d) => {
      Ca(r, d, t);
    };
    o.addEventListener("mousemove", a), this.destroyLoadingSpinner = () => {
      o.removeEventListener("mousemove", a), n.removeChild(r), this.destroyLoadingSpinner = null;
    };
  }
  createContextMenu(e) {
    const { menuItems: t, node: s, column: i, value: r, mouseEvent: o, anchorToElement: n } = e, { ctrlsSvc: a, focusSvc: l, popupSvc: d } = this.beans, c = a.getGridBodyCtrl().eGridBody, h = new uk(t, i, s, r);
    this.createBean(h);
    const u = h.getGui();
    i || l.clearFocusedCell();
    const p = {
      column: i,
      rowNode: s,
      type: "contextMenu",
      mouseEvent: o,
      ePopup: u,
      // move one pixel away so that accidentally double clicking
      // won't show the browser's contextmenu
      nudgeY: 1
    }, g = this.getLocaleTextFunc(), f = d.addPopup({
      modal: !0,
      eChild: u,
      closeOnEsc: !0,
      closedCallback: (C) => {
        c.classList.remove(Tc), this.destroyBean(h), this.dispatchVisibleChangedEvent(!1, C === void 0 ? "api" : "ui");
      },
      click: o,
      positionCallback: () => {
        const C = this.gos.get("enableRtl");
        d.positionPopupUnderMouseEvent({
          ...p,
          nudgeX: C ? (u.offsetWidth + 1) * -1 : 1
        });
      },
      // so when browser is scrolled down, or grid is scrolled, context menu stays with cell
      anchorToElement: n,
      ariaLabel: g("ariaLabelContextMenu", "Context Menu")
    });
    f && (c.classList.add(Tc), h.afterGuiAttached({ container: "contextMenu", hidePopup: f.hideFunc })), this.activeMenu && this.hideActiveMenu(), this.activeMenu = h, h.addEventListener("destroyed", () => {
      this.activeMenu === h && (this.activeMenu = null);
    }), f && h.addEventListener(
      "closeMenu",
      (C) => f.hideFunc({
        mouseEvent: C.mouseEvent ?? void 0,
        keyboardEvent: C.keyboardEvent ?? void 0,
        forceHide: !0
      })
    );
    const m = o && o instanceof MouseEvent && o.type === "mousedown";
    this.dispatchVisibleChangedEvent(!0, m ? "api" : "ui");
  }
  dispatchVisibleChangedEvent(e, t = "ui") {
    this.eventSvc.dispatchEvent({
      type: "contextMenuVisibleChanged",
      visible: e,
      source: t
    });
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: s } = e || {};
    if (t != null)
      return this.beans.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: s }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const s = e.getCellCtrl(t);
    return (s == null ? void 0 : s.eGui) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const s = this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody, i = this.getRowCtrl(e);
    if (!i)
      return s;
    const r = this.getCellGui(i, t);
    return r || (i.isFullWidth() ? i.getFullWidthElement() : s);
  }
  destroy() {
    var e;
    (e = this.destroyLoadingSpinner) == null || e.call(this), super.destroy();
  }
}, uk = class extends L {
  constructor(e, t, s, i) {
    super(
      /* html */
      `<div class="${dk}" role="presentation"></div>`
    ), this.menuItems = e, this.column = t, this.node = s, this.value = i, this.menuList = null, this.focusedCell = null;
  }
  postConstruct() {
    const e = this.createManagedBean(
      new Mr(0, {
        column: this.column,
        node: this.node,
        value: this.value
      })
    ), t = this.beans.menuItemMapper.mapWithStockItems(
      this.menuItems,
      null,
      () => this.getGui(),
      "contextMenu"
    );
    e.addMenuItems(t), this.appendChild(e), this.menuList = e, e.addEventListener("closeMenu", (s) => this.dispatchLocalEvent(s));
  }
  afterGuiAttached(e) {
    e.hidePopup && this.addDestroyFunc(e.hidePopup), this.focusedCell = this.beans.focusSvc.getFocusedCell();
    const t = this.menuList;
    t && ve(t.getGui());
  }
  restoreFocusedCell() {
    const { beans: e, focusedCell: t } = this, s = e.focusSvc, i = s.getFocusedCell();
    if (i && t && Ti(i, t)) {
      const { rowIndex: r, rowPinned: o, column: n } = t;
      ys(e) && s.setFocusedCell({
        rowIndex: r,
        column: n,
        rowPinned: o,
        forceBrowserFocus: !0,
        preventScrollOnBrowserFocus: !tn()
      });
    }
  }
  destroy() {
    this.restoreFocusedCell(), super.destroy();
  }
};
function pk(e) {
  return (
    /* html */
    `<div class="ag-tabs ${e}">
        <div data-ref="eHeader"></div>
        <div data-ref="eBody" role="presentation" class="ag-tabs-body ${e ? `${e}-body` : ""}"></div>
    </div>`
  );
}
var rf = class extends Nt {
  constructor(e) {
    super(pk(e.cssClass)), this.eHeader = S, this.eBody = S, this.items = [], this.tabbedItemScrollMap = /* @__PURE__ */ new Map(), this.params = e;
  }
  postConstruct() {
    this.setupHeader(), this.params.items && this.params.items.forEach((e) => this.addItem(e)), this.initialiseTabGuard({
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      focusInnerElement: this.focusInnerElement.bind(this),
      focusTrapActive: !0
    }), this.addDestroyFunc(() => {
      var e, t, s;
      return (s = (t = (e = this.activeItem) == null ? void 0 : e.tabbedItem) == null ? void 0 : t.afterDetachedCallback) == null ? void 0 : s.call(t);
    });
  }
  setupHeader() {
    const { enableCloseButton: e, cssClass: t } = this.params, s = (i, r) => {
      i.classList.add(`ag-tabs-${r}`), t && i.classList.add(`${t}-${r}`);
    };
    e ? (this.setupCloseButton(s), this.eTabHeader = Z(this.beans).createElement("div"), s(this.eHeader, "header-wrapper"), re(this.eHeader, "presentation"), this.eHeader.appendChild(this.eTabHeader)) : this.eTabHeader = this.eHeader, re(this.eTabHeader, "tablist"), s(this.eTabHeader, "header");
  }
  setupCloseButton(e) {
    const t = Z(this.beans), s = t.createElement("button");
    e(s, "close-button");
    const i = B("close", this.beans);
    oe(s, this.params.closeButtonAriaLabel), s.appendChild(i), this.addManagedElementListeners(s, { click: () => {
      var o, n;
      return (n = (o = this.params).onCloseClicked) == null ? void 0 : n.call(o);
    } });
    const r = t.createElement("div");
    e(r, "close-button-wrapper"), re(r, "presentation"), r.appendChild(s), this.eHeader.appendChild(r), this.eCloseButton = s;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case w.RIGHT:
      case w.LEFT: {
        if (!this.eTabHeader.contains(q(this.beans)))
          return;
        const t = e.key === w.RIGHT, s = this.gos.get("enableRtl"), i = this.items.indexOf(this.activeItem), r = t !== s ? Math.min(i + 1, this.items.length - 1) : Math.max(i - 1, 0);
        if (i === r)
          return;
        e.preventDefault();
        const o = this.items[r];
        this.showItemWrapper(o), o.eHeaderButton.focus();
        break;
      }
      case w.UP:
      case w.DOWN:
        e.stopPropagation();
        break;
    }
  }
  onTabKeyDown(e) {
    var u, p, g, f;
    if (e.defaultPrevented)
      return;
    const { beans: t, eHeader: s, eBody: i, activeItem: r, params: o } = this, { suppressTrapFocus: n, enableCloseButton: a } = o, l = q(t), d = e.target, c = e.shiftKey;
    if (s.contains(l)) {
      e.preventDefault(), a && c && !((u = this.eCloseButton) != null && u.contains(l)) ? (p = this.eCloseButton) == null || p.focus() : n && c ? (g = Wa(Z(t).body, d)) == null || g.focus() : this.focusBody(e.shiftKey);
      return;
    }
    let h = null;
    if (Bg(i, d) && (c && (h = Wa(i, d)), !h && !n && (h = r.eHeaderButton)), !h && i.contains(l) && (h = Pe(t, i, !1, c), !h)) {
      n && !c ? this.forceFocusOutOfContainer(c) : a && !c ? (e.preventDefault(), (f = this.eCloseButton) == null || f.focus()) : (e.preventDefault(), this.focusHeader());
      return;
    }
    h && (e.preventDefault(), h.focus());
  }
  focusInnerElement(e) {
    e ? this.focusBody(!0) : this.focusHeader();
  }
  focusHeader(e) {
    this.activeItem.eHeaderButton.focus({ preventScroll: e });
  }
  focusBody(e) {
    ve(this.eBody, e);
  }
  setAfterAttachedParams(e) {
    this.afterAttachedParams = e;
  }
  showFirstItem() {
    this.items.length > 0 && this.showItemWrapper(this.items[0]);
  }
  addItem(e) {
    const t = document.createElement("span");
    re(t, "tab"), t.setAttribute("tabindex", "-1"), t.appendChild(e.title), t.classList.add("ag-tab"), this.eTabHeader.appendChild(t), oe(t, e.titleLabel);
    const s = {
      tabbedItem: e,
      eHeaderButton: t
    };
    this.items.push(s), t.addEventListener("click", this.showItemWrapper.bind(this, s));
  }
  showItem(e) {
    const t = this.items.find((s) => s.tabbedItem === e);
    t && this.showItemWrapper(t);
  }
  showItemWrapper(e) {
    var i, r, o, n, a, l;
    const { tabbedItem: t, eHeaderButton: s } = e;
    if ((r = (i = this.params).onItemClicked) == null || r.call(i, { item: t }), this.activeItem === e) {
      (n = (o = this.params).onActiveItemClicked) == null || n.call(o);
      return;
    }
    this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), X(this.eBody), t.bodyPromise.then((d) => {
      this.eBody.appendChild(d);
      const c = !tn();
      if (this.params.suppressFocusBodyOnOpen || ve(this.eBody, !1, c), t.afterAttachedCallback && t.afterAttachedCallback(this.afterAttachedParams), this.params.keepScrollPosition) {
        const h = t.getScrollableContainer && t.getScrollableContainer() || d;
        [this.lastScrollListener] = this.addManagedElementListeners(h, {
          scroll: () => {
            this.tabbedItemScrollMap.set(t.name, h.scrollTop);
          }
        });
        const u = this.tabbedItemScrollMap.get(t.name);
        u !== void 0 && setTimeout(() => {
          h.scrollTop = u;
        }, 0);
      }
    }), this.activeItem && (this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), (l = (a = this.activeItem.tabbedItem).afterDetachedCallback) == null || l.call(a)), s.classList.add("ag-tab-selected"), this.activeItem = e;
  }
}, ds = "filterMenuTab", cs = "generalMenuTab", ks = "columnsMenuTab", oo = [cs, ds, ks], gk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "enterpriseMenuFactory";
  }
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  showMenuAfterMouseEvent(e, t, s, i) {
    const { column: r, columnGroup: o } = this.splitColumnOrGroup(e), n = i ? "filterMenuTab" : void 0;
    this.showMenu(
      r,
      o,
      (a) => {
        var d;
        const l = a.getGui();
        this.beans.popupSvc.positionPopupUnderMouseEvent({
          type: s,
          column: r,
          mouseEvent: t,
          ePopup: l
        }), n && ((d = a.showTab) == null || d.call(a, n)), this.dispatchVisibleChangedEvent(!0, !1, r, o, n);
      },
      s,
      n,
      void 0,
      t.target
    );
  }
  splitColumnOrGroup(e) {
    const t = e && Bt(e);
    return { column: t ? e : void 0, columnGroup: t ? void 0 : e };
  }
  showMenuAfterButtonClick(e, t, s, i) {
    let r = -1, o = "left";
    this.gos.get("enableRtl") && (r = 1, o = "right");
    const n = i ? "filterMenuTab" : void 0, a = n ? [n] : void 0, l = we(this.gos), d = (l ? 9 : 4) * r, c = l ? -23 : 4, { column: h, columnGroup: u } = this.splitColumnOrGroup(e);
    this.showMenu(
      h,
      u,
      (p) => {
        var f;
        const g = p.getGui();
        this.beans.popupSvc.positionPopupByComponent({
          type: s,
          column: h,
          eventSource: t,
          ePopup: g,
          alignSide: o,
          nudgeX: d,
          nudgeY: c,
          position: "under",
          keepWithinBounds: !0
        }), n && ((f = p.showTab) == null || f.call(p, n)), this.dispatchVisibleChangedEvent(!0, !1, h, u, n);
      },
      s,
      n,
      a,
      t
    );
  }
  showMenu(e, t, s, i, r, o, n) {
    var m;
    const a = this.getMenuParams(e, t, o, n);
    if (!a)
      return;
    const { menu: l, eMenuGui: d, anchorToElement: c, restoreFocusParams: h } = a, u = [], { menuUtils: p, popupSvc: g } = this.beans;
    u.push((C) => {
      const v = l.getGui();
      this.destroyBean(l), e && (Eo(e, !1, "contextMenu"), p.restoreFocusOnClose(h, v, C));
    });
    const f = this.getLocaleTextFunc();
    if (g.addPopup({
      modal: !0,
      eChild: d,
      closeOnEsc: !0,
      closedCallback: (C) => {
        u.forEach((v) => v(C)), this.dispatchVisibleChangedEvent(!1, !1, e, t, r);
      },
      afterGuiAttached: (C) => l.afterGuiAttached(Object.assign({}, { container: i }, C)),
      // if defaultTab is not present, positionCallback will be called
      // after `showTabBasedOnPreviousSelection` is called.
      positionCallback: r ? () => s(l) : void 0,
      ariaLabel: f("ariaLabelColumnMenu", "Column Menu")
    }), r || ((m = l.showTabBasedOnPreviousSelection) == null || m.call(l), s(l)), $h(this.gos)) {
      const C = g.setPopupPositionRelatedToElement(d, c);
      C && e && this.addStopAnchoring(C, e, u);
    }
    l.addEventListener("tabSelected", (C) => {
      this.dispatchVisibleChangedEvent(!1, !0, e), this.lastSelectedTab = C.key, this.dispatchVisibleChangedEvent(!0, !0, e);
    }), e && Eo(e, !0, "contextMenu"), this.activeMenu = l, l.addEventListener("destroyed", () => {
      this.activeMenu === l && (this.activeMenu = null);
    });
  }
  addStopAnchoring(e, t, s) {
    e.then((i) => {
      t.addEventListener("leftChanged", i), t.addEventListener("visibleChanged", i), s.push(() => {
        t.removeEventListener("leftChanged", i), t.removeEventListener("visibleChanged", i);
      });
    });
  }
  getMenuParams(e, t, s, i) {
    const { focusSvc: r, visibleCols: o, ctrlsSvc: n } = this.beans, a = {
      column: e,
      headerPosition: r.focusedHeader,
      columnIndex: o.allCols.indexOf(e),
      eventSource: i
    }, l = this.createMenu(e, t, a, s, i);
    return l ? {
      menu: l,
      eMenuGui: l.getGui(),
      anchorToElement: i || n.getGridBodyCtrl().eGridBody,
      restoreFocusParams: a
    } : void 0;
  }
  createMenu(e, t, s, i, r) {
    if (we(this.gos))
      return this.createBean(
        new fk(e, s, this.lastSelectedTab, i, r)
      );
    {
      const o = this.beans.colMenuFactory.getMenuItems(e, t);
      return o.length ? this.createBean(new mk(o, e, s, r)) : void 0;
    }
  }
  dispatchVisibleChangedEvent(e, t, s, i, r) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: t,
      key: this.lastSelectedTab ?? r ?? (we(this.gos) ? cs : "columnMenu"),
      column: s ?? null,
      columnGroup: i ?? null
    });
  }
  isMenuEnabled(e) {
    var r;
    if (!we(this.gos))
      return !0;
    const t = !((r = this.beans.filterManager) != null && r.isFilterAllowed(e)), s = e.getColDef().menuTabs ?? oo;
    return (t && s.includes(ds) ? s.length - 1 : s.length) > 0;
  }
  showMenuAfterContextMenuEvent(e, t, s) {
    this.beans.menuUtils.onContextMenu(t, s, (i) => (this.showMenuAfterMouseEvent(e, i, "columnMenu"), !0));
  }
}, fk = class extends P {
  constructor(e, t, s, i, r) {
    super(), this.column = e, this.restoreFocusParams = t, this.initialSelection = s, this.restrictTo = i, this.sourceElement = r, this.tabFactories = {}, this.includeChecks = {};
    const { tabFactories: o, includeChecks: n } = this;
    o[cs] = this.createMainPanel.bind(this), o[ds] = this.createFilterPanel.bind(this), o[ks] = this.createColumnsPanel.bind(this), n[cs] = () => !0, n[ds] = () => {
      var a;
      return e ? !!((a = this.beans.filterManager) != null && a.isFilterAllowed(e)) : !1;
    }, n[ks] = () => !0;
  }
  postConstruct() {
    var s;
    const e = this.getTabsToCreate().map((i) => this.createTab(i)), t = new rf({
      items: e,
      cssClass: "ag-menu",
      onActiveItemClicked: this.onHidePopup.bind(this),
      onItemClicked: this.onTabItemClicked.bind(this)
    });
    this.tabbedLayout = this.createBean(t), (s = this.mainMenuList) == null || s.setParentComponent(t), this.addDestroyFunc(() => this.destroyBean(t));
  }
  getTabsToCreate() {
    var e;
    return this.restrictTo ? this.restrictTo : (((e = this.column) == null ? void 0 : e.getColDef().menuTabs) ?? oo).filter(
      (t) => this.isValidMenuTabItem(t) && this.isNotSuppressed(t)
    );
  }
  isValidMenuTabItem(e) {
    let t = !0, s = oo;
    return this.restrictTo != null && (t = this.restrictTo.indexOf(e) > -1, s = this.restrictTo), t = t && oo.indexOf(e) > -1, t || R(175, { menuTabName: e, itemsToConsider: s }), t;
  }
  isNotSuppressed(e) {
    return this.includeChecks[e]();
  }
  createTab(e) {
    return this.tabFactories[e]();
  }
  showTabBasedOnPreviousSelection() {
    this.showTab(this.initialSelection);
  }
  showTab(e) {
    const { tabItemColumns: t, tabbedLayout: s, tabItemFilter: i, tabItemGeneral: r } = this;
    t && e === ks ? s.showItem(t) : i && e === ds ? s.showItem(i) : r && e === cs ? s.showItem(r) : s.showFirstItem();
  }
  onTabItemClicked(e) {
    let t = null;
    switch (e.item) {
      case this.tabItemColumns:
        t = ks;
        break;
      case this.tabItemFilter:
        t = ds;
        break;
      case this.tabItemGeneral:
        t = cs;
        break;
    }
    t && this.activateTab(t);
  }
  activateTab(e) {
    const t = {
      type: "tabSelected",
      key: e
    };
    this.dispatchLocalEvent(t);
  }
  createMainPanel() {
    const { beans: e, column: t } = this, s = e.colMenuFactory, i = s.createMenu(
      this,
      s.getMenuItems(t),
      this.column,
      () => this.sourceElement ?? this.getGui()
    );
    this.mainMenuList = i, i.addEventListener("closeMenu", this.onHidePopup.bind(this));
    const r = {
      title: B("legacyMenu", e, t),
      titleLabel: cs.replace("MenuTab", ""),
      bodyPromise: U.resolve(i.getGui()),
      name: cs
    };
    return this.tabItemGeneral = r, r;
  }
  onHidePopup(e) {
    this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(
      this.hidePopupFunc,
      this.restoreFocusParams,
      e
    );
  }
  createFilterPanel() {
    const e = this.column ? this.createBean(new sn(this.column, "COLUMN_MENU")) : null;
    this.filterComp = e, e != null && e.hasFilter() || z(119);
    const t = (i) => e == null ? void 0 : e.afterGuiAttached(i), s = () => e == null ? void 0 : e.afterGuiDetached();
    return this.tabItemFilter = {
      title: B("filterTab", this.beans, this.column),
      titleLabel: ds.replace("MenuTab", ""),
      bodyPromise: U.resolve(e == null ? void 0 : e.getGui()),
      afterAttachedCallback: t,
      afterDetachedCallback: s,
      name: ds
    }, this.tabItemFilter;
  }
  createColumnsPanel() {
    const e = document.createElement("div");
    e.classList.add("ag-menu-column-select-wrapper");
    const { beans: t, column: s } = this, r = t.colChooserFactory.createColumnSelectPanel(
      this,
      s
    ).getGui();
    r.classList.add("ag-menu-column-select"), e.appendChild(r);
    const o = {
      title: B("columns", t, s),
      //createColumnsIcon(),
      titleLabel: ks.replace("MenuTab", ""),
      bodyPromise: U.resolve(e),
      name: ks
    };
    return this.tabItemColumns = o, o;
  }
  afterGuiAttached(e) {
    const { container: t, hidePopup: s } = e;
    this.tabbedLayout.setAfterAttachedParams({ container: t, hidePopup: s }), s && (this.hidePopupFunc = s, this.addDestroyFunc(s));
  }
  getGui() {
    return this.tabbedLayout.getGui();
  }
  destroy() {
    super.destroy(), this.destroyBean(this.filterComp);
  }
}, mk = class extends L {
  constructor(e, t, s, i) {
    super(
      /* html */
      `
            <div data-ref="eColumnMenu" role="presentation" class="ag-menu ag-column-menu"></div>
        `
    ), this.menuItems = e, this.column = t, this.restoreFocusParams = s, this.sourceElement = i, this.eColumnMenu = S;
  }
  postConstruct() {
    const e = this.beans.colMenuFactory.createMenu(
      this,
      this.menuItems,
      this.column,
      () => this.sourceElement ?? this.getGui()
    );
    this.mainMenuList = e, e.addEventListener("closeMenu", this.onHidePopup.bind(this)), this.eColumnMenu.appendChild(e.getGui());
  }
  onHidePopup(e) {
    this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(
      this.hidePopupFunc,
      this.restoreFocusParams,
      e
    );
  }
  afterGuiAttached({ hidePopup: e }) {
    e && (this.hidePopupFunc = e, this.addDestroyFunc(e)), ve(this.mainMenuList.getGui());
  }
};
function Ck(e, t) {
  const { contextMenuSvc: s } = e;
  if (!s)
    return;
  const { rowNode: i, column: r, value: o, x: n, y: a } = t || {};
  let { x: l, y: d } = s.getContextMenuPosition(i, r);
  n != null && (l = n), a != null && (d = a), s.showContextMenu({
    mouseEvent: new MouseEvent("mousedown", { clientX: l, clientY: d }),
    rowNode: i,
    column: r,
    value: o
  });
}
function vk(e, t) {
  var s;
  (s = e.colChooserFactory) == null || s.showColumnChooser({ chooserParams: t });
}
function wk(e) {
  var t;
  (t = e.colChooserFactory) == null || t.hideActiveColumnChooser();
}
var yk = class extends P {
  constructor() {
    super(...arguments), this.beanName = "menuUtils";
  }
  restoreFocusOnClose(e, t, s, i) {
    const { eventSource: r } = e, o = s instanceof KeyboardEvent;
    if (!i && !o || !r)
      return;
    const n = q(this.beans);
    // focus is outside of comp
    !t.contains(n) && // something else has focus
    !ys(this.beans) || this.focusHeaderCell(e);
  }
  closePopupAndRestoreFocusOnSelect(e, t, s) {
    let i;
    s && s.keyboardEvent && (i = s.keyboardEvent), e(i && { keyboardEvent: i });
    const r = this.beans, o = r.focusSvc, n = o.getFocusedCell();
    if (ys(r))
      if (n) {
        const { rowIndex: a, rowPinned: l, column: d } = n;
        o.setFocusedCell({
          rowIndex: a,
          column: d,
          rowPinned: l,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      } else
        this.focusHeaderCell(t);
  }
  onContextMenu(e, t, s) {
    if (!this.gos.get("allowContextMenuWithControlKey") && e && (e.ctrlKey || e.metaKey) || (e && this.blockMiddleClickScrollsIfNeeded(e), this.gos.get("suppressContextMenu")))
      return;
    const i = e ?? t.touches[0];
    if (s(i)) {
      const r = e ?? t;
      r && r.cancelable && r.preventDefault();
    }
  }
  // make this async for react
  async focusHeaderCell(e) {
    const { column: t, columnIndex: s, headerPosition: i, eventSource: r } = e, { visibleCols: o, headerNavigation: n, focusSvc: a } = this.beans, l = await o.allCols.some((d) => d === t);
    if (!(t && !t.isAlive())) {
      if (l && r && ke(r)) {
        const d = ml(r);
        d && (t && (n == null || n.scrollToColumn(t)), d.focus());
      } else if (i && s !== -1) {
        const d = o.allCols, c = d[s] || V(d);
        c && a.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: i.headerRowIndex,
            column: c
          }
        });
      }
    }
  }
  blockMiddleClickScrollsIfNeeded(e) {
    this.gos.get("suppressMiddleClickScrolls") && e.which === 2 && e.preventDefault();
  }
}, of = {
  moduleName: "MenuCore",
  version: j,
  beans: [nk, sk, yk],
  icons: {
    // context menu chart item
    chart: "chart",
    // columns in menu (column chooser / columns tab)
    columns: "columns",
    // loading async menu items
    loadingMenuItems: "loading",
    // "Pin column" item in column header menu
    menuPin: "pin",
    // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
    menuValue: "aggregation",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // context menu copy item
    clipboardCopy: "copy",
    // context menu cut item
    clipboardCut: "cut",
    // context menu paste item
    clipboardPaste: "paste",
    // context menu export item
    save: "save",
    // csv export
    csvExport: "csv",
    // excel export,
    excelExport: "excel",
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with colDef.unSortIcon=true
    sortUnSort: "none"
  },
  dependsOn: [te, ts, Wp, Cn]
}, bk = {
  moduleName: "ColumnMenu",
  version: j,
  beans: [gk, lk, ok],
  icons: {
    // menu tab icon in legacy tabbed enterprise column menu
    legacyMenu: "menu",
    // filter tab icon in legacy tabbed enterprise column menu
    filterTab: "filter",
    // column tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // column tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate"
  },
  apiFunctions: {
    showColumnChooser: vk,
    hideColumnChooser: wk
  },
  dependsOn: [of, Li, Ll]
}, Sk = {
  moduleName: "ContextMenu",
  version: j,
  beans: [hk],
  apiFunctions: {
    showContextMenu: Ck
  },
  dependsOn: [of]
}, Dc = class extends Ts {
  constructor() {
    super(
      /* html */
      '<div class="ag-cell-edit-wrapper"></div>'
    );
  }
  init(e) {
    this.params = e;
    const { cellStartedEdit: t, values: s } = e;
    Y(s) && R(180);
    const { params: i, valuesPromise: r } = this.buildRichSelectParams(), o = this.createManagedBean(new jl(i));
    this.richSelect = o, o.addCssClass("ag-cell-editor"), this.appendChild(o), r && r.then((n) => {
      o.setValueList({ valueList: n, refresh: !0 });
      const a = this.getSearchStringCallback(n);
      a && o.setSearchStringCreator(a);
    }), this.addManagedListeners(o, {
      fieldPickerValueSelected: this.onEditorPickerValueSelected.bind(this)
    }), this.focusAfterAttached = t;
  }
  onEditorPickerValueSelected(e) {
    setTimeout(() => this.params.stopEditing(!e.fromEnterKey));
  }
  buildRichSelectParams() {
    const e = this.params, {
      cellRenderer: t,
      cellHeight: s,
      value: i,
      values: r,
      formatValue: o,
      searchDebounceDelay: n,
      valueListGap: a,
      valueListMaxHeight: l,
      valueListMaxWidth: d,
      allowTyping: c,
      filterList: h,
      searchType: u,
      highlightMatch: p,
      valuePlaceholder: g,
      eventKey: f,
      multiSelect: m,
      suppressDeselectAll: C,
      suppressMultiSelectPillRenderer: v
    } = e, b = {
      value: i,
      cellRenderer: t,
      cellRowHeight: s,
      searchDebounceDelay: n,
      valueFormatter: o,
      pickerAriaLabelKey: "ariaLabelRichSelectField",
      pickerAriaLabelValue: "Rich Select Field",
      pickerType: "virtual-list",
      pickerGap: a,
      allowTyping: c,
      filterList: h,
      searchType: u,
      highlightMatch: p,
      maxPickerHeight: l,
      maxPickerWidth: d,
      placeholder: g,
      initialInputValue: (f == null ? void 0 : f.length) === 1 ? f : void 0,
      multiSelect: m,
      suppressDeselectAll: C,
      suppressMultiSelectPillRenderer: v
    };
    let y, F;
    return typeof r == "function" ? y = r(e) : y = r ?? [], Array.isArray(y) ? (b.valueList = y, b.searchStringCreator = this.getSearchStringCallback(y)) : F = y, m && c && (e.allowTyping = b.allowTyping = !1, R(181)), { params: b, valuesPromise: F };
  }
  getSearchStringCallback(e) {
    const t = this.params, { colDef: s } = t;
    if (typeof e[0] != "object" || !s.keyCreator)
      return;
    const { column: i, node: r, data: o } = t;
    return (n) => n.map((a) => {
      const l = this.gos.addGridCommonParams({
        value: a,
        colDef: s,
        column: i,
        node: r,
        data: o
      });
      return s.keyCreator(l);
    });
  }
  // we need to have the gui attached before we can draw the virtual rows, as the
  // virtual row logic needs info about the gui state
  afterGuiAttached() {
    const { focusAfterAttached: e, params: t } = this;
    setTimeout(() => {
      if (!this.isAlive())
        return;
      const s = this.richSelect;
      if (e) {
        const r = s.getFocusableElement();
        r.focus();
        const { allowTyping: o, eventKey: n } = this.params;
        o && (!n || n.length !== 1) && r.select();
      }
      s.showPicker();
      const { eventKey: i } = t;
      i && (i == null ? void 0 : i.length) === 1 && s.searchTextFromString(i);
    });
  }
  focusIn() {
    this.richSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.richSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}, xk = {
  moduleName: "RichSelect",
  version: j,
  beans: [],
  userComponents: { agRichSelect: Dc, agRichSelectCellEditor: Dc },
  icons: {
    // open icon for rich select editor
    richSelectOpen: "small-down",
    // remove for rich select editor pills
    richSelectRemove: "cancel"
  },
  dependsOn: [te, ss]
}, Bs = "__AG_SELECT_ALL__", Vs = "__AG_ADD_SELECTION_TO_FILTER__", Fk = {
  loadingOoo: "Loading...",
  blanks: "(Blanks)",
  searchOoo: "Search...",
  selectAll: "(Select All)",
  selectAllSearchResults: "(Select All Search Results)",
  addCurrentSelectionToFilter: "Add current selection to filter",
  noMatches: "No matches."
}, Rk = class extends L {
  constructor(e) {
    super(
      e.isGroup ? (
        /* html */
        `
            <div class="ag-set-filter-item" aria-hidden="true">
                <span class="ag-set-filter-group-icons">
                    <span class="ag-set-filter-group-closed-icon" data-ref="eGroupClosedIcon"></span>
                    <span class="ag-set-filter-group-opened-icon" data-ref="eGroupOpenedIcon"></span>
                    <span class="ag-set-filter-group-indeterminate-icon" data-ref="eGroupIndeterminateIcon"></span>
                </span>
                <ag-checkbox data-ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
            </div>`
      ) : (
        /* html */
        `
            <div class="ag-set-filter-item">
                <ag-checkbox data-ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
            </div>`
      ),
      [Pt]
    ), this.eCheckbox = S, this.eGroupOpenedIcon = S, this.eGroupClosedIcon = S, this.eGroupIndeterminateIcon = S, this.formattedValue = null, this.focusWrapper = e.focusWrapper, this.value = e.value, this.params = e.params, this.translate = e.translate, this.valueFormatter = e.valueFormatter, this.item = e.item, this.isSelected = e.isSelected, this.isTree = e.isTree, this.depth = e.depth ?? 0, this.isGroup = e.isGroup, this.groupsExist = e.groupsExist, this.isExpanded = e.isExpanded, this.hasIndeterminateExpandState = e.hasIndeterminateExpandState;
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getColDef: () => this.params.colDef,
        getColumn: () => this.params.column,
        getLocation: () => "setFilterValue",
        shouldDisplayTooltip: () => {
          var e;
          return ((e = this.shouldDisplayTooltip) == null ? void 0 : e.call(this)) ?? !0;
        },
        getValueFormatted: () => this.formattedValue,
        getAdditionalParams: () => this.isTree ? { level: this.depth } : {}
      })
    ), this.addDestroyFunc(() => {
      var e;
      return (e = this.destroyCellRendererComponent) == null ? void 0 : e.call(this);
    }), this.render(), this.eCheckbox.setLabelEllipsis(!0).setValue(this.isSelected, !0).setDisabled(!!this.params.readOnly).getInputElement().setAttribute("tabindex", "-1"), this.refreshVariableAriaLabels(), this.isTree && (this.depth > 0 && (this.addCssClass("ag-set-filter-indent-" + this.depth), this.getGui().style.setProperty("--ag-indentation-level", String(this.depth))), this.isGroup ? this.setupExpansion() : this.groupsExist && this.addCssClass("ag-set-filter-add-group-indent"), Sr(this.getAriaElement(), this.depth + 1)), this.refreshAriaChecked(), !this.params.readOnly && this.eCheckbox.onValueChange((e) => this.onCheckboxChanged(!!e));
  }
  getFocusableElement() {
    return this.focusWrapper;
  }
  setupExpansion() {
    const { eGroupClosedIcon: e, eGroupOpenedIcon: t, eGroupIndeterminateIcon: s, hasIndeterminateExpandState: i, beans: r } = this;
    e.appendChild(ms("setFilterGroupClosed", r, null)), t.appendChild(ms("setFilterGroupOpen", r, null));
    const o = this.onExpandOrContractClicked.bind(this);
    this.addManagedElementListeners(e, { click: o }), this.addManagedElementListeners(t, { click: o }), i && (s.appendChild(ms("setFilterGroupIndeterminate", r, null)), this.addManagedElementListeners(s, {
      click: o
    })), this.setExpandedIcons(), this.refreshAriaExpanded();
  }
  onExpandOrContractClicked() {
    this.setExpanded(!this.isExpanded);
  }
  setExpanded(e, t) {
    if (this.isGroup && e !== this.isExpanded) {
      this.isExpanded = e;
      const s = {
        type: "expandedChanged",
        isExpanded: !!e,
        item: this.item
      };
      t || this.dispatchLocalEvent(s), this.setExpandedIcons(), this.refreshAriaExpanded();
    }
  }
  setExpandedIcons() {
    const { isExpanded: e, hasIndeterminateExpandState: t, eGroupClosedIcon: s, eGroupOpenedIcon: i, eGroupIndeterminateIcon: r } = this;
    O(s, t ? e === !1 : !e), O(i, e === !0), t && O(r, e === void 0);
  }
  onCheckboxChanged(e) {
    this.isSelected = e;
    const t = {
      type: "selectionChanged",
      isSelected: e,
      item: this.item
    };
    this.dispatchLocalEvent(t), this.refreshVariableAriaLabels(), this.refreshAriaChecked();
  }
  toggleSelected() {
    this.params.readOnly || this.setSelected(!this.isSelected);
  }
  setSelected(e, t) {
    this.isSelected = e, this.eCheckbox.setValue(e, t), this.refreshAriaChecked();
  }
  refreshVariableAriaLabels() {
    if (!this.isTree)
      return;
    const e = this.getLocaleTextFunc(), t = this.eCheckbox.getValue(), s = t === void 0 ? e("ariaIndeterminate", "indeterminate") : t ? e("ariaVisible", "visible") : e("ariaHidden", "hidden"), i = e("ariaToggleVisibility", "Press SPACE to toggle visibility");
    vs(this.eCheckbox.getInputElement(), void 0), this.eCheckbox.setInputAriaLabel(`${i} (${s})`);
  }
  setupFixedAriaLabels(e) {
    if (!this.isTree)
      return;
    const s = this.getLocaleTextFunc()("ariaFilterValue", "Filter Value"), i = this.getAriaElement();
    oe(i, `${e} ${s}`), _o(i, this.eCheckbox.getInputElement().id);
  }
  refreshAriaChecked() {
    const e = this.getAriaElement();
    vh(e, this.eCheckbox.getValue());
  }
  refreshAriaExpanded() {
    He(this.getAriaElement(), !!this.isExpanded);
  }
  refresh(e, t, s) {
    var a;
    this.item = e, t !== this.isSelected && this.setSelected(t, !0), this.setExpanded(s, !0);
    const { cellRendererComponent: i, cellRendererParams: r, beans: o, params: n } = this;
    if (this.valueFunction) {
      const l = this.valueFunction();
      this.setTooltipAndCellRendererParams(l, l), i || this.renderCellWithoutCellRenderer();
    }
    if (i) {
      const l = So(
        o.userCompFactory,
        n,
        r
      );
      if (!((a = i.refresh) == null ? void 0 : a.call(i, (l == null ? void 0 : l.params) ?? r))) {
        const c = i;
        this.renderCell(), this.destroyBean(c);
      }
    }
  }
  render() {
    const {
      params: { column: e }
    } = this;
    let { value: t } = this, s = null;
    typeof t == "function" ? (this.valueFunction = t, s = this.valueFunction(), t = s) : this.isTree ? s = qe(t) : s = this.getFormattedValue(e, t), this.formattedValue = s, this.setTooltipAndCellRendererParams(t, s), this.renderCell();
  }
  setTooltipAndCellRendererParams(e, t) {
    var i;
    const s = this.gos;
    if (this.params.showTooltips && (!rr(s) || !this.params.cellRenderer)) {
      const r = t ?? qe(e);
      this.shouldDisplayTooltip = ln(
        s,
        () => this.eCheckbox.getGui().querySelector(".ag-label")
      ), (i = this.tooltipFeature) == null || i.setTooltipAndRefresh(r);
    }
    this.cellRendererParams = s.addGridCommonParams({
      value: e,
      valueFormatted: t,
      colDef: this.params.colDef,
      column: this.params.column,
      setTooltip: (r, o) => {
        var n;
        s.assertModuleRegistered("Tooltip", 3), this.shouldDisplayTooltip = o, (n = this.tooltipFeature) == null || n.setTooltipAndRefresh(r);
      }
    });
  }
  getFormattedValue(e, t) {
    return this.beans.valueSvc.formatValue(e, null, t, this.valueFormatter, !1);
  }
  renderCell() {
    const e = So(
      this.beans.userCompFactory,
      this.params,
      this.cellRendererParams
    ), t = e == null ? void 0 : e.newAgStackInstance();
    if (t == null) {
      this.renderCellWithoutCellRenderer();
      return;
    }
    t.then((s) => {
      s && (this.cellRendererComponent = s, this.eCheckbox.setLabel(s.getGui()), this.destroyCellRendererComponent = () => this.destroyBean(s));
    });
  }
  renderCellWithoutCellRenderer() {
    const { valueFormatted: e, value: t } = this.cellRendererParams;
    let s = e ?? t ?? this.translate("blanks");
    typeof s != "string" && (R(208), s = ""), this.eCheckbox.setLabel(s), this.setupFixedAriaLabels(s);
  }
  getComponentHolder() {
    return this.params.column.getColDef();
  }
}, nf = class {
  getModelAsString(e, t) {
    const { values: s } = e || t.getModel() || {}, i = t.getValueModel();
    if (s == null || i == null)
      return "";
    const r = s.filter((a) => i.isKeyAvailable(a)), o = r.length, n = r.slice(0, 10).map((a) => t.getFormattedValue(a));
    return `(${o}) ${n.join(",")}${o > 10 ? ",..." : ""}`;
  }
};
function Ka(e, t, s) {
  let i = e;
  return i ? (i = i.map((r) => qe(ge(r))), !t && s && i.some((r) => r == null) ? V(i) == null ? null : i.filter((r) => r != null) : i) : null;
}
var Pk = class {
  constructor(e, t, s, i, r, o, n, a, l, d) {
    this.rowModel = e, this.filterParams = t, this.createKey = s, this.caseFormat = i, this.valueSvc = r, this.treeDataOrGrouping = o, this.treeData = n, this.groupAllowUnbalanced = a, this.addManagedEventListeners = l, this.rowGroupColsSvc = d;
  }
  extractUniqueValuesAsync(e, t) {
    return new U((s) => {
      if (this.rowModel.isRowDataLoaded())
        s(this.extractUniqueValues(e, t));
      else {
        const [i] = this.addManagedEventListeners({
          rowCountReady: () => {
            i == null || i(), s(this.extractUniqueValues(e, t));
          }
        });
      }
    });
  }
  extractUniqueValues(e, t) {
    var l;
    const s = /* @__PURE__ */ new Map(), i = this.extractExistingFormattedKeys(t), r = /* @__PURE__ */ new Set(), o = this.treeData, n = (l = this.rowGroupColsSvc) == null ? void 0 : l.columns, a = (d, c) => {
      const h = this.caseFormat(d);
      if (!r.has(h)) {
        r.add(h);
        let u = d, p = ge(c);
        const g = i == null ? void 0 : i.get(h);
        g != null && (u = g, p = t.get(g)), s.set(u, p);
      }
    };
    return this.rowModel.forEachLeafNode((d) => {
      if (!d.data || !e(d))
        return;
      if (this.treeDataOrGrouping) {
        this.addValueForTreeDataOrGrouping(d, o, n, a);
        return;
      }
      const c = this.getValue(d);
      c != null && Array.isArray(c) ? (c.forEach((h) => {
        a(this.createKey(h, d), h);
      }), c.length === 0 && a(null, null)) : a(this.createKey(c, d), c);
    }), s;
  }
  addValueForTreeDataOrGrouping(e, t, s = [], i) {
    var n;
    let r;
    if (t) {
      if ((n = e.childrenAfterGroup) != null && n.length)
        return;
      r = e.getRoute() ?? [e.key ?? e.id];
    } else
      r = s.map((a) => this.valueSvc.getKeyForNode(a, e)), r.push(this.getValue(e));
    const o = Ka(r, t, this.groupAllowUnbalanced);
    i(this.createKey(o), o);
  }
  getValue(e) {
    return this.filterParams.getValue(e);
  }
  extractExistingFormattedKeys(e) {
    if (!e)
      return null;
    const t = /* @__PURE__ */ new Map();
    return e.forEach((s, i) => {
      t.set(this.caseFormat(i), i);
    }), t;
  }
}, Tk = class {
  constructor({ caseFormat: e }) {
    this.filteringKeys = null, this.filteringKeysCaseFormatted = null, this.hasNoAppliedFilteringKeys = !1, this.caseFormat = e;
  }
  allFilteringKeys() {
    return this.filteringKeys;
  }
  allFilteringKeysCaseFormatted() {
    return this.filteringKeysCaseFormatted;
  }
  setFilteringKeys(e) {
    this.filteringKeys = new Set(e), this.hasNoAppliedFilteringKeys = !this.filteringKeys || this.filteringKeys.size === 0, this.filteringKeysCaseFormatted = /* @__PURE__ */ new Set(), this.filteringKeys.forEach((t) => this.filteringKeysCaseFormatted.add(this.caseFormat(t)));
  }
  addFilteringKey(e) {
    this.filteringKeys == null && (this.filteringKeys = /* @__PURE__ */ new Set(), this.filteringKeysCaseFormatted = /* @__PURE__ */ new Set()), this.filteringKeys.add(e), this.filteringKeysCaseFormatted.add(this.caseFormat(e)), this.hasNoAppliedFilteringKeys && (this.hasNoAppliedFilteringKeys = !1);
  }
  hasCaseFormattedFilteringKey(e) {
    return this.filteringKeysCaseFormatted.has(this.caseFormat(e));
  }
  hasFilteringKey(e) {
    return this.filteringKeys.has(e);
  }
  reset() {
    this.filteringKeys = null, this.filteringKeysCaseFormatted = null, this.hasNoAppliedFilteringKeys = !1;
  }
}, Dk = class {
  constructor(e, t, s, i) {
    this.valueSvc = e, this.valueFormatter = t, this.formatter = s, this.column = i, this.displayedKeys = [];
  }
  updateDisplayedValuesToAllAvailable(e, t, s) {
    this.displayedKeys = Array.from(s);
  }
  updateDisplayedValuesToMatchMiniFilter(e, t, s, i, r) {
    this.displayedKeys = [];
    for (const o of s)
      if (o == null)
        r && this.displayedKeys.push(o);
      else {
        const n = e(o), a = this.valueSvc.formatValue(
          this.column,
          null,
          n,
          this.valueFormatter,
          !1
        ), l = this.formatter(a);
        i(l) && this.displayedKeys.push(o);
      }
  }
  getDisplayedValueCount() {
    return this.displayedKeys.length;
  }
  getDisplayedItem(e) {
    return this.displayedKeys[e];
  }
  getSelectAllItem() {
    return Bs;
  }
  getAddSelectionToFilterItem() {
    return Vs;
  }
  getDisplayedKeys() {
    return this.displayedKeys;
  }
  forEachDisplayedKey(e) {
    this.displayedKeys.forEach(e);
  }
  someDisplayedKey(e) {
    return this.displayedKeys.some(e);
  }
  hasGroups() {
    return !1;
  }
  refresh() {
  }
}, Ek = (e) => e ? [String(e.getFullYear()), String(e.getMonth() + 1), String(e.getDate())] : null, Ec = class {
  constructor(e, t, s, i) {
    this.formatter = e, this.treeListPathGetter = t, this.treeListFormatter = s, this.treeDataOrGrouping = i, this.allDisplayedItemsTree = [], this.activeDisplayedItemsFlat = [], this.selectAllItem = {
      depth: 0,
      filterPasses: !0,
      available: !0,
      treeKey: Bs,
      children: this.allDisplayedItemsTree,
      expanded: !0,
      key: Bs,
      parentTreeKeys: []
    }, this.addSelectionToFilterItem = {
      depth: 0,
      filterPasses: !0,
      available: !0,
      treeKey: Vs,
      expanded: !0,
      key: Vs,
      parentTreeKeys: []
    };
  }
  updateOnParamsChange(e) {
    this.treeListFormatter = e;
  }
  updateDisplayedValuesToAllAvailable(e, t, s, i) {
    i === "reload" ? this.generateItemTree(e, t, s) : i === "otherFilter" ? (this.updateAvailable(s), this.updateExpandAll()) : i === "miniFilter" && (this.resetFilter(), this.updateExpandAll()), this.flattenItems();
  }
  updateDisplayedValuesToMatchMiniFilter(e, t, s, i, r, o) {
    o === "reload" ? this.generateItemTree(e, t, s) : o === "otherFilter" && this.updateAvailable(s), this.updateFilter(i, r), this.updateExpandAll(), this.flattenItems();
  }
  generateItemTree(e, t, s) {
    this.allDisplayedItemsTree = [], this.groupsExist = !1;
    const i = this.getTreeListPathGetter(e, s);
    for (const r of t) {
      const o = e(r), n = i(o) ?? [null];
      n.length > 1 && (this.groupsExist = !0);
      const a = s.has(r);
      let l = this.allDisplayedItemsTree, d, c = [];
      n.forEach((h, u) => {
        l || (l = [], d.children = l), d = l.find((p) => {
          var g;
          return ((g = p.treeKey) == null ? void 0 : g.toUpperCase()) === (h == null ? void 0 : h.toUpperCase());
        }), d || (d = { treeKey: h, depth: u, filterPasses: !0, expanded: !1, available: a, parentTreeKeys: c }, u === n.length - 1 && (d.key = r), l.push(d)), l = d.children, c = [...c, h];
      });
    }
    this.updateAvailable(s), this.selectAllItem.children = this.allDisplayedItemsTree, this.selectAllItem.expanded = !1;
  }
  getTreeListPathGetter(e, t) {
    if (this.treeListPathGetter)
      return this.treeListPathGetter;
    if (this.treeDataOrGrouping)
      return (i) => i;
    let s = !1;
    for (const i of t) {
      const r = e(i);
      if (r instanceof Date) {
        s = !0;
        break;
      } else if (r != null)
        break;
    }
    return s ? Ek : (R(211), (i) => [String(i)]);
  }
  flattenItems() {
    this.activeDisplayedItemsFlat = [];
    const e = (t) => {
      t.forEach((s) => {
        !s.filterPasses || !s.available || (this.activeDisplayedItemsFlat.push(s), s.children && s.expanded && e(s.children));
      });
    };
    e(this.allDisplayedItemsTree);
  }
  resetFilter() {
    const e = (t) => {
      t.children && t.children.forEach((s) => {
        e(s);
      }), t.filterPasses = !0;
    };
    this.allDisplayedItemsTree.forEach((t) => e(t));
  }
  updateFilter(e, t) {
    const s = (i) => i.available ? i.treeKey == null ? t : e(
      this.formatter(
        this.treeListFormatter ? this.treeListFormatter(i.treeKey, i.depth, i.parentTreeKeys) : i.treeKey
      )
    ) : !1;
    this.allDisplayedItemsTree.forEach(
      (i) => this.recursiveItemCheck(i, !1, s, "filterPasses")
    );
  }
  getDisplayedValueCount() {
    return this.activeDisplayedItemsFlat.length;
  }
  getDisplayedItem(e) {
    return this.activeDisplayedItemsFlat[e];
  }
  getSelectAllItem() {
    return this.selectAllItem;
  }
  getAddSelectionToFilterItem() {
    return this.addSelectionToFilterItem;
  }
  getDisplayedKeys() {
    const e = [];
    return this.forEachDisplayedKey((t) => e.push(t)), e;
  }
  forEachDisplayedKey(e) {
    const t = (s, i) => {
      s.children ? (!s.expanded || !i) && s.children.forEach((r) => {
        r.filterPasses && t(r, !1);
      }) : e(s.key);
    };
    this.activeDisplayedItemsFlat.forEach((s) => t(s, !0));
  }
  someDisplayedKey(e) {
    const t = (s, i) => {
      if (s.children) {
        if (!s.expanded || !i)
          return s.children.some((r) => r.filterPasses ? t(r, !1) : !1);
      } else
        return e(s.key);
      return !1;
    };
    return this.activeDisplayedItemsFlat.some((s) => t(s, !0));
  }
  hasGroups() {
    return this.groupsExist;
  }
  refresh() {
    this.updateExpandAll(), this.flattenItems();
  }
  updateExpandAll() {
    const e = (s, i, r) => {
      for (const o of s) {
        if (!o.filterPasses || !o.available || !o.children)
          continue;
        if (i = i || !!o.expanded, r = r || !o.expanded, i && r)
          return;
        const n = e(o.children, i, r);
        if (n === void 0)
          return;
        n ? i = !0 : r = !0;
      }
      return i && r ? void 0 : i;
    }, t = this.getSelectAllItem();
    t.expanded = e(t.children, !1, !1);
  }
  recursiveItemCheck(e, t, s, i) {
    let r = !1;
    e.children && e.children.forEach((n) => {
      const a = this.recursiveItemCheck(
        n,
        t || s(e),
        s,
        i
      );
      r = r || a;
    });
    const o = t || r || s(e);
    return e[i] = o, o;
  }
  updateAvailable(e) {
    const t = (s) => e.has(s.key);
    this.allDisplayedItemsTree.forEach((s) => this.recursiveItemCheck(s, !1, t, "available"));
  }
}, Mk = class {
  constructor(e) {
    this.localEventService = new Rs(), this.miniFilterText = null, this.addCurrentSelectionToFilter = !1, this.providedValues = null, this.allValues = /* @__PURE__ */ new Map(), this.availableKeys = /* @__PURE__ */ new Set(), this.selectedKeys = /* @__PURE__ */ new Set(), this.initialised = !1;
    const {
      usingComplexObjects: t,
      rowGroupColsSvc: s,
      valueSvc: i,
      treeDataTreeList: r,
      groupingTreeList: o,
      filterParams: n,
      gos: a,
      valueFormatter: l,
      addManagedEventListeners: d
    } = e, {
      column: c,
      colDef: h,
      textFormatter: u,
      doesRowPassOtherFilter: p,
      suppressSorting: g,
      comparator: f,
      rowModel: m,
      values: C,
      caseSensitive: v,
      treeList: b,
      treeListPathGetter: y,
      treeListFormatter: F
    } = n;
    this.filterParams = n, this.gos = a, this.setIsLoading = e.setIsLoading, this.translate = e.translate, this.caseFormat = e.caseFormat, this.createKey = e.createKey, this.usingComplexObjects = !!e.usingComplexObjects, this.formatter = u ?? ((I) => I ?? null), this.doesRowPassOtherFilters = p, this.suppressSorting = g || !1, this.filteringKeys = new Tk({ caseFormat: this.caseFormat });
    const D = f ?? h.comparator, x = !!r || !!o;
    this.compareByValue = !!(t && D || x || b && !y), x && !D ? this.entryComparator = this.createTreeDataOrGroupingComparator() : b && !y && !D ? this.entryComparator = ([I, E], [M, N]) => Qr(E, N) : this.entryComparator = ([I, E], [M, N]) => D(E, N), this.keyComparator = D ?? Qr, this.caseSensitive = !!v;
    const T = a.get("groupAllowUnbalanced");
    J(a) && (this.clientSideValuesExtractor = new Pk(
      m,
      this.filterParams,
      this.createKey,
      this.caseFormat,
      i,
      x,
      !!r,
      T,
      d,
      s
    )), C == null ? this.valuesType = 2 : (this.valuesType = Array.isArray(C) ? 0 : 1, this.providedValues = C), this.displayValueModel = b ? new Ec(
      this.formatter,
      y,
      F,
      r || o
    ) : new Dk(i, l, this.formatter, c), this.updateAllValues().then((I) => this.resetSelectionState(I || []));
  }
  addEventListener(e, t, s) {
    this.localEventService.addEventListener(e, t, s);
  }
  removeEventListener(e, t, s) {
    this.localEventService.removeEventListener(e, t, s);
  }
  updateOnParamsChange(e) {
    return new U((t) => {
      const { values: s, textFormatter: i, suppressSorting: r, treeListFormatter: o } = e, n = this.providedValues, a = this.suppressSorting;
      if (this.filterParams = e, this.formatter = i ?? ((l) => l ?? null), this.suppressSorting = r || !1, this.providedValues = s ?? null, this.displayValueModel instanceof Ec && this.displayValueModel.updateOnParamsChange(o), this.providedValues !== n || this.suppressSorting !== a) {
        !s || s.length === 0 ? (this.valuesType = 2, this.providedValues = null) : this.valuesType = Array.isArray(s) ? 0 : 1;
        const l = this.getModel();
        this.updateAllValues().then(() => {
          this.setModel(l).then(() => t());
        });
      } else
        t();
    });
  }
  /**
   * Re-fetches the values used in the filter from the value source.
   * If keepSelection is false, the filter selection will be reset to everything selected,
   * otherwise the current selection will be preserved.
   */
  refreshValues() {
    return new U((e) => {
      this.allValuesPromise.then(() => {
        const t = this.getModel();
        this.updateAllValues(), this.setModel(t).then(() => e());
      });
    });
  }
  /**
   * Overrides the current values being used for the set filter.
   * If keepSelection is false, the filter selection will be reset to everything selected,
   * otherwise the current selection will be preserved.
   */
  overrideValues(e) {
    return new U((t) => {
      this.allValuesPromise.then(() => {
        this.valuesType = 0, this.providedValues = e, this.refreshValues().then(() => t());
      });
    });
  }
  /** @return has anything been updated */
  refreshAfterAnyFilterChanged() {
    return this.showAvailableOnly() ? this.allValuesPromise.then((e) => (this.updateAvailableKeys(e ?? [], "otherFilter"), !0)) : U.resolve(!1);
  }
  isInitialised() {
    return this.initialised;
  }
  updateAllValues() {
    return this.allValuesPromise = new U((e) => {
      switch (this.valuesType) {
        case 2:
          this.getValuesFromRowsAsync(!1).then((t) => e(this.processAllValues(t)));
          break;
        case 0: {
          e(
            this.processAllValues(
              this.uniqueValues(this.validateProvidedValues(this.providedValues))
            )
          );
          break;
        }
        case 1: {
          this.setIsLoading(!0);
          const t = this.providedValues, { column: s, colDef: i } = this.filterParams, r = this.gos.addGridCommonParams({
            success: (o) => {
              this.setIsLoading(!1), e(this.processAllValues(this.uniqueValues(this.validateProvidedValues(o))));
            },
            colDef: i,
            column: s
          });
          window.setTimeout(() => t(r), 0);
          break;
        }
      }
    }), this.allValuesPromise.then((e) => this.updateAvailableKeys(e || [], "reload")).then(() => this.initialised = !0), this.allValuesPromise;
  }
  processAllValues(e) {
    const t = this.sortKeys(e);
    return this.allValues = e ?? /* @__PURE__ */ new Map(), t;
  }
  validateProvidedValues(e) {
    if (this.usingComplexObjects && (e != null && e.length)) {
      const t = e[0];
      t && typeof t != "object" && typeof t != "function" && (this.createKey(t) == null ? R(209) : R(210));
    }
    return e;
  }
  setValuesType(e) {
    this.valuesType = e;
  }
  getValuesType() {
    return this.valuesType;
  }
  isKeyAvailable(e) {
    return this.availableKeys.has(e);
  }
  showAvailableOnly() {
    return this.valuesType === 2;
  }
  updateAvailableKeys(e, t) {
    const s = this.showAvailableOnly() ? this.sortKeys(this.getValuesFromRows(!0)) : e;
    this.availableKeys = new Set(s), this.localEventService.dispatchEvent({ type: "availableValuesChanged" }), this.updateDisplayedValues(t, e);
  }
  sortKeys(e) {
    const t = e ?? /* @__PURE__ */ new Map();
    if (this.suppressSorting)
      return Array.from(t.keys());
    let s;
    return this.compareByValue ? s = Array.from(t.entries()).sort(this.entryComparator).map(([i]) => i) : s = Array.from(t.keys()).sort(this.keyComparator), this.filterParams.excelMode && t.has(null) && (s = s.filter((i) => i != null), s.push(null)), s;
  }
  getParamsForValuesFromRows(e = !1) {
    if (!this.clientSideValuesExtractor)
      return z(113), null;
    const t = (i) => !e || this.doesRowPassOtherFilters(i), s = e && !this.caseSensitive ? this.allValues : void 0;
    return { predicate: t, existingValues: s };
  }
  getValuesFromRows(e = !1) {
    const t = this.getParamsForValuesFromRows(e);
    return t ? this.clientSideValuesExtractor.extractUniqueValues(t.predicate, t.existingValues) : null;
  }
  getValuesFromRowsAsync(e = !1) {
    const t = this.getParamsForValuesFromRows(e);
    return t ? this.clientSideValuesExtractor.extractUniqueValuesAsync(t.predicate, t.existingValues) : U.resolve(null);
  }
  /** Sets mini filter value. Returns true if it changed from last value, otherwise false. */
  setMiniFilter(e) {
    return e = ge(e), this.miniFilterText === e ? !1 : (e === null && this.setAddCurrentSelectionToFilter(!1), this.miniFilterText = e, this.updateDisplayedValues("miniFilter"), !0);
  }
  getMiniFilter() {
    return this.miniFilterText;
  }
  updateDisplayedValues(e, t) {
    if (e === "expansion") {
      this.displayValueModel.refresh();
      return;
    }
    if (this.miniFilterText == null) {
      this.displayValueModel.updateDisplayedValuesToAllAvailable(
        (o) => this.getValue(o),
        t,
        this.availableKeys,
        e
      );
      return;
    }
    const s = this.caseFormat(this.formatter(this.miniFilterText) || ""), i = (o) => o != null && this.caseFormat(o).indexOf(s) >= 0, r = !!this.filterParams.excelMode && i(this.translate("blanks"));
    this.displayValueModel.updateDisplayedValuesToMatchMiniFilter(
      (o) => this.getValue(o),
      t,
      this.availableKeys,
      i,
      r,
      e
    );
  }
  getDisplayedValueCount() {
    return this.displayValueModel.getDisplayedValueCount();
  }
  getDisplayedItem(e) {
    return this.displayValueModel.getDisplayedItem(e);
  }
  getSelectAllItem() {
    return this.displayValueModel.getSelectAllItem();
  }
  getAddSelectionToFilterItem() {
    return this.displayValueModel.getAddSelectionToFilterItem();
  }
  hasSelections() {
    return this.filterParams.defaultToNothingSelected ? this.selectedKeys.size > 0 : this.allValues.size !== this.selectedKeys.size;
  }
  getKeys() {
    return Array.from(this.allValues.keys());
  }
  getValues() {
    return Array.from(this.allValues.values());
  }
  getValue(e) {
    return this.allValues.get(e);
  }
  setAddCurrentSelectionToFilter(e) {
    this.addCurrentSelectionToFilter = e;
  }
  isInWindowsExcelMode() {
    return this.filterParams.excelMode === "windows";
  }
  isAddCurrentSelectionToFilterChecked() {
    return this.isInWindowsExcelMode() && this.addCurrentSelectionToFilter;
  }
  showAddCurrentSelectionToFilter() {
    return this.isInWindowsExcelMode() && A(this.miniFilterText) && this.miniFilterText.length > 0;
  }
  selectAllMatchingMiniFilter(e = !1) {
    this.miniFilterText == null ? this.selectedKeys = new Set(this.allValues.keys()) : (e && this.selectedKeys.clear(), this.displayValueModel.forEachDisplayedKey((t) => this.selectedKeys.add(t)));
  }
  deselectAllMatchingMiniFilter() {
    this.miniFilterText == null ? this.selectedKeys.clear() : this.displayValueModel.forEachDisplayedKey((e) => this.selectedKeys.delete(e));
  }
  selectKey(e) {
    this.selectedKeys.add(e);
  }
  deselectKey(e) {
    this.filterParams.excelMode && this.isEverythingVisibleSelected() && this.resetSelectionState(this.displayValueModel.getDisplayedKeys()), this.selectedKeys.delete(e);
  }
  isKeySelected(e) {
    return this.selectedKeys.has(e);
  }
  isEverythingVisibleSelected() {
    return !this.displayValueModel.someDisplayedKey((e) => !this.isKeySelected(e));
  }
  isNothingVisibleSelected() {
    return !this.displayValueModel.someDisplayedKey((e) => this.isKeySelected(e));
  }
  getModel() {
    if (!this.hasSelections())
      return null;
    const e = this.isAddCurrentSelectionToFilterChecked() ? this.filteringKeys.allFilteringKeys() : null;
    if (e && e.size > 0) {
      if (this.selectedKeys) {
        const t = /* @__PURE__ */ new Set([
          ...Array.from(e),
          ...Array.from(this.selectedKeys).filter((s) => !e.has(s))
        ]);
        return Array.from(t);
      }
      return Array.from(e);
    }
    return Array.from(this.selectedKeys);
  }
  setModel(e) {
    return this.allValuesPromise.then((t) => {
      if (e == null)
        this.resetSelectionState(t ?? []);
      else {
        this.selectedKeys.clear();
        const s = /* @__PURE__ */ new Map();
        this.allValues.forEach((i, r) => {
          s.set(this.caseFormat(r), r);
        }), e.forEach((i) => {
          const r = this.caseFormat(ge(i)), o = s.get(r);
          o !== void 0 && this.selectKey(o);
        });
      }
    });
  }
  uniqueValues(e) {
    const t = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set();
    return (e ?? []).forEach((i) => {
      const r = ge(i), o = this.createKey(r), n = this.caseFormat(o);
      s.has(n) || (s.add(n), t.set(o, r));
    }), t;
  }
  resetSelectionState(e) {
    this.filterParams.defaultToNothingSelected ? this.selectedKeys.clear() : this.selectedKeys = new Set(e);
  }
  hasGroups() {
    return this.displayValueModel.hasGroups();
  }
  createTreeDataOrGroupingComparator() {
    return ([e, t], [s, i]) => {
      if (t == null)
        return i == null ? 0 : -1;
      if (i == null)
        return 1;
      for (let r = 0; r < t.length; r++) {
        if (r >= i.length)
          return 1;
        const o = Qr(t[r], i[r]);
        if (o !== 0)
          return o;
      }
      return 0;
    };
  }
  setAppliedModelKeys(e) {
    this.filteringKeys.setFilteringKeys(e);
  }
  addToAppliedModelKeys(e) {
    this.filteringKeys.addFilteringKey(e);
  }
  getAppliedModelKeys() {
    return this.filteringKeys.allFilteringKeys();
  }
  getCaseFormattedAppliedModelKeys() {
    return this.filteringKeys.allFilteringKeysCaseFormatted();
  }
  hasAppliedModelKey(e) {
    return this.filteringKeys.hasCaseFormattedFilteringKey(e);
  }
  hasAnyAppliedModelKey() {
    return !this.filteringKeys.hasNoAppliedFilteringKeys;
  }
}, af = class extends on {
  constructor() {
    super("setFilter"), this.filterType = "set", this.eMiniFilter = S, this.eFilterLoading = S, this.eSetFilterList = S, this.eFilterNoMatches = S, this.caseSensitive = !1, this.treeDataTreeList = !1, this.groupingTreeList = !1, this.hardRefreshVirtualList = !1, this.noValueFormatterSupplied = !1, this.filterModelFormatter = new nf(), this.updateSetFilterOnParamsChange = (e) => {
      var i;
      this.setFilterParams = e, this.caseSensitive = !!e.caseSensitive;
      const t = e.keyCreator ?? e.colDef.keyCreator;
      this.setValueFormatter(e.valueFormatter, t, !!e.treeList, !!e.colDef.refData);
      const s = e.column.getId().startsWith(Ss);
      this.treeDataTreeList = this.gos.get("treeData") && !!e.treeList && s, this.groupingTreeList = !!((i = this.rowGroupColsSvc) != null && i.columns.length) && !!e.treeList && s, this.createKey = this.generateCreateKey(t, this.treeDataTreeList || this.groupingTreeList);
    };
  }
  wireBeans(e) {
    this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueSvc = e.valueSvc, this.dataTypeSvc = e.dataTypeSvc;
  }
  postConstruct() {
    super.postConstruct();
  }
  // unlike the simple filters, nothing in the set filter UI shows/hides.
  // maybe this method belongs in abstractSimpleFilter???
  updateUiVisibility() {
  }
  createBodyTemplate() {
    return (
      /* html */
      `
            <div class="ag-set-filter">
                <div data-ref="eFilterLoading" class="ag-filter-loading ag-hidden">${this.translateForSetFilter("loadingOoo")}</div>
                <ag-input-text-field class="ag-mini-filter" data-ref="eMiniFilter"></ag-input-text-field>
                <div data-ref="eFilterNoMatches" class="ag-filter-no-matches ag-hidden">${this.translateForSetFilter("noMatches")}</div>
                <div data-ref="eSetFilterList" class="ag-set-filter-list" role="presentation"></div>
            </div>`
    );
  }
  getAgComponents() {
    return [mt];
  }
  handleKeyDown(e) {
    if (super.handleKeyDown(e), !e.defaultPrevented)
      switch (e.key) {
        case w.SPACE:
          this.handleKeySpace(e);
          break;
        case w.ENTER:
          this.handleKeyEnter(e);
          break;
        case w.LEFT:
          this.handleKeyLeft(e);
          break;
        case w.RIGHT:
          this.handleKeyRight(e);
          break;
      }
  }
  handleKeySpace(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) == null || t.toggleSelected();
  }
  handleKeyEnter(e) {
    const { excelMode: t, readOnly: s } = this.setFilterParams;
    !t || s || (e.preventDefault(), this.onBtApply(!1, !1, e), this.setFilterParams.excelMode === "mac" && this.eMiniFilter.getInputElement().select());
  }
  handleKeyLeft(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) == null || t.setExpanded(!1);
  }
  handleKeyRight(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) == null || t.setExpanded(!0);
  }
  getComponentForKeyEvent(e) {
    if (!this.eSetFilterList.contains(q(this.beans)))
      return;
    const t = this.virtualList.getLastFocusedRow();
    if (t == null)
      return;
    const s = this.virtualList.getComponentAt(t);
    if (s == null)
      return;
    e.preventDefault();
    const { readOnly: i } = this.setFilterParams;
    if (!i)
      return s;
  }
  getCssIdentifier() {
    return "set-filter";
  }
  setModel(e) {
    return e == null && this.valueModel.getModel() == null ? (this.setMiniFilter(null), U.resolve()) : super.setModel(e);
  }
  refresh(e) {
    if (this.applyExcelModeOptions(e), !super.refresh(e))
      return !1;
    const t = this.setFilterParams;
    return [
      "treeList",
      "treeListPathGetter",
      "caseSensitive",
      "comparator",
      "excelMode"
    ].some((i) => e[i] !== (t == null ? void 0 : t[i])) || this.haveColDefParamsChanged(e) ? !1 : (super.updateParams(e), this.updateSetFilterOnParamsChange(e), this.updateMiniFilter(), e.suppressSelectAll !== (t == null ? void 0 : t.suppressSelectAll) && this.createVirtualListModel(e), this.valueModel.updateOnParamsChange(e).then(() => {
      this.refreshFilterValues();
    }), !0);
  }
  haveColDefParamsChanged(e) {
    const { colDef: t, keyCreator: s } = e, { colDef: i, keyCreator: r } = this.setFilterParams, o = s ?? t.keyCreator, n = r ?? (i == null ? void 0 : i.keyCreator), a = t.filterValueGetter !== (i == null ? void 0 : i.filterValueGetter), l = o !== n, d = !!this.dataTypeSvc && !!o && this.dataTypeSvc.getFormatValue(t.cellDataType) === o && t.valueFormatter !== (i == null ? void 0 : i.valueFormatter);
    return a || l || d;
  }
  setModelAndRefresh(e) {
    return this.valueModel.setModel(e).then(() => {
      this.isAlive() && this.checkAndRefreshVirtualList();
    });
  }
  resetUiToDefaults() {
    return this.setMiniFilter(null), this.setModelAndRefresh(null);
  }
  setModelIntoUi(e) {
    this.setMiniFilter(null);
    const t = e == null ? null : e.values;
    return this.setModelAndRefresh(t);
  }
  getModelFromUi() {
    const e = this.valueModel.getModel();
    return e ? { values: e, filterType: this.filterType } : null;
  }
  getValueModel() {
    return this.valueModel;
  }
  areModelsEqual(e, t) {
    return e == null && t == null ? !0 : e != null && t != null && Re(e.values, t.values);
  }
  setParams(e) {
    this.applyExcelModeOptions(e), super.setParams(e), this.updateSetFilterOnParamsChange(e);
    const t = e.keyCreator ?? e.colDef.keyCreator;
    this.valueModel = new Mk({
      filterParams: e,
      setIsLoading: (s) => this.setIsLoading(s),
      translate: (s) => this.translateForSetFilter(s),
      caseFormat: (s) => this.caseFormat(s),
      createKey: this.createKey,
      valueFormatter: this.valueFormatter,
      usingComplexObjects: !!t,
      gos: this.gos,
      rowGroupColsSvc: this.rowGroupColsSvc,
      valueSvc: this.valueSvc,
      treeDataTreeList: this.treeDataTreeList,
      groupingTreeList: this.groupingTreeList,
      addManagedEventListeners: (s) => this.addManagedEventListeners(s)
    }), this.initialiseFilterBodyUi(), this.addEventListenersForDataChanges();
  }
  onAddCurrentSelectionToFilterChange(e) {
    this.valueModel.setAddCurrentSelectionToFilter(e);
  }
  setValueFormatter(e, t, s, i) {
    let r = e;
    if (!r) {
      if (t && !s) {
        z(249);
        return;
      }
      this.noValueFormatterSupplied = !0, i || (r = (o) => qe(o.value));
    }
    this.valueFormatter = r;
  }
  generateCreateKey(e, t) {
    return t && !e ? (z(250), () => null) : e ? (s, i = null) => {
      const r = this.getKeyCreatorParams(s, i);
      return ge(e(r));
    } : (s) => ge(qe(s));
  }
  getFormattedValue(e) {
    let t = this.valueModel.getValue(e);
    this.noValueFormatterSupplied && (this.treeDataTreeList || this.groupingTreeList) && Array.isArray(t) && (t = V(t));
    const s = this.valueSvc.formatValue(
      this.setFilterParams.column,
      null,
      t,
      this.valueFormatter,
      !1
    );
    return s ?? qe(t) ?? this.translateForSetFilter("blanks");
  }
  applyExcelModeOptions(e) {
    e.excelMode === "windows" ? (e.buttons || (e.buttons = ["apply", "cancel"]), e.closeOnApply == null && (e.closeOnApply = !0)) : e.excelMode === "mac" && (e.buttons || (e.buttons = ["reset"]), e.applyMiniFilterWhileTyping == null && (e.applyMiniFilterWhileTyping = !0), e.debounceMs == null && (e.debounceMs = 500)), e.excelMode && e.defaultToNothingSelected && (e.defaultToNothingSelected = !1, R(207));
  }
  addEventListenersForDataChanges() {
    this.isValuesTakenFromGrid() && (this.addManagedPropertyListeners(["groupAllowUnbalanced"], () => {
      this.syncAfterDataChange();
    }), this.addManagedEventListeners({
      cellValueChanged: (e) => {
        e.column === this.setFilterParams.column && this.syncAfterDataChange();
      }
    }));
  }
  syncAfterDataChange() {
    return this.valueModel.refreshValues().then(() => {
      this.checkAndRefreshVirtualList(), (!this.applyActive || this.areModelsEqual(this.getModel(), this.getModelFromUi())) && this.onBtApply(!1, !0);
    });
  }
  setIsLoading(e) {
    O(this.eFilterLoading, e), e || (this.hardRefreshVirtualList = !0);
  }
  initialiseFilterBodyUi() {
    this.initVirtualList(), this.initMiniFilter();
  }
  initVirtualList() {
    const t = this.getLocaleTextFunc()("ariaFilterList", "Filter List"), s = !!this.setFilterParams.treeList, i = this.virtualList = this.createBean(
      new Oi({
        cssIdentifier: "filter",
        ariaRole: s ? "tree" : "listbox",
        listName: t
      })
    ), r = this.eSetFilterList;
    s && r.classList.add("ag-set-filter-tree-list"), r && r.appendChild(i.getGui());
    const { cellHeight: o } = this.setFilterParams;
    o != null && i.setRowHeight(o);
    const n = (l, d) => this.createSetListItem(l, s, d);
    i.setComponentCreator(n);
    const a = (l, d) => this.updateSetListItem(l, d);
    i.setComponentUpdater(a), this.createVirtualListModel(this.setFilterParams);
  }
  createVirtualListModel(e) {
    let t;
    e.suppressSelectAll ? t = new Ak(this.valueModel) : t = new Ik(this.valueModel, () => this.isSelectAllSelected()), e.treeList && (t = new Lk(t)), this.virtualList.setModel(t);
  }
  getSelectAllLabel() {
    const e = this.valueModel.getMiniFilter() == null || !this.setFilterParams.excelMode ? "selectAll" : "selectAllSearchResults";
    return this.translateForSetFilter(e);
  }
  getAddSelectionToFilterLabel() {
    return this.translateForSetFilter("addCurrentSelectionToFilter");
  }
  createSetListItem(e, t, s) {
    const i = this.valueModel.hasGroups(), { isSelected: r, isExpanded: o } = this.isSelectedExpanded(e), { value: n, depth: a, isGroup: l, hasIndeterminateExpandState: d, selectedListener: c, expandedListener: h } = this.newSetListItemAttributes(e), u = {
      focusWrapper: s,
      value: n,
      params: this.setFilterParams,
      translate: (g) => this.translateForSetFilter(g),
      valueFormatter: this.valueFormatter,
      item: e,
      isSelected: r,
      isTree: t,
      depth: a,
      groupsExist: i,
      isGroup: l,
      isExpanded: o,
      hasIndeterminateExpandState: d
    }, p = this.createBean(new Rk(u));
    return p.addEventListener("selectionChanged", c), h && p.addEventListener("expandedChanged", h), p;
  }
  newSetTreeItemAttributes(e) {
    var s, i, r, o;
    const t = this.valueModel.hasGroups();
    return e.key === Bs ? {
      value: () => this.getSelectAllLabel(),
      isGroup: t,
      depth: e.depth,
      hasIndeterminateExpandState: !0,
      selectedListener: (n) => this.onSelectAll(n.isSelected),
      expandedListener: (n) => this.onExpandAll(n.item, n.isExpanded)
    } : e.key === Vs ? {
      value: () => this.getAddSelectionToFilterLabel(),
      depth: e.depth,
      isGroup: !1,
      hasIndeterminateExpandState: !1,
      selectedListener: (n) => {
        this.onAddCurrentSelectionToFilterChange(n.isSelected);
      }
    } : e.children ? {
      value: ((i = (s = this.setFilterParams).treeListFormatter) == null ? void 0 : i.call(s, e.treeKey, e.depth, e.parentTreeKeys)) ?? e.treeKey,
      depth: e.depth,
      isGroup: !0,
      selectedListener: (n) => this.onGroupItemSelected(n.item, n.isSelected),
      expandedListener: (n) => this.onExpandedChanged(n.item, n.isExpanded)
    } : {
      value: ((o = (r = this.setFilterParams).treeListFormatter) == null ? void 0 : o.call(r, e.treeKey, e.depth, e.parentTreeKeys)) ?? e.treeKey,
      depth: e.depth,
      selectedListener: (n) => this.onItemSelected(n.item.key, n.isSelected)
    };
  }
  newSetListItemAttributes(e) {
    return this.isSetFilterModelTreeItem(e) ? this.newSetTreeItemAttributes(e) : e === Bs ? {
      value: () => this.getSelectAllLabel(),
      selectedListener: (t) => this.onSelectAll(t.isSelected)
    } : e === Vs ? {
      value: () => this.getAddSelectionToFilterLabel(),
      selectedListener: (t) => {
        this.onAddCurrentSelectionToFilterChange(t.isSelected);
      }
    } : {
      value: this.valueModel.getValue(e),
      selectedListener: (t) => this.onItemSelected(t.item, t.isSelected)
    };
  }
  updateSetListItem(e, t) {
    const { isSelected: s, isExpanded: i } = this.isSelectedExpanded(e);
    t.refresh(e, s, i);
  }
  isSelectedExpanded(e) {
    let t, s;
    return this.isSetFilterModelTreeItem(e) ? (s = e.expanded, e.key === Bs ? t = this.isSelectAllSelected() : e.key === Vs ? t = this.valueModel.isAddCurrentSelectionToFilterChecked() : e.children ? t = this.areAllChildrenSelected(e) : t = this.valueModel.isKeySelected(e.key)) : e === Bs ? t = this.isSelectAllSelected() : e === Vs ? t = this.valueModel.isAddCurrentSelectionToFilterChecked() : t = this.valueModel.isKeySelected(e), { isSelected: t, isExpanded: s };
  }
  isSetFilterModelTreeItem(e) {
    return (e == null ? void 0 : e.treeKey) !== void 0;
  }
  initMiniFilter() {
    const { eMiniFilter: e } = this, t = this.getLocaleTextFunc();
    e.setDisplayed(!this.setFilterParams.suppressMiniFilter), e.setValue(this.valueModel.getMiniFilter()), e.onValueChange(() => this.onMiniFilterInput()), e.setInputAriaLabel(t("ariaSearchFilterValues", "Search filter values")), this.addManagedElementListeners(e.getInputElement(), {
      keydown: (s) => this.onMiniFilterKeyDown(s)
    });
  }
  updateMiniFilter() {
    const { eMiniFilter: e } = this;
    e.isDisplayed() !== !this.setFilterParams.suppressMiniFilter && e.setDisplayed(!this.setFilterParams.suppressMiniFilter);
    const t = this.valueModel.getMiniFilter();
    e.getValue() !== t && e.setValue(t);
  }
  // we need to have the GUI attached before we can draw the virtual rows, as the
  // virtual row logic needs info about the GUI state
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.resetExpansion(), this.refreshVirtualList();
    const { eMiniFilter: t } = this;
    t.setInputPlaceholder(this.translateForSetFilter("searchOoo")), (!e || !e.suppressFocus) && (t.isDisplayed() ? t.getFocusableElement().focus() : this.virtualList.awaitStable(() => this.virtualList.focusRow(0)));
  }
  afterGuiDetached() {
    super.afterGuiDetached(), this.setFilterParams.excelMode && this.resetMiniFilter();
    const e = this.getModel();
    (this.setFilterParams.excelMode || !this.areModelsEqual(e, this.getModelFromUi())) && (this.resetUiToActiveModel(e), this.showOrHideResults());
  }
  applyModel(e = "api") {
    this.setFilterParams.excelMode && e !== "rowDataUpdated" && this.valueModel.isEverythingVisibleSelected() && this.valueModel.selectAllMatchingMiniFilter();
    const t = this.valueModel.showAddCurrentSelectionToFilter() && this.valueModel.isAddCurrentSelectionToFilterChecked();
    if (t && !this.getModel())
      return !1;
    const s = super.applyModel(e), i = this.getModel();
    return i ? (t || this.valueModel.setAppliedModelKeys(/* @__PURE__ */ new Set()), i.values.forEach((r) => {
      this.valueModel.addToAppliedModelKeys(r);
    })) : t || this.valueModel.setAppliedModelKeys(null), s;
  }
  isModelValid(e) {
    return this.setFilterParams.excelMode ? e == null || e.values.length > 0 : !0;
  }
  doesFilterPass(e) {
    if (!this.valueModel.getCaseFormattedAppliedModelKeys())
      return !0;
    if (!this.valueModel.hasAnyAppliedModelKey())
      return !1;
    const { node: t } = e;
    if (this.treeDataTreeList)
      return this.doesFilterPassForTreeData(t);
    if (this.groupingTreeList)
      return this.doesFilterPassForGrouping(t);
    const s = this.getValueFromNode(t);
    return s != null && Array.isArray(s) ? s.length === 0 ? this.valueModel.hasAppliedModelKey(null) : s.some((i) => this.isInAppliedModel(this.createKey(i, t))) : this.isInAppliedModel(this.createKey(s, t));
  }
  doesFilterPassForTreeData(e) {
    var t;
    return (t = e.childrenAfterGroup) != null && t.length ? !1 : this.isInAppliedModel(
      this.createKey(
        Ka(
          e.getRoute() ?? [e.key ?? e.id],
          !0,
          this.gos.get("groupAllowUnbalanced")
        )
      )
    );
  }
  doesFilterPassForGrouping(e) {
    var s;
    const t = (((s = this.rowGroupColsSvc) == null ? void 0 : s.columns) ?? []).map(
      (i) => this.valueSvc.getKeyForNode(i, e)
    );
    return t.push(this.getValueFromNode(e)), this.isInAppliedModel(
      this.createKey(Ka(t, !1, this.gos.get("groupAllowUnbalanced")))
    );
  }
  isInAppliedModel(e) {
    return this.valueModel.hasAppliedModelKey(e);
  }
  getValueFromNode(e) {
    return this.setFilterParams.getValue(e);
  }
  getKeyCreatorParams(e, t = null) {
    const { colDef: s, column: i, api: r, context: o } = this.setFilterParams;
    return {
      value: e,
      colDef: s,
      column: i,
      node: t,
      data: t == null ? void 0 : t.data,
      api: r,
      context: o
    };
  }
  onNewRowsLoaded() {
    this.isValuesTakenFromGrid() && this.syncAfterDataChange();
  }
  isValuesTakenFromGrid() {
    return this.valueModel.getValuesType() === 2;
  }
  //noinspection JSUnusedGlobalSymbols
  /**
   * Public method provided so the user can change the value of the filter once
   * the filter has been already started
   * @param values The values to use.
   */
  setFilterValues(e) {
    this.valueModel.overrideValues(e).then(() => {
      this.checkAndRefreshVirtualList(), this.onUiChanged();
    });
  }
  //noinspection JSUnusedGlobalSymbols
  /**
   * Public method provided so the user can reset the values of the filter once that it has started.
   */
  resetFilterValues() {
    this.valueModel.setValuesType(
      2
      /* TAKEN_FROM_GRID_VALUES */
    ), this.syncAfterDataChange();
  }
  refreshFilterValues() {
    this.valueModel.isInitialised() && this.valueModel.refreshValues().then(() => {
      this.hardRefreshVirtualList = !0, this.checkAndRefreshVirtualList(), this.onUiChanged();
    });
  }
  onAnyFilterChanged() {
    setTimeout(() => {
      this.isAlive() && this.valueModel.refreshAfterAnyFilterChanged().then((e) => {
        e && (this.checkAndRefreshVirtualList(), this.showOrHideResults());
      });
    }, 0);
  }
  onMiniFilterInput() {
    if (!this.valueModel.setMiniFilter(this.eMiniFilter.getValue()))
      return;
    const { applyMiniFilterWhileTyping: e, readOnly: t } = this.setFilterParams;
    !t && e ? this.filterOnAllVisibleValues(!1) : this.updateUiAfterMiniFilterChange();
  }
  updateUiAfterMiniFilterChange() {
    const { excelMode: e, readOnly: t } = this.setFilterParams;
    e == null || t ? this.checkAndRefreshVirtualList() : this.valueModel.getMiniFilter() == null ? this.resetUiToActiveModel(this.getModel()) : (this.valueModel.selectAllMatchingMiniFilter(!0), this.checkAndRefreshVirtualList(), this.onUiChanged()), this.showOrHideResults();
  }
  showOrHideResults() {
    const e = this.valueModel.getMiniFilter() != null && this.valueModel.getDisplayedValueCount() < 1;
    O(this.eFilterNoMatches, e), O(this.eSetFilterList, !e);
  }
  resetMiniFilter() {
    this.eMiniFilter.setValue(null, !0), this.valueModel.setMiniFilter(null);
  }
  resetUiToActiveModel(e, t) {
    this.setModelAndRefresh(e == null ? null : e.values).then(() => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    });
  }
  handleCancelEnd(e) {
    this.setMiniFilter(null), super.handleCancelEnd(e);
  }
  onMiniFilterKeyDown(e) {
    const { excelMode: t, readOnly: s } = this.setFilterParams;
    e.key === w.ENTER && !t && !s && this.filterOnAllVisibleValues();
  }
  filterOnAllVisibleValues(e = !0) {
    this.valueModel.selectAllMatchingMiniFilter(!0), this.checkAndRefreshVirtualList(), this.onUiChanged(!1, e ? "immediately" : "debounce"), this.showOrHideResults();
  }
  focusRowIfAlive(e) {
    e != null && window.setTimeout(() => {
      this.isAlive() && this.virtualList.focusRow(e);
    }, 0);
  }
  onSelectAll(e) {
    e ? this.valueModel.selectAllMatchingMiniFilter() : this.valueModel.deselectAllMatchingMiniFilter(), this.refreshAfterSelection();
  }
  onGroupItemSelected(e, t) {
    const s = (i) => {
      i.children ? i.children.forEach((r) => s(r)) : this.selectItem(i.key, t);
    };
    s(e), this.refreshAfterSelection();
  }
  onItemSelected(e, t) {
    this.selectItem(e, t), this.refreshAfterSelection();
  }
  selectItem(e, t) {
    t ? this.valueModel.selectKey(e) : this.valueModel.deselectKey(e);
  }
  onExpandAll(e, t) {
    const s = (i) => {
      i.filterPasses && i.available && i.children && (i.children.forEach((r) => s(r)), i.expanded = t);
    };
    s(e), this.refreshAfterExpansion();
  }
  onExpandedChanged(e, t) {
    e.expanded = t, this.refreshAfterExpansion();
  }
  refreshAfterExpansion() {
    const e = this.virtualList.getLastFocusedRow();
    this.valueModel.updateDisplayedValues("expansion"), this.checkAndRefreshVirtualList(), this.focusRowIfAlive(e);
  }
  refreshAfterSelection() {
    const e = this.virtualList.getLastFocusedRow();
    this.checkAndRefreshVirtualList(), this.onUiChanged(), this.focusRowIfAlive(e);
  }
  setMiniFilter(e) {
    this.eMiniFilter.setValue(e), this.onMiniFilterInput();
  }
  getMiniFilter() {
    return this.valueModel.getMiniFilter();
  }
  checkAndRefreshVirtualList() {
    this.virtualList.refresh(!this.hardRefreshVirtualList), this.hardRefreshVirtualList && (this.hardRefreshVirtualList = !1);
  }
  getFilterKeys() {
    return this.valueModel.getKeys();
  }
  getFilterValues() {
    return this.valueModel.getValues();
  }
  getValues() {
    return this.getFilterKeys();
  }
  refreshVirtualList() {
    this.setFilterParams.refreshValuesOnOpen ? this.refreshFilterValues() : this.checkAndRefreshVirtualList();
  }
  translateForSetFilter(e) {
    return this.getLocaleTextFunc()(e, Fk[e]);
  }
  isSelectAllSelected() {
    if (this.setFilterParams.defaultToNothingSelected) {
      if (this.valueModel.hasSelections() && this.valueModel.isEverythingVisibleSelected())
        return !0;
      if (this.valueModel.isNothingVisibleSelected())
        return !1;
    } else {
      if (this.valueModel.hasSelections() && this.valueModel.isNothingVisibleSelected())
        return !1;
      if (this.valueModel.isEverythingVisibleSelected())
        return !0;
    }
  }
  areAllChildrenSelected(e) {
    const t = (s) => {
      if (s.children) {
        let i = !1, r = !1;
        return s.children.some((n) => {
          if (!n.filterPasses || !n.available)
            return !1;
          const a = t(n);
          return a === void 0 ? !0 : (a ? i = !0 : r = !0, i && r);
        }) ? void 0 : i;
      } else
        return this.valueModel.isKeySelected(s.key);
    };
    return this.setFilterParams.defaultToNothingSelected ? this.valueModel.hasSelections() && t(e) : t(e);
  }
  destroy() {
    this.virtualList = this.destroyBean(this.virtualList), super.destroy();
  }
  caseFormat(e) {
    return e == null || typeof e != "string" || this.caseSensitive ? e : e.toUpperCase();
  }
  resetExpansion() {
    if (!this.setFilterParams.treeList)
      return;
    const e = this.valueModel.getSelectAllItem();
    if (this.isSetFilterModelTreeItem(e)) {
      const t = (s) => {
        s.children && (s.children.forEach((i) => t(i)), s.expanded = !1);
      };
      t(e), this.valueModel.updateDisplayedValues("expansion");
    }
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e, this);
  }
  getPositionableElement() {
    return this.eSetFilterList;
  }
}, Ak = class {
  constructor(e) {
    this.model = e;
  }
  getRowCount() {
    return this.model.getDisplayedValueCount();
  }
  getRow(e) {
    return this.model.getDisplayedItem(e);
  }
  areRowsEqual(e, t) {
    return e === t;
  }
}, Ik = class {
  constructor(e, t) {
    this.model = e, this.isSelectAllSelected = t;
  }
  getRowCount() {
    const t = this.model.showAddCurrentSelectionToFilter() ? 2 : 1;
    return this.model.getDisplayedValueCount() + t;
  }
  getRow(e) {
    if (e === 0)
      return this.model.getSelectAllItem();
    const t = this.model.showAddCurrentSelectionToFilter(), s = t ? 2 : 1;
    return e === 1 && t ? this.model.getAddSelectionToFilterItem() : this.model.getDisplayedItem(e - s);
  }
  areRowsEqual(e, t) {
    return e === t;
  }
}, Lk = class {
  constructor(e) {
    this.model = e;
  }
  getRowCount() {
    return this.model.getRowCount();
  }
  getRow(e) {
    return this.model.getRow(e);
  }
  areRowsEqual(e, t) {
    return e == null && t == null ? !0 : e != null && t != null && e.treeKey === t.treeKey && e.depth === t.depth;
  }
}, kk = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input ag-set-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [mt]
    ), this.eFloatingFilterText = S, this.availableValuesListenerAdded = !1, this.filterModelFormatter = new nf();
  }
  wireBeans(e) {
    this.colNames = e.colNames;
  }
  init(e) {
    this.params = e, this.eFloatingFilterText.setDisabled(!0).addGuiEventListener("click", () => this.params.showParentFilter()), this.setParams(e);
  }
  setParams(e) {
    const t = this.colNames.getDisplayNameForColumn(e.column, "header", !0), s = this.getLocaleTextFunc();
    this.eFloatingFilterText.setInputAriaLabel(`${t} ${s("ariaFilterInput", "Filter Input")}`);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  onParentModelChanged(e) {
    this.updateFloatingFilterText(e);
  }
  parentSetFilterInstance(e) {
    this.params.parentFilterInstance((t) => {
      if (!(t instanceof af)) {
        z(248);
        return;
      }
      e(t);
    });
  }
  addAvailableValuesListener() {
    this.parentSetFilterInstance((e) => {
      const t = e.getValueModel();
      t && this.addManagedListeners(t, { availableValuesChanged: () => this.updateFloatingFilterText() });
    }), this.availableValuesListenerAdded = !0;
  }
  updateFloatingFilterText(e) {
    this.availableValuesListenerAdded || this.addAvailableValuesListener(), this.parentSetFilterInstance((t) => {
      this.eFloatingFilterText.setValue(this.filterModelFormatter.getModelAsString(e, t));
    });
  }
}, Ok = {
  moduleName: "SetFilter",
  version: j,
  userComponents: { agSetColumnFilter: af, agSetColumnFloatingFilter: kk },
  icons: {
    // set filter tree list group contracted (click to expand)
    setFilterGroupClosed: "tree-closed",
    // set filter tree list group expanded (click to contract)
    setFilterGroupOpen: "tree-open",
    // set filter tree list expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    setFilterGroupIndeterminate: "tree-indeterminate"
  },
  dependsOn: [te, Ds]
}, Gk = (
  /*css*/
  ".ag-status-bar{border-top:var(--ag-footer-row-border);display:flex;justify-content:space-between;line-height:1.5;overflow:hidden;padding-left:calc(var(--ag-spacing)*4);padding-right:calc(var(--ag-spacing)*4)}.ag-status-panel{display:inline-flex}.ag-status-name-value{font-weight:500;margin-left:var(--ag-spacing);margin-right:var(--ag-spacing);padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding);white-space:nowrap}.ag-status-bar-left{display:inline-flex}.ag-status-bar-center{display:inline-flex;text-align:center}.ag-status-bar-right{display:inline-flex}"
);
function Bk(e, t, s) {
  return e.getCompDetails(t, Vk, void 0, s, !0);
}
var Vk = {
  name: "statusPanel",
  optionalMethods: ["refresh"]
}, Nk = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-status-bar">
            <div data-ref="eStatusBarLeft" class="ag-status-bar-left" role="status"></div>
            <div data-ref="eStatusBarCenter" class="ag-status-bar-center" role="status"></div>
            <div data-ref="eStatusBarRight" class="ag-status-bar-right" role="status"></div>
        </div>`
    ), this.updateQueued = !1, this.panelsPromise = U.resolve(), this.eStatusBarLeft = S, this.eStatusBarCenter = S, this.eStatusBarRight = S, this.compDestroyFunctions = {}, this.registerCSS(Gk);
  }
  wireBeans(e) {
    this.userCompFactory = e.userCompFactory, this.statusBarSvc = e.statusBarSvc;
  }
  postConstruct() {
    this.processStatusPanels(/* @__PURE__ */ new Map()), this.addManagedPropertyListeners(["statusBar"], this.handleStatusBarChanged.bind(this));
  }
  processStatusPanels(e) {
    var s;
    const t = (s = this.gos.get("statusBar")) == null ? void 0 : s.statusPanels;
    if (t) {
      const i = t.filter(
        (n) => n.align === "left"
      ), r = t.filter(
        (n) => n.align === "center"
      ), o = t.filter(
        (n) => !n.align || n.align === "right"
      );
      this.panelsPromise = U.all([
        this.createAndRenderComponents(
          i,
          this.eStatusBarLeft,
          e
        ),
        this.createAndRenderComponents(
          r,
          this.eStatusBarCenter,
          e
        ),
        this.createAndRenderComponents(
          o,
          this.eStatusBarRight,
          e
        )
      ]);
    } else
      this.setDisplayed(!1);
  }
  handleStatusBarChanged() {
    this.updateQueued || (this.updateQueued = !0, this.panelsPromise.then(() => {
      this.updateStatusBar(), this.updateQueued = !1;
    }));
  }
  updateStatusBar() {
    var i;
    const e = (i = this.gos.get("statusBar")) == null ? void 0 : i.statusPanels, t = Array.isArray(e) && e.length > 0;
    this.setDisplayed(t);
    const s = /* @__PURE__ */ new Map();
    t && e.forEach((r) => {
      const o = r.key ?? r.statusPanel, n = this.statusBarSvc.getStatusPanel(o);
      if (n != null && n.refresh) {
        const a = this.gos.addGridCommonParams(r.statusPanelParams ?? {});
        n.refresh(a) && (s.set(o, n), delete this.compDestroyFunctions[o], ce(n.getGui()));
      }
    }), this.resetStatusBar(), t && this.processStatusPanels(s);
  }
  resetStatusBar() {
    this.eStatusBarLeft.innerHTML = "", this.eStatusBarCenter.innerHTML = "", this.eStatusBarRight.innerHTML = "", this.destroyComponents(), this.statusBarSvc.unregisterAllComponents();
  }
  destroy() {
    this.destroyComponents(), super.destroy();
  }
  destroyComponents() {
    Object.values(this.compDestroyFunctions).forEach((e) => e()), this.compDestroyFunctions = {};
  }
  createAndRenderComponents(e, t, s) {
    const i = [];
    return e.forEach((r) => {
      const o = r.key || r.statusPanel, n = s.get(o);
      let a;
      if (n)
        a = U.resolve(n);
      else {
        const l = {}, d = Bk(this.userCompFactory, r, l);
        if (d == null)
          return;
        a = d.newAgStackInstance();
      }
      i.push({
        key: o,
        promise: a
      });
    }), U.all(i.map((r) => r.promise)).then(() => {
      i.forEach((r) => {
        r.promise.then((o) => {
          const n = () => {
            this.destroyBean(o);
          };
          this.isAlive() ? (this.statusBarSvc.registerStatusPanel(r.key, o), t.appendChild(o.getGui()), this.compDestroyFunctions[r.key] = n) : n();
        });
      });
    });
  }
}, Hk = {
  selector: "AG-STATUS-BAR",
  component: Nk
}, Ar = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-status-name-value">
            <span data-ref="eLabel"></span>:&nbsp;
            <span data-ref="eValue" class="ag-status-name-value-value"></span>
        </div>`
    ), this.eLabel = S, this.eValue = S;
  }
  setLabel(e, t) {
    this.setDisplayed(!1);
    const s = this.getLocaleTextFunc();
    this.eLabel.innerHTML = s(e, t);
  }
  setValue(e) {
    this.eValue.innerHTML = e;
  }
}, zk = {
  selector: "AG-NAME-VALUE",
  component: Ar
};
function Wk(e, t) {
  return typeof e != "number" ? "" : Xs(Math.round(e * 100) / 100, t);
}
var _k = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-status-panel ag-status-panel-aggregations">
            <ag-name-value data-ref="avgAggregationComp"></ag-name-value>
            <ag-name-value data-ref="countAggregationComp"></ag-name-value>
            <ag-name-value data-ref="minAggregationComp"></ag-name-value>
            <ag-name-value data-ref="maxAggregationComp"></ag-name-value>
            <ag-name-value data-ref="sumAggregationComp"></ag-name-value>
        </div>`,
      [zk]
    ), this.sumAggregationComp = S, this.countAggregationComp = S, this.minAggregationComp = S, this.maxAggregationComp = S, this.avgAggregationComp = S;
  }
  postConstruct() {
    if (!J(this.gos) && !Te(this.gos)) {
      R(221);
      return;
    }
    this.avgAggregationComp.setLabel("avg", "Average"), this.countAggregationComp.setLabel("count", "Count"), this.minAggregationComp.setLabel("min", "Min"), this.maxAggregationComp.setLabel("max", "Max"), this.sumAggregationComp.setLabel("sum", "Sum"), this.addManagedEventListeners({
      cellSelectionChanged: this.onCellSelectionChanged.bind(this),
      modelUpdated: this.onCellSelectionChanged.bind(this)
    });
  }
  init(e) {
    this.refresh(e);
  }
  refresh(e) {
    return this.params = e, this.onCellSelectionChanged(), !0;
  }
  setAggregationComponentValue(e, t, s) {
    var r;
    const i = this.getAllowedAggregationValueComponent(e);
    A(i) && i ? (i.setValue(
      Wk(t, this.getLocaleTextFunc.bind(this))
    ), i.setDisplayed(s)) : (r = this.getAggregationValueComponent(e)) == null || r.setDisplayed(!1);
  }
  getAllowedAggregationValueComponent(e) {
    const { aggFuncs: t } = this.params;
    return !t || t.includes(e) ? this.getAggregationValueComponent(e) : null;
  }
  getAggregationValueComponent(e) {
    const t = `${e}AggregationComp`;
    return this[t];
  }
  onCellSelectionChanged() {
    const e = this.beans, { rangeSvc: t, valueSvc: s, cellNavigation: i } = e, r = t == null ? void 0 : t.getCellRanges();
    let o = 0, n = 0, a = 0, l = null, d = null;
    const c = {};
    if (r != null && r.length && t)
      for (let p = 0; p < r.length; p++) {
        const g = r[p];
        let f = t.getRangeStartRow(g);
        const m = t.getRangeEndRow(g);
        for (; !(Y(f) || !f || Me(m, f) || !f || !g.columns); )
          g.columns.forEach((v) => {
            if (f === null)
              return;
            const b = ns({
              rowPinned: f.rowPinned,
              column: v,
              rowIndex: f.rowIndex
            });
            if (c[b])
              return;
            c[b] = !0;
            const y = St(e, f);
            if (Y(y))
              return;
            let F = s.getValue(v, y);
            Y(F) || F === "" || (n++, !(typeof F == "object" && "value" in F && (F = F.value, F === "")) && (typeof F == "string" && (F = Number(F)), typeof F == "number" && !isNaN(F) && (o += F, (d === null || F > d) && (d = F), (l === null || F < l) && (l = F), a++)));
          }), f = i.getRowBelow(f);
      }
    const h = n > 1, u = a > 1;
    this.setAggregationComponentValue("count", n, h), this.setAggregationComponentValue("sum", o, u), this.setAggregationComponentValue("min", l, u), this.setAggregationComponentValue("max", d, u), this.setAggregationComponentValue("avg", o / a, u);
  }
}, Uk = class extends Ar {
  postConstruct() {
    if (this.setLabel("filteredRows", "Filtered"), !J(this.gos)) {
      R(222);
      return;
    }
    this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-filtered-row-count"), this.setDisplayed(!0);
    const e = this.onDataChanged.bind(this);
    this.addManagedEventListeners({ modelUpdated: e }), e();
  }
  onDataChanged() {
    const e = this.getTotalRowCountValue(), t = this.getFilteredRowCountValue();
    this.setValue(Xs(t, this.getLocaleTextFunc.bind(this))), this.setDisplayed(e !== t);
  }
  getTotalRowCountValue() {
    let e = 0;
    return this.beans.rowModel.forEachNode(() => e += 1), e;
  }
  getFilteredRowCountValue() {
    let e = 0;
    return this.beans.rowModel.forEachNodeAfterFilter((t) => {
      t.group || (e += 1);
    }), e;
  }
  init() {
  }
  refresh() {
    return !0;
  }
}, Kk = class extends Ar {
  postConstruct() {
    const e = this.gos;
    if (!J(e) && !Te(e)) {
      R(223);
      return;
    }
    this.setLabel("selectedRows", "Selected"), this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-selected-row-count"), this.onRowSelectionChanged();
    const t = this.onRowSelectionChanged.bind(this);
    this.addManagedEventListeners({ modelUpdated: t, selectionChanged: t });
  }
  onRowSelectionChanged() {
    var t;
    const e = ((t = this.beans.selectionSvc) == null ? void 0 : t.getSelectionCount()) ?? 0;
    if (e < 0) {
      this.setValue("?"), this.setDisplayed(!0);
      return;
    }
    this.setValue(Xs(e, this.getLocaleTextFunc.bind(this))), this.setDisplayed(e > 0);
  }
  init() {
  }
  refresh() {
    return !0;
  }
}, $k = class extends Ar {
  postConstruct() {
    if (!J(this.gos)) {
      R(224);
      return;
    }
    this.setLabel("totalAndFilteredRows", "Rows"), this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-total-and-filtered-row-count"), this.setDisplayed(!0), this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) }), this.onDataChanged();
  }
  onDataChanged() {
    const e = this.getLocaleTextFunc.bind(this), t = Xs(this.getFilteredRowCountValue(), e), s = Xs(this.getTotalRowCount(), e);
    if (t === s)
      this.setValue(t);
    else {
      const i = this.getLocaleTextFunc();
      this.setValue(`${t} ${i("of", "of")} ${s}`);
    }
  }
  getFilteredRowCountValue() {
    let e = 0;
    return this.beans.rowModel.forEachNodeAfterFilter((t) => {
      t.group || e++;
    }), e;
  }
  getTotalRowCount() {
    let e = 0;
    return this.beans.rowModel.forEachNode((t) => {
      t.group || e++;
    }), e;
  }
  init() {
  }
  refresh() {
    return !0;
  }
}, jk = class extends Ar {
  postConstruct() {
    if (this.setLabel("totalRows", "Total Rows"), !J(this.gos)) {
      R(225);
      return;
    }
    this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-total-row-count"), this.setDisplayed(!0), this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) }), this.onDataChanged();
  }
  onDataChanged() {
    this.setValue(Xs(this.getRowCountValue(), this.getLocaleTextFunc.bind(this)));
  }
  getRowCountValue() {
    let e = 0;
    return this.beans.rowModel.forEachLeafNode(() => e += 1), e;
  }
  init() {
  }
  refresh() {
    return !0;
  }
};
function qk(e, t) {
  var i;
  const s = (i = e.statusBarSvc) == null ? void 0 : i.getStatusPanel(t);
  return Ys(s);
}
var Yk = class extends P {
  // tslint:disable-next-line
  constructor() {
    super(), this.beanName = "statusBarSvc", this.comps = /* @__PURE__ */ new Map();
  }
  registerStatusPanel(e, t) {
    this.comps.set(e, t);
  }
  unregisterStatusPanel(e) {
    this.comps.delete(e);
  }
  unregisterAllComponents() {
    this.comps.clear();
  }
  getStatusPanel(e) {
    return this.comps.get(e);
  }
  destroy() {
    this.unregisterAllComponents(), super.destroy();
  }
}, Xk = {
  moduleName: "StatusBar",
  version: j,
  beans: [Yk],
  userComponents: {
    agAggregationComponent: _k,
    agTotalRowCountComponent: jk,
    agFilteredRowCountComponent: Uk,
    agTotalAndFilteredRowCountComponent: $k,
    agSelectedRowCountComponent: Kk
  },
  selectors: [Hk],
  apiFunctions: {
    getStatusPanel: qk
  },
  dependsOn: [te, cn]
};
function lf(e) {
  var t;
  return ((t = e.excelCreator) == null ? void 0 : t.getFactoryMode()) === "MULTI_SHEET" ? (R(161), !1) : !0;
}
function Zk(e, t) {
  var s;
  if (lf(e))
    return (s = e.excelCreator) == null ? void 0 : s.getDataAsExcel(t);
}
function Qk(e, t) {
  var s;
  lf(e) && ((s = e.excelCreator) == null || s.exportDataAsExcel(t));
}
function Jk(e, t) {
  var s, i;
  return (s = e.excelCreator) == null || s.setFactoryMode("MULTI_SHEET"), (i = e.excelCreator) == null ? void 0 : i.getSheetDataForExcel(t);
}
function e1(e, t) {
  var s;
  return (s = e.excelCreator) == null ? void 0 : s.getMultipleSheetsAsExcel(t);
}
function t1(e, t) {
  var s;
  (s = e.excelCreator) == null || s.exportMultipleSheetsAsExcel(t);
}
var s1 = {
  moduleName: "ExcelExport",
  version: j,
  beans: [mI],
  apiFunctions: {
    getDataAsExcel: Zk,
    exportDataAsExcel: Qk,
    getSheetDataForExcel: Jk,
    getMultipleSheetsAsExcel: e1,
    exportMultipleSheetsAsExcel: t1
  },
  dependsOn: [dg, te]
};
function i1(e) {
  const t = e.cssIdentifier || "default", s = e.direction || "vertical";
  return (
    /* html */
    `
        <div class="ag-group ag-${t}-group" role="presentation">
            <div data-ref="eToolbar" class="ag-group-toolbar ag-${t}-group-toolbar">
                <ag-checkbox data-ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div data-ref="eContainer" class="ag-group-container ag-group-container-${s} ag-${t}-group-container"></div>
        </div>
    `
  );
}
var es = class extends L {
  constructor(e = {}) {
    super(i1(e), [Pt]), this.params = e, this.suppressEnabledCheckbox = !0, this.suppressToggleExpandOnEnableChange = !1, this.eToolbar = S, this.cbGroupEnabled = S, this.eContainer = S;
    const {
      enabled: t,
      items: s,
      suppressEnabledCheckbox: i,
      expanded: r,
      suppressToggleExpandOnEnableChange: o,
      useToggle: n
    } = e;
    this.cssIdentifier = e.cssIdentifier || "default", this.enabled = t ?? !0, this.items = s || [], this.useToggle = n ?? !1, this.alignItems = e.alignItems || "center", this.expanded = r ?? !0, i != null && (this.suppressEnabledCheckbox = i), o != null && (this.suppressToggleExpandOnEnableChange = o);
  }
  postConstruct() {
    if (this.setupTitleBar(), this.items.length) {
      const r = this.items;
      this.items = [], this.addItems(r);
    }
    const e = this.getLocaleTextFunc();
    this.cbGroupEnabled.setLabel(e("enabled", "Enabled")), this.enabled && this.setEnabled(this.enabled, void 0, !0), this.setAlignItems(this.alignItems);
    const { onEnableChange: t, onExpandedChange: s, suppressOpenCloseIcons: i } = this.params;
    this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(i ?? !1), this.refreshChildDisplay(), O(this.eContainer, this.expanded), this.cbGroupEnabled.onValueChange((r) => {
      this.setEnabled(r, !0, this.suppressToggleExpandOnEnableChange), this.dispatchEnableChangeEvent(r);
    }), t != null && this.onEnableChange(t), s != null && this.onExpandedChange(s);
  }
  refreshChildDisplay() {
    var e;
    O(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), (e = this.eTitleBar) == null || e.refreshOnExpand(this.expanded);
  }
  isExpanded() {
    return this.expanded;
  }
  setAlignItems(e) {
    this.alignItems !== e && this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`), this.alignItems = e;
    const t = `ag-group-item-alignment-${this.alignItems}`;
    return this.addCssClass(t), this;
  }
  toggleGroupExpand(e, t) {
    var s;
    if ((s = this.eTitleBar) != null && s.isSuppressCollapse() && !this.useToggle)
      e = !0, t = !0;
    else if (e = e ?? !this.expanded, this.expanded === e)
      return this;
    return this.expanded = e, this.refreshChildDisplay(), O(this.eContainer, e), t || this.dispatchLocalEvent({
      type: e ? "expanded" : "collapsed"
    }), this;
  }
  addItems(e) {
    e.forEach((t) => this.addItem(t));
  }
  prependItem(e) {
    this.insertItem(e, !0);
  }
  addItem(e) {
    this.insertItem(e, !1);
  }
  insertItem(e, t) {
    const s = this.eContainer, i = e instanceof L ? e.getGui() : e;
    i.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`), t ? (s.insertAdjacentElement("afterbegin", i), this.items.unshift(i)) : (s.appendChild(i), this.items.push(i));
  }
  hideItem(e, t) {
    const s = this.items[t];
    O(s, !e);
  }
  getItemIndex(e) {
    const t = e instanceof L ? e.getGui() : e;
    return this.items.indexOf(t);
  }
  setTitle(e) {
    var t;
    return (t = this.eTitleBar) == null || t.setTitle(e), this;
  }
  addTitleBarWidget(e) {
    var t;
    return (t = this.eTitleBar) == null || t.addWidget(e), this;
  }
  addCssClassToTitleBar(e) {
    var t;
    (t = this.eTitleBar) == null || t.addCssClass(e);
  }
  dispatchEnableChangeEvent(e) {
    const t = {
      type: "enableChange",
      enabled: e
    };
    this.dispatchLocalEvent(t);
  }
  setEnabled(e, t, s) {
    var i;
    return this.enabled = e, this.refreshDisabledStyles(), s || this.toggleGroupExpand(e), t || (this.cbGroupEnabled.setValue(e), (i = this.eToggle) == null || i.setValue(e)), this;
  }
  isEnabled() {
    return this.enabled;
  }
  onEnableChange(e) {
    return this.addManagedListeners(this, { enableChange: (t) => e(t.enabled) }), this;
  }
  onExpandedChange(e) {
    return this.addManagedListeners(this, {
      expanded: () => e(!0),
      collapsed: () => e(!1)
    }), this;
  }
  hideEnabledCheckbox(e) {
    return this.suppressEnabledCheckbox = e, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
  }
  hideOpenCloseIcons(e) {
    var t;
    return (t = this.eTitleBar) == null || t.hideOpenCloseIcons(e), this;
  }
  refreshDisabledStyles() {
    var t;
    const e = !this.enabled;
    this.eContainer.classList.toggle("ag-disabled", e), (t = this.eTitleBar) == null || t.refreshDisabledStyles(this.suppressEnabledCheckbox && e), this.eContainer.classList.toggle("ag-disabled-group-container", e);
  }
  setupTitleBar() {
    const e = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
    this.eToolbar.insertAdjacentElement("beforebegin", e.getGui());
  }
  createDefaultTitleBar() {
    const e = this.createManagedBean(new o1(this.params));
    return this.eTitleBar = e, e.refreshOnExpand(this.expanded), this.addManagedListeners(e, {
      expandedChanged: (t) => this.toggleGroupExpand(t.expanded)
    }), e;
  }
  createToggleTitleBar() {
    const e = this.createManagedBean(
      new Ii({
        value: this.enabled,
        label: this.params.title,
        labelAlignment: "left",
        labelWidth: "flex",
        onValueChange: (t) => {
          this.setEnabled(t, !0), this.dispatchEnableChangeEvent(t);
        }
      })
    );
    return e.addCssClass("ag-group-title-bar"), e.addCssClass(`ag-${this.params.cssIdentifier ?? "default"}-group-title-bar ag-unselectable`), this.eToggle = e, this.toggleGroupExpand(this.enabled), e;
  }
}, sa = "ag-disabled-group-title-bar";
function r1(e) {
  const t = e.cssIdentifier ?? "default", s = e.suppressKeyboardNavigation ? "presentation" : "role";
  return (
    /* html */
    `
        <div class="ag-group-title-bar ag-${t}-group-title-bar ag-unselectable" role="${s}">
            <span class="ag-group-title-bar-icon ag-${t}-group-title-bar-icon" data-ref="eGroupOpenedIcon" role="presentation"></span>
            <span class="ag-group-title-bar-icon ag-${t}-group-title-bar-icon" data-ref="eGroupClosedIcon" role="presentation"></span>
            <span data-ref="eTitle" class="ag-group-title ag-${t}-group-title"></span>
        </div>
    `
  );
}
var o1 = class extends L {
  constructor(e = {}) {
    super(r1(e)), this.suppressOpenCloseIcons = !1, this.suppressKeyboardNavigation = !1, this.eGroupOpenedIcon = S, this.eGroupClosedIcon = S, this.eTitle = S;
    const { title: t, suppressOpenCloseIcons: s, suppressKeyboardNavigation: i } = e;
    t && t.length > 0 && (this.title = t), s != null && (this.suppressOpenCloseIcons = s), this.suppressKeyboardNavigation = i ?? !1;
  }
  postConstruct() {
    this.setTitle(this.title), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract();
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(ms("accordionClosed", this.beans, null)), this.eGroupOpenedIcon.appendChild(ms("accordionOpen", this.beans, null)), this.addManagedElementListeners(this.getGui(), {
      click: () => this.dispatchExpandChanged(),
      keydown: (e) => {
        switch (e.key) {
          case w.ENTER:
          case w.SPACE:
            e.preventDefault(), this.dispatchExpandChanged();
            break;
          case w.RIGHT:
          case w.LEFT:
            e.preventDefault(), this.dispatchExpandChanged(e.key === w.RIGHT);
            break;
        }
      }
    });
  }
  refreshOnExpand(e) {
    this.refreshAriaStatus(e), this.refreshOpenCloseIcons(e);
  }
  refreshAriaStatus(e) {
    this.suppressOpenCloseIcons || He(this.getGui(), e);
  }
  refreshOpenCloseIcons(e) {
    const t = !this.suppressOpenCloseIcons;
    O(this.eGroupOpenedIcon, t && e), O(this.eGroupClosedIcon, t && !e);
  }
  isSuppressCollapse() {
    return this.suppressOpenCloseIcons;
  }
  dispatchExpandChanged(e) {
    const t = {
      type: "expandedChanged",
      expanded: e
    };
    this.dispatchLocalEvent(t);
  }
  setTitle(e) {
    const t = this.getGui(), s = !!e && e.length > 0;
    e = s ? e : void 0, this.eTitle.textContent = e ?? "", O(t, s), e !== this.title && (this.title = e);
    const i = t.classList.contains(sa);
    return this.refreshDisabledStyles(i), this;
  }
  addWidget(e) {
    return this.getGui().appendChild(e), this;
  }
  hideOpenCloseIcons(e) {
    return this.suppressOpenCloseIcons = e, e && this.dispatchExpandChanged(!0), this;
  }
  refreshDisabledStyles(e) {
    const t = this.getGui();
    e ? (t.classList.add(sa), t.removeAttribute("tabindex")) : (t.classList.remove(sa), typeof this.title == "string" && !this.suppressKeyboardNavigation ? t.setAttribute("tabindex", "0") : t.removeAttribute("tabindex"));
  }
}, le = {
  selector: "AG-GROUP-COMPONENT",
  component: es
};
function df(e) {
  const { filters: t } = e;
  return t && t.length > 0 ? t : [{ filter: "agTextColumnFilter" }, { filter: "agSetColumnFilter" }];
}
function Mc(e, t) {
  if (e != null)
    for (let s = e.length - 1; s >= 0; s--)
      t(e[s], s);
}
function n1(e, t) {
  return t.title != null ? t.title : e instanceof on ? e.getFilterTitle() : "Filter";
}
var cf = class extends Nt {
  constructor() {
    super(
      /* html */
      '<div class="ag-multi-filter ag-menu-list-compact"></div>'
    ), this.filterType = "multi", this.filterDefs = [], this.filters = [], this.guiDestroyFuncs = [], this.filterGuis = [], this.activeFilterIndices = [], this.lastActivatedMenuItem = null, this.afterFiltersReadyFuncs = [];
  }
  postConstruct() {
    this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e)
    });
  }
  init(e) {
    this.params = e, this.filterDefs = df(e);
    const { column: t, filterChangedCallback: s } = e;
    this.column = t, this.filterChangedCallback = s;
    const i = [];
    return this.filterDefs.forEach((r, o) => {
      const n = this.createFilter(r, o);
      n != null && i.push(n);
    }), new U((r) => {
      U.all(i).then((o) => {
        this.filters = o, this.refreshGui("columnMenu").then(() => {
          r();
        });
      });
    }).then(() => {
      this.afterFiltersReadyFuncs.forEach((r) => r()), this.afterFiltersReadyFuncs.length = 0;
    });
  }
  refreshGui(e) {
    return e === this.lastOpenedInContainer ? U.resolve() : (this.tabGuardFeature.removeAllChildrenExceptTabGuards(), this.destroyChildren(), U.all(
      this.filters.map((t, s) => {
        const i = this.filterDefs[s], r = n1(t, i);
        let o;
        if (i.display === "subMenu" && e !== "toolPanel")
          o = this.insertFilterMenu(t, r).then(
            (n) => n.getGui()
          );
        else if (i.display === "subMenu" || i.display === "accordion") {
          const n = this.insertFilterGroup(t, r);
          o = U.resolve(n.getGui());
        } else
          o = U.resolve(t.getGui());
        return o;
      })
    ).then((t) => {
      t.forEach((s, i) => {
        i > 0 && this.appendChild(Be(
          /* html */
          '<div class="ag-filter-separator"></div>'
        )), this.appendChild(s);
      }), this.filterGuis = t, this.lastOpenedInContainer = e;
    }));
  }
  destroyChildren() {
    this.guiDestroyFuncs.forEach((e) => e()), this.guiDestroyFuncs.length = 0, this.filterGuis.length = 0;
  }
  insertFilterMenu(e, t) {
    const s = this.createBean(new Ua());
    return s.init({
      menuItemDef: {
        name: t,
        subMenu: [],
        cssClasses: ["ag-multi-filter-menu-item"],
        menuItem: Hg,
        menuItemParams: {
          cssClassPrefix: "ag-compact-menu-option",
          isCompact: !0
        }
      },
      level: 0,
      isAnotherSubMenuOpen: () => !1,
      childComponent: e,
      contextParams: {
        column: null,
        node: null,
        value: null
      }
    }).then(() => {
      s.setParentComponent(this), this.guiDestroyFuncs.push(() => this.destroyBean(s)), this.addManagedListeners(s, {
        menuItemActivated: (r) => {
          this.lastActivatedMenuItem && this.lastActivatedMenuItem !== r.menuItem && this.lastActivatedMenuItem.deactivate(), this.lastActivatedMenuItem = r.menuItem;
        }
      });
      const i = s.getGui();
      return s.addManagedElementListeners(i, {
        // `AgMenuList` normally handles keyboard navigation, so need to do here
        keydown: (r) => {
          const { key: o } = r;
          switch (o) {
            case w.UP:
            case w.RIGHT:
            case w.DOWN:
            case w.LEFT:
              r.preventDefault(), o === w.RIGHT && s.openSubMenu(!0);
              break;
          }
        },
        focusin: () => s.activate(),
        focusout: () => {
          !s.isSubMenuOpen() && !s.isSubMenuOpening() && s.deactivate();
        }
      }), s;
    });
  }
  insertFilterGroup(e, t) {
    const s = this.createBean(
      new es({
        title: t,
        cssIdentifier: "multi-filter"
      })
    );
    return this.guiDestroyFuncs.push(() => this.destroyBean(s)), s.addItem(e.getGui()), s.toggleGroupExpand(!1), e.afterGuiAttached && s.addManagedListeners(s, {
      expanded: () => e.afterGuiAttached({
        container: this.lastOpenedInContainer,
        suppressFocus: !0,
        hidePopup: this.hidePopup
      })
    }), s;
  }
  isFilterActive() {
    return this.filters.some((e) => e.isFilterActive());
  }
  getLastActiveFilterIndex() {
    const e = this.activeFilterIndices;
    return e.length > 0 ? e[e.length - 1] : null;
  }
  doesFilterPass(e, t) {
    let s = !0;
    return this.filters.forEach((i) => {
      !s || i === t || !i.isFilterActive() || (s = i.doesFilterPass(e));
    }), s;
  }
  getModelFromUi() {
    return {
      filterType: this.filterType,
      filterModels: this.filters.map((t) => {
        const s = t;
        return typeof s.getModelFromUi == "function" ? s.getModelFromUi() : null;
      })
    };
  }
  getModel() {
    return this.isFilterActive() ? {
      filterType: this.filterType,
      filterModels: this.filters.map((t) => t.isFilterActive() ? t.getModel() : null)
    } : null;
  }
  setModel(e) {
    const t = (i, r) => new U((o) => {
      const n = i.setModel(r);
      n ? n.then(() => o()) : o();
    });
    let s = [];
    return e == null ? s = this.filters.map((i, r) => t(i, null).then(() => {
      this.updateActiveList(r);
    })) : this.filters.forEach((i, r) => {
      const o = e.filterModels.length > r ? e.filterModels[r] : null, n = t(i, o).then(() => {
        this.updateActiveList(r);
      });
      s.push(n);
    }), U.all(s).then(() => {
    });
  }
  applyModel(e = "api") {
    let t = !1;
    return this.filters.forEach((s) => {
      s instanceof on && (t = s.applyModel(e) || t);
    }), t;
  }
  getChildFilterInstance(e) {
    return this.filters[e];
  }
  afterGuiAttached(e) {
    let t;
    e ? (this.hidePopup = e.hidePopup, t = this.refreshGui(e.container)) : (this.hidePopup = void 0, t = U.resolve());
    const s = e == null ? void 0 : e.suppressFocus;
    t.then(() => {
      const { filterDefs: i, filters: r, filterGuis: o, beans: n } = this;
      let a = !!s;
      i && Mc(i, (d, c) => {
        const h = c === 0, u = d.display && d.display !== "inline", p = s || !h || u, g = { ...e ?? {}, suppressFocus: p }, f = r == null ? void 0 : r[c];
        if (f && (this.executeFunctionIfExistsOnFilter(f, "afterGuiAttached", g), h && !p && (a = !0)), !s && h && u) {
          const m = o[c];
          m && (ve(m) || m.focus({ preventScroll: !0 }), a = !0);
        }
      });
      const l = q(n);
      !a && (ys(n) || this.getGui().contains(l)) && this.forceFocusOutOfContainer(!0);
    });
  }
  afterGuiDetached() {
    this.executeFunctionIfExists("afterGuiDetached");
  }
  onAnyFilterChanged() {
    this.executeFunctionIfExists("onAnyFilterChanged");
  }
  onNewRowsLoaded() {
    this.executeFunctionIfExists("onNewRowsLoaded");
  }
  destroy() {
    this.filters.forEach((e) => this.destroyBean(e)), this.filters.length = 0, this.destroyChildren(), this.hidePopup = void 0, super.destroy();
  }
  executeFunctionIfExists(e, ...t) {
    Mc(this.filters, (s) => {
      this.executeFunctionIfExistsOnFilter(s, e, t);
    });
  }
  executeFunctionIfExistsOnFilter(e, t, ...s) {
    const i = e[t];
    typeof i == "function" && i.apply(e, s);
  }
  createFilter(e, t) {
    const { filterModifiedCallback: s, doesRowPassOtherFilter: i } = this.params, { filterManager: r, userCompFactory: o } = this.beans;
    let n;
    const a = {
      ...r.createFilterParams(this.column, this.column.getColDef()),
      filterModifiedCallback: s,
      filterChangedCallback: (c) => {
        this.executeWhenAllFiltersReady(() => this.filterChanged(t, c));
      },
      doesRowPassOtherFilter: (c) => i(c) && this.doesFilterPass({ node: c, data: c.data }, n)
    }, l = wu(o, e, a, "agTextColumnFilter");
    if (!l)
      return null;
    const d = l.newAgStackInstance();
    return d.then((c) => n = c), d;
  }
  executeWhenAllFiltersReady(e) {
    var t;
    (((t = this.filters) == null ? void 0 : t.length) ?? 0) > 0 ? e() : this.afterFiltersReadyFuncs.push(e);
  }
  updateActiveList(e) {
    const { filters: t, activeFilterIndices: s } = this, i = t[e];
    be(s, e), i.isFilterActive() && s.push(e);
  }
  filterChanged(e, t) {
    this.updateActiveList(e), this.filterChangedCallback(t);
    const s = this.filters[e];
    this.filters.forEach((i) => {
      i !== s && typeof i.onAnyFilterChanged == "function" && i.onAnyFilterChanged();
    });
  }
  onFocusIn(e) {
    const t = this.lastActivatedMenuItem;
    t != null && !t.getGui().contains(e.target) && (t.deactivate(), this.lastActivatedMenuItem = null);
  }
  getModelAsString(e) {
    var i, r;
    if (!this.filters || !((i = e == null ? void 0 : e.filterModels) != null && i.length))
      return "";
    const t = this.getLastActiveFilterIndex() ?? 0, s = this.filters[t];
    return ((r = s.getModelAsString) == null ? void 0 : r.call(s, e.filterModels[t])) ?? "";
  }
}, a1 = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-multi-floating-filter ag-floating-filter-input"></div>'
    ), this.floatingFilters = [], this.compDetailsList = [];
  }
  init(e) {
    this.params = e;
    const { compDetailsList: t } = this.getCompDetailsList(e);
    return this.setParams(t);
  }
  setParams(e) {
    const t = [];
    return e.forEach((s) => {
      const i = s == null ? void 0 : s.newAgStackInstance();
      i != null && (this.compDetailsList.push(s), t.push(i));
    }), U.all(t).then((s) => {
      s.forEach((i, r) => {
        this.floatingFilters.push(i);
        const o = i.getGui();
        this.appendChild(o), r > 0 && O(o, !1);
      });
    });
  }
  refresh(e) {
    this.params = e;
    const { compDetailsList: t, floatingFilterParamsList: s } = this.getCompDetailsList(e);
    t.length === this.compDetailsList.length && t.every(
      (r, o) => {
        var n;
        return !((n = this.beans.filterManager) != null && n.areFilterCompsDifferent(this.compDetailsList[o], r));
      }
    ) ? s.forEach((r, o) => {
      var a;
      const n = this.floatingFilters[o];
      (a = n.refresh) == null || a.call(n, r);
    }) : (X(this.getGui()), this.destroyBeans(this.floatingFilters), this.floatingFilters = [], this.compDetailsList = [], this.setParams(t));
  }
  getCompDetailsList(e) {
    const t = [], s = [], i = e.filterParams, r = e.currentParentModel;
    return df(i).forEach((o, n) => {
      const a = {
        ...e,
        // set the parent filter instance for each floating filter to the relevant child filter instance
        parentFilterInstance: (d) => {
          this.parentMultiFilterInstance((c) => {
            const h = c.getChildFilterInstance(n);
            h != null && d(h);
          });
        },
        // return the parent model for the specific filter
        currentParentModel: () => {
          var d, c;
          return ((c = (d = r()) == null ? void 0 : d.filterModels) == null ? void 0 : c[n]) ?? null;
        }
      };
      pe(a.filterParams, o.filterParams);
      const l = this.getCompDetails(o, a);
      l && (t.push(l), s.push(a));
    }), { compDetailsList: t, floatingFilterParamsList: s };
  }
  onParentModelChanged(e, t) {
    t && t.afterFloatingFilter || this.parentMultiFilterInstance((s) => {
      if (e == null)
        this.floatingFilters.forEach((i, r) => {
          i.onParentModelChanged(null, t), O(i.getGui(), r === 0);
        });
      else {
        const i = s.getLastActiveFilterIndex();
        this.floatingFilters.forEach((r, o) => {
          const n = e.filterModels.length > o ? e.filterModels[o] : null;
          r.onParentModelChanged(n, t);
          const a = i == null ? o === 0 : o === i;
          O(r.getGui(), a);
        });
      }
    });
  }
  destroy() {
    this.destroyBeans(this.floatingFilters), this.floatingFilters.length = 0, super.destroy();
  }
  getCompDetails(e, t) {
    const { filterManager: s, frameworkOverrides: i, userCompFactory: r } = this.beans, o = Uu(
      i,
      e,
      () => s.getDefaultFloatingFilter(this.params.column)
    ) ?? "agReadOnlyFloatingFilter";
    return yu(r, e, t, o);
  }
  parentMultiFilterInstance(e) {
    this.params.parentFilterInstance((t) => {
      t instanceof cf || z(120), e(t);
    });
  }
}, l1 = {
  moduleName: "MultiFilter",
  version: j,
  userComponents: { agMultiColumnFilter: cf, agMultiColumnFloatingFilter: a1 },
  dependsOn: [te, Ds, Cn]
}, d1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "aggColNameSvc";
  }
  getHeaderName(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const { valueColsSvc: s, colModel: i, rowGroupColsSvc: r } = this.beans, o = e.getColDef().pivotValueColumn, n = A(o);
    let a = null, l;
    if (n) {
      const d = (s == null ? void 0 : s.columns) ?? [], c = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && d.length === 1, h = e.getColDef().pivotTotalColumnIds !== void 0;
      if (c && !h)
        return t;
      a = o ? o.getAggFunc() : null, l = !0;
    } else {
      const d = e.isValueActive(), c = i.isPivotMode() || (r == null ? void 0 : r.columns.length) !== 0;
      d && c ? (a = e.getAggFunc(), l = !0) : l = !1;
    }
    if (l) {
      const d = typeof a == "string" ? a : "func";
      return `${this.getLocaleTextFunc()(d, d)}(${t})`;
    }
    return t;
  }
}, c1 = {
  sum: "Sum",
  first: "First",
  last: "Last",
  min: "Min",
  max: "Max",
  count: "Count",
  avg: "Average"
}, h1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "aggFuncSvc", this.aggFuncsMap = {}, this.initialised = !1;
  }
  postConstruct() {
    this.init();
  }
  init() {
    this.initialised || (this.initialiseWithDefaultAggregations(), this.addAggFuncs(this.gos.get("aggFuncs")));
  }
  initialiseWithDefaultAggregations() {
    const e = this.aggFuncsMap;
    e.sum = u1, e.first = p1, e.last = g1, e.min = f1, e.max = m1, e.count = C1, e.avg = v1, this.initialised = !0;
  }
  isAggFuncPossible(e, t) {
    const i = this.getFuncNames(e).includes(t), r = A(this.aggFuncsMap[t]);
    return i && r;
  }
  getDefaultFuncLabel(e) {
    return c1[e] ?? e;
  }
  getDefaultAggFunc(e) {
    const t = e.getColDef().defaultAggFunc;
    if (A(t) && this.isAggFuncPossible(e, t))
      return t;
    if (this.isAggFuncPossible(e, "sum"))
      return "sum";
    const s = this.getFuncNames(e);
    return s != null && s.length ? s[0] : null;
  }
  addAggFuncs(e) {
    this.init(), e && Object.entries(e).forEach(([t, s]) => {
      this.aggFuncsMap[t] = s;
    });
  }
  getAggFunc(e) {
    return this.init(), this.aggFuncsMap[e];
  }
  getFuncNames(e) {
    const t = e.getColDef().allowedAggFuncs;
    return t ?? Object.keys(this.aggFuncsMap).sort();
  }
  clear() {
    this.aggFuncsMap = {};
  }
};
function u1(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const r = t[i];
    typeof r == "number" ? s === null ? s = r : s += typeof s == "number" ? r : BigInt(r) : typeof r == "bigint" && (s === null ? s = r : s = (typeof s == "bigint" ? s : BigInt(s)) + r);
  }
  return s;
}
function p1(e) {
  return e.values.length > 0 ? e.values[0] : null;
}
function g1(e) {
  return e.values.length > 0 ? V(e.values) : null;
}
function f1(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const r = t[i];
    (typeof r == "number" || typeof r == "bigint") && (s === null || s > r) && (s = r);
  }
  return s;
}
function m1(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const r = t[i];
    (typeof r == "number" || typeof r == "bigint") && (s === null || s < r) && (s = r);
  }
  return s;
}
function C1(e) {
  var r, o;
  const { values: t } = e;
  let s = 0;
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    s += a != null && typeof a.value == "number" ? a.value : 1;
  }
  const i = (o = (r = e.rowNode) == null ? void 0 : r.aggData) == null ? void 0 : o[e.column.getColId()];
  return i && i.value === s ? i : {
    value: s,
    toString: function() {
      return this.value.toString();
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function v1(e) {
  var n, a, l;
  const { values: t } = e;
  let s = 0, i = 0;
  for (let d = 0; d < t.length; d++) {
    const c = t[d];
    let h = null;
    typeof c == "number" || typeof c == "bigint" ? (h = c, i++) : c != null && (typeof c.value == "number" || typeof c.value == "bigint") && typeof c.count == "number" && (h = c.value * (typeof c.value == "number" ? c.count : BigInt(c.count)), i += c.count), typeof h == "number" ? s += typeof s == "number" ? h : BigInt(h) : typeof h == "bigint" && (s = (typeof s == "bigint" ? s : BigInt(s)) + h);
  }
  let r = null;
  i > 0 && (r = s / (typeof s == "number" ? i : BigInt(i)));
  const o = (l = (n = e.rowNode) == null ? void 0 : n.aggData) == null ? void 0 : l[(a = e.column) == null ? void 0 : a.getColId()];
  return o && o.count === i && o.value === r ? o : {
    count: i,
    value: r,
    // the grid by default uses toString to render values for an object, so this
    // is a trick to get the default cellRenderer to display the avg value
    toString: function() {
      return typeof this.value == "number" || typeof this.value == "bigint" ? this.value.toString() : "";
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function w1(e, t) {
  e.aggFuncSvc && e.aggFuncSvc.addAggFuncs(t);
}
function y1(e) {
  e.aggFuncSvc && e.aggFuncSvc.clear();
}
function b1(e, t, s) {
  var i, r;
  (r = (i = e.valueColsSvc) == null ? void 0 : i.setColumnAggFunc) == null || r.call(i, t, s, "api");
}
var S1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "aggStage", this.refreshProps = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), this.step = "aggregate";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.aggFuncSvc = e.aggFuncSvc, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.pivotResultCols = e.pivotResultCols, this.valueSvc = e.valueSvc;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  execute(e) {
    var r, o, n;
    const t = !((o = (r = this.valueColsSvc) == null ? void 0 : r.columns) != null && o.length), s = !this.gos.getCallback("getGroupRowAgg");
    if (t && s && ((n = e.changedPath) != null && n.active))
      return;
    const i = this.createAggDetails(e);
    this.recursivelyCreateAggData(i);
  }
  createAggDetails(e) {
    var o;
    const t = this.colModel.isPivotActive(), s = (o = this.valueColsSvc) == null ? void 0 : o.columns, i = t && this.pivotColsSvc ? this.pivotColsSvc.columns : [];
    return {
      alwaysAggregateAtRootLevel: this.gos.get("alwaysAggregateAtRootLevel"),
      groupIncludeTotalFooter: !!Zo(this.gos),
      changedPath: e.changedPath,
      valueColumns: s ?? [],
      pivotColumns: i,
      filteredOnly: !this.isSuppressAggFilteredOnly(),
      userAggFunc: this.gos.getCallback("getGroupRowAgg")
    };
  }
  isSuppressAggFilteredOnly() {
    return ur(this.gos) !== void 0 || this.gos.get("suppressAggFilteredOnly");
  }
  recursivelyCreateAggData(e) {
    const t = (s) => {
      if (!s.hasChildren()) {
        s.aggData && this.setAggData(s, null);
        return;
      }
      if (s.level === -1 && !e.groupIncludeTotalFooter) {
        const o = !this.colModel.isPivotMode();
        if (!e.alwaysAggregateAtRootLevel && o) {
          this.setAggData(s, null);
          return;
        }
      }
      this.aggregateRowNode(s, e);
    };
    e.changedPath.forEachChangedNodeDepthFirst(t, !0);
  }
  aggregateRowNode(e, t) {
    const s = t.valueColumns.length === 0, i = t.pivotColumns.length === 0;
    let r;
    t.userAggFunc ? r = t.userAggFunc({ nodes: e.childrenAfterFilter }) : s ? r = null : i ? r = this.aggregateRowNodeUsingValuesOnly(e, t) : r = this.aggregateRowNodeUsingValuesAndPivot(e), this.setAggData(e, r), e.sibling && this.setAggData(e.sibling, r);
  }
  aggregateRowNodeUsingValuesAndPivot(e) {
    var r, o;
    const t = {}, s = ((o = (r = this.pivotResultCols) == null ? void 0 : r.getPivotResultCols()) == null ? void 0 : o.list) ?? [];
    let i = !0;
    for (let n = 0; n < s.length; n++) {
      const a = s[n], l = a.getColDef();
      if (l.pivotTotalColumnIds != null) {
        i = !1;
        continue;
      }
      const d = l.pivotKeys ?? [];
      let c;
      e.leafGroup ? c = this.getValuesFromMappedSet(e.childrenMapped, d, l.pivotValueColumn) : c = this.getValuesPivotNonLeaf(e, l.colId), t[l.colId] = this.aggregateValues(
        c,
        l.pivotValueColumn.getAggFunc(),
        l.pivotValueColumn,
        e,
        a
      );
    }
    if (!i)
      for (let n = 0; n < s.length; n++) {
        const a = s[n], l = a.getColDef();
        if (l.pivotTotalColumnIds == null || !l.pivotTotalColumnIds.length)
          continue;
        const d = l.pivotTotalColumnIds.map(
          (c) => t[c]
        );
        t[l.colId] = this.aggregateValues(
          d,
          l.pivotValueColumn.getAggFunc(),
          l.pivotValueColumn,
          e,
          a
        );
      }
    return t;
  }
  aggregateRowNodeUsingValuesOnly(e, t) {
    const s = {}, { changedPath: i, valueColumns: r, filteredOnly: o } = t, n = i.active ? i.getValueColumnsForNode(e, r) : r, a = i.active ? i.getNotValueColumnsForNode(e, r) : null, l = this.getValuesNormal(e, n, o), d = e.aggData;
    return n.forEach((c, h) => {
      s[c.getId()] = this.aggregateValues(
        l[h],
        c.getAggFunc(),
        c,
        e
      );
    }), a && d && a.forEach((c) => {
      s[c.getId()] = d[c.getId()];
    }), s;
  }
  getValuesPivotNonLeaf(e, t) {
    return e.childrenAfterFilter.map((s) => s.aggData[t]);
  }
  getValuesFromMappedSet(e, t, s) {
    let i = e;
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      i = i ? i[o] : null;
    }
    return i ? i.map((r) => this.valueSvc.getValue(s, r)) : [];
  }
  getValuesNormal(e, t, s) {
    const i = [];
    t.forEach(() => i.push([]));
    const r = t.length, o = s ? e.childrenAfterFilter : e.childrenAfterGroup, n = o.length;
    for (let a = 0; a < n; a++) {
      const l = o[a];
      for (let d = 0; d < r; d++) {
        const c = t[d], h = this.valueSvc.getValue(c, l);
        i[d].push(h);
      }
    }
    return i;
  }
  aggregateValues(e, t, s, i, r) {
    const o = typeof t == "string" ? this.aggFuncSvc.getAggFunc(t) : t;
    if (typeof o != "function")
      return z(109, { aggFuncOrString: t }), null;
    const n = o, a = this.gos.addGridCommonParams({
      values: e,
      column: s,
      colDef: s ? s.getColDef() : void 0,
      pivotResultColumn: r,
      rowNode: i,
      data: i ? i.data : void 0
    });
    return n(a);
  }
  setAggData(e, t) {
    const s = e.aggData;
    if (e.aggData = t, e.__localEventService) {
      const i = (r) => {
        const o = e.aggData ? e.aggData[r] : void 0, n = s ? s[r] : void 0;
        if (o === n)
          return;
        const a = this.colModel.getCol(r);
        a && e.dispatchCellChangedEvent(a, o, n);
      };
      if (s)
        for (const r of Object.keys(s))
          i(r);
      if (t)
        for (const r of Object.keys(t))
          (!s || !(r in s)) && i(r);
    }
  }
}, x1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "filterAggStage", this.refreshProps = /* @__PURE__ */ new Set([]), this.step = "filter_aggregates";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    var d, c;
    const t = this.beans.colModel.isPivotMode(), s = ((d = this.filterManager) == null ? void 0 : d.isAggregateFilterPresent()) || ((c = this.filterManager) == null ? void 0 : c.isAggregateQuickFilterPresent()), i = (h) => !h.node.group, r = (h) => h.node.leafGroup, o = ur(this.gos) || (t ? r : i), { changedPath: n } = e, a = (h, u = !1) => {
      h.childrenAfterFilter && (h.childrenAfterAggFilter = h.childrenAfterFilter, u && h.childrenAfterAggFilter.forEach((p) => a(p, u)), this.setAllChildrenCount(h)), h.sibling && (h.sibling.childrenAfterAggFilter = h.childrenAfterAggFilter);
    }, l = (h) => {
      var u;
      h.childrenAfterAggFilter = ((u = h.childrenAfterFilter) == null ? void 0 : u.filter((p) => {
        var m;
        return o({ node: p }) && this.filterManager.doesRowPassAggregateFilters({ rowNode: p }) ? (a(p, !0), !0) : (m = p.childrenAfterAggFilter) == null ? void 0 : m.length;
      })) || null, this.setAllChildrenCount(h), h.sibling && (h.sibling.childrenAfterAggFilter = h.childrenAfterAggFilter);
    };
    n.forEachChangedNodeDepthFirst(s ? l : a, !0);
  }
  /** for tree data, we include all children, groups and leafs */
  setAllChildrenCountTreeData(e) {
    const t = e.childrenAfterAggFilter;
    let s = 0;
    if (t) {
      const i = t.length;
      s = i;
      for (let r = 0; r < i; ++r)
        s += t[r].allChildrenCount ?? 0;
    }
    e.setAllChildrenCount(
      // Maintain the historical behaviour:
      // - allChildrenCount is 0 in the root if there are no children
      // - allChildrenCount is null in any non-root row if there are no children
      s === 0 && e.level >= 0 ? null : s
    );
  }
  /* for grid data, we only count the leafs */
  setAllChildrenCountGridGrouping(e) {
    let t = 0;
    e.childrenAfterAggFilter.forEach((s) => {
      s.group ? t += s.allChildrenCount : t++;
    }), e.setAllChildrenCount(t);
  }
  setAllChildrenCount(e) {
    if (!e.hasChildren()) {
      e.setAllChildrenCount(null);
      return;
    }
    this.gos.get("treeData") ? this.setAllChildrenCountTreeData(e) : this.setAllChildrenCountGridGrouping(e);
  }
}, F1 = /* @__PURE__ */ new Set(["__localEventService", "__objectId", "sticky", "__autoHeights", "__checkAutoHeightsDebounced"]);
function qt(e, t) {
  if (e.sibling)
    return;
  const s = new Qe(t);
  Object.keys(e).forEach((i) => {
    F1.has(i) || (s[i] = e[i]);
  }), s.footer = !0, s.setRowTop(null), s.setRowIndex(null), s.oldRowTop = null, s.id = "rowGroupFooter_" + e.id, s.sibling = e, e.sibling = s;
}
function Xl(e) {
  e.sibling && (e.sibling.setRowTop(null), e.sibling.setRowIndex(null), e.sibling = void 0);
}
var R1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "footerSvc";
  }
  addNodes(e, t, s, i, r, o) {
    var u;
    const n = (u = t[0]) == null ? void 0 : u.parent;
    if (!n)
      return;
    let { index: a } = e;
    const l = i && Zo(this.gos), d = Fi(this.gos), c = i && d({ node: n });
    if (n === r) {
      l === o && (qt(n, this.beans), s(n.sibling, a++));
      return;
    }
    c === o && (qt(n, this.beans), s(n.sibling, a++));
  }
  getTopDisplayIndex(e, t, s, i) {
    let r = t;
    if (e[0].footer) {
      if (t === 0)
        return 0;
      r -= 1;
    }
    const o = e[e.length - 1], n = r >= s.length;
    return o.footer && n ? o.rowIndex : i(r);
  }
}, hf = class extends ul {
  constructor() {
    super(...arguments), this.beanName = "valueColsSvc", this.eventName = "columnValueChanged", this.columnProcessors = {
      set: (e, t, s) => this.setValueActive(t, e, s),
      add: (e, t, s) => this.setValueActive(!0, e, s),
      remove: (e, t, s) => this.setValueActive(!1, e, s)
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColValueActive(e, t, s),
      getIndexFunc: () => {
      },
      getInitialIndexFunc: () => {
      },
      getValueFunc: (e) => {
        const t = e.aggFunc;
        if (t === null || t === "")
          return null;
        if (t !== void 0)
          return !!t;
      },
      getInitialValueFunc: (e) => e.initialAggFunc != null && e.initialAggFunc != ""
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => be(this.columns, e)
    };
  }
  extractCols(e, t) {
    return this.columns = super.extractCols(e, t), this.columns.forEach((s) => {
      const i = s.getColDef();
      i.aggFunc != null && i.aggFunc != "" ? this.setColAggFunc(s, i.aggFunc) : s.getAggFunc() || this.setColAggFunc(s, i.initialAggFunc);
    }), this.columns;
  }
  setColumnAggFunc(e, t, s) {
    if (!e)
      return;
    const i = this.colModel.getColDefCol(e);
    i && (this.setColAggFunc(i, t), this.dispatchColumnChangedEvent(this.eventSvc, this.eventName, [i], s));
  }
  syncColumnWithState(e, t, s) {
    const i = s("aggFunc").value1;
    i !== void 0 && (typeof i == "string" ? (this.setColAggFunc(e, i), e.isValueActive() || (this.setColValueActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e))) : (A(i) && R(33), e.isValueActive() && (this.setColValueActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e))));
  }
  setValueActive(e, t, s) {
    if (e !== t.isValueActive() && (this.setColValueActive(t, e, s), e && !t.getAggFunc() && this.aggFuncSvc)) {
      const i = this.aggFuncSvc.getDefaultAggFunc(t);
      this.setColAggFunc(t, i);
    }
  }
  setColAggFunc(e, t) {
    e.aggFunc = t, e.dispatchStateUpdatedEvent("aggFunc");
  }
  setColValueActive(e, t, s) {
    e.aggregationActive !== t && (e.aggregationActive = t, e.dispatchColEvent("columnValueChanged", s));
  }
}, Zl = {
  moduleName: "SharedAggregation",
  version: j,
  beans: [h1, d1, R1, hf],
  apiFunctions: {
    addAggFuncs: w1,
    clearAggFuncs: y1,
    setColumnAggFunc: b1
  },
  dependsOn: [te]
}, uf = {
  moduleName: "Aggregation",
  version: j,
  beans: [S1, x1],
  rowModels: ["clientSide"],
  dependsOn: [Zl]
}, pf = class extends ul {
  constructor() {
    super(...arguments), this.beanName = "pivotColsSvc", this.eventName = "columnPivotChanged", this.columnProcessors = {
      set: (e, t, s) => this.setColPivotActive(e, t, s),
      add: (e, t, s) => this.setColPivotActive(e, !0, s),
      remove: (e, t, s) => this.setColPivotActive(e, !1, s)
    }, this.columnOrdering = {
      enableProp: "pivot",
      initialEnableProp: "initialPivot",
      indexProp: "pivotIndex",
      initialIndexProp: "initialPivotIndex"
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColPivotActive(e, t, s),
      getIndexFunc: (e) => e.pivotIndex,
      getInitialIndexFunc: (e) => e.initialPivotIndex,
      getValueFunc: (e) => e.pivot,
      getInitialValueFunc: (e) => e.initialPivot
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => be(this.columns, e)
    };
  }
  syncColumnWithState(e, t, s, i) {
    const { value1: r, value2: o } = s("pivot", "pivotIndex");
    (r !== void 0 || o !== void 0) && (typeof o == "number" || r ? (e.isPivotActive() || (this.setColPivotActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e)), i && typeof o == "number" && (i[e.getId()] = o)) : e.isPivotActive() && (this.setColPivotActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e)));
  }
  setColPivotActive(e, t, s) {
    e.pivotActive !== t && (e.pivotActive = t, e.dispatchColEvent("columnPivotChanged", s)), e.dispatchStateUpdatedEvent("pivot");
  }
}, P1 = class extends ul {
  constructor() {
    super(...arguments), this.beanName = "rowGroupColsSvc", this.eventName = "columnRowGroupChanged", this.columnProcessors = {
      set: (e, t, s) => this.setActive(t, e, s),
      add: (e, t, s) => this.setActive(!0, e, s),
      remove: (e, t, s) => this.setActive(!1, e, s)
    }, this.columnOrdering = {
      enableProp: "rowGroup",
      initialEnableProp: "initialRowGroup",
      indexProp: "rowGroupIndex",
      initialIndexProp: "initialRowGroupIndex"
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColRowGroupActive(e, t, s),
      getIndexFunc: (e) => e.rowGroupIndex,
      getInitialIndexFunc: (e) => e.initialRowGroupIndex,
      getValueFunc: (e) => e.rowGroup,
      getInitialValueFunc: (e) => e.initialRowGroup
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => be(this.columns, e)
    };
  }
  moveColumn(e, t, s) {
    if (this.columns.length === 0)
      return;
    const i = this.columns[e], r = this.columns.slice(e, t);
    this.columns.splice(e, 1), this.columns.splice(t, 0, i), this.eventSvc.dispatchEvent({
      type: this.eventName,
      columns: r,
      column: r.length === 1 ? r[0] : null,
      source: s
    });
  }
  syncColumnWithState(e, t, s, i) {
    const { value1: r, value2: o } = s("rowGroup", "rowGroupIndex");
    (r !== void 0 || o !== void 0) && (typeof o == "number" || r ? (e.isRowGroupActive() || (this.setColRowGroupActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e)), i && typeof o == "number" && (i[e.getId()] = o)) : e.isRowGroupActive() && (this.setColRowGroupActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e)));
  }
  setActive(e, t, s) {
    e !== t.isRowGroupActive() && (this.setColRowGroupActive(t, e, s), _h(this.gos, e) && this.colModel.setColsVisible([t], !e, s));
  }
  setColRowGroupActive(e, t, s) {
    e.rowGroupActive !== t && (e.rowGroupActive = t, e.dispatchColEvent("columnRowGroupChanged", s)), e.dispatchStateUpdatedEvent("rowGroup");
  }
}, T1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "autoColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener(
      "autoGroupColumnDef",
      (e) => this.onAutoGroupColumnDefChanged(Ws(e.source))
    );
  }
  addAutoCols(e) {
    this.autoCols != null && (e.list = this.autoCols.list.concat(e.list), e.tree = this.autoCols.tree.concat(e.tree), hu(e));
  }
  createAutoCols(e, t) {
    var D;
    const s = this.beans, { colModel: i, gos: r, rowGroupColsSvc: o, colGroupSvc: n } = s, a = i.isPivotMode(), l = Qo(r, a), d = a ? r.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), c = o == null ? void 0 : o.columns, u = !(c && c.length > 0 || r.get("treeData")) || d || l, p = () => {
      this.autoCols && (xs(s, this.autoCols.tree), this.autoCols = null);
    };
    if (u) {
      p();
      return;
    }
    const g = this.generateAutoCols(c), f = cu(g, ((D = this.autoCols) == null ? void 0 : D.list) || null), m = e.treeDepth, v = (this.autoCols ? this.autoCols.treeDepth : -1) == m;
    if (f && v)
      return;
    p();
    const b = (n == null ? void 0 : n.findDepth(e.tree)) ?? 0, y = (n == null ? void 0 : n.balanceTreeForAutoCols(g, b)) ?? [];
    this.autoCols = {
      list: g,
      tree: y,
      treeDepth: b,
      map: {}
    }, t((x) => {
      if (!x)
        return null;
      const T = x.filter((I) => !en(I));
      return [...g, ...T];
    });
  }
  getAutoCol(e) {
    var t;
    return ((t = this.autoCols) == null ? void 0 : t.list.find((s) => hl(s, e))) ?? null;
  }
  getAutoCols() {
    var e;
    return ((e = this.autoCols) == null ? void 0 : e.list) ?? null;
  }
  generateAutoCols(e = []) {
    const t = [], s = this.gos.get("treeData");
    let i = al(this.gos);
    return s && i && (R(182), i = !1), i ? e.forEach((r, o) => {
      t.push(this.createOneAutoCol(r, o));
    }) : t.push(this.createOneAutoCol()), t;
  }
  updateAutoCols(e) {
    var t;
    (t = this.autoCols) == null || t.list.forEach((s, i) => this.updateOneAutoCol(s, i, e));
  }
  isSuppressAutoCol() {
    const e = this.gos;
    return e.get("groupDisplayType") === "custom" ? !0 : e.get("treeDataDisplayType") === "custom";
  }
  // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
  createOneAutoCol(e, t) {
    let s;
    e ? s = `${Ss}-${e.getId()}` : s = Ss;
    const i = this.createAutoColDef(s, e, t);
    i.colId = s;
    const r = new Jo(i, null, s, !0);
    return this.createBean(r), r;
  }
  /**
   * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef
   */
  updateOneAutoCol(e, t, s) {
    const i = e.getColDef(), r = typeof i.showRowGroup == "string" ? i.showRowGroup : void 0, o = this.beans, n = r != null ? o.colModel.getColDefCol(r) : void 0, a = this.createAutoColDef(e.getId(), n ?? void 0, t);
    e.setColDef(a, null, s), fu(o, e, a, s);
  }
  createAutoColDef(e, t, s) {
    let i = this.createBaseColDef(t);
    const r = this.gos.get("autoGroupColumnDef");
    pe(i, r), i = bo(this.beans, i, e, !0), this.gos.get("treeData") || Y(i.field) && Y(i.valueGetter) && Y(i.filterValueGetter) && i.filter !== "agGroupColumnFilter" && (i.filter = !1), s && s > 0 && (i.headerCheckboxSelection = !1);
    const o = wt(this.gos), n = i.valueGetter || i.field != null;
    return o && !n && (i.sortIndex = void 0, i.initialSort = void 0), i;
  }
  createBaseColDef(e) {
    const t = this.gos.get("autoGroupColumnDef"), i = {
      headerName: this.getLocaleTextFunc()("group", "Group")
    };
    if (t && (t.cellRenderer || t.cellRendererSelector) || (i.cellRenderer = "agGroupCellRenderer"), e) {
      const o = e.getColDef();
      Object.assign(i, {
        headerName: this.beans.colNames.getDisplayNameForColumn(e, "header"),
        headerValueGetter: o.headerValueGetter
      }), o.cellRenderer && Object.assign(i, {
        cellRendererParams: {
          innerRenderer: o.cellRenderer,
          innerRendererParams: o.cellRendererParams
        }
      }), i.showRowGroup = e.getColId();
    } else
      i.showRowGroup = !0;
    return i;
  }
  onAutoGroupColumnDefChanged(e) {
    this.updateAutoCols(e);
  }
  destroy() {
    var e;
    xs(this.beans, (e = this.autoCols) == null ? void 0 : e.tree), super.destroy();
  }
}, gf = class extends P {
  addExpandedCss(e, t) {
    t.isExpandable() && (e.push("ag-row-group"), e.push(t.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted"));
  }
  getRowExpandedListeners(e) {
    const { rowNode: t } = e, s = this.updateExpandedCss.bind(this, e, t);
    return {
      expandedChanged: s,
      hasChildrenChanged: s
    };
  }
  setExpanded(e, t, s, i) {
    if (e.expanded === t)
      return;
    e.expanded = t, e.dispatchRowEvent("expandedChanged");
    const r = { ...Hu(e, this.gos, "rowGroupOpened"), expanded: t, event: s || null };
    this.dispatchExpandedEvent(r, i), this.beans.rowRenderer.refreshCells({ rowNodes: [e] });
  }
  isExpandable(e) {
    return e.footer ? !1 : this.beans.colModel.isPivotMode() ? e.hasChildren() && !e.leafGroup : e.hasChildren() || e.master;
  }
  updateExpandedCss(e, t) {
    const s = t.isExpandable(), i = t.expanded == !0;
    e.forEachGui(void 0, (r) => {
      const o = r.rowComp;
      o.addOrRemoveCssClass("ag-row-group", s), o.addOrRemoveCssClass("ag-row-group-expanded", s && i), o.addOrRemoveCssClass("ag-row-group-contracted", s && !i), He(r.element, s && i);
    });
  }
}, D1 = class extends gf {
  constructor() {
    super(...arguments), this.beanName = "expansionSvc", this.events = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  expandRows(e) {
    const t = new Set(e);
    this.rowModel.forEachNode((s) => {
      s.id && t.has(s.id) && (s.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  expandAll(e) {
    const { gos: t, colModel: s, eventSvc: i } = this.beans, r = this.rowModel, o = t.get("treeData"), n = s.isPivotActive(), a = (d) => {
      d && d.forEach((c) => {
        const h = () => {
          c.expanded = e, a(c.childrenAfterGroup);
        };
        if (o) {
          A(c.childrenAfterGroup) && h();
          return;
        }
        if (n) {
          !c.leafGroup && h();
          return;
        }
        c.group && h();
      });
    }, l = r.rootNode;
    l && a(l.childrenAfterGroup), r.refreshModel({ step: "map" }), i.dispatchEvent({
      type: "expandOrCollapseAll",
      source: e ? "expandAll" : "collapseAll"
    });
  }
  onGroupExpandedOrCollapsed() {
    this.rowModel.refreshModel({ step: "map" });
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameSvc. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpandedEvent(e, t) {
    this.events.push(e);
    const s = () => {
      this.rowModel.onRowGroupOpened(), this.events.forEach((i) => this.eventSvc.dispatchEvent(i)), this.events = [];
    };
    t ? s() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.debounce(s)), this.dispatchExpandedDebounced());
  }
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    const t = this.beans.animationFrameSvc;
    if (!t)
      return () => window.setTimeout(e, 0);
    let s = !1;
    return () => {
      if (!t.active) {
        window.setTimeout(e, 0);
        return;
      }
      s || (s = !0, t.addDestroyTask(() => {
        s = !1, e();
      }));
    };
  }
}, E1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "flattenStage", this.refreshProps = /* @__PURE__ */ new Set([
      "groupHideParentOfSingleChild",
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupTotalRow",
      "masterDetail"
    ]), this.step = "map";
  }
  execute(e) {
    const t = e.rowNode, s = [], i = this.beans.colModel.isPivotMode(), r = i && t.leafGroup, o = r ? [t] : t.childrenAfterSort, n = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(n, o, s, i, 0);
    const a = s.length > 0;
    if (!r && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
    a && n.grandTotalRow) {
      qt(t, this.beans);
      const d = n.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(n, t.sibling, s, 0, d);
    }
    return s;
  }
  getFlattenDetails() {
    let e = this.gos.get("groupHideParentOfSingleChild");
    return e || (e = this.gos.get("groupRemoveSingleChildren"), !e && this.gos.get("groupRemoveLowestSingleChildren") && (e = "leafGroupsOnly")), {
      groupHideParentOfSingleChild: e,
      isGroupMultiAutoColumn: al(this.gos),
      hideOpenParents: this.gos.get("groupHideOpenParents"),
      grandTotalRow: Zo(this.gos),
      groupTotalRow: Fi(this.gos)
    };
  }
  recursivelyAddToRowsToDisplay(e, t, s, i, r) {
    var o;
    if (t != null && t.length)
      for (let n = 0; n < t.length; n++) {
        const a = t[n], l = a.hasChildren(), d = i && !l, c = e.groupHideParentOfSingleChild === !0 && l && a.childrenAfterGroup.length === 1, h = e.groupHideParentOfSingleChild === "leafGroupsOnly" && l && a.leafGroup && a.childrenAfterGroup.length === 1, u = i && a.leafGroup, p = e.hideOpenParents && a.expanded && !a.master && !u;
        if (!d && !p && !c && !h && this.addRowNodeToRowsToDisplay(e, a, s, r), !(i && a.leafGroup))
          if (l) {
            const f = c || h;
            if (a.expanded || f) {
              const m = e.groupTotalRow({ node: a });
              m || Xl(a);
              const C = f ? r : r + 1;
              m === "top" && (qt(a, this.beans), this.addRowNodeToRowsToDisplay(e, a.sibling, s, C)), this.recursivelyAddToRowsToDisplay(
                e,
                a.childrenAfterSort,
                s,
                i,
                C
              ), m === "bottom" && (qt(a, this.beans), this.addRowNodeToRowsToDisplay(e, a.sibling, s, C));
            }
          } else {
            const f = (o = this.beans.masterDetailSvc) == null ? void 0 : o.getDetail(a);
            f && this.addRowNodeToRowsToDisplay(e, f, s, r);
          }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, s, i, r) {
    r ? s.unshift(t) : s.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : i);
  }
}, ff = class extends P {
  wireBeans(e) {
    this.expressionSvc = e.expressionSvc, this.valueSvc = e.valueSvc, this.colModel = e.colModel, this.visibleCols = e.visibleCols, this.userCompFactory = e.userCompFactory, this.ctrlsSvc = e.ctrlsSvc, this.rowGroupColsSvc = e.rowGroupColsSvc, this.selectionSvc = e.selectionSvc, this.groupHideOpenParentsSvc = e.groupHideOpenParentsSvc;
  }
  init(e, t, s, i, r, o, n) {
    var c, h, u;
    this.params = n, this.eGui = t, this.eCheckbox = s, this.eExpanded = i, this.eContracted = r, this.comp = e, this.compClass = o;
    const { node: a, colDef: l } = n, d = this.isTopLevelFooter();
    if (!d) {
      if (this.isEmbeddedRowMismatch())
        return;
      if (a.footer && this.gos.get("groupHideOpenParents")) {
        const g = l == null ? void 0 : l.showRowGroup, f = (c = a.rowGroupColumn) == null ? void 0 : c.getColId();
        if (g !== f)
          return;
      }
    }
    if (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), !d) {
      const p = this.rowGroupColsSvc && a.footer && a.rowGroupIndex === this.rowGroupColsSvc.columns.findIndex((y) => y.getColId() === (l == null ? void 0 : l.showRowGroup)), f = this.gos.get("groupDisplayType") != "multipleColumns" || this.gos.get("treeData") || this.gos.get("showOpenedGroup") && this.rowGroupColsSvc && !a.footer && (!a.group || a.rowGroupIndex != null && a.rowGroupIndex > ((h = this.rowGroupColsSvc) == null ? void 0 : h.columns.findIndex(
        (y) => y.getColId() === (l == null ? void 0 : l.showRowGroup)
      ))), m = !a.group && ((l == null ? void 0 : l.field) || (l == null ? void 0 : l.valueGetter)), C = this.isExpandable(), v = this.colModel.isPivotMode() && a.leafGroup && ((u = a.rowGroupColumn) == null ? void 0 : u.getColId()) === (l == null ? void 0 : l.showRowGroup);
      if (!this.showingValueForOpenedParent && !C && !m && !f && !p && !v)
        return;
    }
    this.addExpandAndContract(), this.addFullWidthRowDraggerIfNeeded(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent(), this.refreshAriaExpanded(), this.addManagedPropertyListener("rowSelection", ({ currentValue: p, previousValue: g }) => {
      const f = typeof p == "object" ? p : void 0, m = typeof g == "object" ? g : void 0;
      (f == null ? void 0 : f.checkboxLocation) !== (m == null ? void 0 : m.checkboxLocation) && this.refreshCheckbox();
    });
  }
  getCellAriaRole() {
    var s, i;
    const e = (s = this.params.colDef) == null ? void 0 : s.cellAriaRole, t = (i = this.params.column) == null ? void 0 : i.getColDef().cellAriaRole;
    return e || t || "gridcell";
  }
  destroy() {
    super.destroy(), this.expandListener = null, this.destroyCheckbox();
  }
  refreshAriaExpanded() {
    const { node: e, eGridCell: t } = this.params;
    if (this.expandListener && (this.expandListener = this.expandListener()), !this.isExpandable()) {
      mh(t);
      return;
    }
    const s = () => {
      He(t, this.showingValueForOpenedParent || !!e.expanded);
    };
    [this.expandListener] = this.addManagedListeners(e, { expandedChanged: s }) || null, s();
  }
  isTopLevelFooter() {
    var r;
    if (!Zo(this.gos) || this.params.value != null || this.params.node.level != -1)
      return !1;
    const t = this.params.colDef;
    if (t == null || t.showRowGroup === !0)
      return !0;
    const i = (r = this.rowGroupColsSvc) == null ? void 0 : r.columns;
    return !i || i.length === 0 ? !0 : i[0].getId() === t.showRowGroup;
  }
  // if we are doing embedded full width rows, we only show the renderer when
  // in the body, or if pinning in the pinned section, or if pinning and RTL,
  // in the right section. otherwise we would have the cell repeated in each section.
  isEmbeddedRowMismatch() {
    if (!this.params.fullWidth || !this.gos.get("embedFullWidthRows"))
      return !1;
    const e = this.params.pinned === "left", t = this.params.pinned === "right", s = !e && !t;
    return this.gos.get("enableRtl") ? this.visibleCols.isPinningLeft() ? !t : !s : this.visibleCols.isPinningLeft() ? !e : !s;
  }
  findDisplayedGroupNode() {
    const e = this.params.column, t = this.params.node;
    if (this.showingValueForOpenedParent) {
      let s = t.parent;
      for (; s != null; ) {
        if (s.rowGroupColumn && e.isRowGroupDisplayed(s.rowGroupColumn.getId())) {
          this.displayedGroupNode = s;
          break;
        }
        s = s.parent;
      }
    }
    Y(this.displayedGroupNode) && (this.displayedGroupNode = t);
  }
  setupShowingValueForOpenedParent() {
    var e;
    this.showingValueForOpenedParent = ((e = this.groupHideOpenParentsSvc) == null ? void 0 : e.isShowingValueForOpenedParent(this.params.node, this.params.column)) ?? !1;
  }
  addValueElement() {
    this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount());
  }
  addGroupValue() {
    var o;
    const e = this.adjustParamsWithDetailsFromRelatedColumn(), t = this.getInnerCompDetails(e), { valueFormatted: s, value: i } = e;
    let r = s;
    if (r == null) {
      const n = this.displayedGroupNode.rowGroupColumn && ((o = this.params.column) == null ? void 0 : o.isRowGroupDisplayed(this.displayedGroupNode.rowGroupColumn.getId()));
      this.displayedGroupNode.key === "" && this.displayedGroupNode.group && n ? r = this.getLocaleTextFunc()("blanks", "(Blanks)") : r = i ?? null;
    }
    this.comp.setInnerRenderer(t, r);
  }
  adjustParamsWithDetailsFromRelatedColumn() {
    const e = this.displayedGroupNode.rowGroupColumn, t = this.params.column;
    if (!e)
      return this.params;
    if (t != null && !t.isRowGroupDisplayed(e.getId()))
      return this.params;
    const i = this.params, { value: r, node: o } = this.params, n = this.valueSvc.formatValue(e, o, r);
    return {
      ...i,
      valueFormatted: n
    };
  }
  addFooterValue() {
    const e = this.params.totalValueGetter;
    let t = "";
    if (e) {
      const i = {
        ...this.params,
        value: this.params.value
      };
      typeof e == "function" ? t = e(i) : typeof e == "string" ? t = this.expressionSvc ? this.expressionSvc.evaluate(e, i) : "" : R(179);
    } else
      t = this.getLocaleTextFunc()("footerTotal", "Total") + " " + (this.params.value != null ? this.params.value : "");
    const s = this.getInnerCompDetails(this.params);
    this.comp.setInnerRenderer(s, t);
  }
  getInnerCompDetails(e) {
    if (e.fullWidth)
      return Gn(this.userCompFactory, this.gos.get("groupRowRendererParams"), e);
    const t = Gn(
      this.userCompFactory,
      e,
      e
    ), s = (n) => n && n.componentClass == this.compClass;
    if (t && !s(t))
      return t;
    const i = this.displayedGroupNode.rowGroupColumn, r = i == null ? void 0 : i.getColDef();
    if (!r)
      return;
    const o = So(this.userCompFactory, r, e);
    if (o && !s(o))
      return o;
    if (s(o) && r.cellRendererParams && r.cellRendererParams.innerRenderer)
      return Gn(
        this.userCompFactory,
        r.cellRendererParams,
        e
      );
  }
  addChildCount() {
    this.params.suppressCount || (this.addManagedListeners(this.displayedGroupNode, {
      allChildrenCountChanged: this.updateChildCount.bind(this)
    }), this.updateChildCount());
  }
  updateChildCount() {
    const e = this.displayedGroupNode.allChildrenCount, i = this.isShowRowGroupForThisRow() && e != null && e >= 0 ? `(${e})` : "";
    this.comp.setChildCount(i);
  }
  isShowRowGroupForThisRow() {
    if (this.gos.get("treeData"))
      return !0;
    const e = this.displayedGroupNode.rowGroupColumn;
    if (!e)
      return !1;
    const t = this.params.column;
    return t == null || t.isRowGroupDisplayed(e.getId());
  }
  addExpandAndContract() {
    var o;
    const e = this.params, t = (n, a) => {
      const l = B(n, this.beans, null);
      l && (a.appendChild(l), this.addDestroyFunc(() => a.removeChild(l)));
    };
    t("groupExpanded", this.eExpanded), t("groupContracted", this.eContracted);
    const s = e.eGridCell;
    !(((o = this.params.column) == null ? void 0 : o.isCellEditable(e.node)) && this.gos.get("enableGroupEdit")) && this.isExpandable() && !e.suppressDoubleClickExpand && this.addManagedListeners(s, { dblclick: this.onCellDblClicked.bind(this) }), this.addManagedListeners(this.eExpanded, { click: this.onExpandClicked.bind(this) }), this.addManagedListeners(this.eContracted, { click: this.onExpandClicked.bind(this) }), this.addManagedListeners(s, { keydown: this.onKeyDown.bind(this) }), this.addManagedListeners(e.node, { expandedChanged: this.showExpandAndContractIcons.bind(this) }), this.showExpandAndContractIcons();
    const r = this.onRowNodeIsExpandableChanged.bind(this);
    this.addManagedListeners(this.displayedGroupNode, {
      allChildrenCountChanged: r,
      masterChanged: r,
      groupChanged: r,
      hasChildrenChanged: r
    });
  }
  onExpandClicked(e) {
    nt(e) || (he(e), this.onExpandOrContract(e));
  }
  onExpandOrContract(e) {
    const t = this.displayedGroupNode, s = !t.expanded;
    !s && t.sticky && this.scrollToStickyNode(t), t.setExpanded(s, e);
  }
  scrollToStickyNode(e) {
    this.ctrlsSvc.getScrollFeature().setVerticalScrollPosition(e.rowTop - e.stickyRowTop);
  }
  isExpandable() {
    if (this.showingValueForOpenedParent)
      return !0;
    const e = this.displayedGroupNode, t = this.colModel.isPivotMode() && e.leafGroup;
    if (!(e.isExpandable() && !e.footer && !t))
      return !1;
    const i = this.params.column;
    return i != null && typeof i.getColDef().showRowGroup == "string" ? this.isShowRowGroupForThisRow() : !0;
  }
  showExpandAndContractIcons() {
    const { params: e, displayedGroupNode: t, colModel: s } = this, { node: i } = e, r = this.isExpandable();
    if (r) {
      const d = this.showingValueForOpenedParent ? !0 : i.expanded;
      this.comp.setExpandedDisplayed(d), this.comp.setContractedDisplayed(!d);
    } else
      this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
    const o = s.isPivotMode(), n = o && t.leafGroup, a = r && !n, l = i.footer && i.level === -1;
    this.comp.addOrRemoveCssClass("ag-cell-expandable", a), this.comp.addOrRemoveCssClass("ag-row-group", a), o ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", !!n) : l || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !a);
  }
  onRowNodeIsExpandableChanged() {
    this.showExpandAndContractIcons(), this.setIndent(), this.refreshAriaExpanded();
  }
  setupIndent() {
    const e = this.params.node;
    this.params.suppressPadding || (this.addManagedListeners(e, { uiLevelChanged: this.setIndent.bind(this) }), this.setIndent());
  }
  setIndent() {
    if (this.gos.get("groupHideOpenParents"))
      return;
    const e = this.params, t = e.node, s = !!e.colDef, i = this.gos.get("treeData"), o = !s || i || e.colDef.showRowGroup === !0 ? t.uiLevel : 0;
    this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + o, this.comp.addOrRemoveCssClass(this.indentClass, !0), this.eGui.style.setProperty("--ag-indentation-level", String(o));
  }
  addFullWidthRowDraggerIfNeeded() {
    if (!this.params.fullWidth || !this.params.rowDrag || !this.rowDragSvc)
      return;
    const e = this.rowDragSvc.createRowDragComp(() => this.params.value, this.params.node);
    this.createManagedBean(e), this.eGui.insertAdjacentElement("afterbegin", e.getGui());
  }
  addCheckboxIfNeeded() {
    const e = this.displayedGroupNode, t = this.gos.get("rowSelection"), s = vo(t), i = typeof t == "object" ? s === "autoGroupColumn" && zs(t) : this.params.checkbox, o = (typeof i == "function" || i === !0) && // footers cannot be selected
    !e.footer && // pinned rows cannot be selected
    !e.rowPinned && // details cannot be selected
    !e.detail && !!this.selectionSvc && ot(this.gos);
    if (o) {
      const n = this.selectionSvc.createCheckboxSelectionComponent();
      this.cbComp = n, this.createBean(n), n.init({
        rowNode: this.params.node,
        // when groupHideOpenParents = true and group expanded, we want the checkbox to refer to leaf node state (not group node state)
        column: this.params.column,
        overrides: {
          isVisible: i,
          callbackParams: this.params,
          removeHidden: !0
        }
      }), this.eCheckbox.appendChild(n.getGui());
    }
    this.comp.setCheckboxVisible(o);
  }
  destroyCheckbox() {
    this.cbComp && this.eCheckbox.removeChild(this.cbComp.getGui()), this.cbComp = this.destroyBean(this.cbComp);
  }
  refreshCheckbox() {
    this.destroyCheckbox(), this.addCheckboxIfNeeded();
  }
  onKeyDown(e) {
    !(e.key === w.ENTER) || this.params.suppressEnterExpand || this.params.column && this.params.column.isCellEditable(this.params.node) || this.onExpandOrContract(e);
  }
  onCellDblClicked(e) {
    if (nt(e))
      return;
    wa(this.eExpanded, e) || wa(this.eContracted, e) || this.onExpandOrContract(e);
  }
}, M1 = (
  /* html */
  `<span class="ag-cell-wrapper">
        <span class="ag-group-expanded" data-ref="eExpanded"></span>
        <span class="ag-group-contracted" data-ref="eContracted"></span>
        <span class="ag-group-checkbox ag-invisible" data-ref="eCheckbox"></span>
        <span class="ag-group-value" data-ref="eValue"></span>
        <span class="ag-group-child-count" data-ref="eChildCount"></span>
    </span>`
), Ac = class extends L {
  constructor() {
    super(M1), this.eExpanded = S, this.eContracted = S, this.eCheckbox = S, this.eValue = S, this.eChildCount = S;
  }
  init(e) {
    const t = {
      setInnerRenderer: (o, n) => this.setRenderDetails(o, n),
      setChildCount: (o) => this.eChildCount.textContent = o,
      addOrRemoveCssClass: (o, n) => this.addOrRemoveCssClass(o, n),
      setContractedDisplayed: (o) => O(this.eContracted, o),
      setExpandedDisplayed: (o) => O(this.eExpanded, o),
      setCheckboxVisible: (o) => this.eCheckbox.classList.toggle("ag-invisible", !o)
    }, s = this.createManagedBean(new ff()), i = !e.colDef, r = this.getGui();
    s.init(t, r, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, e), i && re(r, s.getCellAriaRole());
  }
  setRenderDetails(e, t) {
    e ? e.newAgStackInstance().then((s) => {
      if (!s)
        return;
      const i = () => this.destroyBean(s);
      this.isAlive() ? (this.eValue.appendChild(s.getGui()), this.addDestroyFunc(i)) : i();
    }) : this.eValue.innerText = t;
  }
  destroy() {
    this.destroyBean(this.innerCellRenderer), super.destroy();
  }
  refresh() {
    return !1;
  }
}, A1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "showRowGroupCols";
  }
  refresh() {
    this.showRowGroupCols = [], this.showRowGroupColsMap = {};
    const { colModel: e, rowGroupColsSvc: t } = this.beans;
    e.getCols().forEach((s) => {
      const r = s.getColDef().showRowGroup, o = typeof r == "string";
      !o && !(r === !0) || (this.showRowGroupCols.push(s), o ? this.showRowGroupColsMap[r] = s : t && t.columns.forEach((a) => {
        this.showRowGroupColsMap[a.getId()] = s;
      }));
    });
  }
  getShowRowGroupCols() {
    return this.showRowGroupCols;
  }
  getShowRowGroupCol(e) {
    return this.showRowGroupColsMap[e];
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    const { rowGroupColsSvc: s, colModel: i } = this.beans;
    if (t === !0 && s)
      return s.columns.slice(0);
    const r = i.getColDefCol(t);
    return r ? [r] : null;
  }
  isRowGroupDisplayed(e, t) {
    const { colDef: s } = e;
    if ((s == null ? void 0 : s.showRowGroup) == null)
      return !1;
    const i = s.showRowGroup === !0, r = s.showRowGroup === t;
    return i || r;
  }
}, I1 = class extends P {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  postConstruct() {
    this.isClientSide = J(this.gos), this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    }), this.resetStickyContainers();
  }
  setOffsetTop(e) {
    this.extraTopHeight !== e && (this.extraTopHeight = e, this.eventSvc.dispatchEvent({
      type: "stickyTopOffsetChanged",
      offset: e
    }));
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? k1(e) : L1(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let s = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), s);
    const { rowModel: i, rowRenderer: r } = this.beans, o = t ? r.firstVisibleVPixel - this.extraTopHeight : r.lastVisibleVPixel - this.extraTopHeight, n = /* @__PURE__ */ new Set(), a = (h) => {
      if (n.add(h), t) {
        const u = this.getLastPixelOfGroup(h), p = o + s + h.rowHeight;
        u < p ? h.stickyRowTop = s + (u - p) : h.stickyRowTop = s;
      } else {
        const u = this.getFirstPixelOfGroup(h), p = o - (s + h.rowHeight);
        u > p ? h.stickyRowTop = s - (u - p) : h.stickyRowTop = s;
      }
      s = 0, n.forEach((u) => {
        const p = u.stickyRowTop + u.rowHeight;
        s < p && (s = p);
      });
    }, l = this.areFooterRowsStickySuppressed(), d = this.gos.get("suppressGroupRowsSticky"), c = (h) => {
      if (!h.displayed)
        return !1;
      if (h.footer) {
        if (l === !0 || l === "grand" && h.level === -1 || l === "group" && h.level > -1)
          return !1;
        const u = h.sibling.rowIndex ? h.sibling.rowIndex + 1 === h.rowIndex : !1;
        return e === "bottom" && u ? !1 : !n.has(h);
      }
      return h.isExpandable() ? d === !0 || e === "bottom" ? !1 : !n.has(h) && h.expanded : !1;
    };
    for (let h = 0; h < 100; h++) {
      let u = o + s;
      t || (u = o - s);
      const p = i.getRowIndexAtPixel(u), g = i.getRow(p);
      if (g == null)
        break;
      const m = this.getStickyAncestors(g).find(
        (v) => (t ? v.rowIndex < p : v.rowIndex > p) && c(v)
      );
      if (m) {
        a(m);
        continue;
      }
      if ((t ? g.rowTop < u : g.rowTop + g.rowHeight > u) && c(g)) {
        a(g);
        continue;
      }
      break;
    }
    return t || n.forEach((h) => {
      h.stickyRowTop = s - (h.stickyRowTop + h.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, n, s);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = e === "group", s = e === "grand";
    return t && s ? !0 : s ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = Xo(this.gos), t = this.areFooterRowsStickySuppressed(), s = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !s);
  }
  getStickyAncestors(e) {
    const t = [];
    let s = e.footer ? e.sibling : e.parent;
    for (; s; )
      s.sibling && t.push(s.sibling), t.push(s), s = s.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.resetStickyContainers();
  }
  resetStickyContainers() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((s) => s.rowNode === e)) {
      for (let s = 0; s < this.stickyTopRowCtrls.length; s++) {
        const i = this.stickyTopRowCtrls[s].rowNode;
        i !== e && t.add(i);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let s = 0; s < this.stickyBottomRowCtrls.length; s++) {
      const i = this.stickyBottomRowCtrls[s].rowNode;
      i !== e && t.add(i);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, s) {
    const i = e === "top", r = i ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, o = {}, n = [];
    for (let p = 0; p < r.length; p++) {
      const g = r[p].rowNode;
      if (!t.has(g)) {
        o[g.id] = r[p], g.sticky = !1;
        continue;
      }
      n.push(r[p]);
    }
    const a = /* @__PURE__ */ new Set();
    for (let p = 0; p < n.length; p++)
      a.add(n[p].rowNode);
    const l = [];
    t.forEach((p) => {
      a.has(p) || (p.sticky = !0, l.push(this.createRowCon(p, !1, !1)));
    });
    let d = !!l.length || n.length !== r.length;
    i ? this.topContainerHeight !== s && (this.topContainerHeight = s, this.gridBodyCtrl.setStickyTopHeight(s), d = !0) : this.bottomContainerHeight !== s && (this.bottomContainerHeight = s, this.gridBodyCtrl.setStickyBottomHeight(s), d = !0), this.destroyRowCtrls(o, !1);
    const c = [...n, ...l];
    c.sort((p, g) => g.rowNode.rowIndex - p.rowNode.rowIndex), i || c.reverse(), c.forEach((p) => p.setRowTop(p.rowNode.stickyRowTop));
    const h = this.beans.pageBounds;
    let u = 0;
    return i ? (t.forEach((p) => {
      p.rowIndex < h.getFirstRow() && (u += p.rowHeight);
    }), u > this.topContainerHeight && (u = this.topContainerHeight), this.setOffsetTop(u)) : (t.forEach((p) => {
      p.rowIndex > h.getLastRow() && (u += p.rowHeight);
    }), u > this.bottomContainerHeight && (u = this.bottomContainerHeight), this.setOffsetBottom(u)), d ? (i ? this.stickyTopRowCtrls = c : this.stickyBottomRowCtrls = c, !0) : !1;
  }
  ensureRowHeightsValid() {
    let e = !1;
    const t = (s) => {
      const i = s.rowNode;
      if (i.rowHeightEstimated) {
        const r = Ie(this.beans, i);
        i.setRowHeight(r.height), e = !0;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
};
function L1(e) {
  var t, s;
  if (e.isExpandable() || e.footer) {
    if (e.master)
      return e.detailNode.rowTop + e.detailNode.rowHeight;
    if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
      let r = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
      return e.footer && (r = (s = e.sibling.childStore) == null ? void 0 : s.getStoreBounds()), ((r == null ? void 0 : r.heightPx) ?? 0) + ((r == null ? void 0 : r.topPx) ?? 0);
    }
    return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
  }
  return Number.MAX_SAFE_INTEGER;
}
function k1(e) {
  if (e.isExpandable() || e.footer) {
    if (e.footer && e.rowIndex === 0)
      return Number.MAX_SAFE_INTEGER;
    if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
      let i = e.footer ? e.sibling : e;
      for (; i.isExpandable() && i.expanded; )
        if (i.master)
          i = i.detailNode;
        else if (i.childrenAfterSort) {
          if (i.childrenAfterSort.length === 0)
            break;
          i = V(i.childrenAfterSort);
        }
      return i.rowTop + i.rowHeight;
    }
    return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
  }
  return Number.MAX_SAFE_INTEGER;
}
var O1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "stickyRowSvc";
  }
  createStickyRowFeature(e, t, s) {
    const i = this.gos;
    if (Xo(i) && J(i) || Te(i))
      return e.createManagedBean(new I1(t, s));
  }
}, mf = {
  moduleName: "GroupCellRenderer",
  version: j,
  userComponents: {
    agGroupRowRenderer: Ac,
    agGroupCellRenderer: Ac
  },
  dynamicBeans: { groupCellRendererCtrl: ff },
  icons: {
    // shown on row group when contracted (click to expand)
    groupContracted: "tree-closed",
    // shown on row group when expanded (click to contract)
    groupExpanded: "tree-open"
  },
  dependsOn: [te]
}, Cf = {
  moduleName: "GroupColumn",
  version: j,
  beans: [T1, A1, P1, pf, hf],
  dependsOn: [te, mf]
}, vn = {
  moduleName: "ClientSideRowModelHierarchy",
  version: j,
  rowModels: ["clientSide"],
  beans: [E1, D1],
  dependsOn: [te]
}, Ql = {
  moduleName: "StickyRow",
  version: j,
  beans: [O1]
}, G1 = class extends L {
  constructor() {
    super();
  }
  postConstruct() {
    this.setGui(this.createNorthPanel());
    const e = this.onRowGroupChanged.bind(this);
    this.addManagedEventListeners({
      columnRowGroupChanged: e,
      newColumnsLoaded: e
    }), this.addManagedPropertyListener("rowGroupPanelShow", e), this.addManagedPropertyListener("pivotPanelShow", () => this.onPivotPanelShow()), this.onRowGroupChanged();
  }
  createNorthPanel() {
    const e = document.createElement("div");
    e.classList.add("ag-column-drop-wrapper"), re(e, "presentation");
    const t = new tf(!0);
    this.rowGroupComp = this.createManagedBean(t);
    const s = new ef(!0);
    this.pivotComp = this.createManagedBean(s), e.appendChild(t.getGui()), e.appendChild(s.getGui());
    const i = this.onDropPanelVisible.bind(this);
    return this.addManagedListeners(t, {
      displayChanged: i
    }), this.addManagedListeners(s, {
      displayChanged: i
    }), this.onDropPanelVisible(), e;
  }
  onDropPanelVisible() {
    const { rowGroupComp: e, pivotComp: t } = this, s = e.isDisplayed() && t.isDisplayed(), i = "ag-column-drop-horizontal-half-width";
    e.addOrRemoveCssClass(i, s), t.addOrRemoveCssClass(i, s);
  }
  onRowGroupChanged() {
    var s, i;
    const e = this.rowGroupComp;
    if (!e)
      return;
    const t = this.gos.get("rowGroupPanelShow");
    if (t === "always")
      e.setDisplayed(!0);
    else if (t === "onlyWhenGrouping") {
      const r = ((i = (s = this.beans.rowGroupColsSvc) == null ? void 0 : s.columns) == null ? void 0 : i.length) !== 0;
      e.setDisplayed(r);
    } else
      e.setDisplayed(!1);
  }
  onPivotPanelShow() {
    const e = this.pivotComp;
    if (!e)
      return;
    const t = this.gos.get("pivotPanelShow");
    if (t === "always")
      e.setDisplayed(!0);
    else if (t === "onlyWhenPivoting") {
      const s = this.beans.colModel.isPivotActive();
      e.setDisplayed(s);
    } else
      e.setDisplayed(!1);
  }
}, B1 = {
  selector: "AG-GRID-HEADER-DROP-ZONES",
  component: G1
}, V1 = class extends Nt {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-group-filter">
                <div data-ref="eGroupField"></div>
                <div data-ref="eUnderlyingFilter"></div>
            </div>
        `
    ), this.eGroupField = S, this.eUnderlyingFilter = S;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.showRowGroupCols = e.showRowGroupCols;
  }
  postConstruct() {
    this.initialiseTabGuard({});
  }
  init(e) {
    return this.updateParams(e).then(() => {
      this.addManagedEventListeners({
        columnRowGroupChanged: () => this.onColumnRowGroupChanged(),
        filterDestroyed: (t) => this.onFilterDestroyed(t)
      });
    });
  }
  refresh(e) {
    return this.updateParams(e), !0;
  }
  updateParams(e) {
    return this.params = e, this.validateParams(), this.updateGroups();
  }
  validateParams() {
    const { colDef: e } = this.params;
    e.field && R(234), e.filterValueGetter && R(235), e.filterParams && R(236);
  }
  updateGroups() {
    const e = this.updateGroupField();
    return this.getUnderlyingFilters(e);
  }
  getSourceColumns() {
    var t;
    if (this.groupColumn = this.params.column, this.gos.get("treeData"))
      return R(237), [];
    const e = (t = this.showRowGroupCols) == null ? void 0 : t.getSourceColumnsForGroupColumn(this.groupColumn);
    return e || (R(183), []);
  }
  updateGroupField() {
    const e = this.eGroupField;
    X(e), this.eGroupFieldSelect && this.destroyBean(this.eGroupFieldSelect);
    const t = this.getSourceColumns(), s = t.filter((i) => i.isFilterAllowed());
    return s.length ? (t.length === 1 ? (this.selectedColumn = s[0], O(e, !1)) : ((!this.selectedColumn || !s.some((i) => i.getId() === this.selectedColumn.getId())) && (this.selectedColumn = s[0]), this.createGroupFieldSelectElement(s), e.appendChild(this.eGroupFieldSelect.getGui()), e.appendChild(Be(
      /* html */
      '<div class="ag-filter-separator"></div>'
    )), O(e, !0)), s) : (this.selectedColumn = void 0, O(e, !1), null);
  }
  createGroupFieldSelectElement(e) {
    const t = this.createManagedBean(new Ne());
    this.eGroupFieldSelect = t;
    const s = this.getLocaleTextFunc();
    t.setLabel(s("groupFilterSelect", "Select field:")), t.setLabelAlignment("top"), t.addOptions(
      e.map((i) => ({
        value: i.getId(),
        text: this.beans.colNames.getDisplayNameForColumn(i, "groupFilter", !1) ?? void 0
      }))
    ), t.setValue(this.selectedColumn.getId()), t.onValueChange((i) => this.updateSelectedColumn(i)), t.addCssClass("ag-group-filter-field-select-wrapper"), e.length === 1 && t.setDisabled(!0);
  }
  getUnderlyingFilters(e) {
    var i;
    if (!e)
      return this.filterColumnPairs = void 0, this.selectedFilter = void 0, (i = this.beans.colFilter) == null || i.setColFilterActive(this.groupColumn, !1, "columnRowGroupChanged"), U.resolve();
    const t = [], s = [];
    return e.forEach((r) => {
      const o = this.filterManager.getOrCreateFilterWrapper(r);
      o != null && o.filterPromise && t.push(
        o.filterPromise.then((n) => (n && s.push({
          filter: n,
          column: r
        }), r.getId() === this.selectedColumn.getId() && (this.selectedFilter = n ?? void 0), n))
      );
    }), U.all(t).then(() => {
      var r;
      this.filterColumnPairs = s, (r = this.beans.colFilter) == null || r.setColFilterActive(this.groupColumn, this.isFilterActive(), "columnRowGroupChanged");
    });
  }
  addUnderlyingFilterElement() {
    var t;
    if (X(this.eUnderlyingFilter), !this.selectedColumn)
      return U.resolve();
    const e = this.createManagedBean(new sn(this.selectedColumn, "COLUMN_MENU"));
    return this.filterWrapperComp = e, e.hasFilter() ? (this.eUnderlyingFilter.appendChild(e.getGui()), ((t = e.getFilter()) == null ? void 0 : t.then(() => {
      var s, i;
      (s = e.afterGuiAttached) == null || s.call(e, this.afterGuiAttachedParams), !((i = this.afterGuiAttachedParams) != null && i.suppressFocus) && this.eGroupFieldSelect && !this.eGroupFieldSelect.isDisabled() && this.eGroupFieldSelect.getFocusableElement().focus();
    })) ?? U.resolve()) : U.resolve();
  }
  updateSelectedColumn(e) {
    var s;
    if (!e)
      return;
    (s = this.filterWrapperComp) == null || s.afterGuiDetached(), this.destroyBean(this.filterWrapperComp);
    const t = this.getFilterColumnPair(e);
    this.selectedColumn = t == null ? void 0 : t.column, this.selectedFilter = t == null ? void 0 : t.filter, this.dispatchLocalEvent({
      type: "selectedColumnChanged"
    }), this.addUnderlyingFilterElement();
  }
  isFilterActive() {
    var e;
    return !!((e = this.filterColumnPairs) != null && e.some(({ filter: t }) => t.isFilterActive()));
  }
  doesFilterPass() {
    return !0;
  }
  getModel() {
    return null;
  }
  setModel() {
    return U.resolve();
  }
  afterGuiAttached(e) {
    this.afterGuiAttachedParams = e, this.addUnderlyingFilterElement();
  }
  afterGuiDetached() {
    var e, t;
    X(this.eUnderlyingFilter), (t = (e = this.selectedFilter) == null ? void 0 : e.afterGuiDetached) == null || t.call(e);
  }
  onColumnRowGroupChanged() {
    this.updateGroups().then(() => {
      this.dispatchLocalEvent({
        type: "columnRowGroupChanged"
      });
    });
  }
  onFilterDestroyed({ column: e, source: t }) {
    var i;
    if (t === "gridDestroyed")
      return;
    const s = e.getColId();
    (i = this.filterColumnPairs) != null && i.some(({ column: r }) => r.getColId() === s) && setTimeout(() => {
      this.isAlive() && this.updateGroups();
    });
  }
  getFilterColumnPair(e) {
    var t;
    if (e)
      return (t = this.filterColumnPairs) == null ? void 0 : t.find(({ column: s }) => s.getId() === e);
  }
  getSelectedFilter() {
    return this.selectedFilter;
  }
  getSelectedColumn() {
    return this.selectedColumn;
  }
  isFilterAllowed() {
    return !!this.selectedColumn;
  }
}, N1 = class extends L {
  constructor() {
    super(
      /* html */
      `
            <div data-ref="eFloatingFilter" class="ag-group-floating-filter ag-floating-filter-input" role="presentation"></div>
        `
    ), this.eFloatingFilter = S, this.haveAddedColumnListeners = !1;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.params = e;
    const t = this.gos.get("groupDisplayType") === "multipleColumns";
    return new U((s) => {
      this.params.parentFilterInstance((i) => {
        this.parentFilterInstance = i, t ? this.setupUnderlyingFloatingFilterElement().then(() => s()) : (this.setupReadOnlyFloatingFilterElement(), s());
      });
    }).then(() => {
      const s = this.onColChange.bind(this);
      this.addManagedListeners(this.parentFilterInstance, {
        selectedColumnChanged: s,
        columnRowGroupChanged: s
      });
    });
  }
  refresh(e) {
    this.params = e, this.setParams();
  }
  setParams() {
    var s;
    const e = this.beans.colNames.getDisplayNameForColumn(this.params.column, "header", !0), t = this.getLocaleTextFunc();
    (s = this.eFloatingFilterText) == null || s.setInputAriaLabel(`${e} ${t("ariaFilterInput", "Filter Input")}`);
  }
  setupReadOnlyFloatingFilterElement() {
    this.eFloatingFilterText || (this.eFloatingFilterText = this.createManagedBean(new Tt()), this.eFloatingFilterText.setDisabled(!0).addGuiEventListener("click", () => this.params.showParentFilter()), this.setParams()), this.updateDisplayedValue(), this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());
  }
  setupUnderlyingFloatingFilterElement() {
    this.showingUnderlyingFloatingFilter = !1, this.underlyingFloatingFilter = void 0, X(this.eFloatingFilter);
    const e = this.parentFilterInstance.getSelectedColumn();
    if (e && !e.isVisible()) {
      const t = this.filterManager.getFloatingFilterCompDetails(e, this.params.showParentFilter);
      if (t)
        return this.haveAddedColumnListeners || (this.haveAddedColumnListeners = !0, this.addManagedListeners(e, {
          visibleChanged: this.onColumnVisibleChanged.bind(this),
          colDefChanged: this.onColDefChanged.bind(this)
        })), t.newAgStackInstance().then((s) => {
          var i, r;
          this.underlyingFloatingFilter = s, (r = this.underlyingFloatingFilter) == null || r.onParentModelChanged(
            (i = this.parentFilterInstance.getSelectedFilter()) == null ? void 0 : i.getModel()
          ), this.appendChild(s.getGui()), this.showingUnderlyingFloatingFilter = !0;
        });
    }
    return this.setupReadOnlyFloatingFilterElement(), U.resolve();
  }
  onColumnVisibleChanged() {
    this.setupUnderlyingFloatingFilterElement();
  }
  onColDefChanged(e) {
    var s, i;
    if (!e.column)
      return;
    const t = this.filterManager.getFloatingFilterCompDetails(
      e.column,
      this.params.showParentFilter
    );
    t && ((i = (s = this.underlyingFloatingFilter) == null ? void 0 : s.refresh) == null || i.call(s, t.params));
  }
  onParentModelChanged(e, t) {
    var s, i;
    this.showingUnderlyingFloatingFilter ? (i = this.underlyingFloatingFilter) == null || i.onParentModelChanged(
      (s = this.parentFilterInstance.getSelectedFilter()) == null ? void 0 : s.getModel(),
      t
    ) : this.updateDisplayedValue();
  }
  updateDisplayedValue() {
    const { eFloatingFilterText: e, parentFilterInstance: t } = this;
    if (!t || !e)
      return;
    const s = t.getSelectedFilter();
    if (!s) {
      e.setValue(""), e.setDisplayed(!1);
      return;
    }
    if (e.setDisplayed(!0), s.getModelAsString) {
      const i = s.getModel();
      e.setValue(i == null ? "" : s.getModelAsString(i));
    } else
      e.setValue("");
  }
  onColChange() {
    this.showingUnderlyingFloatingFilter || this.updateDisplayedValue();
  }
}, H1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "groupHideOpenParentsSvc";
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents") || this.gos.get("treeData"))
      return;
    const t = (s) => {
      this.pullDownGroupDataForHideOpenParents(s.childrenAfterSort, !1), s.childrenAfterSort.forEach((i) => {
        i.hasChildren() && t(i);
      });
    };
    e && e.executeFromRootNode((s) => t(s));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    if (!this.gos.get("groupHideOpenParents") || Y(e))
      return;
    const { colModel: s, showRowGroupCols: i } = this.beans;
    e.forEach((r) => {
      ((i == null ? void 0 : i.getShowRowGroupCols()) ?? []).forEach((n) => {
        const a = n.getColDef().showRowGroup;
        if (typeof a != "string") {
          z(110);
          return;
        }
        const l = a, d = s.getColDefCol(l);
        if (d !== r.rowGroupColumn)
          if (t)
            Go(r, s, n.getId(), void 0);
          else {
            const h = this.getFirstChildOfFirstChild(r, d);
            h && Go(r, s, n.getId(), h.key);
          }
      });
    });
  }
  isShowingValueForOpenedParent(e, t) {
    if (!this.gos.get("groupHideOpenParents") || !e.groupData)
      return !1;
    if (e.rowGroupColumn != null) {
      const i = e.rowGroupColumn.getId();
      if (t.isRowGroupDisplayed(i))
        return !1;
    }
    return e.groupData[t.getId()] != null;
  }
  getFirstChildOfFirstChild(e, t) {
    let s = e;
    for (; s; ) {
      const i = s.parent;
      if (i != null && i.childrenAfterSort && s === i.childrenAfterSort[0]) {
        if (i.rowGroupColumn === t)
          return i;
      } else
        return null;
      s = i;
    }
    return null;
  }
}, ia = class {
  constructor() {
    this.allSets = {}, this.allParents = [];
  }
  removeFromChildrenAfterGroup(e, t) {
    const s = this.getSet(e);
    s.removeFromChildrenAfterGroup[t.id] = !0;
  }
  isRemoveFromAllLeafChildren(e, t) {
    return !!this.getSet(e).removeFromAllLeafChildren[t.id];
  }
  preventRemoveFromAllLeafChildren(e, t) {
    const s = this.getSet(e);
    delete s.removeFromAllLeafChildren[t.id];
  }
  removeFromAllLeafChildren(e, t) {
    const s = this.getSet(e);
    s.removeFromAllLeafChildren[t.id] = !0;
  }
  getSet(e) {
    return this.allSets[e.id] || (this.allSets[e.id] = {
      removeFromAllLeafChildren: {},
      removeFromChildrenAfterGroup: {}
    }, this.allParents.push(e)), this.allSets[e.id];
  }
  getAllParents() {
    return this.allParents;
  }
  flush() {
    this.allParents.forEach((e) => {
      var i;
      const t = this.allSets[e.id];
      e.childrenAfterGroup = e.childrenAfterGroup.filter(
        (r) => !t.removeFromChildrenAfterGroup[r.id]
      ), e.allLeafChildren = ((i = e.allLeafChildren) == null ? void 0 : i.filter((r) => !t.removeFromAllLeafChildren[r.id])) ?? null, e.updateHasChildren();
      const s = e.sibling;
      s && (s.childrenAfterGroup = e.childrenAfterGroup, s.allLeafChildren = e.allLeafChildren);
    }), this.allSets = {}, this.allParents.length = 0;
  }
};
function z1(e) {
  if (!e)
    return !1;
  const t = e.length;
  if (t < 2)
    return !1;
  let s = !1;
  for (let i = 1; i < t; i++)
    if (Ic(e[i - 1], e[i]) > 0) {
      s = !0;
      break;
    }
  return s ? (e.sort(Ic), !0) : !1;
}
function Ic(e, t) {
  const s = e.sourceRowIndex, i = t.sourceRowIndex, r = s >= 0, o = i >= 0, n = r && o, a = !r && !o;
  return n ? s - i : a ? e.__objectId - t.__objectId : r ? 1 : -1;
}
var W1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "groupStage", this.refreshProps = /* @__PURE__ */ new Set([
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType"
    ]), this.step = "group";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueSvc = e.valueSvc, this.selectionSvc = e.selectionSvc, this.showRowGroupCols = e.showRowGroupCols;
  }
  execute(e) {
    var i;
    const t = this.createGroupingDetails(e);
    if (t.transactions)
      this.handleTransaction(t);
    else {
      const r = e.afterColumnsChanged === !0;
      this.shotgunResetEverything(t, r);
    }
    const s = e.changedPath;
    this.positionLeafsAndGroups(s), this.orderGroups(t), (i = this.selectionSvc) == null || i.updateSelectableAfterGrouping(s);
  }
  positionLeafsAndGroups(e) {
    e.forEachChangedNodeDepthFirst((t) => {
      if (t.childrenAfterGroup) {
        const s = [], i = [];
        let r;
        t.childrenAfterGroup.forEach((o) => {
          var n;
          (n = o.childrenAfterGroup) != null && n.length ? o.key === "" && !r ? r = o : i.push(o) : s.push(o);
        }), r && i.push(r), t.childrenAfterGroup = [...s, ...i];
      }
    }, !1);
  }
  createGroupingDetails(e) {
    var a;
    const { rowNode: t, changedPath: s, rowNodeTransactions: i, rowNodesOrderChanged: r } = e, o = (a = this.rowGroupColsSvc) == null ? void 0 : a.columns;
    return {
      expandByDefault: this.gos.get("groupDefaultExpanded"),
      groupedCols: o,
      rootNode: t,
      pivotMode: this.colModel.isPivotMode(),
      groupedColCount: (o == null ? void 0 : o.length) ?? 0,
      transactions: i,
      rowNodesOrderChanged: !!r,
      // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway
      changedPath: s,
      groupAllowUnbalanced: this.gos.get("groupAllowUnbalanced"),
      isGroupOpenByDefault: this.gos.getCallback("isGroupOpenByDefault"),
      initialGroupOrderComparator: this.gos.getCallback("initialGroupOrderComparator"),
      keyCreators: (o == null ? void 0 : o.map((l) => l.getColDef().keyCreator)) ?? []
    };
  }
  handleTransaction(e) {
    e.transactions.forEach((t) => {
      var r, o, n;
      const s = new ia();
      (r = t.remove) != null && r.length && this.removeNodes(t.remove, e, s), (o = t.update) != null && o.length && this.moveNodesInWrongPath(t.update, e, s), (n = t.add) != null && n.length && this.insertNodes(t.add, e);
      const i = s.getAllParents().slice();
      s.flush(), this.removeEmptyGroups(i, e);
    }), e.rowNodesOrderChanged && this.sortChildren(e);
  }
  // this is used when doing delta updates, eg Redux, keeps nodes in right order
  sortChildren(e) {
    e.changedPath.forEachChangedNodeDepthFirst(
      (t) => {
        z1(t.childrenAfterGroup) && e.changedPath.addParentNode(t);
      },
      !1,
      !0
    );
  }
  orderGroups(e) {
    const t = e.initialGroupOrderComparator;
    A(t) && s(e.rootNode);
    function s(i) {
      A(i.childrenAfterGroup) && // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
      !i.leafGroup && (i.childrenAfterGroup.sort((o, n) => t({ nodeA: o, nodeB: n })), i.childrenAfterGroup.forEach((o) => s(o)));
    }
  }
  getExistingPathForNode(e, t) {
    const s = [];
    let i = e.parent;
    for (; i && i !== t.rootNode; )
      s.push({
        key: i.key,
        rowGroupColumn: i.rowGroupColumn,
        field: i.field
      }), i = i.parent;
    return s.reverse(), s;
  }
  moveNodesInWrongPath(e, t, s) {
    e.forEach((i) => {
      t.changedPath.active && t.changedPath.addParentNode(i.parent);
      const r = (l) => l.key, o = this.getExistingPathForNode(i, t).map(r), n = this.getGroupInfo(i, t).map(r);
      Re(o, n) || this.moveNode(i, t, s);
    });
  }
  moveNode(e, t, s) {
    if (this.removeNodesFromParents([e], t, s), this.insertOneNode(e, t, s), e.setData(e.data), t.changedPath.active) {
      const i = e.parent;
      t.changedPath.addParentNode(i);
    }
  }
  removeNodes(e, t, s) {
    this.removeNodesFromParents(e, t, s), t.changedPath.active && e.forEach((i) => t.changedPath.addParentNode(i.parent));
  }
  forEachParentGroup(e, t, s) {
    let i = t;
    for (; i && i !== e.rootNode; )
      s(i), i = i.parent;
  }
  removeNodesFromParents(e, t, s) {
    const i = s == null, r = s || new ia();
    e.forEach((o) => {
      this.removeFromParent(o, r), this.forEachParentGroup(t, o.parent, (n) => {
        r.removeFromAllLeafChildren(n, o);
      });
    }), i && r.flush();
  }
  removeEmptyGroups(e, t) {
    let s = !0;
    const i = (r) => {
      var l;
      const o = this.getChildrenMappedKey(r.key, r.rowGroupColumn), n = r.parent;
      return (n != null && n.childrenMapped ? !n.childrenMapped[o] : !0) ? !1 : !!r.group && (((l = r.childrenAfterGroup) == null ? void 0 : l.length) ?? 0) === 0;
    };
    for (; s; ) {
      s = !1;
      const r = new ia();
      e.forEach((o) => {
        this.forEachParentGroup(t, o, (n) => {
          var a;
          i(n) && (s = !0, this.removeFromParent(n, r), (a = this.selectionSvc) == null || a.setNodesSelected({
            nodes: [n],
            newValue: !1,
            source: "rowGroupChanged"
          }));
        });
      }), r.flush();
    }
  }
  // removes the node from the parent by:
  // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
  // b) removing from childrenMapped (immediately)
  // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
  // d) setRowIndex(null) - as the rowNode will no longer be displayed.
  removeFromParent(e, t) {
    var i;
    e.parent && (t ? t.removeFromChildrenAfterGroup(e.parent, e) : (be(e.parent.childrenAfterGroup, e), e.parent.updateHasChildren()));
    const s = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    (i = e.parent) != null && i.childrenMapped && delete e.parent.childrenMapped[s], e.setRowTop(null), e.setRowIndex(null);
  }
  /**
   * This is idempotent, but relies on the `key` field being the same throughout a RowNode's lifetime
   */
  addToParent(e, t) {
    const s = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    t != null && t.childrenMapped && t.childrenMapped[s] !== e && (t.childrenMapped[s] = e, t.childrenAfterGroup.push(e), qg(t, this.beans, !0));
  }
  areGroupColsEqual(e, t) {
    return e == null || t == null || e.pivotMode !== t.pivotMode ? !1 : Re(e.groupedCols, t.groupedCols) && Re(e.keyCreators, t.keyCreators);
  }
  checkAllGroupDataAfterColsChanged(e) {
    const t = (s) => {
      s && s.forEach((i) => {
        var n;
        if (!i.group)
          return;
        const o = {
          field: i.field,
          key: i.key,
          rowGroupColumn: i.rowGroupColumn,
          leafNode: (n = i.allLeafChildren) == null ? void 0 : n[0]
        };
        this.setGroupData(i, o), t(i.childrenAfterGroup);
      });
    };
    t(e.rootNode.childrenAfterGroup);
  }
  shotgunResetEverything(e, t) {
    var o, n;
    if (this.noChangeInGroupingColumns(e, t))
      return;
    (n = (o = this.selectionSvc) == null ? void 0 : o.filterFromSelection) == null || n.call(o, (a) => !a.group);
    const { groupedCols: s } = e, i = e.rootNode;
    i.leafGroup = s.length === 0, i.childrenAfterGroup = [], i.childrenMapped = {}, i.updateHasChildren();
    const r = i.sibling;
    r && (r.childrenAfterGroup = i.childrenAfterGroup, r.childrenMapped = i.childrenMapped), this.insertNodes(i.allLeafChildren, e);
  }
  noChangeInGroupingColumns(e, t) {
    let s = !1;
    const i = this.showRowGroupCols.getShowRowGroupCols(), r = i ? i.map((o) => o.getId()).join("-") : "";
    return t && (s = this.areGroupColsEqual(e, this.oldGroupingDetails), this.oldGroupDisplayColIds !== r && this.checkAllGroupDataAfterColsChanged(e)), this.oldGroupingDetails = e, this.oldGroupDisplayColIds = r, s;
  }
  insertNodes(e, t) {
    e.forEach((s) => {
      this.insertOneNode(s, t), t.changedPath.active && t.changedPath.addParentNode(s.parent);
    });
  }
  insertOneNode(e, t, s) {
    const i = this.getGroupInfo(e, t), r = this.findParentForNode(e, i, t, s);
    r.group || R(184, { parentGroupData: r.data, childNodeData: e.data }), e.parent = r, e.level = i.length, r.childrenAfterGroup.push(e), r.updateHasChildren();
  }
  findParentForNode(e, t, s, i) {
    let r = s.rootNode;
    return t.forEach((o, n) => {
      r = this.getOrCreateNextNode(r, o, n, s), i != null && i.isRemoveFromAllLeafChildren(r, e) ? i == null || i.preventRemoveFromAllLeafChildren(r, e) : r.allLeafChildren.push(e);
    }), r;
  }
  getOrCreateNextNode(e, t, s, i) {
    var n;
    const r = this.getChildrenMappedKey(t.key, t.rowGroupColumn);
    let o = (n = e == null ? void 0 : e.childrenMapped) == null ? void 0 : n[r];
    return o || (o = this.createGroup(t, e, s, i), this.addToParent(o, e)), o;
  }
  createGroup(e, t, s, i) {
    const r = new Qe(this.beans);
    return r.group = !0, r.field = e.field, r.rowGroupColumn = e.rowGroupColumn, this.setGroupData(r, e), r.key = e.key, r.id = this.createGroupId(r, t, s), r.level = s, r.leafGroup = s === i.groupedColCount - 1, r.allLeafChildren = [], r.setAllChildrenCount(0), r.rowGroupIndex = s, r.childrenAfterGroup = [], r.childrenMapped = {}, r.updateHasChildren(), r.parent = t, this.setExpandedInitialValue(i, r), r;
  }
  createGroupId(e, t, s) {
    const i = (r, o) => {
      if (!r.rowGroupColumn)
        return null;
      const n = o ? i(o, o.parent) : null;
      return `${n == null ? "" : n + "-"}${r.rowGroupColumn.getColId()}-${r.key}`;
    };
    return fr + i(e, t);
  }
  setGroupData(e, t) {
    e.groupData = {}, this.showRowGroupCols.getShowRowGroupCols().forEach((i) => {
      const r = e.rowGroupColumn;
      r !== null && i.isRowGroupDisplayed(r.getId()) && (e.groupData[i.getColId()] = this.valueSvc.getValue(r, t.leafNode));
    });
  }
  getChildrenMappedKey(e, t) {
    return t ? t.getId() + "-" + e : e;
  }
  setExpandedInitialValue(e, t) {
    if (e.pivotMode && t.leafGroup) {
      t.expanded = !1;
      return;
    }
    const s = e.isGroupOpenByDefault;
    if (s) {
      const i = {
        rowNode: t,
        field: t.field,
        key: t.key,
        level: t.level,
        rowGroupColumn: t.rowGroupColumn
      };
      t.expanded = s(i) == !0;
      return;
    }
    if (e.expandByDefault === -1) {
      t.expanded = !0;
      return;
    }
    t.expanded = t.level < e.expandByDefault;
  }
  getGroupInfo(e, t) {
    const s = [];
    return t.groupedCols.forEach((i) => {
      let r = this.valueSvc.getKeyForNode(i, e), o = r != null && r !== "";
      if ((t.pivotMode || !t.groupAllowUnbalanced) && !o && (r = "", o = !0), o) {
        const a = {
          key: r,
          field: i.getColDef().field,
          rowGroupColumn: i,
          leafNode: e
        };
        s.push(a);
      }
    }), s;
  }
};
function _1(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.setColumns(t, "api");
}
function U1(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.removeColumns(t, "api");
}
function K1(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.addColumns(t, "api");
}
function $1(e, t, s) {
  var i, r;
  (r = (i = e.rowGroupColsSvc) == null ? void 0 : i.moveColumn) == null || r.call(i, t, s, "api");
}
function j1(e) {
  var t;
  return ((t = e.rowGroupColsSvc) == null ? void 0 : t.columns) ?? [];
}
var vf = {
  moduleName: "SharedRowGrouping",
  version: j,
  beans: [H1],
  apiFunctions: {
    setRowGroupColumns: _1,
    removeRowGroupColumns: U1,
    addRowGroupColumns: K1,
    getRowGroupColumns: j1,
    moveRowGroupColumn: $1
  },
  dependsOn: [te, Zl, Cf, Ql]
}, wf = {
  moduleName: "RowGrouping",
  version: j,
  beans: [W1],
  rowModels: ["clientSide"],
  dependsOn: [vf, uf, vn]
}, q1 = {
  moduleName: "RowGroupingPanel",
  version: j,
  selectors: [B1],
  icons: {
    // identifies the pivot drop zone
    pivotPanel: "pivot",
    // "Row groups" drop zone in column tool panel
    rowGroupPanel: "group",
    // separator between column 'pills' when you add multiple columns to the header drop zone
    panelDelimiter: "small-right",
    // version of panelDelimiter used in RTL mode
    panelDelimiterRtl: "small-left"
  },
  dependsOn: [te, ts]
}, Y1 = {
  moduleName: "GroupFilter",
  version: j,
  userComponents: { agGroupColumnFilter: V1, agGroupColumnFloatingFilter: N1 },
  dependsOn: [te, Ds]
}, X1 = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.firstRow = -1, this.lastRow = -1, this.rowCount = -1, this.rowNodesByIndex = {};
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid(e, t, s, i) {
    return !1;
  }
  postConstruct() {
    const e = this.beans;
    this.rowHeight = Ye(e), this.addManagedEventListeners({ viewportChanged: this.onViewportChanged.bind(this) }), this.addManagedPropertyListener("viewportDatasource", () => this.updateDatasource()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = Ye(e), this.updateRowHeights();
    });
  }
  start() {
    this.updateDatasource();
  }
  isLastRowIndexKnown() {
    return !0;
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    var t;
    const e = this.datasource;
    e && ((t = e.destroy) == null || t.call(e), this.beans.rowRenderer.datasourceChanged(), this.firstRow = -1, this.lastRow = -1);
  }
  updateDatasource() {
    const e = this.gos.get("viewportDatasource");
    e && this.setViewportDatasource(e);
  }
  getPageSize() {
    return this.gos.get("viewportRowModelPageSize");
  }
  getBufferSize() {
    return this.gos.get("viewportRowModelBufferSize");
  }
  calculateFirstRow(e) {
    const t = this.getBufferSize(), s = this.getPageSize(), i = e - t;
    return i < 0 ? 0 : Math.floor(i / s) * s;
  }
  calculateLastRow(e) {
    if (e === -1)
      return e;
    const t = this.getBufferSize(), s = this.getPageSize(), i = e + t, r = Math.ceil(i / s) * s, o = this.rowCount - 1;
    return Math.min(r, o);
  }
  onViewportChanged(e) {
    var i;
    const t = this.calculateFirstRow(e.firstRow), s = this.calculateLastRow(e.lastRow);
    (this.firstRow !== t || this.lastRow !== s) && (this.firstRow = t, this.lastRow = s, this.purgeRowsNotInViewport(), (i = this.datasource) == null || i.setViewportRange(this.firstRow, this.lastRow));
  }
  purgeRowsNotInViewport() {
    const e = this.rowNodesByIndex;
    Object.keys(e).forEach((t) => {
      const s = parseInt(t, 10);
      if (s < this.firstRow || s > this.lastRow) {
        if (this.isRowFocused(s))
          return;
        delete e[s];
      }
    });
  }
  isRowFocused(e) {
    const t = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
    return !t || t.rowPinned != null ? !1 : t.rowIndex === e;
  }
  setViewportDatasource(e) {
    this.destroyDatasource(), this.datasource = e, this.rowCount = -1, e.init ? e.init({
      setRowCount: this.setRowCount.bind(this),
      setRowData: this.setRowData.bind(this),
      getRow: this.getRow.bind(this)
    }) : R(226);
  }
  getType() {
    return "viewport";
  }
  getRow(e) {
    return this.rowNodesByIndex[e] || (this.rowNodesByIndex[e] = this.createBlankRowNode(e)), this.rowNodesByIndex[e];
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((s) => {
      s.id === e && (t = s);
    }), t;
  }
  getRowCount() {
    return this.rowCount === -1 ? 0 : this.rowCount;
  }
  getRowIndexAtPixel(e) {
    return this.rowHeight !== 0 ? Math.floor(e / this.rowHeight) : 0;
  }
  getRowBounds(e) {
    const t = this.rowHeight;
    return {
      rowHeight: t,
      rowTop: t * e
    };
  }
  updateRowHeights() {
    const e = this.rowHeight;
    this.forEachNode((t) => {
      t.setRowHeight(e), t.setRowTop(e * t.rowIndex);
    }), this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      newData: !1,
      newPage: !1,
      keepRenderedRows: !0,
      animate: !1
    });
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  isEmpty() {
    return this.rowCount > 0;
  }
  isRowsToRender() {
    return this.rowCount > 0;
  }
  getNodesInRangeForSelection(e, t) {
    const s = e.rowIndex, i = t.rowIndex, r = s < this.firstRow || s > this.lastRow, o = i < this.firstRow || i > this.lastRow;
    if (r || o)
      return [];
    const n = [], a = s <= i ? s : i, l = s <= i ? i : s;
    for (let d = a; d <= l; d++)
      n.push(this.rowNodesByIndex[d]);
    return n;
  }
  forEachNode(e) {
    let t = 0;
    Object.keys(this.rowNodesByIndex).forEach((s) => {
      const i = parseInt(s, 10), r = this.rowNodesByIndex[i];
      e(r, t), t++;
    });
  }
  setRowData(e) {
    const t = this.rowNodesByIndex;
    for (const [s, i] of Object.entries(e)) {
      const r = parseInt(s, 10);
      if (r >= this.firstRow && r <= this.lastRow) {
        let o = t[r];
        Y(o) && (o = this.createBlankRowNode(r), t[r] = o), o.setDataAndId(i, r.toString());
      }
    }
  }
  createBlankRowNode(e) {
    const t = new Qe(this.beans), s = this.rowHeight;
    return t.setRowHeight(s), t.setRowTop(s * e), t.setRowIndex(e), t;
  }
  setRowCount(e, t = !1) {
    if (e === this.rowCount)
      return;
    this.rowCount = e;
    const s = this.eventSvc;
    s.dispatchEventOnce({
      type: "rowCountReady"
    }), s.dispatchEvent({
      type: "modelUpdated",
      newData: !1,
      newPage: !1,
      keepRenderedRows: t,
      animate: !1
    });
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
}, Z1 = {
  moduleName: "ViewportRowModel",
  version: j,
  rowModels: ["viewport"],
  beans: [X1],
  dependsOn: [te]
};
function Q1(e, t) {
  var s;
  (s = e.clipboardSvc) == null || s.copyToClipboard(t);
}
function J1(e, t) {
  var s;
  (s = e.clipboardSvc) == null || s.cutToClipboard(t);
}
function eO(e, t) {
  var s;
  (s = e.clipboardSvc) == null || s.copySelectedRowsToClipboard(t);
}
function tO(e, t) {
  var s;
  (s = e.clipboardSvc) == null || s.copySelectedRangeToClipboard(t);
}
function sO(e) {
  var t;
  (t = e.clipboardSvc) == null || t.copyRangeDown();
}
function iO(e) {
  var t;
  (t = e.clipboardSvc) == null || t.pasteFromClipboard();
}
var ra = "paste", oa = "dragCopy", Lc = "clipboard";
function rO(e, t = ",") {
  const s = [], i = (o) => o === "\r" || o === `
`;
  let r = !1;
  if (e === "")
    return [[""]];
  for (let o = 0, n = 0, a = 0; a < e.length; a++) {
    const l = e[a - 1], d = e[a], c = e[a + 1], h = () => {
      s[o] || (s[o] = []), s[o][n] || (s[o][n] = "");
    };
    if (h(), d === '"' && (r ? c === '"' ? (s[o][n] += '"', a++) : r = !1 : (l === void 0 || l === t || i(l)) && (r = !0)), !r && d !== '"') {
      if (d === t) {
        n++, h();
        continue;
      } else if (i(d)) {
        n = 0, o++, h(), d === "\r" && c === `
` && a++;
        continue;
      }
    }
    s[o][n] += d;
  }
  return s;
}
var oO = class extends P {
  constructor() {
    super(...arguments), this.beanName = "clipboardSvc", this.clientSideRowModel = null, this.gridCtrl = null, this.lastPasteOperationTime = 0, this.navigatorApiFailed = !1;
  }
  postConstruct() {
    const { gos: e, rowModel: t, ctrlsSvc: s } = this.beans;
    J(e) && (this.clientSideRowModel = t), s.whenReady(this, (i) => {
      this.gridCtrl = i.gridCtrl;
    });
  }
  destroy() {
    super.destroy(), this.clientSideRowModel = null, this.gridCtrl = null;
  }
  pasteFromClipboard() {
    !this.gos.get("suppressClipboardApi") && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText ? navigator.clipboard.readText().then(this.processClipboardData.bind(this)).catch((t) => {
      R(40, { e: t, method: "readText" }), this.navigatorApiFailed = !0, this.pasteFromClipboardLegacy();
    }) : this.pasteFromClipboardLegacy();
  }
  pasteFromClipboardLegacy() {
    let e = !1;
    const t = (s) => {
      const i = (/* @__PURE__ */ new Date()).getTime();
      i - this.lastPasteOperationTime < 50 && (e = !0, s.preventDefault()), this.lastPasteOperationTime = i;
    };
    this.executeOnTempElement(
      (s) => {
        s.addEventListener("paste", t), s.focus({ preventScroll: !0 });
      },
      (s) => {
        const i = s.value;
        e ? this.refocusLastFocusedCell() : this.processClipboardData(i), s.removeEventListener("paste", t);
      }
    );
  }
  refocusLastFocusedCell() {
    const { focusSvc: e } = this.beans, t = e.getFocusedCell();
    t && e.setFocusedCell({
      rowIndex: t.rowIndex,
      column: t.column,
      rowPinned: t.rowPinned,
      forceBrowserFocus: !0
    });
  }
  getClipboardDelimiter() {
    const e = this.gos.get("clipboardDelimiter");
    return A(e) ? e : "	";
  }
  processClipboardData(e) {
    if (e == null)
      return;
    let t = rO(e, this.getClipboardDelimiter());
    const s = this.gos.getCallback("processDataFromClipboard");
    if (s && (t = s({ data: t })), t == null)
      return;
    this.gos.get("suppressLastEmptyLineOnPaste") && this.removeLastLineIfBlank(t);
    const { rangeSvc: i } = this.beans, r = (o, n, a, l) => {
      (i == null ? void 0 : i.isMoreThanOneCell()) && !this.hasOnlyOneValueToPaste(t) ? this.pasteIntoActiveRange(i, t, o, n, l) : this.pasteStartingFromFocusedCell(t, o, n, a, l);
    };
    this.doPasteOperation(r);
  }
  // common code to paste operations, e.g. paste to cell, paste to range, and copy range down
  doPasteOperation(e) {
    const t = "clipboard", { eventSvc: s, focusSvc: i, rowRenderer: r, gos: o } = this.beans;
    s.dispatchEvent({
      type: "pasteStart",
      source: t
    });
    const { clientSideRowModel: n } = this, a = n == null ? void 0 : n.rootNode, l = a && new Mi(o.get("aggregateOnlyChangedColumns"), a), d = {}, c = [], h = i.getFocusedCell();
    e(d, c, h, l);
    const u = [...c];
    l && (n.doAggregate(l), l.forEachChangedNodeDepthFirst((p) => {
      u.push(p);
    })), r.refreshCells({ rowNodes: u }), this.dispatchFlashCells(d), this.fireRowChanged(c), this.refocusLastFocusedCell(), s.dispatchEvent({
      type: "pasteEnd",
      source: t
    });
  }
  pasteIntoActiveRange(e, t, s, i, r) {
    const o = this.getRangeSize(e) % t.length != 0;
    let n = 0, a = 0;
    const l = (d, c, h, u) => {
      if (u - n >= t.length) {
        if (o)
          return;
        n += a, a = 0;
      }
      const g = t[u - n];
      i.push(c);
      const f = this.gos.getCallback("processCellFromClipboard");
      h.forEach((m, C) => {
        if (!m.isCellEditable(c) || m.isSuppressPaste(c))
          return;
        C >= g.length && (C = C % g.length);
        const v = this.processCell(
          c,
          m,
          g[C],
          oa,
          f,
          !0
        );
        c.setDataValue(m, v, ra), r && r.addParentNode(c.parent, [m]);
        const { rowIndex: b, rowPinned: y } = d, F = ns({ rowIndex: b, column: m, rowPinned: y });
        s[F] = !0;
      }), a++;
    };
    this.iterateActiveRanges(!1, l);
  }
  getDisplayedColumnsStartingAt(e) {
    let t = e;
    const s = [], i = this.beans.visibleCols;
    for (; t != null; )
      s.push(t), t = i.getColAfter(t);
    return s;
  }
  pasteStartingFromFocusedCell(e, t, s, i, r) {
    if (!i)
      return;
    const o = { rowIndex: i.rowIndex, rowPinned: i.rowPinned }, n = this.getDisplayedColumnsStartingAt(i.column);
    this.isPasteSingleValueIntoRange(e) ? this.pasteSingleValueIntoRange(e, s, t, r) : this.pasteMultipleValues(
      e,
      o,
      s,
      n,
      t,
      Lc,
      r
    );
  }
  // if range is active, and only one cell, then we paste this cell into all cells in the active range.
  isPasteSingleValueIntoRange(e) {
    const t = this.beans.rangeSvc;
    return this.hasOnlyOneValueToPaste(e) && !!t && !t.isEmpty();
  }
  pasteSingleValueIntoRange(e, t, s, i) {
    const r = e[0][0], o = (n, a, l) => {
      t.push(a), l.forEach(
        (d) => this.updateCellValue(a, d, r, s, Lc, i)
      );
    };
    this.iterateActiveRanges(!1, o);
  }
  hasOnlyOneValueToPaste(e) {
    return e.length === 1 && e[0].length === 1;
  }
  copyRangeDown() {
    const { rangeSvc: e, gos: t, valueSvc: s } = this.beans;
    if (!e || e.isEmpty())
      return;
    const i = [], r = (o, n, a, l) => {
      const d = t.getCallback("processCellForClipboard"), c = t.getCallback("processCellFromClipboard"), h = (u, p, g) => {
        i.length ? (n.push(p), g.forEach((f, m) => {
          if (!f.isCellEditable(p) || f.isSuppressPaste(p))
            return;
          const C = this.processCell(
            p,
            f,
            i[m],
            oa,
            c,
            !0
          );
          p.setDataValue(f, C, ra), l && l.addParentNode(p.parent, [f]);
          const { rowIndex: v, rowPinned: b } = u, y = ns({ rowIndex: v, column: f, rowPinned: b });
          o[y] = !0;
        })) : g.forEach((f) => {
          const m = this.processCell(
            p,
            f,
            s.getValue(f, p),
            oa,
            d,
            !1,
            !0
          );
          i.push(m);
        });
      };
      this.iterateActiveRanges(!0, h);
    };
    this.doPasteOperation(r);
  }
  removeLastLineIfBlank(e) {
    const t = V(e);
    if (t && t.length === 1 && t[0] === "") {
      if (e.length === 1)
        return;
      be(e, t);
    }
  }
  fireRowChanged(e) {
    this.gos.get("editType") === "fullRow" && e.forEach((t) => {
      this.eventSvc.dispatchEvent({
        type: "rowValueChanged",
        node: t,
        data: t.data,
        rowIndex: t.rowIndex,
        rowPinned: t.rowPinned
      });
    });
  }
  pasteMultipleValues(e, t, s, i, r, o, n) {
    let a = t;
    const l = this.beans, { gos: d, cellNavigation: c } = l, h = this.clientSideRowModel != null && !d.get("enableGroupEdit") && !d.get("treeData"), u = () => {
      for (; ; ) {
        if (!a)
          return null;
        const p = St(l, a);
        if (a = c.getRowBelow({
          rowPinned: a.rowPinned,
          rowIndex: a.rowIndex
        }), p == null)
          return null;
        if (!(p.detail || p.footer || h && p.group))
          return p;
      }
    };
    e.forEach((p) => {
      const g = u();
      g && (p.forEach(
        (f, m) => this.updateCellValue(g, i[m], f, r, o, n)
      ), s.push(g));
    });
  }
  updateCellValue(e, t, s, i, r, o) {
    if (!e || !t || !t.isCellEditable(e) || t.isSuppressPaste(e))
      return;
    const n = this.processCell(
      e,
      t,
      s,
      r,
      this.gos.getCallback("processCellFromClipboard"),
      !0
    );
    e.setDataValue(t, n, ra);
    const { rowIndex: a, rowPinned: l } = e, d = ns({ rowIndex: a, column: t, rowPinned: l });
    i[d] = !0, o && o.addParentNode(e.parent, [t]);
  }
  copyToClipboard(e = {}) {
    this.copyOrCutToClipboard(e);
  }
  cutToClipboard(e = {}, t = "api") {
    this.gos.get("suppressCutToClipboard") || (this.eventSvc.dispatchEvent({
      type: "cutStart",
      source: t
    }), this.copyOrCutToClipboard(e, !0), this.eventSvc.dispatchEvent({
      type: "cutEnd",
      source: t
    }));
  }
  copyOrCutToClipboard(e, t) {
    let { includeHeaders: s, includeGroupHeaders: i } = e;
    const { gos: r, focusSvc: o } = this.beans;
    s == null && (s = r.get("copyHeadersToClipboard")), i == null && (i = r.get("copyGroupHeadersToClipboard"));
    const n = { includeHeaders: s, includeGroupHeaders: i }, a = r.get("rowSelection"), l = r.get("cellSelection");
    let d = null;
    this.shouldCopyCells(l, a) ? (this.copySelectedRangeToClipboard(n), d = 0) : this.shouldCopyRows(a) ? (this.copySelectedRowsToClipboard(n), d = 1) : o.isAnyCellFocused() && (this.copyFocusedCellToClipboard(n), d = 2), t && d !== null && this.clearCellsAfterCopy(d);
  }
  shouldCopyCells(e, t) {
    const { rangeSvc: s, selectionSvc: i, gos: r } = this.beans;
    if (!s || s.isEmpty())
      return !1;
    if (e)
      return !(typeof t == "object" && t.copySelectedRows && !(i != null && i.isEmpty()));
    {
      const o = r.get("suppressCopySingleCellRanges");
      return !(!s.isMoreThanOneCell() && o);
    }
  }
  shouldCopyRows(e) {
    const { selectionSvc: t, gos: s } = this.beans;
    return (t == null ? void 0 : t.isEmpty()) ?? !0 ? !1 : e && typeof e != "string" ? e.copySelectedRows ?? !1 : !s.get("suppressCopyRowsToClipboard");
  }
  clearCellsAfterCopy(e) {
    const t = this.beans, { rangeSvc: s, focusSvc: i, eventSvc: r } = t;
    if (r.dispatchEvent({ type: "keyShortcutChangedCellStart" }), e === 0)
      s.clearCellRangeCellValues({ cellEventSource: "clipboardSvc" });
    else if (e === 1)
      this.clearSelectedRows();
    else {
      const o = i.getFocusedCell();
      if (o == null)
        return;
      const n = St(t, o);
      n && this.clearCellValue(n, o.column);
    }
    r.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
  }
  clearSelectedRows() {
    const { selectionSvc: e, visibleCols: t } = this.beans, s = (e == null ? void 0 : e.getSelectedNodes()) ?? [], i = t.allCols;
    for (const r of s)
      for (const o of i)
        this.clearCellValue(r, o);
  }
  clearCellValue(e, t) {
    if (!t.isCellEditable(e))
      return;
    const s = this.beans.valueSvc.getDeleteValue(t, e);
    e.setDataValue(t, s, "clipboardSvc");
  }
  iterateActiveRanges(e, t, s) {
    const i = this.beans.rangeSvc;
    if (!i || i.isEmpty())
      return;
    const r = i.getCellRanges();
    e ? this.iterateActiveRange(r[0], t, s, !0) : r.forEach(
      (o, n) => this.iterateActiveRange(o, t, s, n === r.length - 1)
    );
  }
  iterateActiveRange(e, t, s, i) {
    const { rangeSvc: r, cellNavigation: o } = this.beans;
    if (!r)
      return;
    let n = r.getRangeStartRow(e);
    const a = r.getRangeEndRow(e);
    s && e.columns && s(e.columns);
    let l = 0, d = !1;
    for (; !d && n != null; ) {
      const c = St(this.beans, n);
      d = fe(n, a), t(n, c, e.columns, l++, d && i), n = o.getRowBelow(n);
    }
  }
  copySelectedRangeToClipboard(e = {}) {
    const t = this.beans.rangeSvc;
    if (!t || t.isEmpty())
      return;
    const s = t.areAllRangesAbleToMerge(), { data: i, cellsToFlash: r } = s ? this.buildDataFromMergedRanges(t, e) : this.buildDataFromRanges(t, e);
    this.copyDataToClipboard(i), this.dispatchFlashCells(r);
  }
  buildDataFromMergedRanges(e, t) {
    const s = /* @__PURE__ */ new Set(), i = e.getCellRanges(), r = /* @__PURE__ */ new Map(), o = [], n = {};
    i.forEach((c) => {
      c.columns.forEach((p) => s.add(p));
      const { rowPositions: h, cellsToFlash: u } = this.getRangeRowPositionsAndCellsToFlash(e, c);
      h.forEach((p) => {
        const g = `${p.rowIndex}-${p.rowPinned || "null"}`;
        r.get(g) || (r.set(g, !0), o.push(p));
      }), Object.assign(n, u);
    });
    const a = this.beans.visibleCols.allCols, l = Array.from(s);
    return l.sort((c, h) => {
      const u = a.indexOf(c), p = a.indexOf(h);
      return u - p;
    }), { data: this.buildExportParams({
      columns: l,
      rowPositions: o,
      includeHeaders: t.includeHeaders,
      includeGroupHeaders: t.includeGroupHeaders
    }), cellsToFlash: n };
  }
  buildDataFromRanges(e, t) {
    const s = e.getCellRanges(), i = [], r = {};
    return s.forEach((o) => {
      const { rowPositions: n, cellsToFlash: a } = this.getRangeRowPositionsAndCellsToFlash(e, o);
      Object.assign(r, a), i.push(
        this.buildExportParams({
          columns: o.columns,
          rowPositions: n,
          includeHeaders: t.includeHeaders,
          includeGroupHeaders: t.includeGroupHeaders
        })
      );
    }), { data: i.join(`
`), cellsToFlash: r };
  }
  getRangeRowPositionsAndCellsToFlash(e, t) {
    const s = [], i = {}, r = e.getRangeStartRow(t), o = e.getRangeEndRow(t);
    let n = r;
    for (; n && (s.push(n), t.columns.forEach((a) => {
      const { rowIndex: l, rowPinned: d } = n, c = ns({ rowIndex: l, column: a, rowPinned: d });
      i[c] = !0;
    }), !fe(n, o)); )
      n = this.beans.cellNavigation.getRowBelow(n);
    return { rowPositions: s, cellsToFlash: i };
  }
  getCellsToFlashFromRowNodes(e) {
    const t = this.beans.visibleCols.allCols, s = {};
    for (let i = 0; i < e.length; i++) {
      const { level: r, rowIndex: o, rowPinned: n, sibling: a } = e[i], l = r === -1 ? a.rowIndex : o;
      if (l != null)
        for (let d = 0; d < t.length; d++) {
          const c = t[d], h = ns({ rowIndex: l, column: c, rowPinned: n });
          s[h] = !0;
        }
    }
    return s;
  }
  copyFocusedCellToClipboard(e = {}) {
    const t = this.beans.focusSvc.getFocusedCell();
    if (t == null)
      return;
    const s = ns(t), i = { rowPinned: t.rowPinned, rowIndex: t.rowIndex }, r = t.column, o = this.buildExportParams({
      columns: [r],
      rowPositions: [i],
      includeHeaders: e.includeHeaders,
      includeGroupHeaders: e.includeGroupHeaders
    });
    this.copyDataToClipboard(o), this.dispatchFlashCells({ [s]: !0 });
  }
  copySelectedRowsToClipboard(e = {}) {
    var n;
    const { columnKeys: t, includeHeaders: s, includeGroupHeaders: i } = e, r = this.buildExportParams({
      columns: t,
      includeHeaders: s,
      includeGroupHeaders: i
    });
    this.copyDataToClipboard(r);
    const o = ((n = this.beans.selectionSvc) == null ? void 0 : n.getSelectedNodes()) || [];
    this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(o));
  }
  buildExportParams(e) {
    const { columns: t, rowPositions: s, includeHeaders: i = !1, includeGroupHeaders: r = !1 } = e, { gos: o, csvCreator: n } = this.beans, a = {
      columnKeys: t,
      rowPositions: s,
      skipColumnHeaders: !i,
      skipColumnGroupHeaders: !r,
      suppressQuotes: !0,
      columnSeparator: this.getClipboardDelimiter(),
      onlySelected: !s,
      processCellCallback: o.getCallback("processCellForClipboard"),
      processRowGroupCallback: (l) => this.processRowGroupCallback(l),
      processHeaderCallback: o.getCallback("processHeaderForClipboard"),
      processGroupHeaderCallback: o.getCallback("processGroupHeaderForClipboard")
    };
    return n.getDataAsCsv(a, !0);
  }
  processRowGroupCallback({ node: e, column: t }) {
    const { gos: s, valueSvc: i, rowGroupColsSvc: r } = this.beans, o = s.get("treeData");
    let a = (() => {
      var c;
      if (o || !t)
        return e.key;
      const d = (c = e.groupData) == null ? void 0 : c[t.getId()];
      return !d || !e.rowGroupColumn || e.rowGroupColumn.getColDef().useValueFormatterForExport === !1 ? d : i.formatValue(e.rowGroupColumn, e, d) ?? d;
    })();
    if (e.footer) {
      let d = "";
      a && a.length && (d = ` ${a}`), a = `Total${d}`;
    }
    const l = s.getCallback("processCellForClipboard");
    if (l) {
      let d = e.rowGroupColumn;
      return !d && e.footer && e.level === -1 && r && (d = r.columns[0]), l({
        value: a,
        node: e,
        column: d,
        type: "clipboard",
        formatValue: (c) => i.formatValue(d, e, c) ?? c,
        parseValue: (c) => i.parseValue(d, e, c, i.getValue(d, e))
      });
    }
    return a;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  dispatchFlashCells(e) {
    window.setTimeout(() => {
      this.eventSvc.dispatchEvent({
        type: "flashCells",
        cells: e
      });
    }, 0);
  }
  processCell(e, t, s, i, r, o, n) {
    const a = this.beans.valueSvc;
    return r ? r({
      column: t,
      node: e,
      value: s,
      type: i,
      formatValue: (d) => a.formatValue(t, e ?? null, d) ?? d,
      parseValue: (d) => a.parseValue(t, e ?? null, d, a.getValue(t, e))
    }) : o && t.getColDef().useValueParserForImport !== !1 ? a.parseValue(t, e ?? null, s, a.getValue(t, e)) : n && t.getColDef().useValueFormatterForExport !== !1 ? a.formatValue(t, e ?? null, s) ?? s : s;
  }
  copyDataToClipboard(e) {
    const t = this.gos.getCallback("sendToClipboard");
    if (t) {
      t({ data: e });
      return;
    }
    if (!this.gos.get("suppressClipboardApi") && navigator.clipboard) {
      navigator.clipboard.writeText(e).catch((i) => {
        R(40, { e: i, method: "writeText" }), this.copyDataToClipboardLegacy(e);
      });
      return;
    }
    this.copyDataToClipboardLegacy(e);
  }
  copyDataToClipboardLegacy(e) {
    this.executeOnTempElement((t) => {
      const s = Z(this.beans), i = q(this.beans);
      t.value = e || " ", t.select(), t.focus({ preventScroll: !0 }), s.execCommand("copy") || R(41), i != null && i.focus != null && i.focus({ preventScroll: !0 });
    });
  }
  executeOnTempElement(e, t) {
    if (!this.gridCtrl)
      return;
    const s = Z(this.beans), i = s.createElement("textarea"), r = i.style;
    r.width = "1px", r.height = "1px";
    const o = s.documentElement;
    r.top = o.scrollTop + "px", r.left = o.scrollLeft + "px", r.position = "absolute", r.opacity = "0";
    const n = this.gridCtrl.getGui();
    n.appendChild(i);
    try {
      e(i);
    } catch {
      R(42);
    }
    t ? window.setTimeout(() => {
      t(i), n.removeChild(i);
    }, 100) : n.removeChild(i);
  }
  getRangeSize(e) {
    const t = e.getCellRanges();
    let s = 0, i = 0;
    return t.length > 0 && (s = e.getRangeStartRow(t[0]).rowIndex, i = e.getRangeEndRow(t[0]).rowIndex), s - i + 1;
  }
}, nO = {
  moduleName: "Clipboard",
  version: j,
  beans: [oO],
  apiFunctions: {
    copyToClipboard: Q1,
    cutToClipboard: J1,
    copySelectedRowsToClipboard: eO,
    copySelectedRangeToClipboard: tO,
    copySelectedRangeDown: sO,
    pasteFromClipboard: iO
  },
  dependsOn: [te, cg, cn, hg]
}, aO = class extends L {
  constructor() {
    super(...arguments), this.eExpand = S, this.eFilterTextField = S;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `<div class="ag-filter-toolpanel-search" role="presentation">
                <div data-ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <ag-input-text-field data-ref="eFilterTextField" class="ag-filter-toolpanel-search-input"></ag-input-text-field>
            </div>`,
      [mt]
    );
    const e = this.getLocaleTextFunc();
    this.eFilterTextField.setAutoComplete(!1).setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")).onValueChange(this.onSearchTextChanged.bind(this)), this.createExpandIcons(), this.setExpandState(
      0
      /* EXPANDED */
    ), this.addManagedElementListeners(this.eExpand, { click: this.onExpandClicked.bind(this) }), this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
  }
  init(e) {
    this.params = e, this.beans.colModel.ready && this.showOrHideOptions();
  }
  createExpandIcons() {
    const { eExpand: e, beans: t } = this;
    e.appendChild(this.eExpandChecked = B("accordionOpen", t)), e.appendChild(this.eExpandUnchecked = B("accordionClosed", t)), e.appendChild(this.eExpandIndeterminate = B("accordionIndeterminate", t));
  }
  // we only show expand / collapse if we are showing filters
  showOrHideOptions() {
    const { params: e, eFilterTextField: t } = this, s = !e.suppressFilterSearch, i = !e.suppressExpandAll, r = this.getLocaleTextFunc();
    t.setInputPlaceholder(r("searchOoo", "Search..."));
    const o = (a) => a.getOriginalParent() && a.isFilterAllowed(), n = this.beans.colModel.getCols().some(o);
    O(t.getGui(), s), O(this.eExpand, i && n);
  }
  onSearchTextChanged() {
    this.onSearchTextChangedDebounced || (this.onSearchTextChangedDebounced = Ce(
      this,
      () => this.dispatchLocalEvent({ type: "searchChanged", searchText: this.eFilterTextField.getValue() }),
      300
    )), this.onSearchTextChangedDebounced();
  }
  onExpandClicked() {
    const e = this.currentExpandState === 0 ? { type: "collapseAll" } : { type: "expandAll" };
    this.dispatchLocalEvent(e);
  }
  setExpandState(e) {
    this.currentExpandState = e, O(
      this.eExpandChecked,
      e === 0
      /* EXPANDED */
    ), O(
      this.eExpandUnchecked,
      e === 1
      /* COLLAPSED */
    ), O(
      this.eExpandIndeterminate,
      e === 2
      /* INDETERMINATE */
    );
  }
}, lO = {
  selector: "AG-FILTERS-TOOL-PANEL-HEADER",
  component: aO
}, yf = class extends L {
  constructor(e, t) {
    super(
      /* html */
      `
            <div class="ag-filter-toolpanel-instance">
                <div class="ag-filter-toolpanel-header ag-filter-toolpanel-instance-header" data-ref="eFilterToolPanelHeader" role="button" aria-expanded="false">
                    <div data-ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                    <span data-ref="eFilterName" class="ag-header-cell-text"></span>
                    <span data-ref="eFilterIcon" class="ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon" aria-hidden="true"></span>
                </div>
                <div class="ag-filter-toolpanel-instance-body ag-filter" data-ref="agFilterToolPanelBody"></div>
            </div>`
    ), this.hideHeader = e, this.expandedCallback = t, this.eFilterToolPanelHeader = S, this.eFilterName = S, this.agFilterToolPanelBody = S, this.eFilterIcon = S, this.eExpand = S, this.expanded = !1;
  }
  postConstruct() {
    const { beans: e, eExpand: t } = this, s = B("accordionOpen", e);
    this.eExpandChecked = s;
    const i = B("accordionClosed", e);
    this.eExpandUnchecked = i, t.appendChild(s), t.appendChild(i);
  }
  setColumn(e) {
    this.column = e;
    const { beans: t, eFilterToolPanelHeader: s, eFilterIcon: i, eExpandChecked: r, hideHeader: o } = this;
    this.eFilterName.innerText = t.colNames.getDisplayNameForColumn(e, "filterToolPanel", !1) || "", this.addManagedListeners(s, {
      click: this.toggleExpanded.bind(this),
      keydown: this.onKeyDown.bind(this)
    }), this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) }), this.addInIcon("filterActive", i, e), O(i, this.isFilterActive(), { skipAriaHidden: !0 }), O(r, !1), o ? (O(s, !1), s.removeAttribute("tabindex")) : s.setAttribute("tabindex", "0"), this.addManagedListeners(e, { filterChanged: this.onFilterChanged.bind(this) });
  }
  onKeyDown(e) {
    const { key: t } = e, { ENTER: s, SPACE: i, LEFT: r, RIGHT: o } = w;
    t !== s && t !== i && t !== r && t !== o || (e.preventDefault(), t === s || t === i ? this.toggleExpanded() : t === w.LEFT ? this.collapse() : this.expand());
  }
  getColumn() {
    return this.column;
  }
  getColumnFilterName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "filterToolPanel", !1);
  }
  addCssClassToTitleBar(e) {
    this.eFilterToolPanelHeader.classList.add(e);
  }
  addInIcon(e, t, s) {
    if (t == null)
      return;
    const i = B(e, this.beans, s);
    t.appendChild(i);
  }
  isFilterActive() {
    var e;
    return !!((e = this.beans.filterManager) != null && e.isFilterActive(this.column));
  }
  onFilterChanged() {
    O(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: !0 }), this.dispatchLocalEvent({ type: "filterChanged" });
  }
  toggleExpanded() {
    this.expanded ? this.collapse() : this.expand();
  }
  expand() {
    this.expanded || (this.expanded = !0, He(this.eFilterToolPanelHeader, !0), O(this.eExpandChecked, !0), O(this.eExpandUnchecked, !1), this.addFilterElement(), this.expandedCallback());
  }
  addFilterElement(e) {
    var i;
    const t = Be(
      /* html */
      '<div class="ag-filter-toolpanel-instance-filter"></div>'
    ), s = this.createManagedBean(new sn(this.column, "TOOLBAR"));
    this.filterWrapperComp = s, s.hasFilter() && ((i = s.getFilter()) == null || i.then((r) => {
      this.underlyingFilter = r, r && (t.appendChild(s.getGui()), this.agFilterToolPanelBody.appendChild(t), s.afterGuiAttached({ container: "toolPanel", suppressFocus: e }));
    }));
  }
  collapse() {
    if (!this.expanded)
      return;
    this.expanded = !1, He(this.eFilterToolPanelHeader, !1), this.removeFilterElement(), O(this.eExpandChecked, !1), O(this.eExpandUnchecked, !0);
    const e = this.filterWrapperComp;
    e == null || e.afterGuiDetached(), this.destroyBean(e), this.expandedCallback();
  }
  removeFilterElement() {
    X(this.agFilterToolPanelBody);
  }
  isExpanded() {
    return this.expanded;
  }
  refreshFilter(e) {
    var s;
    if (!this.expanded)
      return;
    const t = this.underlyingFilter;
    t && (e ? typeof t.refreshVirtualList == "function" && t.refreshVirtualList() : (s = t.afterGuiDetached) == null || s.call(t));
  }
  onFilterOpened(e) {
    e.source === "COLUMN_MENU" && e.column === this.column && this.expanded && this.collapse();
  }
}, os = class bf extends L {
  constructor(t, s, i, r, o) {
    super(), this.columnGroup = t, this.childFilterComps = s, this.expandedCallback = i, this.depth = r, this.showingColumn = o, this.filterGroupComp = S;
  }
  postConstruct() {
    const t = {
      cssIdentifier: "filter-toolpanel",
      direction: "vertical"
    };
    this.setTemplate(
      /* html */
      `<div class="ag-filter-toolpanel-group-wrapper">
            <ag-group-component data-ref="filterGroupComp"></ag-group-component>
        </div>`,
      [le],
      { filterGroupComp: t }
    ), this.setGroupTitle();
    const { filterGroupComp: s, depth: i, childFilterComps: r, gos: o } = this;
    s.setAlignItems("stretch"), s.addCssClass(`ag-filter-toolpanel-group-level-${i}`), s.getGui().style.setProperty("--ag-indentation-level", String(i)), s.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${i}-header`), r.forEach((n) => {
      s.addItem(n), n.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${i + 1}-header`), n.getGui().style.setProperty("--ag-indentation-level", String(i + 1));
    }), this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "filterToolPanelColumnGroup",
        shouldDisplayTooltip: ln(
          o,
          () => s.getGui().querySelector(".ag-group-title")
        )
      })
    ), this.refreshFilterClass(), this.addExpandCollapseListeners(), this.addFilterChangedListeners(), this.setupTooltip(), this.addInIcon("filterActive");
  }
  setupTooltip() {
    if (!this.showingColumn)
      return;
    const t = () => {
      var s;
      (s = this.tooltipFeature) == null || s.setTooltipAndRefresh(this.columnGroup.getColDef().headerTooltip);
    };
    t(), this.addManagedEventListeners({ newColumnsLoaded: t });
  }
  addCssClassToTitleBar(t) {
    this.filterGroupComp.addCssClassToTitleBar(t);
  }
  refreshFilters(t) {
    this.childFilterComps.forEach((s) => {
      s instanceof bf ? s.refreshFilters(t) : s.refreshFilter(t);
    });
  }
  isColumnGroup() {
    return ae(this.columnGroup);
  }
  isExpanded() {
    return this.filterGroupComp.isExpanded();
  }
  getChildren() {
    return this.childFilterComps;
  }
  getFilterGroupName() {
    return this.filterGroupName ?? "";
  }
  getFilterGroupId() {
    return this.columnGroup.getId();
  }
  hideGroupItem(t, s) {
    this.filterGroupComp.hideItem(t, s);
  }
  hideGroup(t) {
    this.setDisplayed(!t);
  }
  addInIcon(t) {
    const s = B(t, this.beans);
    s && s.classList.add("ag-filter-toolpanel-group-instance-header-icon"), this.filterGroupComp.addTitleBarWidget(s);
  }
  forEachToolPanelFilterChild(t) {
    this.childFilterComps.forEach((s) => {
      s instanceof yf && t(s);
    });
  }
  addExpandCollapseListeners() {
    const t = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.expand()), s = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.collapse());
    this.addManagedListeners(this.filterGroupComp, {
      expanded: t,
      collapsed: s
    });
  }
  getColumns() {
    return ae(this.columnGroup) ? this.columnGroup.getLeafColumns() : [this.columnGroup];
  }
  addFilterChangedListeners() {
    this.getColumns().forEach((t) => {
      this.addManagedListeners(t, { filterChanged: () => this.refreshFilterClass() });
    }), ae(this.columnGroup) || this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) });
  }
  refreshFilterClass() {
    const t = this.getColumns(), s = () => t.some((i) => i.isFilterActive());
    this.filterGroupComp.addOrRemoveCssClass("ag-has-filter", s());
  }
  onFilterOpened(t) {
    t.source === "COLUMN_MENU" && t.column === this.columnGroup && this.isExpanded() && this.collapse();
  }
  expand() {
    this.filterGroupComp.toggleGroupExpand(!0);
  }
  collapse() {
    this.filterGroupComp.toggleGroupExpand(!1);
  }
  setGroupTitle() {
    const t = this.columnGroup, s = ae(t) ? this.getColumnGroupName(t) : this.getColumnName(t);
    this.filterGroupName = s, this.filterGroupComp.setTitle(s || "");
  }
  getColumnGroupName(t) {
    return this.beans.colNames.getDisplayNameForProvidedColumnGroup(null, t, "filterToolPanel");
  }
  getColumnName(t) {
    return this.beans.colNames.getDisplayNameForColumn(t, "filterToolPanel", !1);
  }
  destroyFilters() {
    this.childFilterComps = this.destroyBeans(this.childFilterComps), X(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}, dO = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-filter-list-panel"></div>'
    ), this.initialised = !1, this.hasLoadedInitialState = !1, this.isInitialState = !1, this.filterGroupComps = [], this.suppressOnColumnsChanged = !1, this.onColumnsChangedPending = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  init(e) {
    this.initialised = !0;
    const t = this.gos.addGridCommonParams({
      suppressExpandAll: !1,
      suppressFilterSearch: !1,
      suppressSyncLayoutWithGrid: !1
    });
    pe(t, e), this.params = t, t.suppressSyncLayoutWithGrid || this.addManagedEventListeners({ columnMoved: () => this.onColumnsChanged() }), this.addManagedEventListeners({
      newColumnsLoaded: () => this.onColumnsChanged(),
      toolPanelVisibleChanged: (s) => {
        s.key === "filters" && this.refreshFilters(s.visible);
      },
      dragStarted: () => {
        this.suppressOnColumnsChanged = !0;
      },
      dragStopped: () => {
        this.suppressOnColumnsChanged = !1, this.onColumnsChangedPending && (this.onColumnsChangedPending = !1, this.onColumnsChanged());
      }
    }), this.colModel.ready && this.onColumnsChanged();
  }
  onColumnsChanged() {
    if (this.suppressOnColumnsChanged) {
      this.onColumnsChangedPending = !0;
      return;
    }
    const e = this.colModel.isPivotMode();
    !this.params.suppressSyncLayoutWithGrid && !e ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs(), this.refreshAriaLabel();
  }
  syncFilterLayout() {
    _g(this.colModel, this.setFiltersLayout.bind(this)), this.refreshAriaLabel();
  }
  buildTreeFromProvidedColumnDefs() {
    const e = this.colModel.getColDefColTree();
    this.recreateFilters(e);
  }
  setFiltersLayout(e) {
    const t = Wg(this.colModel, e);
    this.recreateFilters(t);
  }
  recreateFilters(e) {
    const t = q(this.beans);
    this.hasLoadedInitialState || (this.hasLoadedInitialState = !0, this.isInitialState = !!this.params.initialState);
    const s = this.getExpansionState();
    this.destroyFilters();
    const i = this.recursivelyAddComps(e, 0, s);
    this.filterGroupComps = i;
    const r = i.length;
    r && (i.forEach((n) => this.appendChild(n)), this.setFirstAndLastVisible(0, r - 1));
    const o = this.searchFilterText;
    A(o) && this.searchFilters(o), this.fireExpandedEvent(), this.getGui().contains(t) && t.focus(), this.isInitialState = !1, this.refreshAriaLabel();
  }
  recursivelyAddComps(e, t, s) {
    return e.map((i) => {
      var l;
      if (ae(i))
        return ((l = this.recursivelyAddFilterGroupComps(i, t, s)) == null ? void 0 : l.flatMap((d) => d)) ?? [];
      const r = i;
      if (!this.shouldDisplayFilter(r))
        return [];
      const o = t === 0, n = new yf(o, () => this.onFilterExpanded());
      if (this.createBean(n), n.setColumn(r), s.get(r.getId()) && n.expand(), t > 0)
        return n;
      const a = this.createBean(
        new os(r, [n], this.onGroupExpanded.bind(this), t, !0)
      );
      return a.addCssClassToTitleBar("ag-filter-toolpanel-header"), s.get(a.getFilterGroupId()) || a.collapse(), a;
    }).flatMap((i) => i);
  }
  refreshAriaLabel() {
    const e = this.getLocaleTextFunc(), t = e("ariaFilterPanelList", "Filter List"), s = e("filters", "Filters"), l = this.getGui().querySelectorAll(".ag-filter-toolpanel-group-item:not(.ag-filter-toolpanel-group-wrapper, .ag-hidden)").length;
    oe(this.getAriaElement(), `${t} ${l} ${s}`);
  }
  recursivelyAddFilterGroupComps(e, t, s) {
    if (!this.filtersExistInChildren(e.getChildren()))
      return;
    const i = e.getColGroupDef();
    if (i && i.suppressFiltersToolPanel)
      return [];
    const r = e.isPadding() ? t : t + 1, o = this.recursivelyAddComps(e.getChildren(), r, s).flatMap(
      (l) => l
    );
    if (e.isPadding())
      return o;
    const n = new os(
      e,
      o,
      this.onGroupExpanded.bind(this),
      t,
      !1
    );
    this.createBean(n), n.addCssClassToTitleBar("ag-filter-toolpanel-header");
    const a = s.get(n.getFilterGroupId());
    return (this.isInitialState && !a || a === !1) && n.collapse(), [n];
  }
  filtersExistInChildren(e) {
    return e.some((t) => ae(t) ? this.filtersExistInChildren(t.getChildren()) : this.shouldDisplayFilter(t));
  }
  shouldDisplayFilter(e) {
    const t = e.getColDef() && e.getColDef().suppressFiltersToolPanel;
    return e.isFilterAllowed() && !t;
  }
  getExpansionState() {
    const e = /* @__PURE__ */ new Map();
    if (this.isInitialState) {
      const { expandedColIds: s, expandedGroupIds: i } = this.params.initialState;
      return s.forEach((r) => e.set(r, !0)), i.forEach((r) => e.set(r, !0)), e;
    }
    const t = (s) => {
      e.set(s.getFilterGroupId(), s.isExpanded()), s.getChildren().forEach((i) => {
        i instanceof os ? t(i) : e.set(i.getColumn().getId(), i.isExpanded());
      });
    };
    return this.filterGroupComps.forEach(t), e;
  }
  // we don't support refreshing, but must implement because it's on the tool panel interface
  refresh() {
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  expandFilterGroups(e, t) {
    const s = [], i = (r) => {
      const o = r.getFilterGroupId();
      (!t || t.includes(o)) && (e && r.isColumnGroup() ? r.expand() : r.collapse(), s.push(o)), r.getChildren().forEach((a) => {
        a instanceof os && i(a);
      });
    };
    if (this.filterGroupComps.forEach(i), this.onGroupExpanded(), t) {
      const r = t.filter((o) => s.indexOf(o) < 0);
      r.length > 0 && R(166, { unrecognisedGroupIds: r });
    }
  }
  expandFilters(e, t) {
    const s = [], i = (r) => {
      if (r instanceof os) {
        let a = !1;
        return r.getChildren().forEach((l) => {
          i(l) && (e ? (r.expand(), a = !0) : r.isColumnGroup() || r.collapse());
        }), a;
      }
      const o = r.getColumn().getColId(), n = !t || t.includes(o);
      return n && (e ? r.expand() : r.collapse(), s.push(o)), n;
    };
    if (this.filterGroupComps.forEach(i), this.onGroupExpanded(), t) {
      const r = t.filter((o) => s.indexOf(o) < 0);
      r.length > 0 && R(167, { unrecognisedColIds: r });
    }
  }
  onGroupExpanded() {
    this.fireExpandedEvent();
  }
  onFilterExpanded() {
    this.dispatchLocalEvent({ type: "filterExpanded" });
  }
  fireExpandedEvent() {
    let e = 0, t = 0;
    const s = (r) => {
      r.isColumnGroup() && (r.isExpanded() ? e++ : t++, r.getChildren().forEach((o) => {
        o instanceof os && s(o);
      }));
    };
    this.filterGroupComps.forEach(s);
    let i;
    e > 0 && t > 0 ? i = 2 : t > 0 ? i = 1 : i = 0, this.dispatchLocalEvent({ type: "groupExpanded", state: i });
  }
  performFilterSearch(e) {
    this.searchFilterText = A(e) ? e.toLowerCase() : null, this.searchFilters(this.searchFilterText);
  }
  searchFilters(e) {
    const t = (o) => !A(e) || o.toLowerCase().indexOf(e) !== -1, s = (o, n) => {
      if (!(o instanceof os))
        return t(o.getColumnFilterName() || "");
      const a = o.getChildren(), l = t(o.getFilterGroupName()), d = n || l;
      if (d) {
        o.hideGroup(!1);
        for (let h = 0; h < a.length; h++)
          s(a[h], d), o.hideGroupItem(!1, h);
        return !0;
      }
      let c = !1;
      return a.forEach((h, u) => {
        const p = s(h, n);
        o.hideGroupItem(!p, u), p && (c = !0);
      }), o.hideGroup(!c), c;
    };
    let i, r;
    this.filterGroupComps.forEach((o, n) => {
      s(o, !1), i === void 0 ? o.containsCssClass("ag-hidden") || (i = n, r = n) : !o.containsCssClass("ag-hidden") && r !== n && (r = n);
    }), this.setFirstAndLastVisible(i, r), this.refreshAriaLabel();
  }
  setFirstAndLastVisible(e, t) {
    this.filterGroupComps.forEach((s, i) => {
      s.removeCssClass("ag-first-group-visible"), s.removeCssClass("ag-last-group-visible"), i === e && s.addCssClass("ag-first-group-visible"), i === t && s.addCssClass("ag-last-group-visible");
    });
  }
  refreshFilters(e) {
    this.filterGroupComps.forEach((t) => t.refreshFilters(e));
  }
  getExpandedFiltersAndGroups() {
    const e = [], t = /* @__PURE__ */ new Set(), s = (i) => {
      if (i instanceof os) {
        i.getChildren().forEach((o) => s(o));
        const r = i.getFilterGroupId();
        i.isExpanded() && !t.has(r) && e.push(r);
      } else
        i.isExpanded() && t.add(i.getColumn().getColId());
    };
    return this.filterGroupComps.forEach(s), { expandedGroupIds: e, expandedColIds: Array.from(t) };
  }
  destroyFilters() {
    this.filterGroupComps = this.destroyBeans(this.filterGroupComps), X(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}, cO = {
  selector: "AG-FILTERS-TOOL-PANEL-LIST",
  component: dO
}, hO = (
  /*css*/
  ".ag-filter-toolpanel{flex:1 1 0px;min-width:0}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{align-items:center;color:var(--ag-header-text-color);display:flex;font-weight:500;padding:0 var(--ag-spacing);>*{align-items:center;display:flex}}.ag-filter-toolpanel-header{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing);position:relative;&:focus-visible{border-radius:var(--ag-border-radius);box-shadow:inset var(--ag-focus-shadow)}}:where(.ag-ltr) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-ltr) .ag-filter-toolpanel-instance-header-icon{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-rtl) .ag-filter-toolpanel-instance-header-icon{margin-right:var(--ag-spacing)}.ag-filter-toolpanel-search{margin-bottom:var(--ag-spacing);margin-top:var(--ag-widget-container-vertical-padding)}:where(.ag-filter-toolpanel-group:not(.ag-has-filter)>.ag-group-title-bar) .ag-filter-toolpanel-group-instance-header-icon{display:none}.ag-filter-toolpanel-search-input{flex-grow:1;height:calc(var(--ag-spacing)*4)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar-icon{margin-left:var(--ag-spacing)}.ag-filter-toolpanel-expand{cursor:pointer}:where(.ag-ltr) .ag-filter-toolpanel-expand{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-expand{margin-left:var(--ag-spacing)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar,:where(.ag-ltr) .ag-filter-toolpanel-instance-header{padding-left:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar,:where(.ag-rtl) .ag-filter-toolpanel-instance-header{padding-right:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-ltr) .ag-filter-toolpanel-instance-body{margin-left:var(--ag-filter-tool-panel-group-indent)}:where(.ag-rtl) .ag-filter-toolpanel-instance-body{margin-right:var(--ag-filter-tool-panel-group-indent)}.ag-filter-toolpanel-instance-filter{background-color:var(--ag-chrome-background-color)}.ag-filter-toolpanel-group-level-0{border-top:none}"
), uO = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-filter-toolpanel">
            <ag-filters-tool-panel-header data-ref="filtersToolPanelHeaderPanel"></ag-filters-tool-panel-header>
            <ag-filters-tool-panel-list data-ref="filtersToolPanelListPanel"></ag-filters-tool-panel-list>
         </div>`,
      [lO, cO]
    ), this.filtersToolPanelHeaderPanel = S, this.filtersToolPanelListPanel = S, this.initialised = !1, this.listenerDestroyFuncs = [], this.registerCSS(hO);
  }
  init(e) {
    this.initialised && (this.listenerDestroyFuncs.forEach((a) => a()), this.listenerDestroyFuncs = []), this.initialised = !0;
    const s = {
      ...this.gos.addGridCommonParams({
        suppressExpandAll: !1,
        suppressFilterSearch: !1,
        suppressSyncLayoutWithGrid: !1
      }),
      ...e
    };
    this.params = s;
    const { filtersToolPanelHeaderPanel: i, filtersToolPanelListPanel: r } = this;
    i.init(s), r.init(s);
    const o = s.suppressExpandAll, n = s.suppressFilterSearch;
    o && n && i.setDisplayed(!1), this.listenerDestroyFuncs.push(
      ...this.addManagedListeners(i, {
        expandAll: () => r.expandFilterGroups(!0),
        collapseAll: () => r.expandFilterGroups(!1),
        searchChanged: (a) => r.performFilterSearch(a.searchText)
      }),
      ...this.addManagedListeners(r, {
        filterExpanded: s.onStateUpdated,
        groupExpanded: (a) => {
          i.setExpandState(a.state), s.onStateUpdated();
        }
      })
    );
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  setFilterLayout(e) {
    this.filtersToolPanelListPanel.setFiltersLayout(e);
  }
  expandFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!0, e);
  }
  collapseFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!1, e);
  }
  expandFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!0, e);
  }
  collapseFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!1, e);
  }
  syncLayoutWithGrid() {
    this.filtersToolPanelListPanel.syncFilterLayout();
  }
  refresh(e) {
    return this.init(e), !0;
  }
  getState() {
    return this.filtersToolPanelListPanel.getExpandedFiltersAndGroups();
  }
}, pO = {
  moduleName: "FiltersToolPanel",
  version: j,
  userComponents: { agFiltersToolPanel: uO },
  icons: {
    // filter tool panel tab
    filtersToolPanel: "filter"
  },
  dependsOn: [ql, te, Ds]
}, Sf = class extends P {
  constructor() {
    super(...arguments), this.loadRowDataVersion = 0;
  }
  init(e, t) {
    this.params = t, this.comp = e, t.pinned == null && (this.setAutoHeightClasses(), this.setupRefreshStrategy(), this.createDetailGrid(), this.loadRowData(), this.addManagedEventListeners({ fullWidthRowFocused: this.onFullWidthRowFocused.bind(this) }));
  }
  onFullWidthRowFocused(e) {
    const t = this.params, s = { rowIndex: t.node.rowIndex, rowPinned: t.node.rowPinned }, i = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    fe(s, i) && ve(this.comp.getGui(), e.fromBelow);
  }
  setAutoHeightClasses() {
    const e = this.gos.get("detailRowAutoHeight"), t = e ? "ag-details-row-auto-height" : "ag-details-row-fixed-height", s = e ? "ag-details-grid-auto-height" : "ag-details-grid-fixed-height", i = this.comp;
    i.addOrRemoveCssClass(t, !0), i.addOrRemoveDetailGridCssClass(s, !0);
  }
  setupRefreshStrategy() {
    const e = this.params.refreshStrategy;
    if (e == "everything" || e == "nothing" || e == "rows") {
      this.refreshStrategy = e;
      return;
    }
    e != null && R(170, { providedStrategy: e }), this.refreshStrategy = "rows";
  }
  createDetailGrid() {
    const { params: e, gos: t } = this;
    if (Y(e.detailGridOptions)) {
      R(171);
      return;
    }
    const s = { ...e.detailGridOptions };
    t.get("detailRowAutoHeight") && (s.domLayout = "autoHeight"), s.theme || (s.theme = t.get("theme")), this.comp.setDetailGrid(s);
  }
  registerDetailWithMaster(e) {
    const t = this.params, s = t.node.id, i = t.api, r = {
      id: s,
      api: e
    }, o = t.node;
    i.isDestroyed() || (i.addDetailGridInfo(s, r), o.detailGridInfo = r, this.addDestroyFunc(() => {
      o.detailGridInfo === r && (i.isDestroyed() || i.removeDetailGridInfo(s), o.detailGridInfo = null);
    }));
  }
  loadRowData() {
    var o, n, a;
    this.loadRowDataVersion++;
    const e = this.loadRowDataVersion, t = this.params;
    if (((o = t.detailGridOptions) == null ? void 0 : o.rowModelType) === "serverSide") {
      (a = (n = t.node.detailGridInfo) == null ? void 0 : n.api) == null || a.refreshServerSide({ purge: !0 });
      return;
    }
    const s = t.getDetailRowData;
    if (!s) {
      R(172);
      return;
    }
    const i = (l) => {
      this.loadRowDataVersion === e && this.comp.setRowData(l);
    }, r = {
      node: t.node,
      // we take data from node, rather than params.data
      // as the data could have been updated with new instance
      data: t.node.data,
      successCallback: i,
      context: this.gos.getGridCommonParams().context
    };
    s(r);
  }
  refresh() {
    switch (this.refreshStrategy) {
      case "nothing":
        return !0;
      case "everything":
        return !1;
    }
    return this.loadRowData(), !0;
  }
}, gO = class {
  constructor(e) {
    this.parentWrapper = e;
  }
  wrap(e, t, s, i) {
    return this.parentWrapper.wrap(e, t, s, i);
  }
}, fO = class extends L {
  constructor() {
    super(...arguments), this.eDetailGrid = S;
  }
  wireBeans(e) {
    this.context = e.context;
  }
  init(e) {
    this.params = e, this.selectAndSetTemplate();
    const t = {
      addOrRemoveCssClass: (s, i) => this.addOrRemoveCssClass(s, i),
      addOrRemoveDetailGridCssClass: (s, i) => this.eDetailGrid.classList.toggle(s, i),
      setDetailGrid: (s) => this.setDetailGrid(s),
      setRowData: (s) => this.setRowData(s),
      getGui: () => this.eDetailGrid
    };
    this.ctrl = this.createManagedBean(new Sf()), this.ctrl.init(t, e);
  }
  refresh() {
    return this.ctrl && this.ctrl.refresh();
  }
  selectAndSetTemplate() {
    const e = this.params;
    if (e.pinned) {
      this.setTemplate(
        /* html*/
        '<div class="ag-details-row"></div>'
      );
      return;
    }
    const t = () => {
      this.setTemplate(
        /* html */
        `<div class="ag-details-row" role="gridcell">
                <div data-ref="eDetailGrid" class="ag-details-grid" role="presentation"></div>
            </div>`
      );
    };
    if (Y(e.template))
      t();
    else if (typeof e.template == "string")
      this.setTemplate(e.template, []);
    else if (typeof e.template == "function") {
      const s = e.template, i = s(e);
      this.setTemplate(i, []);
    } else
      R(168), t();
    this.eDetailGrid == null && R(169);
  }
  setDetailGrid(e) {
    if (!this.eDetailGrid)
      return;
    const t = this.context.getBean("frameworkCompWrapper"), s = new gO(t), { frameworkOverrides: i } = this.beans, r = Lp(this.eDetailGrid, e, {
      frameworkOverrides: i,
      providedBeanInstances: {
        frameworkCompWrapper: s
      },
      modules: ew(this.params.api.getGridId(), e.rowModelType ?? "clientSide")
    });
    this.detailApi = r, this.ctrl.registerDetailWithMaster(r), this.addDestroyFunc(() => {
      r == null || r.destroy();
    });
  }
  setRowData(e) {
    var t;
    (t = this.detailApi) == null || t.setGridOption("rowData", e);
  }
};
function wn(e, t) {
  var i;
  const s = (i = e.masterDetailSvc) == null ? void 0 : i.store;
  return s ? t(s) : void 0;
}
function mO(e, t, s) {
  wn(e, (i) => {
    i[t] = s;
  });
}
function CO(e, t) {
  wn(e, (s) => {
    delete s[t];
  });
}
function vO(e, t) {
  return wn(e, (s) => s[t]);
}
function wO(e, t) {
  wn(e, (s) => {
    let i = 0;
    Object.values(s).forEach((r) => {
      r && t(r, i++);
    });
  });
}
var yO = (
  /*css*/
  ".ag-details-row{width:100%}.ag-details-row-fixed-height{height:100%}.ag-details-grid{width:100%}.ag-details-grid-fixed-height{height:100%}"
), bO = class extends P {
  constructor() {
    super(...arguments), this.beanName = "masterDetailSvc", this.store = {};
  }
  isEnabled() {
    const e = this.gos;
    return e.get("masterDetail") && // TODO: AG-1752: [Tree Data] Allow tree data leaf rows to serve as master rows for detail grids (Tree Data hosting Master/Detail)"
    !e.get("treeData");
  }
  postConstruct() {
    J(this.gos) && (this.enabled = this.isEnabled(), this.addManagedEventListeners({ beforeRefreshModel: this.beforeRefreshModel.bind(this) }));
  }
  beforeRefreshModel({ params: e }) {
    if (e.changedProps) {
      const t = this.isEnabled();
      if (this.enabled !== t) {
        this.setMasters(null);
        return;
      }
    }
    e.rowDataUpdated && this.setMasters(e.changedRowNodes);
  }
  setMasters(e) {
    var n, a;
    const t = this.isEnabled();
    this.enabled = t;
    const s = this.gos, i = s.get("isRowMaster"), r = s.get("groupDefaultExpanded"), o = (l, d, c) => {
      var p;
      const h = l.master;
      let u = t;
      if (t)
        if (d || c) {
          if (i) {
            const g = l.data;
            u = !!g && !!i(g);
          }
        } else
          u = h;
      if (u && d)
        if (r === -1)
          l.expanded = !0;
        else {
          const g = ((p = this.beans.rowGroupColsSvc) == null ? void 0 : p.columns.length) ?? 0;
          l.expanded = g < r;
        }
      else !u && h && (l.expanded = !1);
      u !== h && (l.master = u, l.dispatchRowEvent("masterChanged"));
    };
    if (e) {
      const l = e.updates;
      for (const d of l.keys()) {
        const c = l.get(d);
        o(d, c, !c);
      }
    } else {
      const l = (a = (n = Dt(this.beans)) == null ? void 0 : n.rootNode) == null ? void 0 : a.allLeafChildren;
      if (l)
        for (let d = 0, c = l.length; d < c; ++d)
          o(l[d], !0, !1);
    }
  }
  /** Used by flatten stage to get or create a detail node from a master node */
  getDetail(e) {
    if (!e.master || !e.expanded)
      return null;
    let t = e.detailNode;
    return t || (t = new Qe(this.beans), t.detail = !0, t.selectable = !1, t.parent = e, A(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t);
  }
  setupDetailRowAutoHeight(e, t) {
    const { gos: s, beans: i } = this;
    if (!s.get("detailRowAutoHeight"))
      return;
    const r = () => {
      const n = t.clientHeight;
      if (n != null && n > 0) {
        const a = () => {
          const { rowModel: l } = this.beans, { rowNode: d } = e;
          d.setRowHeight(n), (J(s) || Te(s)) && l.onRowHeightChanged();
        };
        window.setTimeout(a, 0);
      }
    }, o = Rt(i, t, r);
    e.addDestroyFunc(o), r();
  }
  destroy() {
    this.store = {}, super.destroy();
  }
}, SO = {
  moduleName: "SharedMasterDetail",
  version: j,
  beans: [bO],
  userComponents: { agDetailCellRenderer: fO },
  dynamicBeans: { detailCellRendererCtrl: Sf },
  apiFunctions: {
    addDetailGridInfo: mO,
    removeDetailGridInfo: CO,
    getDetailGridInfo: vO,
    forEachDetailGridInfo: wO
  },
  dependsOn: [te, mf, Ql],
  css: [yO]
}, xO = {
  moduleName: "MasterDetail",
  version: j,
  dependsOn: [SO, vn]
}, xf = class extends L {
  constructor() {
    super(...arguments), this.changedCalculatedValues = !1, this.dragging = !1, this.shouldDestroyOnEndDragging = !1;
  }
  postConstruct() {
    const { dragSvc: e, rangeSvc: t } = this.beans;
    e.addDragSource({
      dragStartPixels: 0,
      eElement: this.getGui(),
      onDragStart: this.onDragStart.bind(this),
      onDragging: (s) => {
        this.dragging = !0, t.autoScrollService.check(s), this.changedCalculatedValues && (this.onDrag(s), this.changedCalculatedValues = !1);
      },
      onDragStop: (s) => {
        this.dragging = !1, this.onDragEnd(s), this.clearDragProperties(), this.shouldDestroyOnEndDragging && this.destroy();
      },
      onDragCancel: () => {
        this.dragging = !1, this.onDragCancel(), this.clearDragProperties();
      }
    }), this.addManagedElementListeners(this.getGui(), { mousedown: this.preventRangeExtension.bind(this) });
  }
  getLastCellHovered() {
    return this.lastCellHovered;
  }
  preventRangeExtension(e) {
    e.stopPropagation();
  }
  onDragStart(e) {
    [this.cellHoverListener] = this.addManagedElementListeners(this.beans.ctrlsSvc.get("gridCtrl").getGui(), {
      mousemove: this.updateValuesOnMove.bind(this)
    }), document.body.classList.add(this.getDraggingCssClass());
  }
  getDraggingCssClass() {
    return `ag-dragging-${this.type === 0 ? "fill" : "range"}-handle`;
  }
  updateValuesOnMove(e) {
    const t = ku(this.gos, e);
    !t || this.lastCellHovered && Ti(t, this.lastCellHovered) || (this.lastCellHovered = t, this.changedCalculatedValues = !0);
  }
  clearDragProperties() {
    this.clearValues(), this.beans.rangeSvc.autoScrollService.ensureCleared(), document.body.classList.remove(this.getDraggingCssClass());
  }
  getType() {
    return this.type;
  }
  refresh(e) {
    const t = this.cellCtrl, s = this.getGui(), i = V(this.beans.rangeSvc.getCellRanges()), r = i.startRow, o = i.endRow;
    if (r && o && (Me(o, r) ? (this.rangeStartRow = o, this.rangeEndRow = r) : (this.rangeStartRow = r, this.rangeEndRow = o)), t !== e || !ke(s)) {
      this.cellCtrl = e;
      const n = e.comp.getParentOfValue();
      n && n.appendChild(s);
    }
    this.cellRange = i;
  }
  clearValues() {
    this.lastCellHovered = void 0, this.removeListeners();
  }
  removeListeners() {
    const e = this.cellHoverListener;
    e && (e(), this.cellHoverListener = void 0);
  }
  destroy() {
    var t;
    if (!this.shouldDestroyOnEndDragging && this.dragging) {
      O(this.getGui(), !1), this.shouldDestroyOnEndDragging = !0;
      return;
    }
    this.shouldDestroyOnEndDragging = !1, super.destroy(), this.removeListeners();
    const e = this.getGui();
    (t = e.parentElement) == null || t.removeChild(e);
  }
};
function FO(e) {
  const t = e.length;
  let s = 0;
  if (t <= 1)
    return e;
  for (let h = 0; h < e.length; h++) {
    const u = e[h], p = u.toString().split("e-");
    if (p.length > 1) {
      s = Math.max(s, parseInt(p[1], 10));
      continue;
    }
    Math.floor(u) !== u && (s = Math.max(s, u.toString().split(".")[1].length));
  }
  let i = 0, r = 0, o = 0, n = 0, a = 0;
  for (let h = 0; h < t; h++)
    a = e[h], i += h, r += a, n += h * h, o += h * a;
  const l = (t * o - i * r) / (t * n - i * i), d = r / t - l * i / t, c = [];
  for (let h = 0; h <= t; h++)
    c.push(parseFloat((h * l + d).toFixed(s)));
  return c;
}
var RO = class extends xf {
  constructor() {
    super(
      /* html */
      '<div class="ag-fill-handle"></div>'
    ), this.markedCells = [], this.cellValues = [], this.isUp = !1, this.isLeft = !1, this.isReduce = !1, this.type = 0;
  }
  updateValuesOnMove(e) {
    super.updateValuesOnMove(e), this.initialXY || (this.initialXY = tr(this.beans, e));
    const { x: t, y: s } = this.initialXY, { x: i, y: r } = tr(this.beans, e), o = Math.abs(t - i), n = Math.abs(s - r), a = this.getFillHandleDirection();
    let l;
    a === "xy" ? l = o > n ? "x" : "y" : l = a, l !== this.dragAxis && (this.dragAxis = l, this.changedCalculatedValues = !0);
  }
  onDrag(e) {
    if (!this.initialPosition) {
      const s = this.cellCtrl;
      if (!s)
        return;
      this.initialPosition = s.cellPosition;
    }
    const t = this.getLastCellHovered();
    t && this.markPathFrom(this.initialPosition, t);
  }
  onDragEnd(e) {
    if (this.initialXY = null, !this.markedCells.length)
      return;
    const t = this.dragAxis === "x", { cellRange: s, rangeStartRow: i, rangeEndRow: r, beans: o } = this, n = s.columns.length;
    let a;
    const { rangeSvc: l, eventSvc: d } = o;
    if (!this.isUp && !this.isLeft)
      a = l.createCellRangeFromCellRangeParams({
        rowStartIndex: i.rowIndex,
        rowStartPinned: i.rowPinned,
        columnStart: s.columns[0],
        rowEndIndex: t ? r.rowIndex : this.lastCellMarked.rowIndex,
        rowEndPinned: t ? r.rowPinned : this.lastCellMarked.rowPinned,
        columnEnd: t ? this.lastCellMarked.column : s.columns[n - 1]
      });
    else {
      const c = t ? i : this.lastCellMarked;
      a = l.createCellRangeFromCellRangeParams({
        rowStartIndex: c.rowIndex,
        rowStartPinned: c.rowPinned,
        columnStart: t ? this.lastCellMarked.column : s.columns[0],
        rowEndIndex: r.rowIndex,
        rowEndPinned: r.rowPinned,
        columnEnd: s.columns[n - 1]
      });
    }
    a && (d.dispatchEvent({
      type: "fillStart"
    }), this.handleValueChanged(s, a, e), l.setCellRanges([a]), d.dispatchEvent({
      type: "fillEnd",
      initialRange: s,
      finalRange: a
    }));
  }
  onDragCancel() {
    this.initialXY = null, this.markedCells.length && this.clearMarkedPath();
  }
  getFillHandleDirection() {
    var t;
    const e = (t = Ln(this.gos)) == null ? void 0 : t.direction;
    return e ? e !== "x" && e !== "y" && e !== "xy" ? (R(177), "xy") : e : "xy";
  }
  handleValueChanged(e, t, s) {
    var F;
    const { rangeSvc: i, gos: r, cellNavigation: o, valueSvc: n } = this.beans, a = i.getRangeEndRow(e), l = i.getRangeStartRow(e), d = i.getRangeEndRow(t), c = i.getRangeStartRow(t), h = this.dragAxis === "y";
    if (this.isReduce && !((F = Ln(r)) != null && F.suppressClearOnFillReduction)) {
      const D = h ? e.columns : e.columns.filter((T) => t.columns.indexOf(T) < 0), x = h ? o.getRowBelow(d) : c;
      x && this.clearCellsInRange(x, a, D);
      return;
    }
    const u = [], p = [], g = [], f = [];
    let m = !0, C = 0;
    const v = () => {
      u.length = 0, p.length = 0, g.length = 0, f.length = 0, C = 0;
    }, b = (D, x) => {
      let T = this.isUp ? a : l, I = !1;
      for (h && (m = !0, v()); !I && T; ) {
        const E = St(this.beans, T);
        if (!E)
          break;
        h && D ? y(
          u,
          D,
          E,
          () => !fe(T, this.isUp ? l : a)
        ) : x && (m = !0, v(), x.forEach(
          (M) => y(
            u,
            M,
            E,
            () => M !== (this.isLeft ? e.columns[0] : V(e.columns))
          )
        )), I = fe(T, this.isUp ? c : d), T = this.isUp ? o.getRowAbove(T) : o.getRowBelow(T);
      }
    }, y = (D, x, T, I) => {
      let E, M = !1;
      if (m)
        E = n.getValue(x, T), p.push(E), g.push(n.getValue(x, T, !0)), f.push(n.formatValue(x, T, E)), m = I();
      else {
        const { value: N, fromUserFunction: _, sourceCol: H, sourceRowNode: W } = this.processValues({
          event: s,
          values: D,
          initialValues: p,
          initialNonAggregatedValues: g,
          initialFormattedValues: f,
          col: x,
          rowNode: T,
          idx: C++
        });
        if (E = N, x.isCellEditable(T)) {
          const K = n.getValue(x, T);
          if (!_) {
            if (H) {
              const se = H.getColDef();
              if (se.useValueFormatterForExport !== !1 && se.valueFormatter) {
                const Se = n.formatValue(H, W, E);
                Se != null && (E = Se);
              }
            }
            x.getColDef().useValueParserForImport !== !1 && (E = n.parseValue(
              x,
              T,
              // if no sourceCol, then currentValue is a number
              H ? E : qe(E),
              K
            ));
          }
          !_ || K !== E ? T.setDataValue(x, E, "rangeSvc") : M = !0;
        }
      }
      M || D.push({
        value: E,
        column: x,
        rowNode: T
      });
    };
    if (h)
      e.columns.forEach((D) => {
        b(D);
      });
    else {
      const D = this.isLeft ? [...t.columns].reverse() : t.columns;
      b(void 0, D);
    }
  }
  clearCellsInRange(e, t, s) {
    const i = {
      startRow: e,
      endRow: t,
      columns: s,
      startColumn: s[0]
    };
    this.beans.rangeSvc.clearCellRangeCellValues({ cellRanges: [i] });
  }
  processValues(e) {
    var p;
    const { event: t, values: s, initialValues: i, initialNonAggregatedValues: r, initialFormattedValues: o, col: n, rowNode: a, idx: l } = e, d = (p = Ln(this.gos)) == null ? void 0 : p.setFillValue, c = this.dragAxis === "y";
    let h;
    if (c ? h = this.isUp ? "up" : "down" : h = this.isLeft ? "left" : "right", d) {
      const g = this.gos.addGridCommonParams({
        event: t,
        values: s.map(({ value: m }) => m),
        initialValues: i,
        initialNonAggregatedValues: r,
        initialFormattedValues: o,
        currentIndex: l,
        currentCellValue: this.beans.valueSvc.getValue(n, a),
        direction: h,
        column: n,
        rowNode: a
      }), f = d(g);
      if (f !== !1)
        return { value: f, fromUserFunction: !0 };
    }
    const u = !s.some(({ value: g }) => {
      const f = parseFloat(g);
      return isNaN(f) || f.toString() !== g.toString();
    });
    if (t.altKey || !u) {
      if (u && i.length === 1) {
        const C = this.isUp || this.isLeft ? -1 : 1;
        return { value: parseFloat(V(s).value) + 1 * C, fromUserFunction: !1 };
      }
      const { value: g, column: f, rowNode: m } = s[l % s.length];
      return { value: g, fromUserFunction: !1, sourceCol: f, sourceRowNode: m };
    }
    return {
      value: V(FO(s.map(({ value: g }) => Number(g)))),
      fromUserFunction: !1
    };
  }
  clearValues() {
    this.clearMarkedPath(), this.clearCellValues(), this.lastCellMarked = void 0, super.clearValues();
  }
  clearMarkedPath() {
    this.markedCells.forEach((e) => {
      if (!e.isAlive())
        return;
      const { comp: t } = e;
      t.addOrRemoveCssClass("ag-selection-fill-top", !1), t.addOrRemoveCssClass("ag-selection-fill-right", !1), t.addOrRemoveCssClass("ag-selection-fill-bottom", !1), t.addOrRemoveCssClass("ag-selection-fill-left", !1);
    }), this.markedCells.length = 0, this.isUp = !1, this.isLeft = !1, this.isReduce = !1;
  }
  clearCellValues() {
    this.cellValues.length = 0;
  }
  markPathFrom(e, t) {
    if (this.clearMarkedPath(), this.clearCellValues(), this.dragAxis === "y") {
      if (fe(t, e))
        return;
      const s = Me(t, e), { rangeStartRow: i, rangeEndRow: r } = this;
      s && (t.rowPinned == i.rowPinned && t.rowIndex >= i.rowIndex || i.rowPinned != r.rowPinned && t.rowPinned == r.rowPinned && t.rowIndex <= r.rowIndex) ? (this.reduceVertical(e, t), this.isReduce = !0) : (this.extendVertical(e, t, s), this.isReduce = !1);
    } else {
      const s = e.column, i = t.column;
      if (s === i)
        return;
      const r = this.beans.visibleCols.allCols, o = r.indexOf(s), n = r.indexOf(i);
      n <= o && n >= r.indexOf(this.cellRange.columns[0]) ? (this.reduceHorizontal(e, t), this.isReduce = !0) : (this.extendHorizontal(e, t, n < o), this.isReduce = !1);
    }
    this.lastCellMarked = t;
  }
  extendVertical(e, t, s) {
    const i = this.beans, { rangeSvc: r, cellNavigation: o } = i;
    let n = e;
    do {
      const a = this.cellRange, l = a.columns.length;
      for (let d = 0; d < l; d++) {
        const c = a.columns[d], u = { ...{ rowIndex: n.rowIndex, rowPinned: n.rowPinned }, column: c }, p = r.isCellInSpecificRange(u, a), g = fe(n, e);
        if (s && (this.isUp = !0), !g) {
          const f = It(i, u);
          if (f) {
            this.markedCells.push(f);
            const m = f.comp;
            p || (m.addOrRemoveCssClass("ag-selection-fill-left", d === 0), m.addOrRemoveCssClass("ag-selection-fill-right", d === l - 1)), m.addOrRemoveCssClass(
              s ? "ag-selection-fill-top" : "ag-selection-fill-bottom",
              fe(n, t)
            );
          }
        }
      }
      if (fe(n, t))
        break;
    } while (
      // tslint:disable-next-line
      n = s ? o.getRowAbove(n) : o.getRowBelow(n)
    );
  }
  reduceVertical(e, t) {
    let s = e;
    const i = this.beans, r = i.cellNavigation;
    do {
      const o = this.cellRange, n = o.columns.length, a = fe(s, t);
      for (let l = 0; l < n; l++) {
        const c = { ...{ rowIndex: s.rowIndex, rowPinned: s.rowPinned }, column: o.columns[l] }, h = It(i, c);
        h && (this.markedCells.push(h), h.comp.addOrRemoveCssClass("ag-selection-fill-bottom", fe(s, t)));
      }
      if (a)
        break;
    } while (s = r.getRowAbove(s));
  }
  extendHorizontal(e, t, s) {
    const i = this.beans, { visibleCols: r, cellNavigation: o } = i, n = r.allCols, a = n.indexOf(s ? t.column : e.column), l = n.indexOf(s ? this.cellRange.columns[0] : t.column), d = s ? 0 : 1, c = n.slice(a + d, l + d), { rangeStartRow: h, rangeEndRow: u } = this;
    c.forEach((p) => {
      let g = h, f = !1;
      do {
        f = fe(g, u);
        const m = It(i, {
          rowIndex: g.rowIndex,
          rowPinned: g.rowPinned,
          column: p
        });
        if (m) {
          this.markedCells.push(m);
          const C = m.comp;
          C.addOrRemoveCssClass("ag-selection-fill-top", fe(g, h)), C.addOrRemoveCssClass("ag-selection-fill-bottom", fe(g, u)), s ? (this.isLeft = !0, C.addOrRemoveCssClass("ag-selection-fill-left", p === c[0])) : C.addOrRemoveCssClass("ag-selection-fill-right", p === V(c));
        }
        g = o.getRowBelow(g);
      } while (!f);
    });
  }
  reduceHorizontal(e, t) {
    const s = this.beans, { visibleCols: i, cellNavigation: r } = s, o = i.allCols, n = o.indexOf(t.column), a = o.indexOf(e.column), l = o.slice(n, a), { rangeStartRow: d, rangeEndRow: c } = this;
    l.forEach((h) => {
      let u = d, p = !1;
      do {
        p = fe(u, c);
        const g = It(this.beans, {
          rowIndex: u.rowIndex,
          rowPinned: u.rowPinned,
          column: h
        });
        g && (this.markedCells.push(g), g.comp.addOrRemoveCssClass("ag-selection-fill-right", h === l[0])), u = r.getRowBelow(u);
      } while (!p);
    });
  }
  refresh(e) {
    const t = this.beans.rangeSvc.getCellRanges()[0];
    if (!t.startRow || !t.endRow) {
      this.destroy();
      return;
    }
    super.refresh(e);
  }
}, PO = class extends xf {
  constructor() {
    super(
      /* html */
      '<div class="ag-range-handle"></div>'
    ), this.type = 1, this.rangeFixed = !1;
  }
  onDrag(e) {
    const t = this.getLastCellHovered();
    if (!t)
      return;
    const s = this.beans.rangeSvc, i = s.getCellRanges(), r = V(i);
    this.rangeFixed || (this.fixRangeStartEnd(r), this.rangeFixed = !0), this.endPosition = {
      rowIndex: t.rowIndex,
      rowPinned: t.rowPinned,
      column: t.column
    }, i.length === 2 && i[0].type === dt.DIMENSION && r.type === dt.VALUE && !fe(this.endPosition, s.getRangeEndRow(r)) && s.updateRangeEnd(
      i[0],
      {
        ...this.endPosition,
        column: i[0].columns[0]
      },
      !0
    ), s.extendLatestRangeToCell(this.endPosition);
  }
  onDragEnd(e) {
    const t = V(this.beans.rangeSvc.getCellRanges());
    this.fixRangeStartEnd(t), this.rangeFixed = !1;
  }
  onDragCancel() {
    this.rangeFixed = !1;
  }
  fixRangeStartEnd(e) {
    const t = this.beans.rangeSvc, s = t.getRangeStartRow(e), i = t.getRangeEndRow(e), r = e.columns[0];
    e.startRow = s, e.endRow = i, e.startColumn = r;
  }
}, TO = (
  /*css*/
  ".ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing),.ag-cell-range-selected.ag-cell-range-chart,.ag-cell-range-selected:not(.ag-cell-focus){background-color:var(--ag-range-selection-background-color);&.ag-cell-range-chart{background-color:var(--ag-range-selection-chart-background-color)!important;&.ag-cell-range-chart-category{background-color:var(--ag-range-selection-chart-category-background-color)!important}}}.ag-cell-range-selected-1.ag-cell-range-chart,.ag-cell-range-selected-1:not(.ag-cell-focus),.ag-root:not(.ag-context-menu-open) .ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-1:not(.ag-cell-inline-editing){background-color:var(--ag-range-selection-background-color)}.ag-cell-range-selected-2.ag-cell-range-chart,.ag-cell-range-selected-2:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-3.ag-cell-range-chart,.ag-cell-range-selected-3:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell-range-selected-4.ag-cell-range-chart,.ag-cell-range-selected-4:not(.ag-cell-focus){background-image:linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color)),linear-gradient(var(--ag-range-selection-background-color),var(--ag-range-selection-background-color))}.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell){&.ag-cell-range-top{border-top-color:var(--ag-range-selection-border-color);border-top-style:var(--ag-range-selection-border-style)}&.ag-cell-range-right{border-right-color:var(--ag-range-selection-border-color);border-right-style:var(--ag-range-selection-border-style)}&.ag-cell-range-bottom{border-bottom-color:var(--ag-range-selection-border-color);border-bottom-style:var(--ag-range-selection-border-style)}&.ag-cell-range-left{border-left-color:var(--ag-range-selection-border-color);border-left-style:var(--ag-range-selection-border-style)}}.ag-cell.ag-selection-fill-top,.ag-cell.ag-selection-fill-top.ag-cell-range-selected{border-top:1px dashed;border-top-color:var(--ag-range-selection-border-color)}:where(.ag-ltr) .ag-cell.ag-selection-fill-right,:where(.ag-ltr) .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}:where(.ag-rtl) .ag-cell.ag-selection-fill-right,:where(.ag-rtl) .ag-cell.ag-selection-fill-right.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}.ag-cell.ag-selection-fill-bottom,.ag-cell.ag-selection-fill-bottom.ag-cell-range-selected{border-bottom:1px dashed;border-bottom-color:var(--ag-range-selection-border-color)}:where(.ag-ltr) .ag-cell.ag-selection-fill-left,:where(.ag-ltr) .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-left:1px dashed var(--ag-range-selection-border-color)!important}:where(.ag-rtl) .ag-cell.ag-selection-fill-left,:where(.ag-rtl) .ag-cell.ag-selection-fill-left.ag-cell-range-selected{border-right:1px dashed var(--ag-range-selection-border-color)!important}.ag-fill-handle,.ag-range-handle{background-color:var(--ag-range-selection-border-color);bottom:-1px;height:6px;position:absolute;width:6px}:where(.ag-ltr) .ag-fill-handle,:where(.ag-ltr) .ag-range-handle{right:-1px}:where(.ag-rtl) .ag-fill-handle,:where(.ag-rtl) .ag-range-handle{left:-1px}.ag-fill-handle{cursor:cell}:where(.ag-ltr) .ag-range-handle{cursor:nwse-resize}:where(.ag-rtl) .ag-range-handle{cursor:nesw-resize}"
);
function DO(e) {
  var t;
  return ((t = e.rangeSvc) == null ? void 0 : t.getCellRanges()) ?? null;
}
function EO(e, t) {
  var s;
  (s = e.rangeSvc) == null || s.addCellRange(t);
}
function kc(e) {
  var t;
  (t = e.rangeSvc) == null || t.removeAllCellRanges();
}
var Ki = "ag-cell-range-selected", MO = "ag-cell-range-chart", AO = "ag-cell-range-single-cell", IO = "ag-cell-range-chart-category", LO = "ag-cell-range-handle", kO = "ag-cell-range-top", OO = "ag-cell-range-right", GO = "ag-cell-range-bottom", BO = "ag-cell-range-left";
function VO(e) {
  var i;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((i = t.handle) == null ? void 0 : i.mode) === "range" : !1 : e.get("enableRangeHandle");
}
function Oc(e) {
  var i;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((i = t.handle) == null ? void 0 : i.mode) === "fill" : !1 : e.get("enableFillHandle");
}
var NO = class {
  constructor(e, t) {
    this.beans = e, this.cellCtrl = t, this.rangeSvc = e.rangeSvc;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onCellSelectionChanged();
  }
  onCellSelectionChanged() {
    const e = this.cellComp;
    if (!e)
      return;
    const { rangeSvc: t, cellCtrl: s, eGui: i } = this, r = t.getCellRangeCount(s.cellPosition);
    this.rangeCount = r;
    const o = this.getHasChartRange();
    this.hasChartRange = o, e.addOrRemoveCssClass(Ki, r !== 0), e.addOrRemoveCssClass(`${Ki}-1`, r === 1), e.addOrRemoveCssClass(`${Ki}-2`, r === 2), e.addOrRemoveCssClass(`${Ki}-3`, r === 3), e.addOrRemoveCssClass(`${Ki}-4`, r >= 4), e.addOrRemoveCssClass(MO, o), hr(i, r > 0 ? !0 : void 0), e.addOrRemoveCssClass(AO, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle();
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), s = !t && e.top, i = !t && e.right, r = !t && e.bottom, o = !t && e.left, n = this.cellComp;
    n.addOrRemoveCssClass(kO, s), n.addOrRemoveCssClass(OO, i), n.addOrRemoveCssClass(GO, r), n.addOrRemoveCssClass(BO, o);
  }
  isSingleCell() {
    const { rangeSvc: e } = this;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeSvc: e } = this;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((s) => [dt.DIMENSION, dt.VALUE].includes(s.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = !1, s = !1, i = !1, r = !1;
    const {
      rangeSvc: o,
      beans: { visibleCols: n },
      cellCtrl: { cellPosition: a }
    } = this, l = a.column;
    let d, c;
    e ? (d = n.getColAfter(l), c = n.getColBefore(l)) : (d = n.getColBefore(l), c = n.getColAfter(l));
    const h = o.getCellRanges().filter((u) => o.isCellInSpecificRange(a, u));
    d || (r = !0), c || (s = !0);
    for (let u = 0; u < h.length && !(t && s && i && r); u++) {
      const p = h[u], g = o.getRangeStartRow(p), f = o.getRangeEndRow(p);
      !t && fe(g, a) && (t = !0), !i && fe(f, a) && (i = !0), !r && d && p.columns.indexOf(d) < 0 && (r = !0), !s && c && p.columns.indexOf(c) < 0 && (s = !0);
    }
    return { top: t, right: s, bottom: i, left: r };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed())
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(LO, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeSvc, s = t.getCellRanges(), i = s.length;
    if (this.rangeCount < 1 || i < 1)
      return !1;
    const r = V(s), { cellPosition: o } = this.cellCtrl, n = Oc(e) && !this.cellCtrl.column.isSuppressFillHandle(), a = VO(e);
    let l = i === 1 && !this.cellCtrl.editing && (n || a);
    if (this.hasChartRange) {
      const c = s[0].type === dt.DIMENSION && t.isCellInSpecificRange(o, s[0]);
      this.cellComp.addOrRemoveCssClass(IO, c), l = r.type === dt.VALUE;
    }
    return l && r.endRow != null && t.isContiguousRange(r) && t.isBottomRightCell(r, o);
  }
  addSelectionHandle() {
    var o;
    const { beans: e, rangeSvc: t } = this, s = V(t.getCellRanges()).type, r = Oc(e.gos) && Y(s) ? 0 : 1;
    if (this.selectionHandle && this.selectionHandle.getType() !== r && (this.selectionHandle = e.context.destroyBean(this.selectionHandle)), !this.selectionHandle) {
      const n = e.registry.createDynamicBean(
        r === 0 ? "fillHandle" : "rangeHandle",
        !1
      );
      n && (this.selectionHandle = e.context.createBean(n));
    }
    (o = this.selectionHandle) == null || o.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, HO = class extends P {
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    const { beans: e, gos: t, eContainer: s } = this, i = e.rangeSvc, r = {
      eElement: s,
      onDragStart: i.onDragStart.bind(i),
      onDragStop: i.onDragStop.bind(i),
      onDragging: i.onDragging.bind(i)
    }, o = e.dragSvc, n = o.addDragSource.bind(o, r), a = o.removeDragSource.bind(o, r);
    this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
      Ve(t) ? n() : a();
    }), this.addDestroyFunc(a), Ve(t) && n();
  }
}, zO = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rangeSvc", this.cellRanges = [], this.bodyScrollListener = this.onBodyScroll.bind(this), this.dragging = !1, this.intersectionRange = !1;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.dragSvc = e.dragSvc, this.colModel = e.colModel, this.visibleCols = e.visibleCols, this.cellNavigation = e.cellNavigation, this.pinnedRowModel = e.pinnedRowModel, this.ctrlsSvc = e.ctrlsSvc;
  }
  postConstruct() {
    const e = this.onColumnsChanged.bind(this), t = () => this.removeAllCellRanges(), s = this.refreshLastRangeStart.bind(this);
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      columnVisible: e,
      columnValueChanged: e,
      columnPivotModeChanged: t,
      columnRowGroupChanged: t,
      columnPivotChanged: t,
      columnGroupOpened: s,
      columnMoved: s,
      columnPinned: s
    }), this.ctrlsSvc.whenReady(this, (i) => {
      const r = i.gridBodyCtrl;
      this.autoScrollService = new vl({
        scrollContainer: r.eBodyViewport,
        scrollAxis: "xy",
        getVerticalPosition: () => r.scrollFeature.getVScrollPosition().top,
        setVerticalPosition: (o) => r.scrollFeature.setVerticalScrollPosition(o),
        getHorizontalPosition: () => r.scrollFeature.getHScrollPosition().left,
        setHorizontalPosition: (o) => r.scrollFeature.setHorizontalScrollPosition(o),
        shouldSkipVerticalScroll: () => !ye(this.gos, "normal"),
        shouldSkipHorizontalScroll: () => !r.scrollFeature.isHorizontalScrollShowing()
      });
    });
  }
  // Called for both columns loaded & column visibility events
  onColumnsChanged() {
    this.refreshLastRangeStart();
    const e = this.visibleCols.allCols;
    this.cellRanges.forEach((s) => {
      const i = s.columns;
      s.columns = s.columns.filter(
        (o) => o.isVisible() && e.indexOf(o) !== -1
      ), !Re(i, s.columns) && this.dispatchChangedEvent(!1, !0, s.id);
    });
    const t = this.cellRanges.length;
    this.cellRanges = this.cellRanges.filter((s) => s.columns.length > 0), t > this.cellRanges.length && this.dispatchChangedEvent(!1, !0);
  }
  refreshLastRangeStart() {
    const e = V(this.cellRanges);
    e && this.refreshRangeStart(e);
  }
  isContiguousRange(e) {
    const t = e.columns;
    if (!t.length)
      return !1;
    const s = this.visibleCols.allCols, i = t.map((r) => s.indexOf(r)).sort((r, o) => r - o);
    return V(i) - i[0] + 1 === t.length;
  }
  getRangeStartRow(e) {
    var i;
    return e.startRow && e.endRow ? Me(e.startRow, e.endRow) ? e.startRow : e.endRow : { rowIndex: 0, rowPinned: (((i = this.pinnedRowModel) == null ? void 0 : i.getPinnedTopRowCount()) ?? 0) > 0 ? "top" : null };
  }
  getRangeEndRow(e) {
    var i;
    if (e.startRow && e.endRow)
      return Me(e.startRow, e.endRow) ? e.endRow : e.startRow;
    const t = ((i = this.pinnedRowModel) == null ? void 0 : i.getPinnedBottomRowCount()) ?? 0;
    return t > 0 ? {
      rowIndex: t - 1,
      rowPinned: "bottom"
    } : {
      rowIndex: this.rowModel.getRowCount() - 1,
      rowPinned: null
    };
  }
  setRangeToCell(e, t = !1) {
    if (!Ve(this.gos))
      return;
    const s = this.calculateColumnsBetween(e.column, e.column);
    if (!s)
      return;
    (Gr(this.gos) || !t || Y(this.cellRanges)) && this.removeAllCellRanges(!0);
    const r = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned
    }, o = {
      startRow: r,
      endRow: r,
      columns: s,
      startColumn: e.column
    };
    this.cellRanges.push(o), this.setNewestRangeStartCell(e), this.onDragStop(), this.dispatchChangedEvent(!0, !0);
  }
  extendLatestRangeToCell(e) {
    if (this.isEmpty() || !this.newestRangeStartCell)
      return;
    const t = V(this.cellRanges);
    this.updateRangeEnd(t, e);
  }
  updateRangeEnd(e, t, s = !1) {
    const i = t.column, r = this.calculateColumnsBetween(e.startColumn, i);
    !r || this.isLastCellOfRange(e, t) || (e.columns = r, e.endRow = { rowIndex: t.rowIndex, rowPinned: t.rowPinned }, s || this.dispatchChangedEvent(!0, !0, e.id));
  }
  refreshRangeStart(e) {
    const { startColumn: t, columns: s } = e, i = (l, d) => {
      const c = e.columns.filter((h) => h !== l);
      l ? (e.startColumn = l, e.columns = d ? [l, ...c] : [...c, l]) : e.columns = c;
    }, { left: r, right: o } = this.getRangeEdgeColumns(e);
    if (t === s[0] && t !== r) {
      i(r, !0);
      return;
    }
    if (t === V(s) && t === o) {
      i(o, !1);
      return;
    }
  }
  getRangeEdgeColumns(e) {
    const t = this.visibleCols.allCols, s = e.columns.map((i) => t.indexOf(i)).filter((i) => i > -1).sort((i, r) => i - r);
    return {
      left: t[s[0]],
      right: t[V(s)]
    };
  }
  // returns true if successful, false if not successful
  extendLatestRangeInDirection(e) {
    if (this.isEmpty() || !this.newestRangeStartCell)
      return;
    const t = e.key, s = e.ctrlKey || e.metaKey, i = V(this.cellRanges), r = this.newestRangeStartCell, o = i.columns[0], n = V(i.columns), a = i.endRow.rowIndex, l = i.endRow.rowPinned, c = { column: r.column === o ? n : o, rowIndex: a, rowPinned: l }, h = this.cellNavigation.getNextCellToFocus(t, c, s);
    if (h)
      return this.setCellRange({
        rowStartIndex: r.rowIndex,
        rowStartPinned: r.rowPinned,
        rowEndIndex: h.rowIndex,
        rowEndPinned: h.rowPinned,
        columnStart: r.column,
        columnEnd: h.column
      }), h;
  }
  setCellRange(e) {
    Ve(this.gos) && (this.removeAllCellRanges(!0), this.addCellRange(e));
  }
  setCellRanges(e) {
    Re(this.cellRanges, e) || this.verifyCellRanges(this.gos) && (this.removeAllCellRanges(!0), e.forEach((t) => {
      t.columns && t.startRow && this.setNewestRangeStartCell({
        rowIndex: t.startRow.rowIndex,
        rowPinned: t.startRow.rowPinned,
        column: t.columns[0]
      }), this.cellRanges.push(t);
    }), this.dispatchChangedEvent(!1, !0));
  }
  setNewestRangeStartCell(e) {
    this.newestRangeStartCell = e;
  }
  clearCellRangeCellValues(e) {
    let { cellRanges: t } = e;
    const { cellEventSource: s = "rangeSvc", dispatchWrapperEvents: i, wrapperEventSource: r = "deleteKey" } = e;
    i && (this.eventSvc.dispatchEvent({
      type: "cellSelectionDeleteStart",
      source: r
    }), this.eventSvc.dispatchEvent({
      type: "rangeDeleteStart",
      source: r
    })), t || (t = this.cellRanges), t.forEach((o) => {
      this.forEachRowInRange(o, (n) => {
        const a = St(this.beans, n);
        if (a)
          for (let l = 0; l < o.columns.length; l++) {
            const d = this.colModel.getCol(o.columns[l]);
            if (!d || !d.isCellEditable(a))
              continue;
            const c = this.beans.valueSvc.getDeleteValue(d, a);
            a.setDataValue(d, c, s);
          }
      });
    }), i && (this.eventSvc.dispatchEvent({
      type: "cellSelectionDeleteEnd",
      source: r
    }), this.eventSvc.dispatchEvent({
      type: "rangeDeleteEnd",
      source: r
    }));
  }
  createCellRangeFromCellRangeParams(e) {
    return this.createPartialCellRangeFromRangeParams(e, !1);
  }
  // Range service can't normally support a range without columns, but charts can
  createPartialCellRangeFromRangeParams(e, t) {
    let s, i = !1;
    if (e.columns)
      s = e.columns.map((n) => this.colModel.getCol(n)).filter((n) => n);
    else {
      const n = this.colModel.getCol(e.columnStart), a = this.colModel.getCol(e.columnEnd);
      if (!n || !a)
        return;
      s = this.calculateColumnsBetween(n, a), s && s.length && (i = s[0] !== n);
    }
    if (!s || !t && s.length === 0)
      return;
    const r = e.rowStartIndex != null ? {
      rowIndex: e.rowStartIndex,
      rowPinned: e.rowStartPinned || null
    } : void 0, o = e.rowEndIndex != null ? {
      rowIndex: e.rowEndIndex,
      rowPinned: e.rowEndPinned || null
    } : void 0;
    return {
      startRow: r,
      endRow: o,
      columns: s,
      startColumn: i ? V(s) : s[0]
    };
  }
  verifyCellRanges(e) {
    const t = kC(e) && Gr(e) && this.cellRanges.length > 0;
    return t && R(93), !t;
  }
  addCellRange(e) {
    const t = this.gos;
    if (!Ve(t) || !this.verifyCellRanges(t))
      return;
    const s = this.createCellRangeFromCellRangeParams(e);
    s && (s.startRow && this.setNewestRangeStartCell({
      rowIndex: s.startRow.rowIndex,
      rowPinned: s.startRow.rowPinned,
      column: s.startColumn
    }), this.cellRanges.push(s), this.dispatchChangedEvent(!1, !0, s.id));
  }
  getCellRanges() {
    return this.cellRanges;
  }
  isEmpty() {
    return this.cellRanges.length === 0;
  }
  isMoreThanOneCell() {
    const e = this.cellRanges.length;
    if (e === 0)
      return !1;
    if (e > 1)
      return !0;
    const t = this.cellRanges[0], s = this.getRangeStartRow(t), i = this.getRangeEndRow(t);
    return s.rowPinned !== i.rowPinned || s.rowIndex !== i.rowIndex || t.columns.length !== 1;
  }
  areAllRangesAbleToMerge() {
    const e = /* @__PURE__ */ new Map();
    if (this.cellRanges.length <= 1)
      return !0;
    this.cellRanges.forEach((i) => {
      this.forEachRowInRange(i, (r) => {
        const o = `${r.rowPinned || "normal"}_${r.rowIndex}`, n = e.get(o), a = i.columns.map((l) => l.getId());
        if (n) {
          const l = a.filter((d) => n.indexOf(d) === -1);
          n.push(...l);
        } else
          e.set(o, a);
      });
    });
    let s;
    for (const i of e.values()) {
      const r = i.sort().join();
      if (s === void 0) {
        s = r;
        continue;
      }
      if (s !== r)
        return !1;
    }
    return !0;
  }
  forEachRowInRange(e, t) {
    const s = this.getRangeStartRow(e), i = this.getRangeEndRow(e);
    let r = s;
    for (; r && (t(r), !fe(r, i)); )
      r = this.cellNavigation.getRowBelow(r);
  }
  removeAllCellRanges(e) {
    this.isEmpty() || (this.onDragStop(), this.cellRanges.length = 0, e || this.dispatchChangedEvent(!1, !0));
  }
  // as the user is dragging outside of the panel, the div starts to scroll, which in turn
  // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate
  // the selection my mimicking a new mouse event
  onBodyScroll() {
    this.dragging && this.lastMouseEvent && this.onDragging(this.lastMouseEvent);
  }
  isCellInAnyRange(e) {
    return this.getCellRangeCount(e) > 0;
  }
  isCellInSpecificRange(e, t) {
    const s = t.columns !== null && t.columns.includes(e.column), i = this.isRowInRange(e.rowIndex, e.rowPinned, t);
    return s && i;
  }
  isLastCellOfRange(e, t) {
    const { startRow: s, endRow: i } = e, r = Me(s, i) ? i : s, o = t.rowIndex === r.rowIndex && t.rowPinned === r.rowPinned, n = e.columns[0], a = V(e.columns), l = e.startColumn === n ? a : n;
    return t.column === l && o;
  }
  isBottomRightCell(e, t) {
    const s = this.visibleCols.allCols, i = e.columns.map((d) => s.indexOf(d)).sort((d, c) => d - c), { startRow: r, endRow: o } = e, n = Me(r, o) ? o : r, a = s.indexOf(t.column) === V(i), l = t.rowIndex === n.rowIndex && ge(t.rowPinned) === ge(n.rowPinned);
    return a && l;
  }
  // returns the number of ranges this cell is in
  getCellRangeCount(e) {
    return this.isEmpty() ? 0 : this.cellRanges.filter((t) => this.isCellInSpecificRange(e, t)).length;
  }
  isRowInRange(e, t, s) {
    const i = this.getRangeStartRow(s), r = this.getRangeEndRow(s), o = { rowIndex: e, rowPinned: t || null }, n = o.rowIndex === i.rowIndex && o.rowPinned == i.rowPinned, a = o.rowIndex === r.rowIndex && o.rowPinned == r.rowPinned;
    if (n || a)
      return !0;
    const l = !Me(o, i), d = Me(o, r);
    return l && d;
  }
  getDraggingRange() {
    return this.draggingRange;
  }
  onDragStart(e) {
    var d;
    if (!Ve(this.gos))
      return;
    const { ctrlKey: t, metaKey: s, shiftKey: i } = e, r = t || s, n = !Gr(this.gos) ? r : !1, a = i && !!((d = this.cellRanges) != null && d.length);
    !n && (!a || A(V(this.cellRanges).type)) && this.removeAllCellRanges(!0);
    const l = this.dragSvc.startTarget;
    if (l && this.updateValuesOnMove(l), !!this.lastCellHovered) {
      if (this.dragging = !0, this.lastMouseEvent = e, this.intersectionRange = n && this.getCellRangeCount(this.lastCellHovered) > 1, a || this.setNewestRangeStartCell(this.lastCellHovered), this.cellRanges.length > 0)
        this.draggingRange = V(this.cellRanges);
      else {
        const c = {
          rowIndex: this.lastCellHovered.rowIndex,
          rowPinned: this.lastCellHovered.rowPinned
        };
        this.draggingRange = {
          startRow: c,
          endRow: c,
          columns: [this.lastCellHovered.column],
          startColumn: this.newestRangeStartCell.column
        }, this.cellRanges.push(this.draggingRange);
      }
      this.ctrlsSvc.getGridBodyCtrl().eBodyViewport.addEventListener("scroll", this.bodyScrollListener, { passive: !0 }), this.dispatchChangedEvent(!0, !1, this.draggingRange.id);
    }
  }
  intersectLastRange(e) {
    if (e && this.dragging || Gr(this.gos) || this.isEmpty())
      return;
    const t = V(this.cellRanges), s = this.getRangeStartRow(t), i = this.getRangeEndRow(t), r = [];
    this.cellRanges.slice(0, -1).forEach((o) => {
      const n = this.getRangeStartRow(o), a = this.getRangeEndRow(o), l = o.columns, d = l.filter((h) => t.columns.indexOf(h) === -1);
      if (d.length === l.length) {
        r.push(o);
        return;
      }
      if (Me(i, n) || Me(a, s)) {
        r.push(o);
        return;
      }
      const c = r.length;
      if (Me(n, s)) {
        const h = {
          columns: [...l],
          startColumn: t.startColumn,
          startRow: { ...n },
          endRow: this.cellNavigation.getRowAbove(s)
        };
        r.push(h);
      }
      if (d.length > 0) {
        const h = {
          columns: d,
          startColumn: d.includes(t.startColumn) ? t.startColumn : d[0],
          startRow: this.rowMax([{ ...s }, { ...n }]),
          endRow: this.rowMin([{ ...i }, { ...a }])
        };
        r.push(h);
      }
      Me(i, a) && r.push({
        columns: [...l],
        startColumn: t.startColumn,
        startRow: this.cellNavigation.getRowBelow(i),
        endRow: { ...a }
      }), r.length - c === 1 && (r[r.length - 1].id = o.id);
    }), this.cellRanges = r, e && this.dispatchChangedEvent(!1, !0);
  }
  rowMax(e) {
    let t;
    return e.forEach((s) => {
      (t === void 0 || Me(t, s)) && (t = s);
    }), t;
  }
  rowMin(e) {
    let t;
    return e.forEach((s) => {
      (t === void 0 || Me(s, t)) && (t = s);
    }), t;
  }
  updateValuesOnMove(e) {
    const t = Cl(this.gos, e), s = t == null ? void 0 : t.cellPosition;
    if (this.cellHasChanged = !1, !(!s || this.lastCellHovered && Ti(s, this.lastCellHovered))) {
      if (t != null && t.editing) {
        this.dragSvc.cancelDrag(e);
        return;
      }
      this.lastCellHovered && (this.cellHasChanged = !0), this.lastCellHovered = s;
    }
  }
  onDragging(e) {
    if (!this.dragging || !e)
      return;
    this.updateValuesOnMove(e.target), this.lastMouseEvent = e;
    const t = this.lastCellHovered, s = (o) => t && t.rowPinned === o && this.newestRangeStartCell.rowPinned === o, i = s("top") || s("bottom");
    if (this.autoScrollService.check(e, i), !this.cellHasChanged)
      return;
    const r = this.calculateColumnsBetween(
      this.newestRangeStartCell.column,
      t.column
    );
    r && (this.draggingRange.endRow = {
      rowIndex: t.rowIndex,
      rowPinned: t.rowPinned
    }, this.draggingRange.columns = r, this.dispatchChangedEvent(!1, !1, this.draggingRange.id));
  }
  onDragStop() {
    if (!this.dragging)
      return;
    const { id: e } = this.draggingRange;
    this.autoScrollService.ensureCleared(), this.ctrlsSvc.getGridBodyCtrl().eBodyViewport.removeEventListener("scroll", this.bodyScrollListener), this.lastMouseEvent = null, this.dragging = !1, this.draggingRange = void 0, this.lastCellHovered = void 0, this.intersectionRange && (this.intersectionRange = !1, this.intersectLastRange()), this.dispatchChangedEvent(!1, !0, e);
  }
  dispatchChangedEvent(e, t, s) {
    this.eventSvc.dispatchEvent({
      type: "cellSelectionChanged",
      started: e,
      finished: t,
      id: s
    }), this.eventSvc.dispatchEvent({
      type: "rangeSelectionChanged",
      started: e,
      finished: t,
      id: s
    });
  }
  calculateColumnsBetween(e, t) {
    const s = this.visibleCols.allCols, i = e === t, r = s.indexOf(e);
    if (r < 0) {
      R(178, { colId: e.getId() });
      return;
    }
    const o = i ? r : s.indexOf(t);
    if (o < 0) {
      R(178, { colId: t.getId() });
      return;
    }
    if (i)
      return [e];
    const n = Math.min(r, o), a = n === r ? o : r, l = [];
    for (let d = n; d <= a; d++)
      l.push(s[d]);
    return l;
  }
  createDragListenerFeature(e) {
    return new HO(e);
  }
  createCellRangeFeature(e, t) {
    return new NO(e, t);
  }
}, Ff = {
  moduleName: "CellSelection",
  version: j,
  beans: [zO],
  dynamicBeans: { fillHandle: RO, rangeHandle: PO },
  apiFunctions: {
    getCellRanges: DO,
    addCellRange: EO,
    clearRangeSelection: kc,
    clearCellSelection: kc
  },
  dependsOn: [te, cn, Il],
  css: [TO]
}, WO = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`
    ), this.eLoadingIcon = S, this.eLoadingText = S;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = B("groupLoading", this.beans, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
}, _O = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-skeleton-container"></div>'
    );
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => vs(e.eParentOfValue)), vs(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.getLocaleTextFunc();
    this.getGui().innerText = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    oe(this.getGui(), t);
  }
  setupLoading(e) {
    const s = Z(this.beans).createElement("div");
    s.classList.add("ag-skeleton-effect");
    const i = e.node.rowIndex;
    if (i != null) {
      const n = 75 + 25 * (i % 2 === 0 ? Math.sin(i) : Math.cos(i));
      s.style.width = `${n}%`;
    }
    this.getGui().appendChild(s);
    const o = this.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    oe(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
}, UO = {
  moduleName: "LoadingCellRenderer",
  version: j,
  userComponents: {
    agLoadingCellRenderer: WO
  },
  icons: {
    // rotating spinner shown by the loading cell renderer
    groupLoading: "loading"
  },
  dependsOn: [te]
}, KO = {
  moduleName: "SkeletonCellRenderer",
  version: j,
  userComponents: {
    agSkeletonCellRenderer: _O
  },
  dependsOn: [te]
};
function $O(e) {
  return e.colModel.isPivotMode();
}
function jO(e, t, s) {
  var i;
  return ((i = e.pivotResultCols) == null ? void 0 : i.lookupPivotResultCol(t, s)) ?? null;
}
function qO(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.setColumns(t, "api");
}
function YO(e) {
  var t;
  return ((t = e.valueColsSvc) == null ? void 0 : t.columns) ?? [];
}
function XO(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.removeColumns(t, "api");
}
function ZO(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.addColumns(t, "api");
}
function QO(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.setColumns(t, "api");
}
function JO(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.removeColumns(t, "api");
}
function eG(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.addColumns(t, "api");
}
function tG(e) {
  var t;
  return ((t = e.pivotColsSvc) == null ? void 0 : t.columns) ?? [];
}
function sG(e, t) {
  var s;
  (s = e.pivotResultCols) == null || s.setPivotResultCols(t, "api");
}
function iG(e) {
  var s;
  const t = (s = e.pivotResultCols) == null ? void 0 : s.getPivotResultCols();
  return t ? t.list : null;
}
var Gc = "PivotRowTotal_", rG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pivotColDefSvc";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.colNames = e.colNames;
  }
  postConstruct() {
    const e = () => this.gos.get("serverSidePivotResultFieldSeparator") ?? "_";
    this.fieldSeparator = e(), this.addManagedPropertyListener("serverSidePivotResultFieldSeparator", () => {
      this.fieldSeparator = e();
    });
    const t = () => this.gos.get("pivotDefaultExpanded");
    this.pivotDefaultExpanded = t(), this.addManagedPropertyListener("pivotDefaultExpanded", () => {
      this.pivotDefaultExpanded = t();
    });
  }
  createPivotColumnDefs(e) {
    const t = this.createPivotColumnsFromUniqueValues(e);
    function s(o, n = []) {
      return o.forEach((a) => {
        a.children !== void 0 ? s(a.children, n) : n.push(a);
      }), n;
    }
    const i = s(t);
    this.addRowGroupTotals(t, i), this.addExpandablePivotGroups(t, i), this.addPivotTotalsToGroups(t, i);
    const r = i.map((o) => ({ ...o }));
    return {
      pivotColumnGroupDefs: t,
      pivotColumnDefs: r
    };
  }
  createPivotColumnsFromUniqueValues(e) {
    var r;
    const t = ((r = this.pivotColsSvc) == null ? void 0 : r.columns) ?? [], s = t.length;
    return this.recursivelyBuildGroup(
      0,
      e,
      [],
      s,
      t
    );
  }
  recursivelyBuildGroup(e, t, s, i, r) {
    var d;
    const o = (d = this.valueColsSvc) == null ? void 0 : d.columns;
    if (e >= i)
      return this.buildMeasureCols(s);
    const n = r[e].getColDef(), a = this.headerNameComparator.bind(this, n.pivotComparator);
    if ((o == null ? void 0 : o.length) === 1 && this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && e === i - 1) {
      const c = [];
      for (const h of Object.keys(t)) {
        const u = [...s, h], p = this.createColDef(o[0], h, u);
        p.columnGroupShow = "open", c.push(p);
      }
      return c.sort(a), c;
    }
    const l = [];
    for (const [c, h] of Object.entries(t)) {
      const u = this.pivotDefaultExpanded === -1 || e < this.pivotDefaultExpanded, p = [...s, c];
      l.push({
        children: this.recursivelyBuildGroup(e + 1, h, p, i, r),
        headerName: c,
        pivotKeys: p,
        columnGroupShow: "open",
        openByDefault: u,
        groupId: this.generateColumnGroupId(p)
      });
    }
    return l.sort(a), l;
  }
  buildMeasureCols(e) {
    var s;
    const t = ((s = this.valueColsSvc) == null ? void 0 : s.columns) ?? [];
    return t.length === 0 ? [this.createColDef(null, "-", e)] : t.map((i) => {
      const r = this.colNames.getDisplayNameForColumn(i, "header");
      return {
        ...this.createColDef(i, r, e),
        columnGroupShow: "open"
      };
    });
  }
  addExpandablePivotGroups(e, t) {
    const s = this.gos.get("suppressExpandablePivotGroups");
    if (s || this.gos.get("pivotColumnGroupTotals"))
      return;
    const i = (r, o, n) => {
      var d;
      if ("children" in r) {
        const c = /* @__PURE__ */ new Map();
        r.children.forEach((u) => {
          i(u, o, c);
        });
        const h = !r.children.some((u) => u.children);
        (d = this.valueColsSvc) == null || d.columns.forEach((u) => {
          const p = this.colNames.getDisplayNameForColumn(u, "header"), g = this.createColDef(u, p, r.pivotKeys);
          g.pivotTotalColumnIds = c.get(u.getColId()), g.columnGroupShow = s ? "open" : "closed", g.aggFunc = u.getAggFunc(), h || (r.children.push(g), o.push(g));
        }), this.merge(n, c);
        return;
      }
      if (!r.pivotValueColumn)
        return;
      const a = r.pivotValueColumn.getColId();
      n.has(a) ? n.get(a).push(r.colId) : n.set(a, [r.colId]);
    };
    e.forEach((r) => {
      i(r, t, /* @__PURE__ */ new Map());
    });
  }
  addPivotTotalsToGroups(e, t) {
    var o;
    if (!this.gos.get("pivotColumnGroupTotals"))
      return;
    const s = this.gos.get("pivotColumnGroupTotals") === "after", i = (o = this.valueColsSvc) == null ? void 0 : o.columns, r = i == null ? void 0 : i.map((n) => n.getAggFunc());
    if (!(!r || r.length < 1 || !this.sameAggFuncs(r)) && i) {
      const n = i[0];
      e.forEach((a) => {
        this.recursivelyAddPivotTotal(a, t, n, s);
      });
    }
  }
  recursivelyAddPivotTotal(e, t, s, i) {
    const r = e;
    if (!r.children) {
      const n = e;
      return n.colId ? [n.colId] : null;
    }
    let o = [];
    if (r.children.forEach((n) => {
      const a = this.recursivelyAddPivotTotal(n, t, s, i);
      a && (o = o.concat(a));
    }), r.children.length > 1) {
      const a = this.getLocaleTextFunc()("pivotColumnGroupTotals", "Total"), l = this.createColDef(s, a, e.pivotKeys, !0);
      l.pivotTotalColumnIds = o, l.aggFunc = s.getAggFunc(), l.columnGroupShow = this.gos.get("suppressExpandablePivotGroups") ? "open" : void 0;
      const d = e.children;
      i ? d.push(l) : d.unshift(l), t.push(l);
    }
    return o;
  }
  addRowGroupTotals(e, t) {
    var n;
    if (!this.gos.get("pivotRowTotals"))
      return;
    const s = this.gos.get("pivotRowTotals") === "after", r = (((n = this.valueColsSvc) == null ? void 0 : n.columns) ?? []).slice();
    s || r.reverse();
    const o = r.length > 1 || !this.gos.get("removePivotHeaderRowWhenSingleValueColumn");
    for (let a = 0; a < r.length; a++) {
      const l = r[a], d = this.colNames.getDisplayNameForColumn(l, "header"), c = this.createColDef(l, d, []), h = [];
      for (let p = 0; p < t.length; p++) {
        const g = t[p];
        g.pivotValueColumn === l && h.push(g.colId);
      }
      c.pivotTotalColumnIds = h, c.colId = Gc + c.colId;
      const u = o ? {
        children: [c],
        pivotKeys: [],
        groupId: `${Gc}_pivotGroup_${l.getColId()}`
      } : c;
      t.push(c), s ? e.push(u) : e.unshift(u);
    }
  }
  createColDef(e, t, s, i = !1) {
    const r = {};
    if (e) {
      const o = e.getColDef();
      Object.assign(r, o), r.hide = !1;
    }
    return r.headerName = t, r.colId = this.generateColumnId(
      s || [],
      e && !i ? e.getColId() : ""
    ), r.field = r.colId, r.valueGetter = (o) => {
      var n;
      return (n = o.data) == null ? void 0 : n[o.colDef.field];
    }, r.pivotKeys = s, r.pivotValueColumn = e, r.filter === !0 && (r.filter = "agNumberColumnFilter"), r;
  }
  sameAggFuncs(e) {
    if (e.length == 1)
      return !0;
    for (let t = 1; t < e.length; t++)
      if (e[t] !== e[0])
        return !1;
    return !0;
  }
  headerNameComparator(e, t, s) {
    return e ? e(t.headerName, s.headerName) : t.headerName && !s.headerName ? 1 : !t.headerName && s.headerName ? -1 : !t.headerName || !s.headerName ? 0 : t.headerName < s.headerName ? -1 : t.headerName > s.headerName ? 1 : 0;
  }
  merge(e, t) {
    t.forEach((s, i) => {
      const o = [...e.has(i) ? e.get(i) : [], ...s];
      e.set(i, o);
    });
  }
  generateColumnGroupId(e) {
    var s;
    return `pivotGroup_${(((s = this.pivotColsSvc) == null ? void 0 : s.columns) ?? []).map((i) => i.getColId()).join("-")}_${e.join("-")}`;
  }
  generateColumnId(e, t) {
    var i;
    return `pivot_${(((i = this.pivotColsSvc) == null ? void 0 : i.columns) ?? []).map((r) => r.getColId()).join("-")}_${e.join("-")}_${t}`;
  }
  /**
   * Used by the SSRM to create secondary columns from provided fields
   * @param fields
   */
  createColDefsFromFields(e) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
      const n = e[r].split(this.fieldSeparator);
      let a = t;
      for (let l = 0; l < n.length; l++) {
        const d = n[l];
        a[d] == null && (a[d] = {}), a = a[d];
      }
    }
    const s = (r, o, n, a) => {
      const l = [];
      for (const h of Object.keys(n)) {
        const u = n[h], p = s(`${r}${this.fieldSeparator}${h}`, h, u, a + 1);
        l.push(p);
      }
      if (l.length === 0) {
        const h = this.colModel.getColDefCol(o);
        if (h) {
          const p = this.colNames.getDisplayNameForColumn(h, "header") ?? o, g = this.createColDef(h, p, void 0, !1);
          return g.colId = r, g.aggFunc = h.getAggFunc(), g.valueGetter = (f) => {
            var m;
            return (m = f.data) == null ? void 0 : m[r];
          }, g;
        }
        return {
          colId: r,
          headerName: o,
          // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
          // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
          valueGetter: (p) => {
            var g;
            return (g = p.data) == null ? void 0 : g[r];
          }
        };
      }
      return this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && l.length === 1 && "colId" in l[0] ? (l[0].headerName = o, l[0]) : {
        openByDefault: this.pivotDefaultExpanded === -1 || a < this.pivotDefaultExpanded,
        groupId: r,
        headerName: o,
        children: l
      };
    }, i = [];
    for (const r of Object.keys(t)) {
      const o = t[r], n = s(r, r, o, 0);
      i.push(n);
    }
    return i;
  }
}, oG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pivotResultCols";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.visibleCols = e.visibleCols;
  }
  destroy() {
    var e;
    xs(this.beans, (e = this.pivotResultCols) == null ? void 0 : e.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null)
      return null;
    const s = this.colModel.getColDefCol(t);
    let i = null;
    return this.pivotResultCols.list.forEach((r) => {
      const o = r.getColDef().pivotKeys, n = r.getColDef().pivotValueColumn;
      Re(o, e) && n === s && (i = r);
    }), i;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.colModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var s, i;
    if (this.colModel.ready && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const r = uu(
          this.beans,
          e,
          !1,
          ((s = this.pivotResultCols) == null ? void 0 : s.tree) || this.previousPivotResultCols || void 0,
          t
        );
        xs(this.beans, (i = this.pivotResultCols) == null ? void 0 : i.tree, r.columnTree);
        const o = r.columnTree, n = r.treeDept, a = cl(o), l = {};
        this.pivotResultCols = { tree: o, treeDepth: n, list: a, map: l }, this.pivotResultCols.list.forEach((c) => this.pivotResultCols.map[c.getId()] = c);
        const d = !!this.previousPivotResultCols;
        this.previousPivotResultCols = null, this.colModel.refreshCols(!d);
      } else
        this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null, this.colModel.refreshCols(!1);
      this.visibleCols.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), s = this.gos.get("processPivotResultColGroupDef");
    if (!t && !s)
      return;
    const i = (r) => {
      r.forEach((o) => {
        if (A(o.children)) {
          const a = o;
          s && s(a), i(a.children);
        } else
          t && t(o);
      });
    };
    e && i(e);
  }
}, Bc = "Exceeded maximum allowed pivot column count.", nG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "pivotStage", this.refreshProps = /* @__PURE__ */ new Set([
      "removePivotHeaderRowWhenSingleValueColumn",
      "pivotRowTotals",
      "pivotColumnGroupTotals",
      "suppressExpandablePivotGroups"
    ]), this.step = "pivot", this.uniqueValues = {}, this.lastTimeFailed = !1, this.maxUniqueValues = -1, this.currentUniqueCount = 0;
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc, this.colModel = e.colModel, this.pivotResultCols = e.pivotResultCols, this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueColsSvc = e.valueColsSvc, this.pivotColsSvc = e.pivotColsSvc, this.pivotColDefSvc = e.pivotColDefSvc;
  }
  execute(e) {
    const t = e.changedPath;
    this.colModel.isPivotActive() ? this.executePivotOn(t) : this.executePivotOff(t);
  }
  executePivotOff(e) {
    this.aggregationColumnsHashLastTime = null, this.uniqueValues = {}, this.pivotResultCols.isPivotResultColsPresent() && (this.pivotResultCols.setPivotResultCols(null, "rowModelUpdated"), e && (e.active = !1));
  }
  executePivotOn(e) {
    var C, v, b;
    const t = ((C = this.valueColsSvc) == null ? void 0 : C.columns.length) ?? 1, s = this.gos.get("pivotMaxGeneratedColumns");
    this.maxUniqueValues = s === -1 ? -1 : s / t;
    let i;
    try {
      i = this.bucketUpRowNodes(e);
    } catch (y) {
      if (y.message === Bc) {
        this.pivotResultCols.setPivotResultCols([], "rowModelUpdated"), this.eventSvc.dispatchEvent({
          type: "pivotMaxColumnsExceeded",
          message: y.message
        }), this.lastTimeFailed = !0;
        return;
      }
      throw y;
    }
    const r = this.setUniqueValues(i), o = ((v = this.valueColsSvc) == null ? void 0 : v.columns) ?? [], n = o.map((y) => `${y.getId()}-${y.getColDef().headerName}`).join("#"), a = o.map((y) => y.getAggFunc().toString()).join("#"), l = this.aggregationColumnsHashLastTime !== n, d = this.aggregationFuncsHashLastTime !== a;
    this.aggregationColumnsHashLastTime = n, this.aggregationFuncsHashLastTime = a;
    const c = (((b = this.rowGroupColsSvc) == null ? void 0 : b.columns) ?? []).map((y) => y.getId()).join("#"), h = c !== this.groupColumnsHashLastTime;
    this.groupColumnsHashLastTime = c;
    const u = this.gos.get("pivotRowTotals"), p = this.gos.get("pivotColumnGroupTotals"), g = this.gos.get("suppressExpandablePivotGroups"), f = this.gos.get("removePivotHeaderRowWhenSingleValueColumn"), m = u !== this.pivotRowTotalsLastTime || p !== this.pivotColumnGroupTotalsLastTime || g !== this.suppressExpandablePivotGroupsLastTime || f !== this.removePivotHeaderRowWhenSingleValueColumnLastTime;
    if (this.pivotRowTotalsLastTime = u, this.pivotColumnGroupTotalsLastTime = p, this.suppressExpandablePivotGroupsLastTime = g, this.removePivotHeaderRowWhenSingleValueColumnLastTime = f, this.lastTimeFailed || r || l || h || d || m) {
      const { pivotColumnGroupDefs: y, pivotColumnDefs: F } = this.pivotColDefSvc.createPivotColumnDefs(
        this.uniqueValues
      );
      this.pivotColumnDefs = F, this.pivotResultCols.setPivotResultCols(y, "rowModelUpdated"), e && (e.active = !1);
    }
    this.lastTimeFailed = !1;
  }
  setUniqueValues(e) {
    const t = JSON.stringify(e), s = JSON.stringify(this.uniqueValues);
    return t !== s ? (this.uniqueValues = e, !0) : !1;
  }
  bucketUpRowNodes(e) {
    this.currentUniqueCount = 0;
    const t = {};
    e.forEachChangedNodeDepthFirst((i) => {
      i.leafGroup && (i.childrenMapped = null);
    });
    const s = (i) => {
      var r;
      i.leafGroup ? this.bucketRowNode(i, t) : (r = i.childrenAfterFilter) == null || r.forEach(s);
    };
    return e.executeFromRootNode(s), t;
  }
  bucketRowNode(e, t) {
    var i;
    const s = (i = this.pivotColsSvc) == null ? void 0 : i.columns;
    (s == null ? void 0 : s.length) === 0 ? e.childrenMapped = null : e.childrenMapped = this.bucketChildren(e.childrenAfterFilter, s, 0, t), e.sibling && (e.sibling.childrenMapped = e.childrenMapped);
  }
  bucketChildren(e, t = [], s, i) {
    const r = {}, o = t[s];
    if (e.forEach((n) => {
      let a = this.valueSvc.getKeyForNode(o, n);
      if (Y(a) && (a = ""), !i[a]) {
        this.currentUniqueCount += 1, i[a] = {};
        const l = this.maxUniqueValues !== -1, d = this.currentUniqueCount > this.maxUniqueValues;
        if (l && d)
          throw Error(Bc);
      }
      r[a] || (r[a] = []), r[a].push(n);
    }), s === t.length - 1)
      return r;
    {
      const n = {};
      for (const [a, l] of Object.entries(r))
        n[a] = this.bucketChildren(l, t, s + 1, i[a]);
      return n;
    }
  }
  getPivotColumnDefs() {
    return this.pivotColumnDefs;
  }
}, Rf = {
  moduleName: "SharedPivot",
  version: j,
  beans: [oG, rG, pf],
  apiFunctions: {
    isPivotMode: $O,
    getPivotResultColumn: jO,
    setValueColumns: qO,
    getValueColumns: YO,
    removeValueColumns: XO,
    addValueColumns: ZO,
    setPivotColumns: QO,
    removePivotColumns: JO,
    addPivotColumns: eG,
    getPivotColumns: tG,
    setPivotResultColumns: sG,
    getPivotResultColumns: iG
  },
  dependsOn: [vf, gp]
}, aG = {
  moduleName: "Pivot",
  version: j,
  rowModels: ["clientSide"],
  beans: [nG],
  dependsOn: [Rf, wf, vn]
}, lG = (e, t) => e.treeNode.sourceIdx - t.treeNode.sourceIdx, dG = me.values(), qr = (e, t) => {
  e.parent = null, e.treeNode = null, t ? e.childrenAfterGroup = [] : (e.level = 0, e.childrenAfterGroup = null, e.allLeafChildren = null);
}, cG = class $a {
  constructor(t, s, i) {
    this.parent = t, this.key = s, this.level = i, this.children = null, this.invalidatedHead = null, this.invalidatedNext = void 0, this.row = null, this.oldRow = null, this.duplicateRows = null, this.childrenAfterGroup = me, this.allLeafChildren = me, this.childrenChanged = !1, this.leafChildrenChanged = !1, this.sourceIdx = -1;
  }
  /** Returns the number of children in this node */
  get size() {
    var t;
    return ((t = this.children) == null ? void 0 : t.size) ?? 0;
  }
  isEmptyFillerNode() {
    var t, s;
    return !((t = this.row) != null && t.data) && !((s = this.children) != null && s.size);
  }
  /** Returns an iterator able to iterate all children in this node, in order of insertion */
  enumChildren() {
    var t;
    return ((t = this.children) == null ? void 0 : t.values()) ?? dG;
  }
  /**
   * Gets a node a key in the given parent. If the node does not exists, creates a filler node, with null row.
   * We cast to string just to be sure the user passed a string correctly and not a number or something else.
   * @param key - The key of the node to get.
   * @param append - If true, the node will be moved to the end of the children list.
   * @returns the node at the given key, or a new filler node inserted there if it does not exist.
   */
  upsertKey(t) {
    var i, r;
    typeof t != "string" && (t = String(t));
    let s = (i = this.children) == null ? void 0 : i.get(t);
    return s || (s = new $a(this, t, this.level + 1), (r = this.children ?? (this.children = /* @__PURE__ */ new Map())) == null || r.set(s.key, s)), s;
  }
  /** Same as upsertKey, but moves the node to the end no matter what. */
  appendKey(t) {
    var r;
    const s = this.children;
    typeof t != "string" && (t = String(t));
    let i = s == null ? void 0 : s.get(t);
    return i ? (s.delete(t), s.set(t, i)) : (i = new $a(this, t, this.level + 1), (r = this.children ?? (this.children = /* @__PURE__ */ new Map())) == null || r.set(i.key, i)), i;
  }
  /** Removes this node from the parent, and free memory. This node cannot be used after this. */
  destroy() {
    var i;
    const { row: t, parent: s } = this;
    s !== null && ((i = s == null ? void 0 : s.children) == null || i.delete(this.key), t !== null && qr(t, !0), this.parent = null);
  }
  /**
   * Sets the row for the TreeNode.
   * If the row is already set, it will be replaced with the new row, and the old row will be orphaned.
   * childrenAfterGroup and allLeafChildren will be reassigned.
   * @returns True if the row changed
   */
  setRow(t) {
    const { level: s, row: i, childrenAfterGroup: r } = this;
    if (s < 0)
      i !== null && i !== t && qr(i, !0);
    else {
      if (i === t)
        return !1;
      i !== null ? (t !== null && (t.allLeafChildren = i.allLeafChildren ?? this.allLeafChildren ?? me), qr(i, !1)) : t !== null && (t.allLeafChildren = this.allLeafChildren ?? me);
    }
    return t !== null && (t.level = s, t.childrenAfterGroup = r, t.treeNode = this), this.row = t, !0;
  }
  /**
   * Removes a row from the tree node.
   * If the row is the main row, it will be replaced with the first row in the duplicate rows, if any.
   * If the row is a duplicate row, it will be removed from the duplicate rows.
   * @param rowToRemove - The row to be removed.
   * @returns `true` if the row was successfully removed, `false` if the row was not found.
   */
  removeRow(t) {
    const { level: s, row: i, duplicateRows: r, childrenAfterGroup: o } = this;
    if (i === t) {
      const n = this.popDuplicateRow();
      n ? (this.row = n, n.childrenAfterGroup = o, s >= 0 && (n.allLeafChildren = i.allLeafChildren ?? this.allLeafChildren ?? me)) : this.row = null;
    } else {
      if (!(r != null && r.delete(t)))
        return !1;
      r.size === 0 && (this.duplicateRows = null);
    }
    return qr(t, s < 0), !0;
  }
  /**
   * Adds a duplicate row to the tree node.
   * @param newRow - The new row to be added.
   * @returns A boolean indicating whether the row was successfully added.
   */
  addDuplicateRow(t) {
    const { level: s } = this;
    let i = this.duplicateRows;
    if (i === null)
      i = /* @__PURE__ */ new Set(), this.duplicateRows = i;
    else if (i.has(t))
      return !1;
    return i.add(t), t.treeNode = this, t.level = s, s >= 0 && (t.allLeafChildren = me), t.childrenAfterGroup = me, !0;
  }
  /**
   * This is needed to be sure that the row is the duplicate row with the smallest sourceRowIndex, in O(n).
   * @returns this.row
   */
  sortFirstDuplicateRow() {
    const t = this.duplicateRows, s = this.row;
    if (!s || !t)
      return s;
    let i = s;
    for (const r of t)
      r.sourceRowIndex < i.sourceRowIndex && (i = r);
    return i !== s && (i.childrenAfterGroup = this.childrenAfterGroup, i.allLeafChildren = s.allLeafChildren ?? this.allLeafChildren ?? me, s.childrenAfterGroup = me, s.allLeafChildren = me, t.delete(i), t.add(s), this.row = i), i;
  }
  /** Pops the first duplicate row from the list of duplicates */
  popDuplicateRow() {
    let t = null;
    const s = this.duplicateRows;
    return s !== null && (t = s.values().next().value, t !== null && s.delete(t) && s.size === 0 && (this.duplicateRows = null)), t;
  }
  /**
   * Dequeues the next child invalidated node to be committed. Order is not deterministic.
   * @returns the next child node to be committed, or null if all children were already dequeued.
   */
  dequeueInvalidated() {
    const t = this.invalidatedHead;
    return t !== null && (this.invalidatedHead = t.invalidatedNext ?? null, t.invalidatedNext = void 0), t;
  }
  /**
   * Invalidates this node and all its parents until the root is reached.
   * Order of invalidated nodes is not deterministic.
   * The root itself cannot be invalidated, as it has no parents.
   * If a node is already invalidated, it will stop the recursion.
   */
  invalidate() {
    let t = this, s = this.parent;
    for (; s !== null && t.invalidatedNext === void 0; )
      t.invalidatedNext = s.invalidatedHead, s.invalidatedHead = t, t = s, s = t.parent;
  }
  /** Marks childrenChanged in the parent, so the childrenAfterGroup will be recomputed and invalidates the parent. */
  invalidateOrder() {
    var s, i;
    const t = this.parent;
    t !== null && !t.childrenChanged && ((((s = this.children) == null ? void 0 : s.size) ?? 0) > 1 || !((i = t.row) != null && i.data)) && (t.childrenChanged = !0, t.invalidate());
  }
  /**
   * When we receive rowNodeOrder not undefined, we need to update the rowPosition of the node,
   * to ensure it will be sorted in the right order in childrenAfterGroup.
   * This function makes sense to be called only in the post-order commit DFS
   * as it assumes children's childrenAfterGroup is already updated.
   * @returns the rowPosition the node should have.
   */
  getNewSourceIdx() {
    var s, i;
    const t = this.row;
    return t != null && t.data ? t.sourceRowIndex : ((i = (s = this.childrenAfterGroup[0]) == null ? void 0 : s.treeNode) == null ? void 0 : i.sourceIdx) ?? this.sourceIdx;
  }
  /**
   * This is called in post order during commit to update the childrenAfterGroup array.
   * It uses the rowNodeOrder map to sort the children in the right order, if is passed.
   * It assumes all children childrenAfterGroup are up to date and rows all created.
   *
   * It replaces the array with _EmptyArray if there are no children, to reduce memory usage and GC pressure.
   * It does sort the children only if strictly needed, to avoid unnecessary work.
   *
   * If the order changes, also the order in the children map will be updated,
   * so the next call to enumChildren() will return the children in the right order.
   */
  updateChildrenAfterGroup(t) {
    var l;
    this.childrenChanged = !1;
    const s = t && ((l = this.children) == null ? void 0 : l.size) || 0;
    if (s === 0)
      return this.row.childrenAfterGroup = me, this.childrenAfterGroup.length === 0 ? !1 : (this.leafChildrenChanged = !0, this.childrenAfterGroup = me, !0);
    let i = !1, r = this.childrenAfterGroup;
    r === me ? (r = new Array(s), this.childrenAfterGroup = r, this.row.childrenAfterGroup = r, i = !0) : r.length !== s && (r.length = s, i = !0);
    let o = 0, n = -1, a = !1;
    for (const d of this.enumChildren()) {
      const c = d.getNewSourceIdx();
      c < n && (a = !0), n = c, d.sourceIdx = c;
      const h = d.row;
      r[o] !== h && (r[o] = h, i = !0), ++o;
    }
    return i && (this.leafChildrenChanged = !0), a && this.reorderChildrenList(r), i || a;
  }
  /** This reorders the given array and rebuild the children map. */
  reorderChildrenList(t) {
    const s = t.length, i = this.children;
    t.sort(lG), i.clear();
    for (let r = 0; r < s; ++r) {
      const o = t[r].treeNode;
      i.set(o.key, o);
    }
  }
  /**
   * Rebuild the allLeafChildren rows array of a node. It uses childrenAfterGroup, we assume to be already updated.
   * This is called in post order during commit, after the childrenAfterGroup are updated with updateChildrenAfterGroup().
   * It uses the childrenAfterGroup and allLeafChildren of all the children, we assume they are updated.
   */
  updateAllLeafChildren() {
    var n, a;
    const { parent: t, row: s, childrenAfterGroup: i } = this;
    this.leafChildrenChanged = !1;
    let r = !1;
    const o = i.length;
    if (o === 0)
      r = ((n = s.allLeafChildren) == null ? void 0 : n.length) !== 0, s.allLeafChildren = me, this.allLeafChildren = me;
    else if (o === 1 && ((a = i[0].allLeafChildren) != null && a.length))
      s.allLeafChildren = i[0].allLeafChildren, this.allLeafChildren = null, r = !0;
    else {
      let l = this.allLeafChildren;
      (l === me || l === null) && (l = [], this.allLeafChildren = l);
      const d = l.length;
      let c = 0;
      for (let h = 0; h < o; ++h) {
        const u = i[h], p = u.allLeafChildren, g = p.length;
        if (g)
          for (let f = 0; f < g; ++f) {
            const m = p[f];
            (c >= d || l[c] !== m) && (l[c] = m, r = !0), ++c;
          }
        else
          (c >= d || l[c] !== u) && u && (l[c] = u, r = !0), ++c;
      }
      d !== c && (l.length = c, r = !0), s.allLeafChildren !== l && (s.allLeafChildren = l, r = !0);
    }
    r && t && (t.leafChildrenChanged = !0);
  }
}, hG = (e) => (e.treeNodeFlags & 1) !== 0, Pf = (e) => (e.treeNodeFlags & 2) !== 0, Vc = (e) => (e.treeNodeFlags & 4) !== 0, uG = (e) => (e.treeNodeFlags & 8) !== 0, Nc = (e) => (e.treeNodeFlags & 16) !== 0, Hc = (e, t) => {
  t ? e.treeNodeFlags |= 2 : e.treeNodeFlags &= -3;
}, pG = (e) => {
  const t = e.treeNodeFlags;
  t & 1 && (e.treeNodeFlags = t | 4);
}, gG = (e) => {
  const t = e.treeNodeFlags;
  t & 1 && (e.treeNodeFlags = t | 12);
}, Wt = (e) => {
  e.treeNodeFlags |= 16;
}, zc = (e) => {
  const t = e.level < 0, s = e.treeNodeFlags, i = (s & 1) !== 0;
  if (e.treeNodeFlags = 1 | s & -29, !i || t) {
    const r = e.childrenAfterGroup;
    e.childrenAfterFilter = r, e.childrenAfterAggFilter = r, e.childrenAfterSort = r;
  }
  if (t) {
    const r = e.sibling;
    r && (r.childrenAfterGroup = e.childrenAfterGroup, r.childrenMapped = e.childrenMapped);
  }
}, $i = (e) => {
  e.treeNodeFlags = 0;
}, fG = (e, t, s) => {
  if (t !== s && t !== null && t.group && Pf(t) && !e.isGroupOpenByDefault)
    return t.expanded;
  const i = e.isGroupOpenByDefault;
  return i ? i({
    rowNode: s,
    field: s.field,
    key: s.key,
    level: s.level,
    rowGroupColumn: s.rowGroupColumn
  }) == !0 : e.expandByDefault === -1 || s.level < e.expandByDefault;
}, Tf = class extends tp {
  constructor() {
    super(...arguments), this.oldGroupDisplayColIds = "", this.rowsPendingDestruction = null, this.treeRoot = null;
  }
  activate(e) {
    super.activate(e), (this.treeRoot ?? (this.treeRoot = new cG(null, "", -1))).setRow(e);
  }
  destroy() {
    super.destroy(), this.treeRoot = null, this.rowsPendingDestruction = null, this.oldGroupDisplayColIds = "";
  }
  deactivate() {
    const e = this.treeRoot;
    if (e) {
      const t = e.row;
      t !== null && (e.removeRow(t), $i(t)), this.treeDestroy(e);
    }
    this.commitDestroyedRows(), super.deactivate(), this.treeRoot = null, this.oldGroupDisplayColIds = "";
  }
  /** Add or updates the row to a non-root node, preparing the tree correctly for the commit. */
  treeSetRow(e, t, s) {
    var n;
    const { level: i, row: r } = e;
    if (i < 0)
      return !1;
    let o = !1;
    if (r !== t) {
      const a = t.treeNode;
      a !== null && a !== e && (a.removeRow(t), a.invalidate()), r === null ? (e.setRow(t), o = !0) : r.data ? e.addDuplicateRow(t) && (o = !0) : (e.setRow(t), this.destroyRow(r, !0), o = !0);
    }
    return !s && !Vc(t) && (pG(t), o = !0), o && e.invalidate(), (n = this.rowsPendingDestruction) == null || n.delete(t), o;
  }
  /**
   * Overwrites the row property of a non-root node to null.
   * @returns The previous row, if any, that was overwritten.
   */
  treeRemove(e, t) {
    const { parent: s, level: i } = e;
    if (i < 0)
      return;
    let r = !1;
    e.removeRow(t) && (r = !0, s && (s.childrenChanged = !0), this.destroyRow(t, !t.data)), r && e.invalidate();
  }
  /** Commit the changes performed to the tree */
  treeCommit(e) {
    var n, a;
    const { treeRoot: t, rootNode: s } = this;
    if (!t || !s)
      return;
    const i = this.treeData, r = {
      rootNode: s,
      changedPath: e,
      treeData: i,
      expandByDefault: this.gos.get("groupDefaultExpanded"),
      isGroupOpenByDefault: this.gos.getCallback("isGroupOpenByDefault")
    };
    this.treeCommitChildren(r, t, !1);
    const o = t.row;
    o && (i && (o.leafGroup = !1), t.childrenChanged && t.updateChildrenAfterGroup(i) && Wt(o), Nc(o) && (n = r.changedPath) != null && n.active && r.changedPath.addParentNode(o), zc(o), o.updateHasChildren()), this.commitDestroyedRows(), (a = this.beans.selectionSvc) == null || a.updateSelectableAfterGrouping(e);
  }
  /** Calls commitChild for each invalidated child, recursively. We commit only the invalidated paths. */
  treeCommitChildren(e, t, s) {
    var i, r;
    for (; ; ) {
      const o = t.dequeueInvalidated();
      if (o === null)
        break;
      o.parent === t && this.treeCommitChild(e, o, s || !(((i = t.row) == null ? void 0 : i.expanded) ?? !0));
    }
    t.childrenChanged || (t.childrenChanged = (e.treeData ? t.size : 0) !== ((r = t.row.childrenAfterGroup) == null ? void 0 : r.length));
  }
  /** Commit the changes performed to a node and its children */
  treeCommitChild(e, t, s) {
    if (t.isEmptyFillerNode()) {
      this.treeClear(t);
      return;
    }
    if (this.treeCommitPreOrder(e, t), this.treeCommitChildren(e, t, s), t.isEmptyFillerNode()) {
      this.treeClear(t);
      return;
    }
    this.treeCommitPostOrder(e, t, s);
  }
  treeCommitPreOrder(e, t) {
    let s = t.row;
    if (s === null ? (s = this.createFillerRow(t), t.setRow(s)) : (s = t.sortFirstDuplicateRow(), s.allChildrenCount === void 0 && (s.allChildrenCount = null)), e.treeData) {
      if (s.parent = t.parent.row, t.oldRow !== s)
        for (const r of t.enumChildren()) {
          const o = r.row;
          o !== null && (o.parent = s);
        }
      const i = t.key;
      s.key !== i ? (s.key = i, gG(s), this.setGroupData(s, i)) : s.groupData || this.setGroupData(s, i);
    } else
      s.key = t.key, s.parent = e.rootNode;
  }
  treeCommitPostOrder(e, t, s) {
    var u, p, g;
    const i = t.parent, r = t.row, o = t.oldRow, n = e.treeData;
    t.childrenChanged && t.updateChildrenAfterGroup(n) && Wt(r), t.leafChildrenChanged && t.updateAllLeafChildren();
    const a = !!((u = r.childrenAfterGroup) != null && u.length), l = a || !r.data, d = r.group;
    d !== l ? (Wt(r), qg(r, this.beans, l), !l && !r.expanded && Hc(r, !1)) : r.hasChildren() !== a && (Wt(r), r.updateHasChildren()), l && !Pf(r) && (r.expanded = fG(e, o, r), Hc(r, !0)), Vc(r) && (Wt(i.row), uG(r) && r.setData(r.data)), o !== r && (t.oldRow = r, o !== null && (d || t.size !== 0) && Wt(r), i.childrenChanged = !0, Wt(i.row)), Nc(r) && (n && ((p = e.changedPath) != null && p.active) ? e.changedPath.addParentNode(r) : Wt(e.rootNode)), zc(r), (g = t.duplicateRows) != null && g.size && !t.duplicateRowsWarned && (t.duplicateRowsWarned = !0, R(186, {
      rowId: r.id,
      rowData: r.data,
      duplicateRowsData: Array.from(t.duplicateRows).map((f) => f.data)
    })), s && r.rowIndex !== null && r.clearRowTopAndRowIndex();
    const c = t.getNewSourceIdx(), h = t.sourceIdx;
    h !== c && (t.sourceIdx = c, h !== -1 && (i.childrenChanged = !0));
  }
  createFillerRow(e) {
    const t = new Qe(this.beans);
    t.key = e.key, t.group = !0, t.field = null, t.leafGroup = !1, t.rowGroupIndex = null, t.allChildrenCount = null;
    let s = e.level + "-" + e.key, i = e.parent;
    for (; i !== null; ) {
      const r = i.parent;
      if (r === null)
        break;
      s = `${i.level}-${i.key}-${s}`, i = r;
    }
    return t.id = fr + s, t;
  }
  setGroupData(e, t) {
    var r;
    const s = {};
    e.groupData = s;
    const i = (r = this.beans.showRowGroupCols) == null ? void 0 : r.getShowRowGroupCols();
    if (i)
      for (const o of i)
        s[o.getColId()] = t;
  }
  /** Called to clear a subtree. */
  treeClear(e) {
    const { parent: t, oldRow: s, row: i, level: r } = e;
    if (t !== null && s !== null && (t.childrenChanged = !0, t.row !== null && Wt(t.row)), i !== null && r >= 0) {
      let o = e.row;
      for (; o !== null && e.removeRow(o); )
        this.destroyRow(o, !o.data), o = e.row;
    }
    for (const o of e.enumChildren())
      this.treeClear(o);
    e.destroy();
  }
  /** Called by the deactivate, to destroy the whole tree. */
  treeDestroy(e) {
    const { row: t, level: s, duplicateRows: i } = e;
    if (t && (s >= 0 && !t.data ? this.destroyRow(t, !0) : $i(t)), i)
      for (const r of i)
        s >= 0 && !r.data ? this.destroyRow(r, !0) : $i(r);
    for (const r of e.enumChildren())
      this.treeDestroy(r);
    e.destroy();
  }
  /**
   * Finalizes the deletion of a row.
   * @param immediate If true, the row is deleted immediately.
   * If false, the row is marked for deletion, and will be deleted later with this.deleteDeletedRows()
   */
  destroyRow(e, t) {
    if (e.isSelected())
      t = !1;
    else if (!hG(e)) {
      $i(e);
      return;
    }
    if (!t) {
      (this.rowsPendingDestruction ?? (this.rowsPendingDestruction = /* @__PURE__ */ new Set())).add(e);
      return;
    }
    $i(e), e.clearRowTopAndRowIndex(), e.groupData = null;
  }
  /**
   * destroyRow can defer the deletion to the end of the commit stage.
   * This method finalizes the deletion of rows that were marked for deletion.
   */
  commitDestroyedRows() {
    const { rowsPendingDestruction: e } = this;
    let t = null;
    if (e !== null) {
      for (const s of e)
        this.destroyRow(s, !0), s.isSelected() && (t ?? (t = [])).push(s);
      this.rowsPendingDestruction = null;
    }
    t && this.deselectNodes(t);
  }
  refreshModel(e) {
    var t, s, i;
    if (e.afterColumnsChanged)
      if (this.treeData) {
        const r = ((s = (t = this.beans.showRowGroupCols) == null ? void 0 : t.getShowRowGroupCols()) == null ? void 0 : s.map((o) => o.getId()).join("-")) ?? "";
        if (this.oldGroupDisplayColIds !== r) {
          this.oldGroupDisplayColIds = r;
          const o = (i = this.rootNode) == null ? void 0 : i.childrenAfterGroup;
          if (o)
            for (let n = 0, a = o.length ?? 0; n < a; ++n) {
              const l = o[n], d = l.treeNode;
              d && this.setGroupData(l, d.key);
            }
        }
      } else
        this.oldGroupDisplayColIds = "";
  }
}, mG = (e) => {
  if (typeof e != "string" || !e.length)
    return [];
  const t = e.split(".");
  return t.includes("__proto__") ? [] : t;
}, CG = (e) => {
  const t = mG(e);
  let s = null;
  const i = t.length - 1;
  return i === 0 ? s = (r) => r == null ? void 0 : r[e] : i > 0 ? s = (r) => {
    let o = r;
    for (let n = 0; n <= i && o !== null && o !== void 0; ++n)
      if (o = o[t[n]], n < i && typeof o != "object" && o !== void 0)
        return null;
    return o;
  } : s = () => {
  }, s.path = e, s;
}, vG = class extends Tf {
  constructor() {
    super(...arguments), this.beanName = "csrmChildrenTreeNodeSvc", this.childrenGetter = null;
  }
  get treeData() {
    return this.gos.get("treeData");
  }
  extractRowData() {
    const e = this.treeRoot;
    return e && Array.from(e.enumChildren(), (t) => t.row.data);
  }
  destroy() {
    super.destroy(), this.childrenGetter = null;
  }
  activate(e) {
    const t = this.childrenGetter, s = this.gos.get("treeDataChildrenField");
    (!t || t.path !== s) && (this.childrenGetter = CG(s)), super.activate(e);
  }
  loadNewRowData(e) {
    const t = this.treeRoot, s = this.rootNode, i = this.childrenGetter, r = /* @__PURE__ */ new Map(), o = [];
    s.allLeafChildren = o, this.treeClear(t), t.setRow(s);
    const n = (a, l) => {
      let d = r.get(l);
      if (d !== void 0) {
        z(2, { nodeId: d.id });
        return;
      }
      d = this.createRowNode(l, o.length), r.set(l, d), o.push(d), a = a.upsertKey(d.id), this.treeSetRow(a, d, !0);
      const c = i == null ? void 0 : i(l);
      if (c)
        for (let h = 0, u = c.length; h < u; ++h)
          n(a, c[h]);
    };
    for (let a = 0, l = e.length; a < l; ++a)
      n(t, e[a]);
    this.treeCommit();
  }
  setImmutableRowData(e, t) {
    const s = this.gos, i = this.treeRoot, r = this.rootNode, o = this.childrenGetter, n = Yt(s), a = !s.get("suppressMaintainUnsortedOrder"), l = /* @__PURE__ */ new Map(), d = new Mi(!1, r);
    e.changedPath = d;
    const c = e.changedRowNodes, h = r.allLeafChildren, u = [], p = [];
    let g = !1, f = !1;
    const v = a ? (F, D) => {
      const x = D == null ? void 0 : D.length;
      let T = !0, I = -1;
      for (let E = 0; E < x; ++E) {
        const M = b(F, D[E]);
        M >= 0 && (M < I && (T = !1), I = M);
      }
      T || (g = !0, F.childrenChanged || (F.childrenChanged = !0, F.invalidate()));
    } : (F, D) => {
      for (let x = 0, T = D.length; x < T; ++x)
        b(F, D[x]);
    }, b = (F, D) => {
      let x = l.get(D);
      if (x !== void 0)
        return R(2, { nodeId: x.id }), -1;
      const T = n({ data: D, level: F.level + 1 });
      let I = !1;
      x = this.getRowNode(T), x ? x.data !== D && (c.update(x), x.updateData(D), !x.selectable && x.isSelected() && p.push(x)) : (x = this.createRowNode(D, -1), c.add(x), I = !0), l.set(D, x);
      let E, M;
      a ? (M = F.appendKey(x.id), E = x.sourceRowIndex, x.sourceRowIndex = u.push(x) - 1) : (M = F.upsertKey(x.id), E = -1), this.treeSetRow(M, x, I) && (f = !0);
      const N = o == null ? void 0 : o(D);
      return N && v(M, N), E;
    };
    if (v(i, t), h)
      for (let F = 0, D = h.length; F < D; ++F) {
        const x = h[F], T = x.treeNode;
        if (T) {
          const I = x.data;
          I && !l.has(I) && (c.remove(x), this.treeRemove(T, x));
        }
      }
    if (!a) {
      const F = (D) => {
        for (const x of D.enumChildren()) {
          const T = x.row;
          T && (T.sourceRowIndex = u.push(T) - 1, F(x));
        }
      };
      F(i);
    }
    r.allLeafChildren = u, i.allLeafChildren = u, p.length && this.deselectNodes(p), this.treeCommit(d);
    const y = r.sibling;
    y && (y.allLeafChildren = u), (f || g) && (e.step = "group", e.rowDataUpdated = !0, e.rowNodesOrderChanged = g);
  }
  refreshModel(e) {
    var i, r;
    const { rootNode: t, treeRoot: s } = this;
    if (s) {
      if ((i = e.changedProps) != null && i.has("treeData") && !e.newData) {
        s.setRow(t);
        const o = t == null ? void 0 : t.allLeafChildren;
        if (o)
          for (let n = 0, a = o.length; n < a; ++n) {
            const l = o[n];
            l.groupData = null, (r = l.treeNode) == null || r.invalidate();
          }
        this.treeCommit();
      }
      super.refreshModel(e);
    }
  }
}, wG = class extends Tf {
  constructor() {
    super(...arguments), this.beanName = "csrmPathTreeNodeSvc";
  }
  loadNewRowData(e) {
    const t = this.rootNode, s = this.treeRoot;
    this.treeClear(s), s.setRow(t), super.loadNewRowData(e);
    const i = t.allLeafChildren, r = this.gos.get("getDataPath");
    for (let o = 0, n = i.length; o < n; ++o)
      this.addOrUpdateRow(r, i[o], !0);
    this.treeCommit();
  }
  get treeData() {
    const e = this.gos;
    return e.get("treeData") && !!e.get("getDataPath");
  }
  refreshModel(e) {
    const t = e.changedRowNodes;
    t && this.executeTransactions(t, e.changedPath, e.rowNodesOrderChanged), super.refreshModel(e);
  }
  executeTransactions(e, t, s) {
    var a;
    const i = this.treeRoot;
    if (!i)
      return;
    i.setRow(this.rootNode);
    for (const l of e.removals) {
      const d = l.treeNode;
      d && this.treeRemove(d, l);
    }
    const r = e.updates, o = this.gos.get("getDataPath");
    for (const l of r.keys())
      this.addOrUpdateRow(o, l, r.get(l));
    const n = (a = i.row) == null ? void 0 : a.allLeafChildren;
    if (s && n)
      for (let l = 0, d = n.length; l < d; ++l) {
        const c = n[l].treeNode;
        c && c.sourceIdx !== l && c.invalidateOrder();
      }
    this.treeCommit(t);
  }
  addOrUpdateRow(e, t, s) {
    const i = this.treeRoot;
    if (!this.treeData) {
      this.treeSetRow(i.upsertKey(t.id), t, s);
      return;
    }
    const r = e == null ? void 0 : e(t.data), o = r == null ? void 0 : r.length;
    if (!o)
      R(185, { data: t.data });
    else {
      let n = 0, a = i;
      do
        a = a.upsertKey(r[n++]);
      while (n < o);
      this.treeSetRow(a, t, s);
    }
  }
}, Df = {
  moduleName: "SharedTreeData",
  version: j,
  dependsOn: [te, Zl, Cf, Ql]
}, yG = {
  moduleName: "TreeData",
  version: j,
  beans: [wG, vG],
  rowModels: ["clientSide"],
  dependsOn: [Df, uf, vn]
}, bG = "ag-Grid-MissingKey", SG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmBlockUtils";
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc, this.showRowGroupCols = e.showRowGroupCols, this.nodeManager = e.ssrmNodeManager, this.expansionSvc = e.expansionSvc, this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  createRowNode(e) {
    const t = new Qe(this.beans), s = e.rowHeight != null ? e.rowHeight : Ye(this.beans);
    return t.setRowHeight(s), t.group = e.group, t.leafGroup = e.leafGroup, t.level = e.level, t.uiLevel = e.level, t.parent = e.parent, t.stub = !0, t.__needsRefreshWhenVisible = !1, t.group && (t.expanded = !1, t.field = e.field, t.rowGroupColumn = e.rowGroupColumn), t;
  }
  destroyRowNode(e, t = !1) {
    e.childStore && !t && (this.destroyBean(e.childStore), e.childStore = null), e.sibling && !e.footer && this.destroyRowNode(e.sibling, !1), e.clearRowTopAndRowIndex(), e.id != null && this.nodeManager.removeNode(e);
  }
  setTreeGroupInfo(e) {
    e.updateHasChildren();
    const t = this.gos.get("getServerSideGroupKey"), s = e.hasChildren();
    s && t != null && (e.key = t(e.data)), !s && e.childStore != null && (this.destroyBean(e.childStore), e.childStore = null, e.expanded = !1);
  }
  setRowGroupInfo(e) {
    if (e.key = this.valueSvc.getValue(e.rowGroupColumn, e), (e.key === null || e.key === void 0) && rl(() => {
      var r;
      R(190, { rowGroupId: (r = e.rowGroupColumn) == null ? void 0 : r.getId(), data: e.data });
    }, "SSBlock-BadKey"), this.gos.get("groupAllowUnbalanced") && e.key === "") {
      const r = this.serverSideRowModel.getParams();
      e.childStore = this.createBean(this.storeFactory.createStore(r, e));
    }
    Fi(this.beans.gos)({ node: e }) && (qt(e, this.beans), e.sibling && (e.sibling.uiLevel = e.uiLevel + 1));
  }
  setMasterDetailInfo(e) {
    const t = this.gos.get("isRowMaster");
    t != null ? e.master = t(e.data) : e.master = !0;
  }
  updateDataIntoRowNode(e, t) {
    e.updateData(t), this.gos.get("treeData") ? (this.setTreeGroupInfo(e), this.setChildCountIntoRowNode(e)) : e.group ? (this.setChildCountIntoRowNode(e), e.footer || (Fi(this.beans.gos)({ node: e }) ? e.sibling ? e.sibling.updateData(t) : qt(e, this.beans) : e.sibling && Xl(e))) : this.gos.get("masterDetail");
  }
  setDataIntoRowNode(e, t, s, i) {
    var o;
    e.stub = !1;
    const r = this.gos.get("treeData");
    e.setDataAndId(t, s), r ? this.setTreeGroupInfo(e) : e.group ? this.setRowGroupInfo(e) : this.gos.get("masterDetail") && this.setMasterDetailInfo(e), (r || e.group) && (this.setGroupDataIntoRowNode(e), this.setChildCountIntoRowNode(e)), A(t) && (e.setRowHeight(Ie(this.beans, e, !1, i).height), (o = e.sibling) == null || o.setRowHeight(
      Ie(this.beans, e.sibling, !1, i).height
    ));
  }
  setChildCountIntoRowNode(e) {
    const t = this.gos.get("getChildCount");
    t && e.setAllChildrenCount(t(e.data));
  }
  setGroupDataIntoRowNode(e) {
    var i;
    const t = ((i = this.showRowGroupCols) == null ? void 0 : i.getShowRowGroupCols()) ?? [], s = this.gos.get("treeData");
    t.forEach((r) => {
      if (e.groupData == null && (e.groupData = {}), s)
        e.groupData[r.getColId()] = e.key;
      else if (r.isRowGroupDisplayed(e.rowGroupColumn.getId())) {
        const o = this.valueSvc.getValue(e.rowGroupColumn, e);
        e.groupData[r.getColId()] = o;
      }
    });
  }
  clearDisplayIndex(e) {
    var i;
    e.clearRowTopAndRowIndex(), e.hasChildren() && !!e.childStore && ((i = e.childStore) == null || i.clearDisplayIndexes()), e.master && e.detailNode && e.detailNode.clearRowTopAndRowIndex();
  }
  setDisplayIndex(e, t, s, i) {
    const r = this.gos.get("groupAllowUnbalanced") && e.group && e.key === "";
    if (this.gos.get("groupHideOpenParents") && e.group && e.expanded || r ? (e.setRowIndex(null), e.setRowTop(null)) : (e.setRowIndex(t.value++), e.setRowTop(s.value), s.value += e.rowHeight), e.setUiLevel(i), e.footer)
      return;
    if (e.master && (e.expanded && e.detailNode ? (e.detailNode.setRowIndex(t.value++), e.detailNode.setRowTop(s.value), s.value += e.detailNode.rowHeight) : e.detailNode && e.detailNode.clearRowTopAndRowIndex()), e.hasChildren() && !!e.childStore) {
      const l = e.childStore;
      e.expanded || r ? l.setDisplayIndexes(t, s, r ? i : i + 1) : l.clearDisplayIndexes();
    }
  }
  extractRowBounds(e, t) {
    const s = (i) => ({
      rowHeight: i.rowHeight,
      rowTop: i.rowTop
    });
    if (e.rowIndex === t)
      return s(e);
    if (e.hasChildren() && e.expanded && e.childStore) {
      const i = e.childStore;
      if (i.isDisplayIndexInStore(t))
        return i.getRowBounds(t);
    } else if (e.master && e.expanded && e.detailNode && e.detailNode.rowIndex === t)
      return s(e.detailNode);
  }
  isPixelInNodeRange(e, t) {
    return !A(e.rowTop) || !A(e.rowHeight) ? !1 : t >= e.rowTop && t < e.rowTop + e.rowHeight;
  }
  getIndexAtPixel(e, t) {
    if (this.isPixelInNodeRange(e, t))
      return e.rowIndex;
    const s = e.master && e.expanded, i = e.detailNode;
    if (s && i && this.isPixelInNodeRange(i, t))
      return e.detailNode.rowIndex;
    if (e.hasChildren() && e.expanded && e.childStore) {
      const r = e.childStore;
      if (r.isPixelInRange(t))
        return r.getRowIndexAtPixel(t);
    }
    return null;
  }
  createNodeIdPrefix(e) {
    const t = [];
    let s = e;
    for (; s && s.level >= 0; )
      s.key === "" ? t.push(bG) : t.push(s.key), s = s.parent;
    if (t.length > 0)
      return t.reverse().join("-");
  }
  checkOpenByDefault(e) {
    var t;
    return (t = this.expansionSvc) == null ? void 0 : t.checkOpenByDefault(e);
  }
}, xG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmExpandListener";
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  postConstruct() {
    Te(this.gos) && this.addManagedEventListeners({ rowGroupOpened: this.onRowGroupOpened.bind(this) });
  }
  onRowGroupOpened(e) {
    const t = e.node;
    if (t.expanded) {
      if (t.master)
        this.createDetailNode(t);
      else if (Y(t.childStore)) {
        const s = this.serverSideRowModel.getParams();
        t.childStore = this.createBean(this.storeFactory.createStore(s, t));
      }
    } else this.gos.get("purgeClosedRowNodes") && A(t.childStore) && (t.childStore = this.destroyBean(t.childStore));
    this.eventSvc.dispatchEvent({ type: "storeUpdated" });
  }
  createDetailNode(e) {
    if (A(e.detailNode))
      return e.detailNode;
    const t = new Qe(this.beans);
    t.detail = !0, t.selectable = !1, t.parent = e, A(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1;
    const s = 200, i = Ie(this.beans, t).height;
    return t.rowHeight = i || s, e.detailNode = t, t;
  }
}, FG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmFilterListener";
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel, this.filterManager = e.filterManager, this.listenerUtils = e.ssrmListenerUtils;
  }
  postConstruct() {
    Te(this.gos) && this.addManagedEventListeners({
      advancedFilterEnabledChanged: () => this.onFilterChanged(!0),
      filterChanged: () => this.onFilterChanged()
    });
  }
  onFilterChanged(e) {
    var l, d;
    const t = this.serverSideRowModel.getParams();
    if (!t)
      return;
    const s = t.filterModel;
    let i, r;
    if ((l = this.filterManager) != null && l.isAdvFilterEnabled()) {
      i = this.filterManager.getAdvFilterModel();
      const c = e ? Object.keys(s ?? {}) : this.getAdvancedFilterColumns(s), h = this.getAdvancedFilterColumns(i);
      c.forEach((u) => h.add(u)), r = Array.from(h);
    } else if (i = ((d = this.filterManager) == null ? void 0 : d.getFilterModel()) ?? {}, e) {
      const c = this.getAdvancedFilterColumns(s);
      Object.keys(i).forEach((h) => c.add(h)), r = Array.from(c);
    } else
      r = this.findChangedColumns(s, i);
    const o = this.listenerUtils.isSortingWithValueColumn(r), n = this.listenerUtils.isSortingWithSecondaryColumn(r), a = {
      valueColChanged: o,
      secondaryColChanged: n,
      changedColumns: r
    };
    this.serverSideRowModel.refreshAfterFilter(i, a);
  }
  findChangedColumns(e, t) {
    const s = {};
    Object.keys(e).forEach((r) => s[r] = !0), Object.keys(t).forEach((r) => s[r] = !0);
    const i = [];
    return Object.keys(s).forEach((r) => {
      const o = JSON.stringify(e[r]), n = JSON.stringify(t[r]);
      o != n && i.push(r);
    }), i;
  }
  getAdvancedFilterColumns(e) {
    const t = /* @__PURE__ */ new Set();
    if (!e)
      return t;
    const s = (i) => {
      i.filterType === "join" ? i.conditions.forEach((r) => s(r)) : t.add(i.colId);
    };
    return s(e), t;
  }
}, RG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmListenerUtils";
  }
  wireBeans(e) {
    this.pivotResultCols = e.pivotResultCols, this.valueColsSvc = e.valueColsSvc;
  }
  isSortingWithValueColumn(e) {
    var s;
    const t = (((s = this.valueColsSvc) == null ? void 0 : s.columns) ?? []).map((i) => i.getColId());
    for (let i = 0; i < e.length; i++)
      if (t.indexOf(e[i]) > -1)
        return !0;
    return !1;
  }
  isSortingWithSecondaryColumn(e) {
    var i;
    const t = (i = this.pivotResultCols) == null ? void 0 : i.getPivotResultCols();
    if (!t)
      return !1;
    const s = t.list.map((r) => r.getColId());
    for (let r = 0; r < e.length; r++)
      if (s.indexOf(e[r]) > -1)
        return !0;
    return !1;
  }
}, PG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmSortSvc";
  }
  wireBeans(e) {
    this.sortSvc = e.sortSvc, this.serverSideRowModel = e.rowModel, this.listenerUtils = e.ssrmListenerUtils;
  }
  postConstruct() {
    Te(this.gos) && this.addManagedEventListeners({ sortChanged: this.onSortChanged.bind(this) });
  }
  onSortChanged() {
    const e = this.serverSideRowModel.getParams();
    if (!e)
      return;
    const t = this.sortSvc.getSortModel(), s = e.sortModel, i = this.findChangedColumnsInSort(t, s), r = this.listenerUtils.isSortingWithValueColumn(i), o = this.listenerUtils.isSortingWithSecondaryColumn(i), n = {
      valueColChanged: r,
      secondaryColChanged: o,
      changedColumns: i
    };
    this.serverSideRowModel.refreshAfterSort(t, n);
  }
  // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,
  // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache
  // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache
  // was previously sorted by A and then the A sort now needs to be cleared.
  findChangedColumnsInSort(e, t) {
    let s = [];
    [e, t].forEach((o) => {
      if (o) {
        const n = o.map((a) => a.colId);
        s = s.concat(n);
      }
    });
    const i = (o, n) => {
      const a = o ? o.sort : null, l = n ? n.sort : null;
      return a !== l;
    }, r = (o, n) => {
      const a = o ? t.indexOf(o) : -1, l = n ? e.indexOf(n) : -1;
      return a !== l;
    };
    return s.filter((o) => {
      const n = t.find((l) => l.colId === o), a = e.find((l) => l.colId === o);
      return i(n, a) || r(n, a);
    });
  }
}, TG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmNodeManager", this.rowNodes = {};
  }
  addRowNode(e) {
    const t = e.id;
    this.rowNodes[t] && R(187, {
      rowId: t,
      firstData: this.rowNodes[t].data,
      secondData: e.data
    }), this.rowNodes[t] = e;
  }
  removeNode(e) {
    const t = e.id;
    this.rowNodes[t] && (this.rowNodes[t] = void 0);
  }
  destroy() {
    this.clear(), super.destroy();
  }
  clear() {
    this.rowNodes = {}, super.destroy();
  }
}, DG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = Ce(this, this.onRowHeightChanged.bind(this), 100), this.pauseStoreUpdateListening = !1, this.started = !1, this.managingPivotResultColumns = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.colNames = e.colNames, this.pivotResultCols = e.pivotResultCols, this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.filterManager = e.filterManager, this.sortSvc = e.sortSvc, this.rowRenderer = e.rowRenderer, this.nodeManager = e.ssrmNodeManager, this.storeFactory = e.ssrmStoreFactory, this.pivotColDefSvc = e.pivotColDefSvc;
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  start() {
    this.started = !0, this.updateDatasource();
  }
  destroyDatasource() {
    this.datasource && (this.datasource.destroy && this.datasource.destroy(), this.rowRenderer.datasourceChanged(), this.datasource = void 0);
  }
  postConstruct() {
    const e = this.resetRootStore.bind(this);
    this.addManagedEventListeners({
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.onStoreUpdated.bind(this),
      columnValueChanged: e,
      columnPivotChanged: e,
      columnRowGroupChanged: e,
      columnPivotModeChanged: e
    }), this.addManagedPropertyListeners(
      [
        /**
         * Following properties omitted as they are likely to come with undesired  side effects.
         * 'getRowId', 'isRowMaster', 'getRowHeight', 'isServerSideGroup', 'getServerSideGroupKey',
         * */
        "masterDetail",
        "treeData",
        "removePivotHeaderRowWhenSingleValueColumn",
        "cacheBlockSize"
      ],
      e
    ), this.addManagedPropertyListener("groupAllowUnbalanced", () => this.onStoreUpdated()), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights()), this.verifyProps(), this.addManagedPropertyListener("serverSideDatasource", () => this.updateDatasource());
  }
  updateDatasource() {
    const e = this.gos.get("serverSideDatasource");
    e && this.setDatasource(e);
  }
  verifyProps() {
    ot(this.gos) && !this.gos.exists("getRowId") && R(188);
  }
  setDatasource(e) {
    this.started && (this.destroyDatasource(), this.datasource = e, this.resetRootStore());
  }
  applyRowData(e, t, s) {
    const i = this.getRootStore();
    if (!i)
      return;
    const r = i.getChildStore(s);
    r && r.applyRowData(e, t, e.rowData.length);
  }
  isLastRowIndexKnown() {
    const e = this.getRootStore();
    return e ? e.isLastRowIndexKnown() : !1;
  }
  onColumnEverything() {
    var d, c, h, u;
    if (!this.storeParams) {
      this.resetRootStore();
      return;
    }
    const e = this.columnsToValueObjects((d = this.rowGroupColsSvc) == null ? void 0 : d.columns), t = this.columnsToValueObjects((c = this.valueColsSvc) == null ? void 0 : c.columns), s = this.columnsToValueObjects((h = this.pivotColsSvc) == null ? void 0 : h.columns), i = (p) => {
      const g = {};
      p.oldCols.forEach((C) => g[C.id] = C);
      const f = p.newCols.every((C) => {
        const v = g[C.id];
        return v && delete g[C.id], v && v.field === C.field && v.aggFunc === C.aggFunc;
      }), m = !p.allowRemovedColumns && !!Object.values(g).length;
      return f && !m;
    }, r = !bi(this.storeParams.sortModel, ((u = this.sortSvc) == null ? void 0 : u.getSortModel()) ?? []), o = !i({
      oldCols: this.storeParams.rowGroupCols,
      newCols: e
    }), n = !i({
      oldCols: this.storeParams.pivotCols,
      newCols: s
    }), a = !!(e != null && e.length) && !i({
      oldCols: this.storeParams.valueCols,
      newCols: t,
      allowRemovedColumns: !0
    });
    if (r || o || n || a)
      this.resetRootStore();
    else {
      const p = this.createStoreParams();
      this.storeParams.rowGroupCols = p.rowGroupCols, this.storeParams.pivotCols = p.pivotCols, this.storeParams.valueCols = p.valueCols;
    }
  }
  destroyRootStore() {
    !this.rootNode || !this.rootNode.childStore || (this.rootNode.childStore = this.destroyBean(this.rootNode.childStore), this.nodeManager.clear());
  }
  refreshAfterSort(e, t) {
    this.storeParams && (this.storeParams.sortModel = e);
    const s = this.getRootStore();
    s && (s.refreshAfterSort(t), this.onStoreUpdated());
  }
  generateSecondaryColumns(e) {
    var s;
    if (!this.pivotColDefSvc) {
      this.gos.assertModuleRegistered("SharedPivot", 2);
      return;
    }
    const t = this.pivotColDefSvc.createColDefsFromFields(e);
    this.managingPivotResultColumns = !0, (s = this.pivotResultCols) == null || s.setPivotResultCols(t, "rowModelUpdated");
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes(), t = Ie(this.beans, this.rootNode);
    if (this.rootNode.setRowHeight(t.height, t.estimated), this.rootNode.sibling) {
      const s = Ie(this.beans, this.rootNode.sibling);
      this.rootNode.sibling.setRowHeight(s.height, s.estimated);
    }
    e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      const s = Ie(this.beans, t);
      t.setRowHeight(s.height, s.estimated);
      const i = t.detailNode;
      if (i) {
        const r = Ie(this.beans, i);
        i.setRowHeight(r.height, r.estimated);
      }
      if (t.sibling) {
        const r = Ie(this.beans, t.sibling);
        i.setRowHeight(r.height, r.estimated);
      }
      e = !0;
    }), e;
  }
  resetRootStore() {
    var e;
    this.destroyRootStore(), this.rootNode = new Qe(this.beans), this.rootNode.group = !0, this.rootNode.level = -1, this.datasource && (this.storeParams = this.createStoreParams(), this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode)), this.updateRowIndexesAndBounds()), this.managingPivotResultColumns && ((e = this.pivotResultCols) == null || e.setPivotResultCols(null, "api"), this.managingPivotResultColumns = !1), this.dispatchModelUpdated(!0);
  }
  columnsToValueObjects(e = []) {
    return e.map(
      (t) => ({
        id: t.getId(),
        aggFunc: t.getAggFunc(),
        displayName: this.colNames.getDisplayNameForColumn(t, "model"),
        field: t.getColDef().field
      })
    );
  }
  createStoreParams() {
    var o, n, a, l, d, c, h;
    const e = this.columnsToValueObjects((o = this.rowGroupColsSvc) == null ? void 0 : o.columns), t = this.columnsToValueObjects((n = this.valueColsSvc) == null ? void 0 : n.columns), s = this.columnsToValueObjects((a = this.pivotColsSvc) == null ? void 0 : a.columns), i = nl(this.gos);
    return {
      // the columns the user has grouped and aggregated by
      valueCols: t,
      rowGroupCols: e,
      pivotCols: s,
      pivotMode: this.colModel.isPivotMode(),
      // sort and filter model
      filterModel: (l = this.filterManager) != null && l.isAdvFilterEnabled() ? (d = this.filterManager) == null ? void 0 : d.getAdvFilterModel() : ((c = this.filterManager) == null ? void 0 : c.getFilterModel()) ?? {},
      sortModel: ((h = this.sortSvc) == null ? void 0 : h.getSortModel()) ?? [],
      datasource: this.datasource,
      lastAccessedSequence: { value: 0 },
      // blockSize: blockSize == null ? 100 : blockSize,
      dynamicRowHeight: i
    };
  }
  getParams() {
    return this.storeParams;
  }
  dispatchModelUpdated(e = !1) {
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: !e,
      keepRenderedRows: !e,
      newPage: !1,
      newData: !1
    });
  }
  onStoreUpdated() {
    this.pauseStoreUpdateListening || (this.updateRowIndexesAndBounds(), this.dispatchModelUpdated());
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  onRowHeightChanged() {
    this.updateRowIndexesAndBounds(), this.dispatchModelUpdated();
  }
  updateRowIndexesAndBounds() {
    const e = this.getRootStore();
    e && e.setDisplayIndexes({ value: 0 }, { value: 0 }, 0);
  }
  retryLoads() {
    const e = this.getRootStore();
    e && (e.retryLoads(), this.onStoreUpdated());
  }
  getRow(e) {
    const t = this.getRootStore();
    if (t)
      return t.getRowUsingDisplayIndex(e);
  }
  /**
   * Pauses the store, to prevent it updating the UI. This is used when doing batch updates to the store.
   */
  setPaused(e) {
    this.pauseStoreUpdateListening = e;
  }
  expandAll(e) {
    this.pauseStoreUpdateListening = !0, this.forEachNode((t) => {
      t.stub || t.hasChildren() && t.setExpanded(e);
    }), this.pauseStoreUpdateListening = !1, this.onStoreUpdated();
  }
  refreshAfterFilter(e, t) {
    this.storeParams && (this.storeParams.filterModel = e);
    const s = this.getRootStore();
    s && (s.refreshAfterFilter(t), this.onStoreUpdated());
  }
  getRootStore() {
    var e;
    return (e = this.rootNode) == null ? void 0 : e.childStore;
  }
  getRowCount() {
    const e = this.getRootStore();
    return e ? e.getDisplayIndexEnd() : 0;
  }
  getTopLevelRowCount() {
    const e = this.getRootStore();
    return e ? e.getRowCount() : 1;
  }
  getTopLevelRowDisplayedIndex(e) {
    const t = this.getRootStore();
    return t ? t.getTopLevelRowDisplayedIndex(e) : e;
  }
  getRowBounds(e) {
    const t = this.getRootStore();
    return t ? t.getRowBounds(e) : {
      rowTop: 0,
      rowHeight: Ye(this.beans)
    };
  }
  getBlockStates() {
    const e = this.getRootStore();
    if (!e)
      return;
    const t = {};
    return e.forEachStoreDeep((s) => {
      Object.entries(s.getBlockStates()).forEach(([i, r]) => {
        t[i] = r;
      });
    }), t;
  }
  getRowIndexAtPixel(e) {
    const t = this.getRootStore();
    return e <= 0 || !t ? 0 : t.getRowIndexAtPixel(e);
  }
  isEmpty() {
    return !1;
  }
  isRowsToRender() {
    return this.getRootStore() != null && this.getRowCount() > 0;
  }
  getType() {
    return "serverSide";
  }
  forEachNode(e) {
    const t = this.getRootStore();
    t && t.forEachNodeDeep(e);
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    const s = this.getRootStore();
    s && s.forEachNodeDeepAfterFilterAndSort(e, void 0, t);
  }
  /** @return false if store hasn't started */
  executeOnStore(e, t) {
    if (!this.started)
      return !1;
    const s = this.getRootStore();
    if (!s)
      return !0;
    const i = s.getChildStore(e);
    return i && t(i), !0;
  }
  refreshStore(e = {}) {
    const t = e.route ? e.route : [];
    this.executeOnStore(t, (s) => s.refreshStore(e.purge == !0));
  }
  getStoreState() {
    const e = [], t = this.getRootStore();
    return t && t.addStoreStates(e), e;
  }
  getNodesInRangeForSelection(e, t) {
    const s = e.rowIndex, i = t.rowIndex;
    if (s === null && i === null)
      return [];
    if (i === null)
      return e ? [e] : [];
    if (s === null)
      return [t];
    const r = [], [o, n] = [s, i].sort((a, l) => a - l);
    return this.forEachNode((a) => {
      const l = a.rowIndex;
      l == null || a.stub || l >= o && l <= n && r.push(a);
    }), r.length !== n - o + 1 ? null : r;
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((s) => {
      s.id === e && (t = s), s.detailNode && s.detailNode.id === e && (t = s.detailNode);
    }), t;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  setRowCount(e, t) {
    const s = this.getRootStore();
    s && s.setRowCount(e, t);
  }
  destroy() {
    this.destroyDatasource(), this.destroyRootStore(), super.destroy();
  }
};
function EG(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectionState()) ?? null;
}
function MG(e, t) {
  var s;
  (s = e.selectionSvc) == null || s.setSelectionState(t, "api");
}
function AG(e, t) {
  var s;
  return (s = e.ssrmTxnManager) == null ? void 0 : s.applyTransaction(t);
}
function IG(e, t) {
  var r;
  const s = t.startRow ?? 0, i = t.route ?? [];
  if (s < 0) {
    R(189, { startRow: s });
    return;
  }
  (r = ki(e)) == null || r.applyRowData(t.successParams, s, i);
}
function LG(e, t, s) {
  var i;
  return (i = e.ssrmTxnManager) == null ? void 0 : i.applyTransactionAsync(t, s);
}
function kG(e) {
  var t;
  (t = ki(e)) == null || t.retryLoads();
}
function OG(e) {
  var t;
  return (t = e.ssrmTxnManager) == null ? void 0 : t.flushAsyncTransactions();
}
function GG(e, t) {
  var s;
  (s = ki(e)) == null || s.refreshStore(t);
}
function BG(e) {
  var t;
  return ((t = ki(e)) == null ? void 0 : t.getStoreState()) ?? [];
}
var VG = class extends gf {
  constructor() {
    super(...arguments), this.beanName = "expansionSvc", this.queuedRowIds = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedEventListeners({
      columnRowGroupChanged: () => {
        this.queuedRowIds.clear();
      }
    });
  }
  checkOpenByDefault(e) {
    if (!e.isExpandable())
      return;
    if (this.queuedRowIds.has(e.id)) {
      this.queuedRowIds.delete(e.id), e.setExpanded(!0);
      return;
    }
    const t = this.gos.getCallback("isServerSideGroupOpenByDefault");
    if (!t)
      return;
    const s = {
      data: e.data,
      rowNode: e
    };
    t(s) && e.setExpanded(!0);
  }
  expandRows(e) {
    e.forEach((t) => {
      const s = this.serverSideRowModel.getRowNode(t);
      s ? s.setExpanded(!0) : this.queuedRowIds.add(t);
    });
  }
  expandAll(e) {
    this.serverSideRowModel.expandAll(e);
  }
  onGroupExpandedOrCollapsed() {
  }
  dispatchExpandedEvent(e) {
    this.eventSvc.dispatchEvent(e);
  }
}, na = class extends P {
  constructor() {
    super(...arguments), this.selectedState = { selectAll: !1, toggledNodes: /* @__PURE__ */ new Set() }, this.selectAllUsed = !1, this.selectedNodes = {};
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionSvc = e.selectionSvc;
  }
  getSelectedState() {
    return {
      selectAll: this.selectedState.selectAll,
      toggledNodes: [...this.selectedState.toggledNodes]
    };
  }
  setSelectedState(e) {
    if (typeof e != "object") {
      z(115);
      return;
    }
    if (!("selectAll" in e)) {
      z(116);
      return;
    }
    if (typeof e.selectAll != "boolean") {
      z(117);
      return;
    }
    if (!("toggledNodes" in e) || !Array.isArray(e.toggledNodes))
      return R(197);
    const t = {
      selectAll: e.selectAll,
      toggledNodes: /* @__PURE__ */ new Set()
    };
    e.toggledNodes.forEach((i) => {
      typeof i == "string" ? t.toggledNodes.add(i) : R(196, { key: i });
    });
    const s = t.selectAll || t.toggledNodes.size > 1;
    if (ll(this.gos) && !bs(this.gos) && s) {
      R(198);
      return;
    }
    this.selectedState = t;
  }
  deleteSelectionStateFromParent(e, t) {
    if (this.selectedState.toggledNodes.size === 0)
      return !1;
    let s = !1;
    return t.forEach((i) => {
      this.selectedState.toggledNodes.delete(i) && (s = !0);
    }), s;
  }
  setNodesSelected(e) {
    const { nodes: t, clearSelection: s, newValue: i } = e;
    if (t.length === 0)
      return 0;
    const r = s && i;
    if (!bs(this.gos) || r) {
      if (t.length > 1)
        return z(241), 0;
      const n = t[0], a = n.footer ? n.sibling : n;
      return i && a.selectable ? (this.selectedNodes = { [a.id]: a }, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set([a.id])
      }) : (this.selectedNodes = {}, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set()
      }), 1;
    }
    const o = (n, a = i) => {
      const l = n.footer ? n.sibling : n;
      a && l.selectable ? this.selectedNodes[l.id] = l : delete this.selectedNodes[l.id], a === this.selectedState.selectAll || !l.selectable ? this.selectedState.toggledNodes.delete(l.id) : this.selectedState.toggledNodes.add(l.id);
    };
    return t.forEach((n) => o(n)), 1;
  }
  processNewRow(e) {
    this.selectedNodes[e.id] && (this.selectedNodes[e.id] = e);
  }
  isNodeSelected(e) {
    const t = this.selectedState.toggledNodes.has(e.id);
    return this.selectedState.selectAll ? !t : t;
  }
  getSelectedNodes() {
    return this.selectAllUsed && R(199), Object.values(this.selectedNodes);
  }
  getSelectedRows() {
    return this.getSelectedNodes().map((e) => e.data);
  }
  getSelectionCount() {
    return this.selectedState.selectAll ? -1 : this.selectedState.toggledNodes.size;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAll && !((e = this.selectedState.toggledNodes) != null && e.size);
  }
  selectAllRowNodes() {
    this.selectedState = { selectAll: !0, toggledNodes: /* @__PURE__ */ new Set() }, this.selectedNodes = {}, this.selectAllUsed = !0;
  }
  deselectAllRowNodes() {
    this.selectedState = { selectAll: !1, toggledNodes: /* @__PURE__ */ new Set() }, this.selectedNodes = {};
  }
  getSelectAllState() {
    return this.selectedState.selectAll ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}, aa = class extends P {
  constructor() {
    super(...arguments), this.selectedState = { selectAllChildren: !1, toggledNodes: /* @__PURE__ */ new Map() };
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.filterManager = e.filterManager, this.selectionSvc = e.selectionSvc;
  }
  postConstruct() {
    this.addManagedEventListeners({
      // if model has updated, a store may now be fully loaded to clean up indeterminate states
      modelUpdated: () => this.removeRedundantState(),
      // when the grouping changes, the state no longer makes sense, so reset the state.
      columnRowGroupChanged: () => this.selectionSvc.reset("rowGroupChanged")
    });
  }
  getSelectedState() {
    const e = this.gos.get("treeData"), t = (s, i, r) => {
      var n;
      const o = {
        nodeId: r
      };
      if ((e || this.rowGroupColsSvc && i <= ((n = this.rowGroupColsSvc) == null ? void 0 : n.columns.length)) && (o.selectAllChildren = s.selectAllChildren), s.toggledNodes.size) {
        const a = [];
        s.toggledNodes.forEach((l, d) => {
          const c = t(l, i + 1, d);
          a.push(c);
        }), o.toggledNodes = a;
      }
      return o;
    };
    return t(this.selectedState, 0);
  }
  setSelectedState(e) {
    if ("selectAll" in e) {
      z(111);
      return;
    }
    const t = (s, i) => {
      var a;
      if (typeof s != "object")
        throw z(243), new Error();
      if ("selectAllChildren" in s && typeof s.selectAllChildren != "boolean")
        throw z(244), new Error();
      if ("toggledNodes" in s) {
        if (!Array.isArray(s.toggledNodes))
          throw z(245), new Error();
        if (!s.toggledNodes.every(
          (d) => typeof d == "object" && "nodeId" in d && typeof d.nodeId == "string"
        ))
          throw z(246), new Error();
      }
      const r = s.selectAllChildren ?? !i, o = (a = s.toggledNodes) == null ? void 0 : a.map((l) => [
        l.nodeId,
        t(l, r)
      ]);
      if (o == null ? void 0 : o.some(
        ([, l]) => r === l.selectAllChildren && l.toggledNodes.size === 0
      ))
        throw z(247), new Error();
      return {
        selectAllChildren: r,
        toggledNodes: new Map(o)
      };
    };
    try {
      this.selectedState = t(e, !!e.selectAllChildren);
    } catch {
    }
  }
  deleteSelectionStateFromParent(e, t) {
    let s = this.selectedState;
    const i = [...e];
    for (; s && i.length; )
      s = s.toggledNodes.get(i.pop());
    if (!s)
      return !1;
    let r = !1;
    return t.forEach((o) => {
      s != null && s.toggledNodes.delete(o) && (r = !0);
    }), r && this.removeRedundantState(), r;
  }
  setNodesSelected({ nodes: e, newValue: t, clearSelection: s }) {
    if (e.length === 0)
      return 0;
    const i = s && t;
    if (!bs(this.gos) || i) {
      if (e.length > 1)
        return z(241), 0;
      this.deselectAllRowNodes();
    }
    return e.forEach((r) => {
      const o = r.footer ? r.sibling : r, n = this.getRouteToNode(o);
      this.recursivelySelectNode(n, this.selectedState, t);
    }), this.removeRedundantState(), 1;
  }
  isNodeSelected(e) {
    const t = this.getRouteToNode(e);
    return this.isNodePathSelected(t, this.selectedState);
  }
  isNodePathSelected([e, ...t], s) {
    if (t.length === 0) {
      const i = s.toggledNodes.has(e.id);
      if (e.hasChildren()) {
        const r = s.toggledNodes.get(e.id);
        if (r && r.toggledNodes.size)
          return;
      }
      return s.selectAllChildren ? !i : i;
    }
    if (s.toggledNodes.has(e.id)) {
      const i = s.toggledNodes.get(e.id);
      if (i)
        return this.isNodePathSelected(t, i);
    }
    return s.selectAllChildren;
  }
  getRouteToNode(e) {
    const t = [];
    let s = e;
    for (; s.parent; )
      t.push(s), s = s.parent;
    return t.reverse();
  }
  removeRedundantState() {
    var t;
    if ((t = this.filterManager) != null && t.isAnyFilterPresent())
      return;
    const e = (s = this.selectedState, i, r) => {
      if (s.toggledNodes.forEach((a, l) => {
        e(a, l, s);
      }), i) {
        const a = this.rowModel.getRowNode(i), l = a == null ? void 0 : a.childStore;
        if ((l == null ? void 0 : l.isLastRowIndexKnown()) && s.toggledNodes.size >= l.getRowCount()) {
          for (const h of s.toggledNodes.entries()) {
            const [u, p] = h;
            if (p.toggledNodes.size > 0 || !this.rowModel.getRowNode(u))
              return;
          }
          s.selectAllChildren = !s.selectAllChildren, s.toggledNodes.clear();
        }
      }
      const o = s.toggledNodes.size === 0, n = (r == null ? void 0 : r.selectAllChildren) === s.selectAllChildren;
      o && n && (r == null || r.toggledNodes.delete(i));
    };
    e();
  }
  recursivelySelectNode([e, ...t], s, i) {
    if (!e)
      return;
    if (!t.length) {
      const a = e.selectable;
      if (s.selectAllChildren === i || !a) {
        s.toggledNodes.delete(e.id);
        return;
      }
      const d = {
        selectAllChildren: i,
        toggledNodes: /* @__PURE__ */ new Map()
      };
      s.toggledNodes.set(e.id, d);
      return;
    }
    const o = s.toggledNodes.has(e.id), n = s.toggledNodes.get(e.id) ?? {
      selectAllChildren: s.selectAllChildren,
      toggledNodes: /* @__PURE__ */ new Map()
    };
    o || s.toggledNodes.set(e.id, n), this.recursivelySelectNode(t, n, i), s.selectAllChildren === n.selectAllChildren && n.toggledNodes.size === 0 && s.toggledNodes.delete(e.id);
  }
  getSelectedNodes() {
    R(202);
    const e = [];
    return this.rowModel.forEachNode((t) => {
      t.isSelected() && e.push(t);
    }), e;
  }
  processNewRow() {
  }
  getSelectedRows() {
    return this.getSelectedNodes().map((e) => e.data);
  }
  getSelectionCount() {
    return -1;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAllChildren && !((e = this.selectedState.toggledNodes) != null && e.size);
  }
  selectAllRowNodes() {
    this.selectedState = { selectAllChildren: !0, toggledNodes: /* @__PURE__ */ new Map() };
  }
  deselectAllRowNodes() {
    this.selectedState = { selectAllChildren: !1, toggledNodes: /* @__PURE__ */ new Map() };
  }
  getSelectAllState() {
    return this.selectedState.selectAllChildren ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}, NG = class extends sp {
  constructor() {
    super(...arguments), this.beanName = "selectionSvc";
  }
  postConstruct() {
    super.postConstruct(), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      const s = qs(this.gos), i = s && this.selectionStrategy instanceof na ? aa : !s && this.selectionStrategy instanceof aa ? na : void 0;
      i && (this.destroyBean(this.selectionStrategy), this.selectionStrategy = this.createManagedBean(new i()), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api"));
    }), this.addManagedPropertyListeners(["rowSelection"], () => {
      const s = Ri(this.gos);
      s !== this.selectionMode && (this.selectionMode = s, this.deselectAllRowNodes({ source: "api" }));
    }), this.selectionMode = Ri(this.gos);
    const t = qs(this.gos) ? aa : na;
    this.selectionStrategy = this.createManagedBean(new t());
  }
  handleSelectionEvent(e, t, s) {
    if (this.isRowSelectionBlocked(t))
      return 0;
    let i = 0;
    const r = this.inferNodeSelections(t, e.shiftKey, e.metaKey || e.ctrlKey, s);
    return r == null ? 0 : ("select" in r ? (r.reset ? this.selectionStrategy.deselectAllRowNodes({ source: "api" }) : this.selectionStrategy.setNodesSelected({ nodes: r.deselect, newValue: !1, source: s }), i = this.selectionStrategy.setNodesSelected({ nodes: r.select, newValue: !0, source: s })) : i = this.selectionStrategy.setNodesSelected({
      nodes: [r.node],
      newValue: r.newValue,
      clearSelection: r.clearSelection,
      event: e,
      source: s
    }), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged(s), i);
  }
  getSelectionState() {
    return this.selectionStrategy.getSelectedState();
  }
  setSelectionState(e, t) {
    if (!ot(this.gos)) {
      R(132);
      return;
    }
    Array.isArray(e) || (this.selectionStrategy.setSelectedState(e), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged(t));
  }
  setNodesSelected(e) {
    if (!ot(this.gos) && e.newValue)
      return R(132), 0;
    const { nodes: t, ...s } = e;
    if (t.length > 1 && this.selectionMode !== "multiRow")
      return R(130), 0;
    const i = {
      nodes: t.filter((o) => o.selectable),
      ...s
    };
    if (!i.nodes.length)
      return 0;
    const r = this.selectionStrategy.setNodesSelected(i);
    return this.shotgunResetNodeSelectionState(i.source), this.dispatchSelectionChanged(i.source), r;
  }
  /**
   * Deletes the selection state for a set of nodes, for use after deleting nodes via
   * transaction. As this is designed for transactions, all nodes should belong to the same group.
   */
  deleteSelectionStateFromParent(e, t) {
    this.selectionStrategy.deleteSelectionStateFromParent(e, t) && (this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api"));
  }
  shotgunResetNodeSelectionState(e) {
    this.beans.rowModel.forEachNode((t) => {
      if (t.stub)
        return;
      const s = this.selectionStrategy.isNodeSelected(t);
      s !== t.isSelected() && this.selectRowNode(t, s, void 0, e);
    });
  }
  getSelectedNodes() {
    return this.selectionStrategy.getSelectedNodes();
  }
  getSelectedRows() {
    return this.selectionStrategy.getSelectedRows();
  }
  getSelectionCount() {
    return this.selectionStrategy.getSelectionCount();
  }
  syncInRowNode(e) {
    this.selectionStrategy.processNewRow(e);
    const t = this.selectionStrategy.isNodeSelected(e);
    if (t != !1 && !e.selectable) {
      this.selectionStrategy.setNodesSelected({
        nodes: [e],
        newValue: !1,
        source: "api"
      }), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api");
      return;
    }
    e.__selected = t;
  }
  reset() {
    this.selectionStrategy.deselectAllRowNodes({ source: "api" }), this.selectionCtx.reset();
  }
  isEmpty() {
    return this.selectionStrategy.isEmpty();
  }
  hasNodesToSelect() {
    return !0;
  }
  selectAllRowNodes(e) {
    if (!ot(this.gos)) {
      R(132);
      return;
    }
    if (Wc(e), ll(this.gos) && !bs(this.gos))
      return R(130);
    this.selectionStrategy.selectAllRowNodes(e), this.selectionCtx.reset(), this.beans.rowModel.forEachNode((t) => {
      t.stub || this.selectRowNode(t, !0, void 0, e.source);
    }), this.dispatchSelectionChanged(e.source);
  }
  deselectAllRowNodes(e) {
    Wc(e), this.selectionStrategy.deselectAllRowNodes(e), this.selectionCtx.reset(), this.beans.rowModel.forEachNode((t) => {
      t.stub || this.selectRowNode(t, !1, void 0, e.source);
    }), this.dispatchSelectionChanged(e.source);
  }
  getSelectAllState(e) {
    return this.selectionStrategy.getSelectAllState(e);
  }
  // used by CSRM
  getBestCostNodeSelection() {
    return R(194, { method: "getBestCostNodeSelection" });
  }
  /**
   * Updates the selectable state for a node by invoking isRowSelectable callback.
   * If the node is not selectable, it will be deselected.
   *
   * Callers:
   *  - property isRowSelectable changed
   *  - after grouping / treeData
   */
  updateSelectable() {
    if (!ot(this.gos))
      return;
    const e = [];
    this.beans.rowModel.forEachNode((t) => {
      !this.updateRowSelectable(t, !0) && t.isSelected() && e.push(t);
    }), e.length && this.setNodesSelected({
      nodes: e,
      newValue: !1,
      source: "selectableChanged"
    });
  }
  updateSelectableAfterGrouping() {
    return z(194, { method: "updateSelectableAfterGrouping" });
  }
};
function Wc({ selectAll: e }) {
  (e === "filtered" || e === "currentPage") && R(195, { justCurrentPage: e === "currentPage" });
}
var HG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "rowChildrenSvc";
  }
  getHasChildrenValue(e) {
    const t = this.gos.get("treeData"), s = this.gos.get("isServerSideGroup");
    return !e.stub && !e.footer && (t ? !!s && s(e.data) : !!e.group);
  }
}, zG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "lazyBlockLoadingSvc", this.outboundRequests = 0, this.cacheLoadingNodesMap = /* @__PURE__ */ new Map(), this.isCheckQueued = !1, this.nextBlockToLoad = void 0;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.maxOutboundRequests = Wh(this.gos);
  }
  subscribe(e) {
    this.cacheLoadingNodesMap.set(e, /* @__PURE__ */ new Set());
  }
  unsubscribe(e) {
    this.cacheLoadingNodesMap.delete(e);
  }
  /**
   * Queues a microtask to check if any blocks need to be loaded.
   */
  queueLoadCheck() {
    this.isCheckQueued || (this.isCheckQueued = !0, window.queueMicrotask(() => {
      this.queueLoadAction(), this.isCheckQueued = !1;
    }));
  }
  onLoadComplete() {
    this.outboundRequests -= 1, this.queueLoadCheck();
  }
  hasAvailableLoadBandwidth() {
    return this.maxOutboundRequests === void 0 ? !0 : this.outboundRequests < this.maxOutboundRequests;
  }
  queueLoadAction() {
    const e = this.getBlockToLoad();
    if (!e)
      return;
    const t = this.nextBlockToLoad && this.nextBlockToLoad.cache === e.cache && this.nextBlockToLoad.index === e.index;
    if (!t && (!this.nextBlockToLoad || !t)) {
      this.nextBlockToLoad = e, window.clearTimeout(this.loaderTimeout);
      const s = Number(this.nextBlockToLoad.index), i = this.nextBlockToLoad.cache, r = e.index + e.cache.getBlockSize();
      this.loaderTimeout = window.setTimeout(() => {
        i.isAlive() && (this.loaderTimeout = void 0, this.attemptLoad(i, s, r), this.nextBlockToLoad = void 0);
      }, this.gos.get("blockLoadDebounceMillis"));
    }
  }
  attemptLoad(e, t, s) {
    this.hasAvailableLoadBandwidth() && (this.executeLoad(e, t, s), this.queueLoadCheck());
  }
  executeLoad(e, t, s) {
    var h;
    const i = e.getSsrmParams(), r = {
      startRow: t,
      endRow: s,
      rowGroupCols: i.rowGroupCols,
      valueCols: i.valueCols,
      pivotCols: i.pivotCols,
      pivotMode: i.pivotMode,
      groupKeys: e.store.getParentNode().getRoute() ?? [],
      filterModel: i.filterModel,
      sortModel: i.sortModel
    }, o = this.cacheLoadingNodesMap.get(e), n = () => {
      for (let u = 0; u < s - t; u++)
        o.delete(t + u);
    }, a = () => {
      for (let u = 0; u < s - t; u++)
        o.add(t + u);
    }, l = (u) => {
      this.onLoadComplete(), e.onLoadSuccess(t, s - t, u), n();
    }, d = () => {
      this.onLoadComplete(), e.onLoadFailed(t, s - t), n();
    }, c = this.gos.addGridCommonParams({
      request: r,
      success: l,
      fail: d,
      parentNode: e.store.getParentNode()
    });
    a(), this.outboundRequests += 1, (h = e.getSsrmParams().datasource) == null || h.getRows(c);
  }
  getBlockToLoad() {
    var a, l;
    const e = this.rowRenderer.firstRenderedRow, t = this.rowRenderer.lastRenderedRow;
    for (let d = e; d <= t; d++) {
      const c = this.rowModel.getRow(d);
      if (!c)
        continue;
      const h = (a = c.parent) == null ? void 0 : a.childStore;
      if (!h)
        continue;
      const u = h.getCache(), p = u.getNodes().getBy("node", c);
      if (!p)
        continue;
      const g = this.cacheLoadingNodesMap.get(u);
      if (!(g != null && g.has(p.index)) && (c.__needsRefreshWhenVisible || c.stub && !c.failedLoad))
        return {
          cache: u,
          index: u.getBlockStartIndex(p.index)
        };
    }
    let s = null, i = null, r = Number.MAX_SAFE_INTEGER;
    for (const d of this.cacheLoadingNodesMap.keys())
      d.getNodesToRefresh().forEach((h) => {
        if (h.rowIndex == null) {
          i = h, s = d;
          return;
        }
        const u = d.getNodes().getBy("node", h);
        if (!u)
          return;
        const p = this.cacheLoadingNodesMap.get(d);
        if (p != null && p.has(u.index))
          return;
        const g = Math.abs(e - h.rowIndex), f = Math.abs(h.rowIndex - t);
        g < r && (i = h, r = g, s = d), f < r && (i = h, r = f, s = d);
      });
    if (!s)
      return;
    const o = s, n = (l = o.getNodes().getBy("node", i)) == null ? void 0 : l.index;
    return n == null ? void 0 : {
      cache: o,
      index: o.getBlockStartIndex(n)
    };
  }
  isRowLoading(e, t) {
    var s;
    return ((s = this.cacheLoadingNodesMap.get(e)) == null ? void 0 : s.has(t)) ?? !1;
  }
}, WG = class {
  constructor(...e) {
    this.indexes = e, this.maps = new Map(this.indexes.map((t) => [t, /* @__PURE__ */ new Map()]));
  }
  getSize() {
    return this.maps.get(this.indexes[0]).size;
  }
  getBy(e, t) {
    return this.maps.get(e).get(t);
  }
  set(e) {
    this.indexes.forEach((t) => {
      this.maps.get(t).set(e[t], e);
    });
  }
  delete(e) {
    this.indexes.forEach((t) => {
      this.maps.get(t).delete(e[t]);
    });
  }
  clear() {
    this.maps.forEach((e) => e.clear());
  }
  getIterator(e) {
    return this.maps.get(e).values();
  }
  forEach(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    for (; (s = t.next()) && !s.done; )
      e(s.value);
  }
  find(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    for (; (s = t.next()) && !s.done; )
      if (e(s.value))
        return s.value;
  }
  filter(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    const i = [];
    for (; (s = t.next()) && !s.done; )
      e(s.value) && i.push(s.value);
    return i;
  }
}, _G = 100, la = class extends P {
  constructor(e, t, s, i) {
    super(), this.live = !0, this.removedNodeCache = /* @__PURE__ */ new Map(), this.store = e, this.numberOfRows = t, this.isLastRowKnown = s, this.storeParams = i;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.blockUtils = e.ssrmBlockUtils, this.focusSvc = e.focusSvc, this.nodeManager = e.ssrmNodeManager, this.serverSideRowModel = e.rowModel, this.rowNodeSorter = e.rowNodeSorter, this.sortSvc = e.sortSvc, this.lazyBlockLoadingSvc = e.lazyBlockLoadingSvc, this.colModel = e.colModel;
  }
  postConstruct() {
    this.lazyBlockLoadingSvc.subscribe(this), this.nodeMap = new WG("index", "id", "node"), this.nodeDisplayIndexMap = /* @__PURE__ */ new Map(), this.nodesToRefresh = /* @__PURE__ */ new Set(), this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), this.getRowIdFunc = Yt(this.gos), this.isMasterDetail = this.gos.get("masterDetail");
  }
  destroy() {
    this.lazyBlockLoadingSvc.unsubscribe(this), this.numberOfRows = 0, this.nodeMap.forEach((e) => this.blockUtils.destroyRowNode(e.node)), this.nodeMap.clear(), this.nodeDisplayIndexMap.clear(), this.nodesToRefresh.clear(), this.live = !1, super.destroy();
  }
  /**
   * Get the row node for a specific display index from this store
   * @param displayIndex the display index of the node to find
   * @returns undefined if the node is not in the store bounds, otherwise will always return a node
   */
  getRowByDisplayIndex(e) {
    var l, d, c, h, u;
    if (!this.store.isDisplayIndexInStore(e))
      return;
    const t = this.nodeDisplayIndexMap.get(e);
    if (t)
      return (t.stub || t.__needsRefreshWhenVisible) && this.lazyBlockLoadingSvc.queueLoadCheck(), t;
    if (this.gos.get("groupHideOpenParents") || this.gos.get("groupAllowUnbalanced")) {
      const p = this.nodeMap.find(
        (g) => {
          var f;
          return !!((f = g.node.childStore) != null && f.isDisplayIndexInStore(e));
        }
      );
      if (p)
        return (l = p.node.childStore) == null ? void 0 : l.getRowUsingDisplayIndex(e);
    }
    if (e === this.store.getDisplayIndexStart())
      return this.createStubNode(0, e);
    const i = this.nodeDisplayIndexMap.get(e - 1);
    if (i) {
      if (this.isMasterDetail && i.master && i.expanded)
        return i.detailNode;
      if (i.expanded && ((d = i.childStore) != null && d.isDisplayIndexInStore(e)))
        return (c = i.childStore) == null ? void 0 : c.getRowUsingDisplayIndex(
          e
        );
      const p = this.nodeMap.getBy("node", i);
      return this.createStubNode(p.index + 1, e);
    }
    const r = this.getSurroundingNodesByDisplayIndex(e);
    if (r == null) {
      const p = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
      return this.createStubNode(p, e);
    }
    const { previousNode: o, nextNode: n } = r;
    if (o && o.node.expanded && ((h = o.node.childStore) != null && h.isDisplayIndexInStore(e)))
      return (u = o.node.childStore) == null ? void 0 : u.getRowUsingDisplayIndex(e);
    if (n) {
      const p = n.node.rowIndex - e, g = n.index - p;
      return this.createStubNode(g, e);
    }
    const a = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
    return this.createStubNode(a, e);
  }
  /**
   * Used for creating and positioning a stub node without firing a store updated event
   */
  createStubNode(e, t) {
    const s = this.store.getRowBounds(t), i = this.createRowAtIndex(e, null, (r) => {
      r.setRowIndex(t), r.setRowTop(s.rowTop), this.nodeDisplayIndexMap.set(t, r);
    });
    if (e === 0 && this.gos.get("groupHideOpenParents")) {
      const r = this.store.getParentNode().groupData;
      if (r)
        for (const o of Object.keys(r))
          Go(i, this.colModel, o, r[o]);
    }
    return this.lazyBlockLoadingSvc.queueLoadCheck(), i;
  }
  /**
   * @param index The row index relative to this store
   * @returns A rowNode at the given store index
   */
  getRowByStoreIndex(e) {
    var t;
    return (t = this.nodeMap.getBy("index", e)) == null ? void 0 : t.node;
  }
  /**
   * Given a number of rows, skips through the given sequence & row top reference (using default row height)
   * @param numberOfRowsToSkip number of rows to skip over in the given sequence
   * @param displayIndexSeq the sequence in which to skip
   * @param nextRowTop the row top reference in which to skip
   */
  skipDisplayIndexes(e, t, s) {
    if (e === 0)
      return;
    const i = Ye(this.beans);
    t.value += e, s.value += e * i;
  }
  /**
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t, s) {
    this.nodeDisplayIndexMap.clear();
    const i = {};
    this.nodeMap.forEach((n) => {
      i[n.index] = n.node;
    });
    let r = -1;
    for (const n of Object.keys(i)) {
      const a = i[n], l = Number(n), d = l - 1 - r;
      this.skipDisplayIndexes(d, e, t);
      const c = l === 0;
      if (a.setFirstChild(c), c && this.gos.get("groupHideOpenParents")) {
        const h = this.store.getParentNode().groupData;
        if (h)
          for (const u of Object.keys(h))
            Go(a, this.colModel, u, c ? h[u] : void 0);
      }
      this.blockUtils.setDisplayIndex(a, e, t, s), a.rowIndex != null && this.nodeDisplayIndexMap.set(a.rowIndex, a), r = l;
    }
    const o = this.numberOfRows - 1 - r;
    this.skipDisplayIndexes(o, e, t), this.purgeExcessRows();
  }
  getRowCount() {
    return this.numberOfRows;
  }
  setRowCount(e, t) {
    this.numberOfRows = e, t != null && (this.isLastRowKnown = t, t === !1 && (this.numberOfRows += 1)), this.fireStoreUpdatedEvent();
  }
  getNodes() {
    return this.nodeMap;
  }
  getNodeCachedByDisplayIndex(e) {
    return this.nodeDisplayIndexMap.get(e) ?? null;
  }
  getNodesToRefresh() {
    return this.nodesToRefresh;
  }
  /**
   * @returns the previous and next loaded row nodes surrounding the given display index
   */
  getSurroundingNodesByDisplayIndex(e) {
    let t, s;
    return this.nodeMap.forEach((i) => {
      if (e > i.node.rowIndex) {
        (s == null || s.node.rowIndex < i.node.rowIndex) && (s = i);
        return;
      }
      if (t == null || t.node.rowIndex > i.node.rowIndex) {
        t = i;
        return;
      }
    }), !s && !t ? null : { previousNode: s, nextNode: t };
  }
  /**
   * Get or calculate the display index for a given store index
   * @param storeIndex the rows index within this store
   * @returns the rows visible display index relative to the grid
   */
  getDisplayIndexFromStoreIndex(e) {
    var n;
    const t = this.nodeMap.getBy("index", e);
    if (t)
      return t.node.rowIndex;
    let s, i;
    if (this.nodeMap.forEach((a) => {
      if (e > a.index) {
        (i == null || i.index < a.index) && (i = a);
        return;
      }
      if (s == null || s.index > a.index) {
        s = a;
        return;
      }
    }), !s)
      return this.store.getDisplayIndexEnd() - (this.numberOfRows - e);
    if (!i)
      return this.store.getDisplayIndexStart() + e;
    const r = e - i.index;
    return (((n = i.node.childStore) == null ? void 0 : n.getDisplayIndexEnd()) ?? i.node.rowIndex) + r;
  }
  /**
   * Creates a new row and inserts it at the given index
   * @param atStoreIndex the node index relative to this store
   * @param data the data object to populate the node with
   * @returns the new row node
   */
  createRowAtIndex(e, t, s) {
    var o, n;
    const i = this.nodeMap.getBy("index", e);
    if (i) {
      const { node: a } = i;
      if (a.__needsRefreshWhenVisible = !1, this.doesNodeMatch(t, a))
        return this.blockUtils.updateDataIntoRowNode(a, t), this.nodesToRefresh.delete(a), a;
      if (this.getRowIdFunc == null && a.hasChildren() && a.expanded)
        return this.nodesToRefresh.delete(a), a;
      this.destroyRowAtIndex(e);
    }
    if (t && this.getRowIdFunc != null) {
      const a = this.getRowId(t), l = a && ((o = this.removedNodeCache) == null ? void 0 : o.get(a));
      if (l)
        return (n = this.removedNodeCache) == null || n.delete(a), this.blockUtils.updateDataIntoRowNode(l, t), this.nodeMap.set({
          id: l.id,
          node: l,
          index: e
        }), this.nodesToRefresh.delete(l), l.__needsRefreshWhenVisible = !1, l;
      const d = this.nodeMap.getBy("id", a);
      if (d) {
        this.nodeMap.delete(d);
        const { node: c, index: h } = d;
        return this.blockUtils.updateDataIntoRowNode(c, t), this.nodeMap.set({
          id: c.id,
          node: c,
          index: e
        }), this.nodesToRefresh.delete(c), c.__needsRefreshWhenVisible = !1, this.getBlockStartIndex(h) === this.getBlockStartIndex(e) || this.markBlockForVerify(h), c;
      }
    }
    const r = this.blockUtils.createRowNode(this.store.getRowDetails());
    if (t != null) {
      const a = this.getPrefixedId(this.store.getIdSequence().value++);
      this.blockUtils.setDataIntoRowNode(r, t, a, void 0), this.serverSideRowModel.setPaused(!0), this.blockUtils.checkOpenByDefault(r), this.serverSideRowModel.setPaused(!1), this.nodeManager.addRowNode(r);
    }
    return this.nodeMap.set({
      id: r.id,
      node: r,
      index: e
    }), s && s(r), r;
  }
  getBlockStates() {
    const e = {}, t = {};
    this.nodeMap.forEach(({ node: o, index: n }) => {
      const a = this.getBlockStartIndex(n);
      !o.stub && !o.failedLoad && (e[a] = (e[a] ?? 0) + 1);
      let l = "loaded";
      o.failedLoad ? l = "failed" : this.lazyBlockLoadingSvc.isRowLoading(this, a) ? l = "loading" : (this.nodesToRefresh.has(o) || o.stub) && (l = "needsLoading"), t[a] || (t[a] = /* @__PURE__ */ new Set()), t[a].add(l);
    });
    const s = {
      loading: 4,
      failed: 3,
      needsLoading: 2,
      loaded: 1
    }, i = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), r = {};
    return Object.entries(t).forEach(([o, n]) => {
      const l = [...n].sort(
        (h, u) => (s[h] ?? 0) - (s[u] ?? 0)
      )[0], d = Number(o) / this.getBlockSize(), c = i ? `${i}-${d}` : String(d);
      r[c] = {
        blockNumber: d,
        startRow: Number(o),
        endRow: Number(o) + this.getBlockSize(),
        pageStatus: l,
        loadedRowCount: e[o] ?? 0
      };
    }), r;
  }
  destroyRowAtIndex(e) {
    const t = this.nodeMap.getBy("index", e);
    t && (this.nodeMap.delete(t), this.nodeDisplayIndexMap.delete(t.node.rowIndex), this.nodesToRefresh.size > 0 ? this.removedNodeCache.set(t.node.id, t.node) : this.blockUtils.destroyRowNode(t.node), this.nodesToRefresh.delete(t.node));
  }
  getSsrmParams() {
    return this.store.getSsrmParams();
  }
  /**
   * @param id the base id to be prefixed
   * @returns a node id with prefix if required
   */
  getPrefixedId(e) {
    return this.defaultNodeIdPrefix ? this.defaultNodeIdPrefix + "-" + e : e.toString();
  }
  markBlockForVerify(e) {
    const [t, s] = this.getBlockBounds(e);
    this.nodeMap.filter((r) => r.index >= t && r.index < s).forEach(({ node: r }) => {
      r.__needsRefreshWhenVisible = !0;
    });
  }
  doesNodeMatch(e, t) {
    if (t.stub)
      return !1;
    const s = this.getRowId(e);
    return s === null ? t.data === e : t.id === s;
  }
  /**
   * Deletes any stub nodes not within the given range
   */
  purgeStubsOutsideOfViewport() {
    const { firstRenderedRow: e, lastRenderedRow: t } = this.rowRenderer, s = this.getBlockStartIndex(e), [, i] = this.getBlockBounds(t);
    this.nodeMap.forEach((r) => {
      this.lazyBlockLoadingSvc.isRowLoading(this, r.index) || r.node.failedLoad || r.node.stub && (r.index < s || r.index > i) && this.destroyRowAtIndex(r.index);
    });
  }
  getBlocksDistanceFromRow(e, t) {
    const s = {};
    return e.forEach(({ node: i, index: r }) => {
      const [o, n] = this.getBlockBounds(r);
      if (o in s)
        return;
      const a = Math.abs(i.rowIndex - t);
      let l;
      const d = this.nodeMap.getBy("index", [n - 1]);
      d && (l = Math.abs(d.node.rowIndex - t));
      const c = l == null || a < l ? a : l;
      s[o] = c;
    }), Object.entries(s);
  }
  purgeExcessRows() {
    if (this.purgeStubsOutsideOfViewport(), this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null)
      return;
    const { firstRenderedRow: e, lastRenderedRow: t } = this.rowRenderer, s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    this.nodeMap.forEach(({ index: p, node: g }) => {
      const f = this.getBlockStartIndex(p);
      s.add(f), g.rowIndex >= e && g.rowIndex <= t && i.add(f);
    });
    const r = Math.max(i.size, this.storeParams.maxBlocksInCache ?? 0), n = s.size - r;
    if (n <= 0)
      return;
    let a = Number.MAX_SAFE_INTEGER, l = Number.MIN_SAFE_INTEGER;
    i.forEach((p) => {
      a > p && (a = p), l < p && (l = p);
    });
    const d = this.nodeMap.filter(({ node: p, index: g }) => {
      const f = this.getBlockStartIndex(g);
      return !(f >= a && f <= l) && !this.isNodeCached(p);
    });
    if (d.length === 0)
      return;
    const c = e + (t - e) / 2, h = this.getBlocksDistanceFromRow(d, c), u = this.getBlockSize();
    h.sort((p, g) => Math.sign(g[1] - p[1]));
    for (let p = 0; p < Math.min(n, h.length); p++) {
      const g = Number(h[p][0]);
      for (let f = g; f < g + u; f++) {
        const m = this.nodeMap.getBy("index", f);
        !m || this.isNodeCached(m.node) || this.destroyRowAtIndex(f);
      }
    }
  }
  isNodeFocused(e) {
    const t = this.focusSvc.getFocusCellToUseAfterRefresh();
    return !t || t.rowPinned != null ? !1 : t.rowIndex === e.rowIndex;
  }
  isNodeCached(e) {
    const t = this.gos.get("groupAllowUnbalanced") && e.key === "";
    return e.isExpandable() && e.expanded || this.isNodeFocused(e) || t;
  }
  extractDuplicateIds(e) {
    if (this.getRowIdFunc == null)
      return [];
    const t = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
    return e.forEach((i) => {
      const r = this.getRowId(i);
      if (t.has(r)) {
        s.add(r);
        return;
      }
      t.add(r);
    }), [...s];
  }
  onLoadSuccess(e, t, s) {
    if (!this.live)
      return;
    const i = s.groupLevelInfo;
    if (this.store.setStoreInfo(i), this.getRowIdFunc != null) {
      const n = this.extractDuplicateIds(s.rowData);
      if (n.length > 0) {
        const a = n.join(", ");
        R(205, { duplicateIdText: a }), this.onLoadFailed(e, t);
        return;
      }
    }
    s.pivotResultFields && this.serverSideRowModel.generateSecondaryColumns(s.pivotResultFields);
    const r = this.nodesToRefresh.size > 0;
    if (s.rowData.forEach((n, a) => {
      var c;
      const l = e + a, d = this.nodeMap.getBy("index", l);
      if ((c = d == null ? void 0 : d.node) != null && c.stub) {
        this.createRowAtIndex(l, n);
        return;
      }
      if (d && this.doesNodeMatch(n, d.node)) {
        this.blockUtils.updateDataIntoRowNode(d.node, n), this.nodesToRefresh.delete(d.node), d.node.__needsRefreshWhenVisible = !1;
        return;
      }
      this.createRowAtIndex(l, n);
    }), s.rowCount != null && s.rowCount !== -1)
      this.numberOfRows = s.rowCount, this.isLastRowKnown = !0;
    else if (t > s.rowData.length)
      this.numberOfRows = e + s.rowData.length, this.isLastRowKnown = !0;
    else if (!this.isLastRowKnown) {
      const n = e + s.rowData.length + 1;
      n > this.numberOfRows && (this.numberOfRows = n);
    }
    this.isLastRowKnown && this.nodeMap.filter((a) => a.index >= this.numberOfRows).forEach((a) => this.destroyRowAtIndex(a.index)), this.fireStoreUpdatedEvent();
    const o = this.nodesToRefresh.size === 0;
    r && o && this.fireRefreshFinishedEvent();
  }
  fireRefreshFinishedEvent() {
    this.nodesToRefresh.size === 0 && (this.removedNodeCache.forEach((t) => {
      this.blockUtils.destroyRowNode(t);
    }), this.removedNodeCache = /* @__PURE__ */ new Map(), this.store.fireRefreshFinishedEvent());
  }
  /**
   * @returns true if all rows are loaded
   */
  isStoreFullyLoaded() {
    const e = this.isLastRowKnown, t = this.nodeMap.getSize() === this.numberOfRows;
    if (!e || !t || this.nodesToRefresh.size > 0)
      return;
    let s = -1;
    return this.nodeMap.find((r) => (s += 1, !!(r.index !== s || r.node.__needsRefreshWhenVisible || r.node.stub))) == null;
  }
  isLastRowIndexKnown() {
    return this.isLastRowKnown;
  }
  onLoadFailed(e, t) {
    if (!this.live)
      return;
    const s = this.nodesToRefresh.size > 0;
    for (let r = e; r < e + t && r < this.getRowCount(); r++) {
      let { node: o } = this.nodeMap.getBy("index", r) ?? {};
      o && this.nodesToRefresh.delete(o), (!o || !o.stub) && (o && !o.stub && this.destroyRowAtIndex(r), o = this.createRowAtIndex(r)), o.__needsRefreshWhenVisible = !1, o.failedLoad = !0;
    }
    const i = this.nodesToRefresh.size === 0;
    s && i && this.fireRefreshFinishedEvent(), this.fireStoreUpdatedEvent();
  }
  markNodesForRefresh() {
    this.nodeMap.forEach((e) => {
      e.node.stub && !e.node.failedLoad || this.nodesToRefresh.add(e.node);
    }), this.lazyBlockLoadingSvc.queueLoadCheck(), this.isLastRowKnown && this.numberOfRows === 0 && (this.numberOfRows = 1, this.isLastRowKnown = !1, this.fireStoreUpdatedEvent());
  }
  isNodeInCache(e) {
    return !!this.nodeMap.getBy("id", e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  fireStoreUpdatedEvent() {
    this.live && this.store.fireStoreUpdatedEvent();
  }
  getRowId(e) {
    if (this.getRowIdFunc == null)
      return null;
    const { level: t } = this.store.getRowDetails(), s = this.store.getParentNode().getRoute() ?? [];
    return this.getRowIdFunc({
      data: e,
      parentKeys: s.length > 0 ? s : void 0,
      level: t
    });
  }
  getOrderedNodeMap() {
    const e = {};
    return this.nodeMap.forEach((t) => e[t.index] = t), e;
  }
  clearDisplayIndexes() {
    this.nodeDisplayIndexMap.clear();
  }
  /**
   * Client side sorting
   */
  clientSideSortRows() {
    var r;
    const e = ((r = this.sortSvc) == null ? void 0 : r.getSortOptions()) ?? [];
    if (!e.some((o) => o.sort != null) || !this.rowNodeSorter)
      return;
    const s = new Array(this.nodeMap.getSize());
    this.nodeMap.forEach((o) => s[o.index] = o.node), this.nodeMap.clear(), this.rowNodeSorter.doFullSort(s, e).forEach((o, n) => {
      this.nodeMap.set({
        id: o.id,
        node: o,
        index: n
      });
    });
  }
  /**
   * Transaction Support here
   */
  updateRowNodes(e) {
    const t = [];
    return e.forEach((s) => {
      const i = this.getRowId(s), r = this.nodeMap.getBy("id", i);
      r && (this.blockUtils.updateDataIntoRowNode(r.node, s), t.push(r.node));
    }), t;
  }
  insertRowNodes(e, t) {
    const s = this.store.getRowCount() - (this.store.getParentNode().sibling ? 1 : 0), i = t == null && this.isLastRowKnown ? s : t;
    if (i == null || s < i)
      return [];
    const r = {};
    e.forEach((l) => {
      const d = this.getRowId(l);
      d && this.isNodeInCache(d) || (r[d] = l);
    });
    const o = Object.values(r), n = o.length;
    if (n === 0)
      return [];
    const a = this.nodeMap.filter((l) => l.index >= i);
    return a.forEach((l) => this.nodeMap.delete(l)), a.forEach((l) => {
      this.nodeMap.set({
        node: l.node,
        index: l.index + n,
        id: l.id
      });
    }), this.numberOfRows += n, o.map(
      (l, d) => this.createRowAtIndex(i + d, l)
    );
  }
  removeRowNodes(e) {
    const t = [], s = [];
    let i = 0;
    const r = [...e], o = this.getOrderedNodeMap();
    let n = -1;
    for (const a of Object.keys(o)) {
      n += 1;
      const l = o[a], d = r.findIndex((h) => h === l.id);
      if (d !== -1) {
        r.splice(d, 1), this.destroyRowAtIndex(Number(a)), t.push(l.node), i += 1;
        continue;
      }
      if (i === 0)
        continue;
      const c = Number(a);
      n !== c && s.push(l.node), this.nodeMap.delete(l), this.nodeMap.set({
        id: l.id,
        node: l.node,
        index: c - i
      });
    }
    return this.numberOfRows -= this.isLastRowIndexKnown() ? e.length : i, r.length > 0 && s.length > 0 && (s.forEach((a) => a.__needsRefreshWhenVisible = !0), this.lazyBlockLoadingSvc.queueLoadCheck()), t;
  }
  /**
   * Return the block size configured for this cache
   */
  getBlockSize() {
    return this.storeParams.cacheBlockSize || _G;
  }
  /**
   * Get the start index of the loading block for a given index
   */
  getBlockStartIndex(e) {
    const t = this.getBlockSize();
    return e - e % t;
  }
  /**
   * Get the start and end index of a block, given a row store index
   */
  getBlockBounds(e) {
    const t = this.getBlockStartIndex(e), s = this.getBlockSize();
    return [t, t + s];
  }
}, UG = class extends P {
  constructor(e, t, s) {
    super(), this.idSequence = { value: 0 }, this.ssrmParams = e, this.parentRowNode = s, this.storeParams = t, this.level = s.level + 1, this.group = e.rowGroupCols ? this.level < e.rowGroupCols.length : !1, this.leafGroup = e.rowGroupCols ? this.level === e.rowGroupCols.length - 1 : !1, this.info = {};
  }
  wireBeans(e) {
    this.blockUtils = e.ssrmBlockUtils, this.storeUtils = e.ssrmStoreUtils, this.selectionSvc = e.selectionSvc, this.rowGroupColsSvc = e.rowGroupColsSvc;
  }
  postConstruct() {
    let e = 1;
    if (this.level === 0 && (e = this.storeUtils.getServerSideInitialRowCount() ?? 1, this.eventSvc.dispatchEventOnce({
      type: "rowCountReady"
    })), this.cache = this.createManagedBean(new la(this, e, !1, this.storeParams)), !this.gos.get("treeData") && this.group && this.rowGroupColsSvc) {
      const s = this.ssrmParams.rowGroupCols[this.level];
      this.groupField = s.field, this.rowGroupColumn = this.rowGroupColsSvc.columns[this.level];
    }
  }
  destroy() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.destroyBean(this.cache), super.destroy();
  }
  /**
   * Given a server response, ingest the rows outside of the data source lifecycle.
   *
   * @param rowDataParams the server response containing the rows to ingest
   * @param startRow the index to start ingesting rows
   * @param expectedRows the expected number of rows in the response (used to determine if the last row index is known)
   */
  applyRowData(e, t, s) {
    this.cache.onLoadSuccess(t, s, e);
  }
  /**
   * Applies a given transaction to the data set within this store
   *
   * @param transaction an object containing delta instructions determining the changes to apply to this store
   * @returns an object determining the status of this transaction and effected nodes
   */
  applyTransaction(e) {
    var c, h, u;
    const t = Yt(this.gos);
    if (!t)
      return R(206), {
        status: Mt.Cancelled
      };
    const s = this.gos.getCallback("isApplyServerSideTransaction");
    if (s) {
      const p = {
        transaction: e,
        parentNode: this.parentRowNode,
        groupLevelInfo: this.info
      };
      if (!s(p))
        return { status: Mt.Cancelled };
    }
    const i = this.cache.isStoreFullyLoaded();
    let r;
    (c = e.update) != null && c.length && (r = this.cache.updateRowNodes(e.update));
    let o;
    if ((h = e.add) != null && h.length) {
      let p = e.addIndex;
      p != null && p < 0 && (p = void 0), o = this.cache.insertRowNodes(e.add, p);
    }
    let n;
    if ((u = e.remove) != null && u.length) {
      const p = e.remove.map(
        (f) => t({ level: this.level, parentKeys: this.parentRowNode.getRoute() ?? [], data: f })
      ), g = [...new Set(p)];
      n = this.cache.removeRowNodes(g);
    }
    const a = this.gos.get("serverSideEnableClientSideSort"), l = (r == null ? void 0 : r.length) || (o == null ? void 0 : o.length);
    return i && a && l && this.cache.clientSideSortRows(), this.updateSelectionAfterTransaction(r, n), {
      status: Mt.Applied,
      update: r,
      add: o,
      remove: n
    };
  }
  updateSelectionAfterTransaction(e, t) {
    if (!this.selectionSvc)
      return;
    const s = [];
    e == null || e.forEach((i) => {
      i.isSelected() && !i.selectable && s.push(i);
    }), t == null || t.forEach((i) => {
      i.isSelected() && s.push(i);
    }), s.length && this.selectionSvc.setNodesSelected({
      newValue: !1,
      clearSelection: !1,
      nodes: s,
      source: "rowDataChanged"
    });
  }
  /**
   * Clear the display indexes, used for fading rows out when stores are not being destroyed
   */
  clearDisplayIndexes() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.cache.getNodes().forEach((e) => this.blockUtils.clearDisplayIndex(e.node)), this.parentRowNode.sibling && this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling), this.cache.clearDisplayIndexes();
  }
  /**
   * @returns an index representing the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexStart() {
    return this.displayIndexStart;
  }
  /**
   * @returns the index representing one after the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexEnd() {
    return this.displayIndexEnd;
  }
  /**
   * @returns the virtual size of this store
   */
  getRowCount() {
    return this.parentRowNode.sibling ? this.cache.getRowCount() + 1 : this.cache.getRowCount();
  }
  /**
   * Sets the current row count of the store, and whether the last row index is known
   */
  setRowCount(e, t) {
    this.cache.setRowCount(e, t);
  }
  /**
   * Given a display index, returns whether that row is within this store or a child store of this store
   *
   * @param displayIndex the visible index of a row
   * @returns whether or not the row exists within this store
   */
  isDisplayIndexInStore(e) {
    return this.cache.getRowCount() === 0 ? !1 : this.displayIndexStart <= e && e < this.getDisplayIndexEnd();
  }
  /**
   * Recursively sets up the display indexes and top position of every node belonging to this store.
   *
   * Called after a row height changes, or a store updated event.
   *
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t, s) {
    this.displayIndexStart = e.value, this.topPx = t.value;
    const i = this.parentRowNode.level > -1 && Fi(this.gos)({ node: this.parentRowNode });
    i || Xl(this.parentRowNode), i === "top" && (qt(this.parentRowNode, this.beans), this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, e, t, s)), this.cache.setDisplayIndexes(e, t, s), i === "bottom" && (qt(this.parentRowNode, this.beans), this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, e, t, s)), this.displayIndexEnd = e.value, this.heightPx = t.value - this.topPx;
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachStoreDeep(e, t = { value: 0 }) {
    e(this, t.value++), this.cache.getNodes().forEach((s) => {
      const i = s.node.childStore;
      i && i.forEachStoreDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachNodeDeep(e, t = { value: 0 }) {
    this.cache.getNodes().forEach((s) => {
      e(s.node, t.value++);
      const i = s.node.childStore;
      i && i.forEachNodeDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep
   */
  forEachNodeDeepAfterFilterAndSort(e, t = { value: 0 }, s = !1) {
    const i = this.parentRowNode.level > -1 && Fi(this.gos)({ node: this.parentRowNode });
    i === "top" && e(this.parentRowNode.sibling, t.value++);
    const r = this.cache.getOrderedNodeMap();
    for (const o of Object.values(r)) {
      e(o.node, t.value++);
      const n = o.node.childStore;
      n && n.forEachNodeDeepAfterFilterAndSort(e, t, s);
    }
    i === "bottom" && e(this.parentRowNode.sibling, t.value++);
  }
  /**
   * Removes the failed status from all nodes, and marks them as stub to encourage reloading
   */
  retryLoads() {
    this.cache.getNodes().forEach(({ node: e }) => {
      e.failedLoad && (e.failedLoad = !1, e.__needsRefreshWhenVisible = !0, e.stub = !0);
    }), this.forEachChildStoreShallow((e) => e.retryLoads()), this.fireStoreUpdatedEvent();
  }
  /**
   * Given a display index, returns the row at that location.
   *
   * @param displayRowIndex the displayed index within the grid to search for
   * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return
   */
  getRowUsingDisplayIndex(e) {
    return this.parentRowNode.sibling && e === this.parentRowNode.sibling.rowIndex ? this.parentRowNode.sibling : this.cache.getRowByDisplayIndex(e);
  }
  /**
   * Given a display index, returns the row top and height for the row at that index.
   *
   * @param displayIndex the display index of the node
   * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex
   */
  getRowBounds(e) {
    if (!this.isDisplayIndexInStore(e))
      return null;
    const t = this.cache.getNodeCachedByDisplayIndex(e);
    if (t) {
      const a = this.blockUtils.extractRowBounds(t, e);
      if (a)
        return a;
    }
    const { previousNode: s, nextNode: i } = this.cache.getSurroundingNodesByDisplayIndex(e) ?? {};
    if (s) {
      const a = this.blockUtils.extractRowBounds(s.node, e);
      if (a != null)
        return a;
    }
    const r = Ye(this.beans);
    if (i) {
      const a = (i.node.rowIndex - e) * r;
      return {
        rowTop: i.node.rowTop - a,
        rowHeight: r
      };
    }
    const o = this.topPx + this.heightPx, n = (this.getDisplayIndexEnd() - e) * r;
    return {
      rowTop: o - n,
      rowHeight: r
    };
  }
  /**
   * Given a vertical pixel, determines whether this store contains a row at that pixel
   *
   * @param pixel a vertical pixel position from the grid
   * @returns whether that pixel points to a virtual space belonging to this store
   */
  isPixelInRange(e) {
    return e >= this.topPx && e < this.topPx + this.heightPx;
  }
  /**
   * Given a vertical pixel, returns the row existing at that pixel location
   *
   * @param pixel a vertical pixel position from the grid
   * @returns the display index at the given pixel location
   */
  getRowIndexAtPixel(e) {
    if (e < this.topPx)
      return this.getDisplayIndexStart();
    if (e >= this.topPx + this.heightPx)
      return this.getDisplayIndexEnd() - 1;
    if (this.parentRowNode.sibling && e > this.parentRowNode.sibling.rowTop && e < this.parentRowNode.sibling.rowTop + this.parentRowNode.sibling.rowHeight)
      return this.parentRowNode.sibling.rowIndex;
    let t = Number.MAX_SAFE_INTEGER, s = null, i = Number.MAX_SAFE_INTEGER, r = null;
    if (this.cache.getNodes().forEach(({ node: l }) => {
      const d = Math.abs(e - l.rowTop);
      if (l.rowTop < e) {
        d < t && (t = d, s = l);
        return;
      }
      d < i && (i = d, r = l);
    }), s = s, r = r, s) {
      const l = this.blockUtils.getIndexAtPixel(s, e);
      if (l != null)
        return l;
    }
    const o = Ye(this.beans);
    if (r) {
      const l = r.rowTop, d = Math.ceil((l - e) / o);
      return r.rowIndex - d;
    }
    const n = this.topPx + this.heightPx, a = Math.floor((n - e) / o);
    return this.getDisplayIndexEnd() - a;
  }
  /**
   * Given a path of group keys, returns the child store for that group.
   *
   * @param keys the grouping path to the desired store
   * @returns the child store for the given keys, or null if not found
   */
  getChildStore(e) {
    return this.storeUtils.getChildStore(e, this, (t) => {
      const s = this.cache.getNodes().find((i) => i.node.key == t);
      return s ? s.node : null;
    });
  }
  /**
   * Executes a provided callback on each child store belonging to this store
   *
   * @param cb the callback to execute
   */
  forEachChildStoreShallow(e) {
    this.cache.getNodes().forEach(({ node: t }) => {
      t.childStore && e(t.childStore);
    });
  }
  /**
   * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.
   *
   * If a purge refresh occurs, the row count is preserved.
   *
   * @param params a set of properties pertaining to the sort changes
   */
  refreshAfterSort(e) {
    if (this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      const s = this.cache.isStoreFullyLoaded(), i = this.gos.get("serverSideEnableClientSideSort");
      if (!(s && i)) {
        const o = this.cache.getRowCount(), n = this.cache.isLastRowIndexKnown();
        this.destroyBean(this.cache), this.cache = this.createManagedBean(new la(this, o, n, this.storeParams));
        return;
      }
      this.cache.clientSideSortRows();
    }
    this.forEachChildStoreShallow((s) => s.refreshAfterSort(e));
  }
  /**
   * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.
   *
   * If a refresh occurs, the row count is reset.
   *
   * @param params a set of properties pertaining to the filter changes
   */
  refreshAfterFilter(e) {
    if (!this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      this.refreshStore(!0);
      return;
    }
    this.forEachChildStoreShallow((s) => s.refreshAfterFilter(e));
  }
  /**
   * Marks all existing nodes as requiring reloaded, and triggers a load check
   *
   * @param purge whether to remove all nodes and data in favour of stub nodes
   */
  refreshStore(e) {
    if (e) {
      this.destroyBean(this.cache), this.cache = this.createManagedBean(new la(this, 1, !1, this.storeParams)), this.fireStoreUpdatedEvent();
      return;
    }
    this.cache.markNodesForRefresh();
  }
  /**
   * Used for pagination, given a local/store index, returns the display index of that row
   *
   * @param topLevelIndex the store index of a row
   * @returns the display index for the given store index
   */
  getTopLevelRowDisplayedIndex(e) {
    return this.cache.getDisplayIndexFromStoreIndex(e) ?? e;
  }
  /**
   * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known
   *
   * @returns whether the last index of this store is known, or if lazy loading still required
   */
  isLastRowIndexKnown() {
    return this.cache.isLastRowIndexKnown();
  }
  /**
   * Used by the selection service to select a range of nodes
   *
   * @param firstInRange the first node in the range to find
   * @param lastInRange the last node in the range to find
   * @returns a range of nodes between firstInRange and lastInRange inclusive
   */
  getRowNodesInRange(e, t) {
    return this.cache.getNodes().filter(({ node: s }) => s.rowIndex >= e.rowIndex && s.rowIndex <= t.rowIndex).map(({ node: s }) => s);
  }
  /**
   * Mutates a given array to add this stores state, and recursively add all the children store states.
   *
   * @param result a mutable results array
   */
  addStoreStates(e) {
    e.push({
      route: this.parentRowNode.getRoute() ?? [],
      rowCount: this.getRowCount(),
      lastRowIndexKnown: this.isLastRowIndexKnown(),
      info: this.info,
      maxBlocksInCache: this.storeParams.maxBlocksInCache,
      cacheBlockSize: this.storeParams.cacheBlockSize
    }), this.forEachChildStoreShallow((t) => t.addStoreStates(e));
  }
  getIdSequence() {
    return this.idSequence;
  }
  getParentNode() {
    return this.parentRowNode;
  }
  getRowDetails() {
    return {
      field: this.groupField,
      group: this.group,
      leafGroup: this.leafGroup,
      level: this.level,
      parent: this.parentRowNode,
      rowGroupColumn: this.rowGroupColumn
    };
  }
  getSsrmParams() {
    return this.ssrmParams;
  }
  setStoreInfo(e) {
    e && Object.assign(this.info, e);
  }
  // gets called 1) row count changed 2) cache purged
  fireStoreUpdatedEvent() {
    this.eventSvc.dispatchEvent({
      type: "storeUpdated"
    });
  }
  // gets called when row data updated, and no more refreshing needed
  fireRefreshFinishedEvent() {
    this.eventSvc.dispatchEvent({
      type: "storeRefreshed",
      route: this.parentRowNode.getRoute()
    });
  }
  getBlockStates() {
    return this.cache.getBlockStates();
  }
  getStoreBounds() {
    return {
      topPx: this.topPx,
      heightPx: this.heightPx
    };
  }
  getCache() {
    return this.cache;
  }
}, KG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmStoreFactory";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc, this.rowAutoHeight = e.rowAutoHeight;
  }
  createStore(e, t) {
    const s = this.getStoreParams(e, t);
    return new UG(e, s, t);
  }
  getStoreParams(e, t) {
    const s = this.getLevelSpecificParams(t), i = this.getBlockSize(s), r = this.getMaxBlocksInCache(e, s);
    return {
      cacheBlockSize: i,
      maxBlocksInCache: r
    };
  }
  getMaxBlocksInCache(e, t) {
    var r;
    const s = t && t.maxBlocksInCache != null ? t.maxBlocksInCache : this.gos.get("maxBlocksInCache");
    if (s != null && s >= 0) {
      if (e.dynamicRowHeight) {
        R(203);
        return;
      }
      if ((r = this.rowAutoHeight) != null && r.active) {
        R(204);
        return;
      }
      return s;
    }
  }
  getBlockSize(e) {
    const t = e && e.cacheBlockSize != null ? e.cacheBlockSize : this.gos.get("cacheBlockSize");
    return t != null && t > 0 ? t : 100;
  }
  getLevelSpecificParams(e) {
    var r, o;
    const t = this.gos.getCallback("getServerSideGroupLevelParams");
    if (!t)
      return;
    const s = {
      level: e.level + 1,
      parentRowNode: e.level >= 0 ? e : void 0,
      rowGroupColumns: ((r = this.rowGroupColsSvc) == null ? void 0 : r.columns) ?? [],
      pivotColumns: ((o = this.pivotColsSvc) == null ? void 0 : o.columns) ?? [],
      pivotMode: this.colModel.isPivotMode()
    };
    return t(s);
  }
}, $G = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmStoreUtils";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  getChildStore(e, t, s) {
    if (!(e != null && e.length))
      return t;
    const i = e[0], r = s(i);
    if (r) {
      if (e.length === 1 && !r.childStore) {
        const a = this.serverSideRowModel.getParams();
        r.childStore = this.createBean(this.storeFactory.createStore(a, r));
      }
      const o = e.slice(1, e.length), n = r.childStore;
      return n ? n.getChildStore(o) : null;
    }
    return null;
  }
  isServerRefreshNeeded(e, t, s) {
    if (s.valueColChanged || s.secondaryColChanged)
      return !0;
    const i = e.level + 1;
    if (!(i < t.length))
      return !0;
    const n = t[i].id;
    return s.changedColumns.indexOf(n) > -1 ? !0 : this.colModel.getCols().filter((c) => c.getColDef().showRowGroup && s.changedColumns.includes(c.getId())).map((c) => c.getColDef().showRowGroup).some((c) => c === !0 || c === n);
  }
  getServerSideInitialRowCount() {
    return this.gos.get("serverSideInitialRowCount");
  }
  isServerSideSortAllLevels() {
    return this.gos.get("serverSideSortAllLevels") && Te(this.gos);
  }
  isServerSideOnlyRefreshFilteredGroups() {
    return this.gos.get("serverSideOnlyRefreshFilteredGroups") && Te(this.gos);
  }
}, jG = class extends P {
  constructor() {
    super(...arguments), this.beanName = "ssrmTxnManager", this.asyncTransactions = [];
  }
  wireBeans(e) {
    this.valueCache = e.valueCache, this.serverSideRowModel = e.rowModel, this.selectionSvc = e.selectionSvc;
  }
  postConstruct() {
    Te(this.gos);
  }
  applyTransactionAsync(e, t) {
    this.asyncTransactionsTimeout == null && this.scheduleExecuteAsync(), this.asyncTransactions.push({ transaction: e, callback: t });
  }
  scheduleExecuteAsync() {
    const e = this.gos.get("asyncTransactionWaitMillis");
    this.asyncTransactionsTimeout = window.setTimeout(() => {
      this.executeAsyncTransactions();
    }, e);
  }
  executeAsyncTransactions() {
    var r;
    if (!this.asyncTransactions)
      return;
    const e = [], t = [], s = [];
    let i = !1;
    this.asyncTransactions.forEach((o) => {
      let n;
      if (this.serverSideRowModel.executeOnStore(o.transaction.route, (d) => {
        n = d.applyTransaction(o.transaction);
      }) ? n == null && (n = { status: Mt.StoreNotFound }) : n = { status: Mt.StoreNotStarted }, t.push(n), n.status == Mt.StoreLoading) {
        s.push(o);
        return;
      }
      o.callback && e.push(() => o.callback(n)), n.status === Mt.Applied && (i = !0);
    }), e.length > 0 && window.setTimeout(() => {
      e.forEach((o) => o());
    }, 0), this.asyncTransactionsTimeout = void 0, this.asyncTransactions = s, i && ((r = this.valueCache) == null || r.onDataChanged(), this.eventSvc.dispatchEvent({ type: "storeUpdated" })), t.length > 0 && this.eventSvc.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    });
  }
  flushAsyncTransactions() {
    this.asyncTransactionsTimeout != null && clearTimeout(this.asyncTransactionsTimeout), this.executeAsyncTransactions();
  }
  applyTransaction(e) {
    var i;
    let t;
    if (this.serverSideRowModel.executeOnStore(e.route, (r) => {
      t = r.applyTransaction(e);
    }))
      if (t) {
        if ((i = this.valueCache) == null || i.onDataChanged(), t.remove && this.selectionSvc) {
          const r = t.remove.map((o) => o.id);
          this.selectionSvc.deleteSelectionStateFromParent(e.route || [], r);
        }
        return this.eventSvc.dispatchEvent({ type: "storeUpdated" }), t;
      } else
        return { status: Mt.StoreNotFound };
    else return { status: Mt.StoreNotStarted };
  }
}, qG = {
  moduleName: "ServerSideRowModel",
  version: j,
  rowModels: ["serverSide"],
  beans: [
    DG,
    xG,
    $G,
    SG,
    TG,
    jG,
    FG,
    KG,
    RG,
    NG,
    zG,
    HG,
    VG,
    PG
  ],
  dependsOn: [
    te,
    Nl,
    og,
    Rf,
    Df,
    UO,
    KO
  ]
}, YG = {
  moduleName: "ServerSideRowModelApi",
  version: j,
  rowModels: ["serverSide"],
  apiFunctions: {
    getServerSideSelectionState: EG,
    setServerSideSelectionState: MG,
    applyServerSideTransaction: AG,
    applyServerSideTransactionAsync: LG,
    applyServerSideRowData: IG,
    retryServerSideLoads: kG,
    flushServerSideAsyncTransactions: OG,
    refreshServerSide: GG,
    getServerSideGroupLevelState: BG
  },
  dependsOn: [te, ng, ag]
}, XG = (
  /*css*/
  ".ag-sparkline-wrapper{height:100%;left:0;position:absolute;top:0;width:100%}.ag-sparkline-wrapper :where(canvas){position:absolute}"
), da = Symbol("WrappedFunctionMarker"), _c = (e, t) => {
  if (e[da])
    return e;
  const s = (...i) => t(e, ...i);
  return s[da] = da, s;
}, ZG = ["ag-default", "ag-material", "ag-sheets", "ag-polychroma", "ag-vivid"], QG = class extends L {
  constructor() {
    super(
      /* html */
      `<div class="ag-sparkline-wrapper">
            <span data-ref="eSparkline"></span>
        </div>`
    ), this.eSparkline = S;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["chartThemeOverrides", "chartThemes"], (e) => this.refresh(this.params));
  }
  init(e) {
    this.refresh(e);
    const t = Rt(this.beans, this.getGui(), () => this.refresh(e));
    this.addDestroyFunc(() => t());
  }
  getThemeName() {
    return (this.gos.get("chartThemes") || ZG)[0];
  }
  refresh(e) {
    var i, r, o, n, a;
    this.params = e;
    const { clientWidth: t, clientHeight: s } = this.getGui();
    if (!this.sparklineInstance && e && t > 0 && s) {
      this.sparklineOptions = {
        container: this.eSparkline,
        width: t,
        height: s,
        ...e.sparklineOptions,
        data: this.processData(e.value)
      }, (i = this.sparklineOptions.tooltip) != null && i.renderer ? this.wrapTooltipRenderer() : this.sparklineOptions.tooltip = {
        ...this.sparklineOptions.tooltip,
        renderer: (d) => ({ content: this.createDefaultContent(d) })
      };
      const l = (r = this.sparklineOptions) == null ? void 0 : r.theme;
      return this.sparklineOptions.type === "bar" && this.sparklineOptions.itemStyler ? this.wrapItemStyler(this.sparklineOptions) : (a = (n = (o = l == null ? void 0 : l.overrides) == null ? void 0 : o.bar) == null ? void 0 : n.series) != null && a.itemStyler && this.wrapItemStyler(l.overrides.bar.series), this.updateTheme(this.sparklineOptions), this.sparklineInstance = e.createSparkline(this.sparklineOptions), !0;
    } else if (this.sparklineInstance) {
      const l = e == null ? void 0 : e.value;
      return this.sparklineOptions.width = t, this.sparklineOptions.height = s, this.sparklineOptions.data = this.processData(l), this.updateTheme(this.sparklineOptions), this.sparklineInstance.updateDelta(this.sparklineOptions), !0;
    }
    return !1;
  }
  updateTheme(e) {
    const t = this.getThemeName();
    typeof e.theme == "string" || !e.theme ? e.theme = t : e.theme && (e.theme.baseTheme = t);
  }
  processData(e = []) {
    return e.length === 0 ? e : e.filter((t) => t != null);
  }
  createContext() {
    var e, t;
    return {
      data: (e = this.params) == null ? void 0 : e.data,
      cellData: (t = this.params) == null ? void 0 : t.value
    };
  }
  createDefaultContent(e, t) {
    var n;
    const s = t == null ? void 0 : t.title, i = this.sparklineOptions.xKey, r = Array.isArray((n = this.sparklineOptions.data) == null ? void 0 : n[0]);
    return `${!s && (i || r) ? `${e.xValue} ` : ""}${e.yValue}`;
  }
  wrapItemStyler(e) {
    e.itemStyler = _c(e.itemStyler, (t, s) => t({
      ...s,
      context: this.createContext()
    }));
  }
  wrapTooltipRenderer() {
    this.sparklineOptions.tooltip = {
      ...this.sparklineOptions.tooltip,
      renderer: _c(this.sparklineOptions.tooltip.renderer, (e, t) => {
        const s = e({
          ...t,
          context: this.createContext()
        });
        return typeof s == "string" ? s : {
          content: this.createDefaultContent(t, s),
          ...s
        };
      })
    };
  }
  destroy() {
    var e;
    super.destroy(), (e = this.sparklineInstance) == null || e.destroy();
  }
}, Uc = "Sparklines", JG = {
  moduleName: Uc,
  version: j,
  dependsOn: [te],
  validate: () => ({
    isValid: !1,
    message: Nh(258)
  }),
  with: (e) => (e.setup(), {
    moduleName: Uc,
    version: j,
    dependsOn: [te],
    css: [XG],
    userComponents: {
      agSparklineCellRenderer: {
        classImp: QG,
        /** Default params for provided components */
        params: { createSparkline: e.createSparkline }
      }
    },
    validate: () => ({ isValid: !0 })
  })
}, eB = class extends P {
  constructor(e) {
    super(), this.beanName = "agChartsExports", this.isEnterprise = !1, this.create = e.create, this._Theme = e._Theme, this._Scene = e._Scene, this.isEnterprise = e.isEnterprise, this._Util = e._Util;
  }
};
function Kc(e) {
  return e.chart != null ? e.chart : e;
}
function Gs(e, t, s) {
  if (e == null)
    return s;
  const i = t.split(".");
  let r = e;
  for (; i.length > 1; )
    if (r = r[i.shift()], r == null)
      return s;
  const o = r[i[0]];
  return o ?? s;
}
function tB(e, t, s) {
  if (e == null)
    return;
  const i = t.split(".");
  let r = e;
  i.forEach((o, n) => {
    r[o] || (r[o] = {}), n < i.length - 1 && (r = r[o]);
  }), r[i[i.length - 1]] = s;
}
var sB = {
  column: "bar",
  groupedColumn: "bar",
  stackedColumn: "bar",
  normalizedColumn: "bar",
  bar: "bar",
  groupedBar: "bar",
  stackedBar: "bar",
  normalizedBar: "bar",
  line: "line",
  stackedLine: "line",
  normalizedLine: "line",
  scatter: "scatter",
  bubble: "bubble",
  pie: "pie",
  donut: "donut",
  doughnut: "donut",
  area: "area",
  stackedArea: "area",
  normalizedArea: "area",
  histogram: "histogram",
  radarLine: "radar-line",
  radarArea: "radar-area",
  nightingale: "nightingale",
  radialColumn: "radial-column",
  radialBar: "radial-bar",
  sunburst: "sunburst",
  rangeBar: "range-bar",
  rangeArea: "range-area",
  boxPlot: "box-plot",
  treemap: "treemap",
  heatmap: "heatmap",
  waterfall: "waterfall"
}, iB = /* @__PURE__ */ new Set(["columnLineCombo", "areaColumnCombo", "customCombo"]), rB = ["grouped", "stacked", "normalized"], Ef = {
  area: {
    isCartesian: !0,
    canInvert: !0
  },
  bar: {
    isCartesian: !0,
    canInvert: !0
  },
  histogram: {
    isCartesian: !0
  },
  line: {
    isCartesian: !0,
    canInvert: !0
  },
  pie: {
    isPie: !0
  },
  donut: {
    isPie: !0,
    canInvert: !0
  },
  scatter: {
    isCartesian: !0
  },
  bubble: {
    isCartesian: !0
  },
  "radial-column": {
    isPolar: !0,
    isEnterprise: !0,
    isRadial: !0,
    canInvert: !0
  },
  "radial-bar": {
    isPolar: !0,
    isEnterprise: !0,
    isRadial: !0,
    canInvert: !0
  },
  "radar-line": {
    isPolar: !0,
    isEnterprise: !0,
    canInvert: !0
  },
  "radar-area": {
    isPolar: !0,
    isEnterprise: !0,
    canInvert: !0
  },
  nightingale: {
    isPolar: !0,
    isEnterprise: !0,
    canInvert: !0
  },
  "range-bar": {
    isCartesian: !0,
    isEnterprise: !0,
    canSwitchDirection: !0
  },
  "range-area": {
    isCartesian: !0,
    isEnterprise: !0
  },
  "box-plot": {
    isCartesian: !0,
    isEnterprise: !0,
    canSwitchDirection: !0
  },
  treemap: {
    isEnterprise: !0,
    isHierarchical: !0
  },
  sunburst: {
    isEnterprise: !0,
    isHierarchical: !0
  },
  heatmap: {
    isCartesian: !0,
    isEnterprise: !0
  },
  waterfall: {
    isCartesian: !0,
    isEnterprise: !0,
    canSwitchDirection: !0
  }
};
function oB(e) {
  return !!Ef[e];
}
function Jl(e) {
  return iB.has(e);
}
function Es(e, t) {
  var s;
  return !!((s = Ef[e]) != null && s[t]);
}
function nB(e) {
  return Es(ne(e), "isEnterprise");
}
var aB = /* @__PURE__ */ new Set(["stackedColumn", "normalizedColumn", "stackedBar", "normalizedBar"]);
function lB(e) {
  return aB.has(e);
}
function gs(e) {
  return Es(e, "isCartesian");
}
function ja(e) {
  return Es(e, "isPolar");
}
function dB(e) {
  return Es(e, "isRadial");
}
function Ns(e) {
  return Es(e, "isHierarchical");
}
function yr(e) {
  return e === "doughnut" ? "donut" : e;
}
function Mf(e) {
  return sB[e];
}
function ne(e) {
  return Mf(e) ?? "line";
}
function Af(e) {
  return Es(e, "isPie");
}
function cB(e) {
  return e === "pie" || e === "waterfall" || e === "histogram";
}
function qa(e) {
  return Ns(ne(e)) ? void 0 : 1;
}
function Bo(e) {
  return Ns(ne(e)) ? 2 : cB(e) ? 1 : void 0;
}
function If(e) {
  return !Jl(e) && Es(ne(e), "canInvert");
}
function hB(e) {
  return Es(ne(e), "canSwitchDirection");
}
function ed(e) {
  switch (e) {
    case "groupedColumn":
    case "stackedColumn":
    case "normalizedColumn":
    case "groupedBar":
    case "stackedBar":
    case "normalizedBar":
    case "stackedLine":
    case "normalizedLine":
    case "stackedArea":
    case "normalizedArea":
      return `${e}Full`;
    case "doughnut":
      return "donut";
    case "areaColumnCombo":
      return "AreaColumnCombo";
    default:
      return e;
  }
}
var Lf = ["number", "category", "grouped-category", "log", "time"];
function uB(e) {
  switch (e) {
    case "bar":
    case "stackedBar":
    case "normalizedBar":
      return ["number", "category"];
    case "groupedBar":
      return ["number", "grouped-category"];
    case "column":
    case "stackedColumn":
    case "normalizedColumn":
    case "line":
    case "stackedLine":
    case "normalizedLine":
    case "area":
    case "stackedArea":
    case "normalizedArea":
    case "histogram":
      return ["category", "number"];
    case "groupedColumn":
      return ["grouped-category", "number"];
    case "scatter":
    case "bubble":
      return ["number", "number"];
    default:
      return;
  }
}
function pB(e, t, s, i, r) {
  const { chartOptionsToRestore: o, chartPaletteToRestore: n, chartThemeToRestore: a, agChartsExports: l } = e, d = wB(e), c = td(d, l._Theme), h = c ? { baseTheme: d } : kf(e, d) ?? {}, u = e.getGridOptionsChartThemeOverrides(), p = e.apiChartThemeOverrides, g = ne(e.chartType), f = e.crossFiltering ? fB(t, e, g) : void 0, v = [
    c ? CB(e, s, (() => {
      const b = (y) => y ? Object.keys(y).some((F) => Gs(y[F], "title.enabled", !1)) : !1;
      return b(u) || b(p);
    })()) : void 0,
    vB(),
    i,
    f,
    u,
    p,
    { ...o ?? {} },
    r
  ].filter((b) => !!b).reduce(
    (b, y) => ({
      baseTheme: b,
      overrides: y
    }),
    h
  );
  if (n && d === a) {
    const b = e.agChartsExports._Theme.getChartTheme(h).palette;
    gB(n, b) || (v.palette = n);
  }
  return v;
}
function gB(e, t) {
  const s = (i, r) => i === r ? !0 : (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) ? !1 : (i == null ? void 0 : i.every((o, n) => o === (r == null ? void 0 : r[n]))) ?? !1;
  return s(e.fills, t.fills) && s(e.strokes, t.strokes);
}
function td(e, t) {
  return Object.keys(t.themes).includes(e);
}
function fB(e, t, s) {
  const i = {
    listeners: {
      legendItemClick: (r) => {
        const o = e.getChart(), n = [r.seriesId, `${r.seriesId}-filtered-out`];
        o.series.filter((a) => n.includes(a.id)).forEach((a) => a.toggleSeriesItem(void 0, "category", r.itemId, void 0));
      }
    }
  };
  return {
    [s]: {
      tooltip: {
        delay: 500
      },
      legend: i,
      listeners: {
        click: (r) => t.crossFilterCallback(r, !0)
      }
    }
  };
}
var mB = Lf.reduce(
  (e, t) => ({ ...e, [t]: { title: { _enabledFromTheme: !0 } } }),
  {}
);
function CB(e, t, s) {
  const i = e.getExtraPaddingDirections();
  return {
    common: {
      ...t ? { animation: { duration: 500 } } : void 0,
      axes: mB,
      padding: {
        // don't add extra padding when a title is present!
        top: !s && i.includes("top") ? 40 : 20,
        right: i.includes("right") ? 30 : 20,
        bottom: i.includes("bottom") ? 40 : 20,
        left: i.includes("left") ? 30 : 20
      },
      suppressFieldDotNotation: !0
    }
  };
}
function vB() {
  return {
    pie: {
      series: {
        title: { _enabledFromTheme: !0 },
        calloutLabel: { _enabledFromTheme: !0 },
        sectorLabel: {
          enabled: !1,
          _enabledFromTheme: !0
        }
      }
    },
    donut: {
      series: {
        title: { _enabledFromTheme: !0 },
        calloutLabel: { _enabledFromTheme: !0 },
        sectorLabel: {
          enabled: !1,
          _enabledFromTheme: !0
        }
      }
    }
  };
}
function wB(e) {
  let t = e.getChartThemeName();
  const s = e.getChartThemes();
  return s.includes(t) || (t = s[0]), t;
}
function kf(e, t) {
  const { customChartThemes: s } = e, i = s && s[t];
  return i || R(140, { name: t }), i;
}
var Ir = class {
  constructor(e) {
    this.chartProxyParams = e, this.clearThemeOverrides = !1, this.agChartsExports = e.agChartsExports, this.chart = e.chartInstance, this.chartType = e.chartType, this.crossFiltering = e.crossFiltering, this.crossFilterCallback = e.crossFilterCallback, this.standaloneChartType = ne(this.chartType), this.chart == null ? this.chart = e.agChartsExports.create(this.getCommonChartOptions()) : this.clearThemeOverrides = !0;
  }
  crossFilteringReset() {
  }
  update(e) {
    this.getChartRef().update(this.getUpdateOptions(e, this.getCommonChartOptions(e.updatedOverrides)));
  }
  updateThemeOverrides(e) {
    this.getChartRef().updateDelta({ theme: { overrides: e } });
  }
  getChart() {
    return Kc(this.chart);
  }
  getChartRef() {
    return this.chart;
  }
  downloadChart(e, t, s) {
    const { chart: i } = this, r = Kc(i), o = t || (r.title ? r.title.text : "chart"), { width: n, height: a } = e || {};
    i.download({ width: n, height: a, fileName: o, fileFormat: s });
  }
  getChartImageDataURL(e) {
    return this.getChart().getCanvasDataURL(e);
  }
  getChartOptions() {
    return this.chart.getOptions();
  }
  getChartThemeOverrides() {
    return this.getChartOptions().theme.overrides ?? {};
  }
  getChartPalette() {
    return this.agChartsExports._Theme.getChartTheme(this.getChartOptions().theme).palette;
  }
  setPaired(e) {
    const t = ne(this.chartProxyParams.chartType);
    this.chart.updateDelta({ theme: { overrides: { [t]: { paired: e } } } });
  }
  isPaired() {
    const e = ne(this.chartProxyParams.chartType);
    return Gs(this.getChartThemeOverrides(), `${e}.paired`, !0);
  }
  lookupCustomChartTheme(e) {
    return kf(this.chartProxyParams, e);
  }
  getSeriesGroupType() {
  }
  transformCategoryData(e, t) {
    return e.map((s, i) => {
      const r = s[t], o = r && r.toString ? r.toString() : "", n = { ...s };
      return n[t] = { id: i, value: r, toString: () => o }, n;
    });
  }
  getCommonChartOptions(e) {
    var o;
    const t = this.clearThemeOverrides ? {} : ((o = this.chart) == null ? void 0 : o.getOptions()) ?? {}, s = this.chart != null ? this.getActiveFormattingPanelOverrides() : void 0;
    this.clearThemeOverrides = !1;
    const i = pB(
      this.chartProxyParams,
      this,
      this.agChartsExports.isEnterprise,
      this.getChartThemeDefaults(),
      e ?? s
    ), r = {
      ...t,
      mode: "integrated"
    };
    return r.theme = i, r.container = this.chartProxyParams.parentElement, r;
  }
  getChartThemeDefaults() {
    const e = this.getSeriesChartThemeDefaults(), t = e ? {
      [this.standaloneChartType]: e
    } : {}, s = {
      enabled: !0,
      snap: !0,
      label: {
        enabled: !1
      }
    }, i = this.agChartsExports.isEnterprise ? {
      zoom: {
        enabled: !0
      },
      animation: {
        enabled: !0,
        duration: 500
      },
      axes: {
        number: { crosshair: s },
        category: { crosshair: s },
        log: { crosshair: s },
        time: { crosshair: s }
      }
    } : {};
    return i.minHeight = 0, i.minWidth = 0, i.navigator = {
      enabled: !1
    }, {
      common: i,
      ...t
    };
  }
  getSeriesChartThemeDefaults() {
  }
  getActiveFormattingPanelOverrides() {
    var t;
    if (this.clearThemeOverrides)
      return {};
    const e = (t = this.chart) == null ? void 0 : t.getOptions().theme;
    return (e == null ? void 0 : e.overrides) ?? {};
  }
  destroy({ keepChartInstance: e = !1 } = {}) {
    if (e)
      return this.chart.resetAnimations(), this.chart;
    this.destroyChart();
  }
  destroyChart() {
    this.chart && (this.chart.destroy(), this.chart = void 0);
  }
}, Ms = class extends Ir {
  constructor(e) {
    super(e), this.crossFilteringAllPoints = /* @__PURE__ */ new Set(), this.crossFilteringSelectedPoints = [];
  }
  getUpdateOptions(e, t) {
    const s = this.getAxes(e, t);
    return {
      ...t,
      data: this.getData(e, s),
      axes: s,
      series: this.getSeries(e)
    };
  }
  getData(e, t) {
    const s = ["area", "line"].includes(this.standaloneChartType);
    return this.crossFiltering && s ? this.getCrossFilterData(e) : this.getDataTransformedData(e, t);
  }
  getDataTransformedData(e, t) {
    const s = t[0].type, { categories: i, data: r } = e, [o] = i;
    switch (s) {
      case "category":
        return this.transformCategoryData(r, o.id);
      case "time":
        return this.transformTimeData(r, o.id);
      default:
        return r;
    }
  }
  getXAxisType(e) {
    return e.grouping ? "grouped-category" : this.isXAxisOfType(e, "time", (t) => t instanceof Date) ? "time" : this.isXAxisOfType(e, "number") ? "number" : "category";
  }
  isXAxisOfType(e, t, s) {
    const [i] = e.categories;
    if (i != null && i.chartDataType)
      return i.chartDataType === t;
    if (!s)
      return !1;
    const r = e.data[0];
    return r ? s(r[i.id]) : !1;
  }
  transformTimeData(e, t) {
    var i;
    return ((i = e[0]) == null ? void 0 : i[t]) instanceof Date ? e : e.map((r) => {
      const o = r[t];
      return typeof o == "string" ? {
        ...r,
        [t]: new Date(o)
      } : r;
    });
  }
  crossFilteringReset() {
    this.crossFilteringSelectedPoints = [], this.crossFilteringAllPoints.clear();
  }
  crossFilteringPointSelected(e) {
    return this.crossFilteringSelectedPoints.length == 0 || this.crossFilteringSelectedPoints.includes(e);
  }
  crossFilteringDeselectedPoints() {
    return this.crossFilteringSelectedPoints.length > 0 && this.crossFilteringAllPoints.size !== this.crossFilteringSelectedPoints.length;
  }
  extractLineAreaCrossFilterSeries(e, t) {
    const [s] = t.categories, i = (r) => this.standaloneChartType === "area" ? t.getCrossFilteringContext().lastSelectedChartId === t.chartId ? r + "-total" : r : r + "-total";
    return e.map((r) => (r.yKey = i(r.yKey), r.listeners = {
      nodeClick: (o) => {
        const n = o.datum[r.xKey], a = o.event.metaKey || o.event.ctrlKey;
        this.crossFilteringAddSelectedPoint(a, n), this.crossFilterCallback(o);
      }
    }, r.marker = {
      itemStyler: (o) => {
        const n = o.datum[s.id];
        return {
          fill: o.highlighted ? "yellow" : o.fill,
          size: o.highlighted ? 14 : this.crossFilteringPointSelected(n) ? 8 : 0
        };
      }
    }, this.standaloneChartType === "area" && (r.fillOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1), this.standaloneChartType === "line" && (r.strokeOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1), r));
  }
  getCrossFilterData(e) {
    this.crossFilteringAllPoints.clear();
    const [t] = e.categories, s = e.fields[0].colId, i = `${s}-filtered-out`, r = e.getCrossFilteringContext().lastSelectedChartId;
    return e.data.map((o) => {
      const n = o[t.id];
      this.crossFilteringAllPoints.add(n);
      const a = this.crossFilteringPointSelected(n);
      return this.standaloneChartType === "area" && r === e.chartId && (o[`${s}-total`] = a ? o[s] : o[s] + o[i]), this.standaloneChartType === "line" && (o[`${s}-total`] = a ? o[s] : o[s] + o[i]), o;
    });
  }
  crossFilteringAddSelectedPoint(e, t) {
    e ? this.crossFilteringSelectedPoints.push(t) : this.crossFilteringSelectedPoints = [t];
  }
  isHorizontal(e) {
    const t = this.standaloneChartType;
    if (t !== "waterfall" && t !== "box-plot" && t !== "range-bar")
      return !1;
    const s = e.theme, i = (r) => {
      var n, a, l;
      const o = (l = (a = (n = r == null ? void 0 : r.overrides) == null ? void 0 : n[t]) == null ? void 0 : a.series) == null ? void 0 : l.direction;
      return o != null ? o === "horizontal" : typeof (r == null ? void 0 : r.baseTheme) == "object" ? i(r.baseTheme) : !1;
    };
    return i(s);
  }
}, yB = class extends Ms {
  constructor(e) {
    super(e);
  }
  getSeries(e) {
    const t = e.fields[0];
    return [
      {
        type: this.standaloneChartType,
        xKey: t.colId,
        xName: t.displayName,
        yName: this.chartProxyParams.translate("histogramFrequency"),
        areaPlot: !1
        // only constant width is supported via integrated charts
      }
    ];
  }
  getAxes(e) {
    return [
      {
        type: "number",
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
  }
}, bB = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e, t) {
    return [
      {
        type: this.getXAxisType(e),
        position: this.isHorizontal(t) ? "left" : "bottom"
      },
      {
        type: "number",
        position: this.isHorizontal(t) ? "bottom" : "left"
      }
    ];
  }
  getSeries(e) {
    const [t] = e.categories, [s] = e.fields;
    return [{
      type: this.standaloneChartType,
      xKey: t.id,
      xName: t.name,
      yKey: s.colId,
      yName: s.displayName ?? void 0
    }];
  }
}, no = "AG-GRID-DEFAULT-LABEL-KEY";
function SB(e, t) {
  const s = Of(e, i, r);
  return sd(s);
  function i(n) {
    return t.length;
  }
  function r(n, a) {
    const l = t[a], d = n[l];
    return o(d);
  }
  function o(n) {
    return n == null ? null : String(n);
  }
}
function xB(e, t) {
  const s = Of(e, i, r);
  return sd(s);
  function i(o) {
    var n;
    return ((n = t(o)) == null ? void 0 : n.length) ?? 0;
  }
  function r(o, n) {
    const a = t(o);
    if (!a)
      return null;
    const l = a.length - 1 - n;
    return a[l];
  }
}
function sd(e, t = null, s) {
  const { depth: i, rootValues: r, value: o, children: n } = e;
  if (r)
    return r.map((l) => ({ [no]: t, ...l }));
  if (i === 0)
    return [{ [no]: t, ...o }];
  const a = [];
  for (const [l, d] of n.entries())
    a.push(...sd(d, l, !0));
  return s ? [
    {
      [no]: t,
      children: a,
      ...o ?? {}
    }
  ] : a;
}
function Of(e, t, s) {
  const i = { depth: 0, children: /* @__PURE__ */ new Map() };
  return e.forEach((o) => {
    const n = t(o);
    r(o, n, s, 0, i);
  }), i;
  function r(o, n, a, l, d) {
    if (l === n)
      return l === 0 ? (d.rootValues || (d.rootValues = []), d.rootValues.push(o)) : d.value = o, d;
    {
      const c = a(o, l), h = d.children.get(c), u = r(
        o,
        n,
        a,
        l + 1,
        h || { depth: 0, children: /* @__PURE__ */ new Map() }
      );
      return d.children.set(c, u), d.depth = Math.max(1 + u.depth, d.depth), d;
    }
  }
}
var FB = class extends Ir {
  constructor(e) {
    super(e);
  }
  getUpdateOptions(e, t) {
    const { fields: s } = e, [i, r] = s;
    return {
      ...t,
      series: this.getSeries(i, r),
      data: this.getData(e, i, r)
    };
  }
  getSeriesChartThemeDefaults() {
    return {
      gradientLegend: {
        gradient: {
          preferredLength: 200
        }
      }
    };
  }
  getSeries(e, t) {
    return [
      {
        type: this.standaloneChartType,
        labelKey: no,
        // Size and color fields are inferred from the range data
        sizeKey: e == null ? void 0 : e.colId,
        sizeName: (e == null ? void 0 : e.displayName) ?? void 0,
        colorKey: t == null ? void 0 : t.colId,
        colorName: (t == null ? void 0 : t.displayName) ?? void 0
      }
    ];
  }
  getData(e, t, s) {
    const { categories: i, data: r, groupData: o, grouping: n } = e;
    if (n) {
      const a = s ? r.concat(
        (o == null ? void 0 : o.map((l) => {
          const d = { ...l };
          return delete d[t.colId], d;
        })) ?? []
      ) : r;
      return xB(a, (l) => {
        var d;
        return ((d = l[Ss]) == null ? void 0 : d.labels) ?? null;
      });
    } else {
      const a = i.map(({ id: l }) => l);
      return SB(r, a);
    }
  }
}, RB = class extends Ir {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = this.standaloneChartType === "radial-bar";
    return [
      { type: t ? "angle-number" : "angle-category" },
      { type: t ? "radius-category" : "radius-number" }
    ];
  }
  getSeries(e) {
    const { fields: t, categories: s, seriesGroupType: i } = e, [r] = s, o = this.standaloneChartType === "radial-bar", n = this.getSeriesGroupTypeOptions(i);
    return t.map((a) => ({
      type: this.standaloneChartType,
      angleKey: o ? a.colId : r.id,
      angleName: o ? a.displayName ?? void 0 : r.name,
      radiusKey: o ? r.id : a.colId,
      radiusName: o ? r.name : a.displayName ?? void 0,
      ...n
    }));
  }
  getSeriesGroupType() {
    var i, r;
    const e = this.standaloneChartType;
    if (!["nightingale", "radial-bar", "radial-column"].includes(e))
      return;
    const t = (r = (i = this.getChart().series) == null ? void 0 : i[0]) == null ? void 0 : r.properties.toJson(), s = () => t.normalizedTo ? "normalized" : "stacked";
    return e === "nightingale" ? t.grouped ? "grouped" : s() : t.stacked ? s() : "grouped";
  }
  getUpdateOptions(e, t) {
    const s = this.getAxes(e);
    return {
      ...t,
      data: this.getData(e, s),
      axes: s,
      series: this.getSeries(e)
    };
  }
  getData(e, t) {
    if (t.some((i) => i.type === "angle-category" || i.type === "radius-category")) {
      const [i] = e.categories;
      return this.transformCategoryData(e.data, i.id);
    } else
      return e.data;
  }
  getSeriesGroupTypeOptions(e) {
    return e ? {
      grouped: e === "grouped" || void 0,
      stacked: e !== "grouped" || void 0,
      normalizedTo: e === "normalized" ? 100 : void 0
    } : {};
  }
};
function PB(e, t) {
  return e.reduce((s, i, r, o) => s.concat(t(i, r, o)), new Array());
}
var TB = "AG-GRID-DEFAULT-HEATMAP-CATEGORY-KEY", DB = "AG-GRID-DEFAULT-HEATMAP-SERIES-KEY", EB = "AG-GRID-DEFAULT-HEATMAP-VALUE-KEY", MB = class extends Ir {
  constructor(e) {
    super(e);
  }
  getUpdateOptions(e, t) {
    const s = DB, i = EB, r = TB;
    return {
      ...t,
      series: this.getSeries(e, s, i, r),
      data: this.getData(e, s, i, r)
    };
  }
  getSeries(e, t, s, i) {
    const [r] = e.categories;
    return [
      {
        type: this.standaloneChartType,
        // The axis keys reference synthetic fields based on the category values and series column names
        yKey: i,
        xKey: t,
        // The color key references a synthetic field based on the series column value for a specific cell
        colorKey: s,
        yName: r.name,
        // We don't know how to label the 'x' series, as it is a synthetic series created from the set of all input columns
        // In future releases we may want to consider inferring the series label from column groupings etc
        xName: void 0,
        colorName: void 0
      }
    ];
  }
  getData(e, t, s, i) {
    const [r] = e.categories;
    return PB(e.data, (o, n) => {
      const a = o[r.id], l = a == null ? "" : String(a), d = { id: n, value: a, toString: () => l };
      return e.fields.map(({ colId: c, displayName: h }) => ({
        ...o,
        [t]: h,
        [s]: o[c],
        [i]: d
      }));
    });
  }
  getSeriesChartThemeDefaults() {
    return {
      gradientLegend: {
        gradient: {
          preferredLength: 200
        }
      },
      series: {
        tooltip: {
          renderer: AB
        }
      }
    };
  }
};
function AB(e) {
  const { xKey: t, yKey: s, colorKey: i, yName: r, datum: o } = e;
  return {
    title: "",
    data: [
      { label: r, value: o[s] },
      { label: o[t], value: i && o[i] }
    ].map(({ label: a, value: l }) => ({ label: String(a), value: String(l) }))
  };
}
var IB = class extends P {
  wireBeans(e) {
    this.sortSvc = e.sortSvc, this.gridRowModel = e.rowModel, this.colModel = e.colModel, this.valueSvc = e.valueSvc, this.pivotResultCols = e.pivotResultCols, this.rowNodeSorter = e.rowNodeSorter, this.aggStage = e.aggStage;
  }
  getData(e) {
    if (e.crossFiltering) {
      if (e.grouping)
        return R(141), { chartData: [], colNames: {} };
      if (!J(this.gos))
        return R(142), { chartData: [], colNames: {} };
    }
    Te(this.gos) && e.pivoting && this.updatePivotKeysForSSRM();
    const s = this.extractRowsFromGridRowModel(e);
    return s.chartData = this.aggregateRowsByDimension(e, s.chartData), s;
  }
  extractRowsFromGridRowModel(e) {
    const { crossFiltering: t, startRow: s, endRow: i, valueCols: r, dimensionCols: o, grouping: n } = e;
    let a = [];
    const l = {}, d = {}, c = {};
    let h = {}, u = [], p;
    if (t)
      h = this.getFilteredRowNodes(), u = this.getAllRowNodes(), p = u.length;
    else {
      const m = this.gridRowModel.getRowCount() - 1;
      s === i && s === 0 && o.length === 0 && r.length === 0 ? p = 0 : p = (i >= 0 ? Math.min(i, m) : m) - s + 1;
    }
    p > 0 && r.forEach((m) => {
      let C = [];
      const v = m.getColDef().pivotKeys;
      v && (C = v.slice());
      const b = m.getColDef().headerName;
      b && C.push(b), C.length > 0 && (l[m.getId()] = C);
    });
    let g = 0;
    for (let m = 0; m < p; m++) {
      const C = t ? u[m] : this.gridRowModel.getRow(m + s);
      if (C.footer || C.detail) {
        g++;
        continue;
      }
      const v = {};
      o.forEach((b) => {
        const y = b.colId, F = this.colModel.getCol(y);
        if (F) {
          const D = this.valueSvc.getValue(F, C);
          if (n) {
            const x = D != null && D.toString ? String(D.toString()) : "", T = this.getGroupLabels(C, x);
            v[y] = T.slice().reverse(), C.group && (d[T.toString()] = m - g);
            const I = T.slice(1, T.length).toString();
            I && (c[I] = d[I]);
          } else
            v[y] = D;
        } else
          v[Vt] = m + 1;
      }), r.forEach((b) => {
        const y = b.getColId();
        if (t) {
          const F = y + "-filtered-out", D = this.valueSvc.getValue(b, C), x = D != null && typeof D.toNumber == "function" ? D.toNumber() : D;
          h[C.id] ? (v[y] = x, v[F] = e.aggFunc || e.isScatter ? void 0 : 0) : (v[y] = e.aggFunc || e.isScatter ? void 0 : 0, v[F] = x);
        } else {
          let F = this.valueSvc.getValue(b, C);
          F && Object.prototype.hasOwnProperty.call(F, "toString") && (F = parseFloat(F.toString())), v[y] = F != null && typeof F.toNumber == "function" ? F.toNumber() : F;
        }
      }), a.push(v);
    }
    let f;
    if (n) {
      const m = Object.values(c), C = a;
      a = [], f = [];
      for (let v = 0; v < C.length; v++)
        (m.includes(v) ? f : a).push(C[v]);
    }
    return { chartData: a, colNames: l, groupChartData: f };
  }
  aggregateRowsByDimension(e, t) {
    const s = e.dimensionCols;
    if (!e.aggFunc || s.length === 0)
      return t;
    const i = V(s), r = i && i.colId, o = {}, n = [];
    if (t.forEach((a) => {
      let l = o;
      s.forEach((d) => {
        const c = d.colId, h = a[c];
        if (c === r) {
          let u = l[h];
          u || (u = { __children: [] }, s.forEach((p) => {
            const g = p.colId;
            u[g] = a[g];
          }), l[h] = u, n.push(u)), u.__children.push(a);
        } else
          l[h] || (l[h] = {}), l = l[h];
      });
    }), this.gos.assertModuleRegistered("SharedRowGrouping", 1)) {
      const a = this.aggStage;
      n.forEach(
        (l) => e.valueCols.forEach((d) => {
          if (e.crossFiltering)
            e.valueCols.forEach((c) => {
              const h = c.getColId(), u = l.__children.filter((C) => typeof C[h] < "u").map((C) => C[h]), p = a.aggregateValues(u, e.aggFunc);
              l[c.getId()] = p && typeof p.value < "u" ? p.value : p;
              const g = `${h}-filtered-out`, f = l.__children.filter((C) => typeof C[g] < "u").map((C) => C[g]), m = a.aggregateValues(f, e.aggFunc);
              l[g] = m && typeof m.value < "u" ? m.value : m;
            });
          else {
            const c = l.__children.map((u) => u[d.getId()]), h = a.aggregateValues(c, e.aggFunc);
            l[d.getId()] = h && typeof h.value < "u" ? h.value : h;
          }
        })
      );
    }
    return n;
  }
  updatePivotKeysForSSRM() {
    var s, i;
    const e = (i = (s = this.pivotResultCols) == null ? void 0 : s.getPivotResultCols()) == null ? void 0 : i.list;
    if (!e)
      return;
    const t = this.extractPivotKeySeparator(e);
    e.forEach((r) => {
      if (t === "")
        r.getColDef().pivotKeys = [];
      else {
        const o = r.getColId().split(t);
        r.getColDef().pivotKeys = o.slice(0, o.length - 1);
      }
    });
  }
  extractPivotKeySeparator(e) {
    if (e.length === 0)
      return "";
    const t = (i, r) => {
      const o = i.getGroupId();
      return i.getParent() ? t(i.getParent(), o) : r.split(o)[1][0];
    }, s = e[0];
    return s.getParent() == null ? "" : t(s.getParent(), s.getColId());
  }
  getGroupLabels(e, t) {
    const s = [t];
    for (; e && e.level !== 0; )
      e = e.parent, e && s.push(e.key);
    return s;
  }
  getFilteredRowNodes() {
    const e = {};
    return this.gridRowModel.forEachNodeAfterFilterAndSort((t) => {
      e[t.id] = t;
    }), e;
  }
  getAllRowNodes() {
    const e = [];
    return this.gridRowModel.forEachNode((t) => {
      e.push(t);
    }), this.sortRowNodes(e);
  }
  sortRowNodes(e) {
    var s;
    const t = (s = this.sortSvc) == null ? void 0 : s.getSortOptions();
    return !t || t.length == 0 || !this.rowNodeSorter ? e : this.rowNodeSorter.doFullSort(e, t);
  }
}, LB = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartColSvc", this.valueColsWithoutSeriesType = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.colNames = e.colNames, this.valueSvc = e.valueSvc;
  }
  postConstruct() {
    const e = () => this.valueColsWithoutSeriesType.clear();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e
    });
  }
  getColumn(e) {
    return this.colModel.getColDefCol(e);
  }
  getAllDisplayedColumns() {
    return this.beans.visibleCols.allCols;
  }
  getColDisplayName(e, t) {
    const s = "chart", i = this.colNames.getDisplayNameForColumn(e, s);
    if (t) {
      const r = [i], o = (n) => {
        if (!n)
          return;
        const a = this.colNames.getDisplayNameForColumnGroup(n, s);
        a != null && a.length && (r.unshift(a), o(n.getParent()));
      };
      return o(e.getParent()), r.join(" - ");
    }
    return i;
  }
  getRowGroupColumns() {
    var e;
    return ((e = this.beans.rowGroupColsSvc) == null ? void 0 : e.columns) ?? [];
  }
  getGroupDisplayColumns() {
    var e;
    return ((e = this.beans.showRowGroupCols) == null ? void 0 : e.getShowRowGroupCols()) ?? [];
  }
  isPivotMode() {
    return this.colModel.isPivotMode();
  }
  isPivotActive() {
    return this.colModel.isPivotActive();
  }
  getChartColumns() {
    const e = this.colModel.getCols(), t = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
    return e.forEach((i) => {
      const r = i.getColDef(), o = r.chartDataType;
      if (o)
        switch (o) {
          case "category":
          case "time":
            t.add(i);
            return;
          case "series":
            s.add(i);
            return;
          case "excluded":
            return;
          default:
            R(153, { chartDataType: o });
            break;
        }
      if (r.colId === "ag-Grid-AutoColumn") {
        t.add(i);
        return;
      }
      if (!i.isPrimary()) {
        s.add(i);
        return;
      }
      (this.isInferredValueCol(i) ? s : t).add(i);
    }), { dimensionCols: t, valueCols: s };
  }
  isInferredValueCol(e) {
    const t = e.getColId();
    if (t === "ag-Grid-AutoColumn")
      return !1;
    const s = St(this.beans, { rowIndex: 0, rowPinned: null });
    if (!s)
      return this.valueColsWithoutSeriesType.has(t);
    let i = this.valueSvc.getValue(e, s);
    i == null && (i = this.extractLeafData(s, e)), i != null && typeof i.toNumber == "function" && (i = i.toNumber());
    const r = typeof i == "number";
    return r && this.valueColsWithoutSeriesType.add(t), r;
  }
  extractLeafData(e, t) {
    if (!e.allLeafChildren)
      return null;
    for (let s = 0; s < e.allLeafChildren.length; s++) {
      const i = e.allLeafChildren[s], r = this.valueSvc.getValue(t, i);
      if (r != null)
        return r;
    }
    return null;
  }
  destroy() {
    this.valueColsWithoutSeriesType.clear(), super.destroy();
  }
}, kB = /* @__PURE__ */ new Set(["line", "groupedColumn", "stackedColumn", "area", "stackedArea"]), OB = class extends P {
  constructor(e) {
    super(), this.suppressComboChartWarnings = !1, this.chartDataModel = e, this.seriesChartTypes = e.params.seriesChartTypes ?? [];
  }
  postConstruct() {
    this.initComboCharts();
  }
  update(e) {
    this.seriesChartTypes = e ?? this.seriesChartTypes, this.initComboCharts(), this.updateSeriesChartTypes();
  }
  initComboCharts() {
    const e = this.seriesChartTypes && this.seriesChartTypes.length > 0;
    (this.chartDataModel.chartType === "customCombo" || e) && (this.chartDataModel.chartType = "customCombo", this.savedCustomSeriesChartTypes = this.seriesChartTypes || []);
  }
  updateSeriesChartTypes() {
    if (this.chartDataModel.isComboChart()) {
      if (this.seriesChartTypes = this.seriesChartTypes.map((e) => {
        const t = ["groupedColumn", "stackedColumn", "stackedArea"].includes(e.chartType);
        return e.secondaryAxis = t ? !1 : e.secondaryAxis, e;
      }), this.chartDataModel.chartType === "customCombo") {
        this.updateSeriesChartTypesForCustomCombo();
        return;
      }
      this.updateChartSeriesTypesForBuiltInCombos();
    }
  }
  updateSeriesChartTypesForCustomCombo() {
    !(this.seriesChartTypes && this.seriesChartTypes.length > 0) && !this.suppressComboChartWarnings && R(150), this.seriesChartTypes = this.seriesChartTypes.map((i) => (kB.has(i.chartType) || (R(151, { chartType: i.chartType }), i.chartType = "line"), i));
    const t = (i) => {
      (!this.savedCustomSeriesChartTypes || this.savedCustomSeriesChartTypes.length === 0) && (this.savedCustomSeriesChartTypes = this.seriesChartTypes);
      const r = this.savedCustomSeriesChartTypes.find((o) => o.colId === i.colId);
      return r || (i.selected && !this.suppressComboChartWarnings && R(152, { colId: i.colId }), {
        colId: i.colId,
        chartType: "line",
        secondaryAxis: !1
      });
    }, s = this.chartDataModel.valueColState.map(t);
    this.seriesChartTypes = s, this.savedCustomSeriesChartTypes = s, this.suppressComboChartWarnings = !0;
  }
  updateChartSeriesTypesForBuiltInCombos() {
    const { chartType: e, valueColState: t } = this.chartDataModel, s = e === "columnLineCombo" ? "groupedColumn" : "stackedArea", i = e === "columnLineCombo" ? "line" : "groupedColumn", r = t.filter((n) => n.selected), o = Math.ceil(r.length / 2);
    this.seriesChartTypes = r.map((n, a) => {
      const l = a >= o ? i : s;
      return { colId: n.colId, chartType: l, secondaryAxis: !1 };
    });
  }
}, Vt = "AG-GRID-DEFAULT-CATEGORY", GB = class extends P {
  constructor(e) {
    super(), this.unlinked = !1, this.chartData = [], this.valueColState = [], this.dimensionColState = [], this.colNames = {}, this.crossFiltering = !1, this.grouping = !1, this.params = e, this.chartId = e.chartId, this.setParams(e);
  }
  wireBeans(e) {
    this.rangeSvc = e.rangeSvc, this.chartTranslation = e.chartTranslation;
  }
  setParams(e) {
    const {
      chartType: t,
      pivotChart: s,
      chartThemeName: i,
      switchCategorySeries: r,
      aggFunc: o,
      cellRange: n,
      suppressChartRanges: a,
      unlinkChart: l,
      crossFiltering: d,
      seriesGroupType: c
    } = e;
    this.chartType = t, this.pivotChart = s ?? !1, this.chartThemeName = i, this.switchCategorySeries = !!r, this.aggFunc = o, this.referenceCellRange = n, this.suppliedCellRange = n, this.suppressChartRanges = a ?? !1, this.unlinked = !!l, this.crossFiltering = !!d, this.seriesGroupType = c;
  }
  postConstruct() {
    this.datasource = this.createManagedBean(new IB()), this.chartColSvc = this.createManagedBean(new LB()), this.comboChartModel = this.createManagedBean(new OB(this)), this.updateCellRanges({ setColsFromRange: !0 }), this.updateData();
  }
  updateModel(e) {
    const { cellRange: t, seriesChartTypes: s } = e;
    t !== this.suppliedCellRange && (this.dimensionCellRange = void 0, this.valueCellRange = void 0), this.setParams(e), this.updateSelectedDimensions(t == null ? void 0 : t.columns), this.updateCellRanges({ setColsFromRange: !0 }), (this.isComboChart() || s) && this.comboChartModel.update(s), this.unlinked || this.updateData();
  }
  updateCellRanges(e) {
    const { updatedColState: t, resetOrder: s, maintainColState: i, setColsFromRange: r } = e ?? {};
    this.valueCellRange && (this.referenceCellRange = this.valueCellRange);
    const { dimensionCols: o, valueCols: n } = this.chartColSvc.getChartColumns(), a = this.getAllColumnsFromRanges();
    t && this.updateColumnState(t, s), this.setDimensionCellRange(o, a, t), this.setValueCellRange(n, a, r), !t && !i && (this.resetColumnState(), this.syncDimensionCellRange()), this.comboChartModel.updateSeriesChartTypes();
  }
  updateData() {
    const { startRow: e, endRow: t } = this.getRowIndexes();
    this.pivotChart && this.resetColumnState(), this.grouping = this.isGrouping();
    const s = {
      aggFunc: this.aggFunc,
      dimensionCols: this.getSelectedDimensions(),
      grouping: this.grouping,
      pivoting: this.isPivotActive(),
      crossFiltering: this.crossFiltering,
      valueCols: this.getSelectedValueCols(),
      startRow: e,
      endRow: t,
      isScatter: ["scatter", "bubble"].includes(this.chartType)
    }, { chartData: i, colNames: r, groupChartData: o } = this.datasource.getData(s);
    this.chartData = i, this.groupChartData = o, this.colNames = r, this.categoryAxisType = void 0;
  }
  isGrouping() {
    const e = this.gos.get("treeData"), t = e ? null : this.chartColSvc.getRowGroupColumns(), s = e || t && t.length > 0, i = this.getSelectedDimensions().map(({ colId: n }) => n), o = this.chartColSvc.getGroupDisplayColumns().map((n) => n.getColId()).some((n) => i.includes(n));
    return !!s && o;
  }
  getSelectedValueCols() {
    return this.valueColState.filter((e) => e.selected).map((e) => e.column);
  }
  getSelectedDimensions() {
    return this.dimensionColState.filter((e) => e.selected);
  }
  getColDisplayName(e, t) {
    return this.chartColSvc.getColDisplayName(e, t);
  }
  isPivotMode() {
    return this.chartColSvc.isPivotMode();
  }
  getChartDataType(e) {
    const t = this.chartColSvc.getColumn(e);
    return t ? t.getColDef().chartDataType : void 0;
  }
  isPivotActive() {
    return this.chartColSvc.isPivotActive();
  }
  createCellRange(e, ...t) {
    return {
      id: this.chartId,
      // set range ID to match chart ID so we can identify changes to the ranges for this chart
      startRow: this.referenceCellRange.startRow,
      endRow: this.referenceCellRange.endRow,
      columns: t,
      startColumn: e === dt.DIMENSION || this.referenceCellRange.startColumn == null ? t[0] : this.referenceCellRange.startColumn,
      type: e
    };
  }
  getAllColumnsFromRanges() {
    if (this.pivotChart)
      return new Set(this.chartColSvc.getAllDisplayedColumns());
    const e = this.dimensionCellRange || this.valueCellRange ? [] : this.referenceCellRange.columns;
    return this.dimensionCellRange && e.push(...this.dimensionCellRange.columns), this.valueCellRange && e.push(...this.valueCellRange.columns), new Set(e);
  }
  getRowIndexes() {
    let e = 0, t = 0;
    const { rangeSvc: s, valueCellRange: i, dimensionCellRange: r } = this, o = i || r;
    if (s && o) {
      e = s.getRangeStartRow(o).rowIndex;
      const n = s.getRangeEndRow(o);
      t = n.rowPinned === "bottom" ? -1 : n.rowIndex;
    }
    return { startRow: e, endRow: t };
  }
  resetColumnState() {
    const { dimensionCols: e, valueCols: t } = this.chartColSvc.getChartColumns(), s = this.getAllColumnsFromRanges(), i = this.valueColState.length < 1;
    this.dimensionColState = [], this.valueColState = [];
    const r = Ns(ne(this.chartType));
    let o = !1, n = 1;
    const a = this.suppliedCellRange.columns[0];
    e.forEach((c) => {
      const h = c.getColId() === "ag-Grid-AutoColumn";
      let u = !1;
      this.crossFiltering && this.aggFunc ? a.getColId() === c.getColId() && (u = !0) : u = h ? !0 : (!o || r) && s.has(c), this.dimensionColState.push({
        column: c,
        colId: c.getColId(),
        displayName: this.getColDisplayName(c),
        selected: u,
        order: n++
      }), u && (o = !0);
    });
    const l = {
      colId: Vt,
      displayName: this.chartTranslation.translate("defaultCategory"),
      selected: !o,
      // if no dimensions in range select the default
      order: 0
    };
    this.dimensionColState.unshift(l);
    const d = this.referenceCellRange.columns.filter(
      (c) => t.has(c)
    );
    t.forEach((c) => {
      i && this.referenceCellRange.columns.includes(c) && (c = d.shift()), this.valueColState.push({
        column: c,
        colId: c.getColId(),
        displayName: this.getColDisplayName(c),
        selected: s.has(c),
        order: n++
      });
    });
  }
  updateColumnState(e, t) {
    const s = (d) => d.colId === e.colId, { dimensionColState: i, valueColState: r } = this, o = i.find(s), n = r.find(s);
    if (o)
      if (Ns(ne(this.chartType)))
        o.selected = e.selected;
      else {
        const c = e.selected ? o : i.filter((h) => h !== o).find(({ selected: h }) => h);
        i.forEach((h) => h.selected = h === c);
      }
    else n && (n.selected = e.selected);
    const a = [...i, ...r], l = [];
    t || (a.forEach((d, c) => {
      c === e.order && l.push(e.colId), d.colId !== e.colId && l.push(d.colId);
    }), a.forEach((d) => {
      const c = l.indexOf(d.colId);
      d.order = c >= 0 ? l.indexOf(d.colId) : a.length - 1;
    })), this.reorderColState();
  }
  reorderColState() {
    const e = (t, s) => t.order - s.order;
    this.dimensionColState.sort(e), this.valueColState.sort(e);
  }
  setDimensionCellRange(e, t, s) {
    this.dimensionCellRange = void 0;
    const i = Ns(ne(this.chartType));
    if (!s && !this.dimensionColState.length) {
      const a = new Array();
      e.forEach((l) => {
        a.length > 0 && !i || !t.has(l) || a.push(l);
      }), a.length > 0 && (this.dimensionCellRange = this.createCellRange(dt.DIMENSION, ...a));
      return;
    }
    let r = s ? [s] : [];
    if (this.crossFiltering && this.aggFunc) {
      const a = this.suppliedCellRange.columns[0];
      r = this.dimensionColState.filter(
        (l) => l.colId === a.getColId()
      );
    } else (i || r.length === 0 || r.some(({ column: a }) => !a || !e.has(a))) && (r = this.dimensionColState.filter((a) => a.selected));
    const o = r.length === 1 ? r[0].colId === Vt : !1, n = r.map(({ column: a }) => a).filter((a) => a != null);
    n.length > 0 && !o && (this.dimensionCellRange = this.createCellRange(dt.DIMENSION, ...n));
  }
  setValueCellRange(e, t, s) {
    this.valueCellRange = void 0;
    const i = [], r = Bo(this.chartType);
    let o = 0;
    if (e.forEach((n) => {
      s ? (r == null || o < r) && t.has(n) && (i.push(n), o++) : this.valueColState.some((a) => a.selected && a.colId === n.getColId()) && i.push(n);
    }), i.length > 0) {
      let n = [];
      this.valueColState.length > 0 ? n = this.valueColState.map((a) => a.colId) : t.forEach((a) => n.push(a.getColId())), i.sort((a, l) => n.indexOf(a.getColId()) - n.indexOf(l.getColId())), this.valueCellRange = this.createCellRange(dt.VALUE, ...i);
    }
  }
  resetCellRanges(e, t) {
    if (!e && !t)
      return;
    const { dimensionCols: s, valueCols: i } = this.chartColSvc.getChartColumns(), r = this.getAllColumnsFromRanges();
    e && this.setDimensionCellRange(s, r), t && this.setValueCellRange(i, r);
  }
  updateSelectedDimensions(e) {
    const t = new Set(e.map((i) => i.getColId()));
    if (Ns(ne(this.chartType))) {
      const i = this.dimensionColState.filter((o) => t.has(o.colId)), r = new Set(i.map((o) => o.colId));
      this.dimensionColState = this.dimensionColState.map((o) => ({
        ...o,
        selected: r.has(o.colId)
      }));
    } else {
      const r = (this.dimensionColState.find((o) => t.has(o.colId)) || this.dimensionColState[0]).colId;
      this.dimensionColState = this.dimensionColState.map((o) => ({
        ...o,
        selected: o.colId === r
      }));
    }
  }
  syncDimensionCellRange() {
    const e = this.getSelectedDimensions();
    if (e.length === 0)
      return;
    const t = e.map(({ column: s }) => s).filter((s) => s != null);
    t.length > 0 && (this.dimensionCellRange = this.createCellRange(dt.DIMENSION, ...t));
  }
  isComboChart(e) {
    return Jl(e ?? this.chartType);
  }
}, Gf = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e, t) {
    return [
      {
        type: this.getXAxisType(e),
        position: this.isHorizontal(t) ? "left" : "bottom"
      },
      {
        type: "number",
        position: this.isHorizontal(t) ? "bottom" : "left"
      }
    ];
  }
  computeSeriesStatistics(e, t) {
    const { data: s, fields: i } = e, [r] = e.categories, o = r.id || Vt, n = this.groupDataByCategory(o, s);
    return Array.from(n).map(([a, l]) => {
      const d = { [r.id]: a };
      return i.forEach((c, h) => {
        const u = l.map((p) => p[c.colId]).filter((p) => typeof p == "number" && !isNaN(p));
        Object.entries(t(u)).forEach(([p, g]) => {
          const f = `${p}:${h}`;
          d[f] = u.length > 0 ? g : null;
        });
      }), d;
    });
  }
  groupDataByCategory(e, t) {
    const s = (i) => {
      if (e === Vt)
        return 1;
      const r = i[e];
      return r == null ? "" : r instanceof Date ? r.getTime() : r;
    };
    return t.reduce((i, r) => {
      const o = s(r), n = i.get(o);
      return n ? n.push(r) : i.set(o, [r]), i;
    }, /* @__PURE__ */ new Map());
  }
}, BB = class extends Gf {
  constructor(e) {
    super(e);
  }
  getSeries(e) {
    const [t] = e.categories;
    return e.fields.map((s, i) => ({
      type: this.standaloneChartType,
      // xKey/xName refer to category buckets
      xKey: t.id,
      xName: t.name,
      // yName is used to label the series
      yName: s.displayName ?? void 0,
      // custom field labels shown in the tooltip
      minName: "Min",
      q1Name: "Q1",
      medianName: "Median",
      q3Name: "Q3",
      maxName: "Max",
      // generated 'synthetic fields' from getData()
      minKey: `min:${i}`,
      q1Key: `q1:${i}`,
      medianKey: `median:${i}`,
      q3Key: `q3:${i}`,
      maxKey: `max:${i}`
    }));
  }
  getData(e) {
    return this.computeSeriesStatistics(e, (t) => {
      const s = t.sort((i, r) => i - r);
      return {
        min: s[0],
        q1: this.quantile(s, 0.25),
        median: this.quantile(s, 0.5),
        q3: this.quantile(s, 0.75),
        max: s[s.length - 1]
      };
    });
  }
  quantile(e, t) {
    const s = (e.length - 1) * t, i = Math.floor(s), r = s - i;
    return e[i + 1] !== void 0 ? e[i] + r * (e[i + 1] - e[i]) : e[i];
  }
}, VB = class extends Gf {
  constructor(e) {
    super(e);
  }
  getSeries(e) {
    const [t] = e.categories;
    return e.fields.map((s, i) => ({
      type: this.standaloneChartType,
      // xKey/xName refer to category buckets
      xKey: t.id,
      xName: t.name,
      // yName is used to label the series
      yName: s.displayName ?? void 0,
      // custom field labels shown in the tooltip
      yLowName: "Min",
      yHighName: "Max",
      // generated 'synthetic fields' from getData()
      yLowKey: `min:${i}`,
      yHighKey: `max:${i}`
    }));
  }
  getData(e) {
    return this.computeSeriesStatistics(e, (t) => ({
      min: Math.min(...t),
      max: Math.max(...t)
    }));
  }
}, NB = class extends P {
  constructor() {
    super(...arguments), this.beanName = "enterpriseChartProxyFactory";
  }
  createChartProxy(e) {
    switch (e.chartType) {
      case "histogram":
        return new yB(e);
      case "radarLine":
      case "radarArea":
      case "nightingale":
      case "radialColumn":
      case "radialBar":
        return new RB(e);
      case "rangeBar":
      case "rangeArea":
        return new VB(e);
      case "boxPlot":
        return new BB(e);
      case "treemap":
      case "sunburst":
        return new FB(e);
      case "heatmap":
        return new MB(e);
      case "waterfall":
        return new bB(e);
    }
  }
}, Bf = class extends P {
  constructor(e, t, s, i) {
    super(), this.chartController = e, this.eGui = t, this.cssClass = s, this.createPanels = i, this.panels = [];
  }
  postConstruct() {
    this.addManagedListeners(this.chartController, {
      chartUpdated: () => this.refreshPanels(!0),
      chartApiUpdate: () => this.refreshPanels(!1)
    });
  }
  addComponent(e) {
    this.createBean(e), this.panels.push(e), e.addCssClass(this.cssClass), this.eGui.appendChild(e.getGui());
  }
  refreshPanels(e) {
    const t = this.chartController.getChartType(), s = this.chartController.isGrouping(), i = ne(t);
    e && t === this.chartType && s === this.isGrouping || (this.destroyPanels(), this.createPanels(t, i), this.chartType = t, this.isGrouping = s);
  }
  destroyPanels() {
    this.panels.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    }), this.panels = [];
  }
  destroy() {
    this.destroyPanels(), super.destroy();
  }
}, HB = class extends L {
  constructor(e) {
    super(), this.chartMenuParamsFactory = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuParamsFactory.addEnableParams(
      "animation.enabled",
      {
        cssIdentifier: "charts-advanced-settings-top-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        title: this.chartTranslation.translate("animation"),
        suppressEnabledCheckbox: !0,
        useToggle: !0
      }
    ), t = this.chartMenuParamsFactory.getDefaultNumberInputParams(
      "animation.duration",
      "durationMillis",
      {
        min: 0
      }
    );
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="animationGroup">
                <ag-input-number-field data-ref="animationHeightInput"></ag-input>
            </ag-group-component>
        </div>`,
      [le, an],
      {
        animationGroup: e,
        animationHeightInput: t
      }
    );
  }
}, zB = class extends Tt {
  constructor() {
    super({
      template: (
        /* html */
        `
            <div role="presentation" class="ag-color-input">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <input data-ref="eInput" class="ag-input-field-input">
                    <div data-ref="eColor" class="ag-color-input-color"></div>
                </div>
            </div>`
      )
    }), this.eColor = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation, this.color = e.agChartsExports._Util.Color;
  }
  setColor(e) {
    const t = e.toRgbaString();
    this.setValue(this.color.fromString(t).toHexString().toUpperCase(), !0), this.eColor.style.backgroundColor = t;
  }
  setValue(e, t) {
    const s = this.color.validColorString(e ?? "");
    return this.eInput.setCustomValidity(s ? "" : this.chartTranslation.translate("invalidColor")), super.setValue(e, t), s && !t && this.dispatchLocalEvent({ type: "colorChanged" }), this;
  }
  onColorChanged(e) {
    this.addManagedListeners(this, { colorChanged: () => e(this.color.fromString(this.value)) });
  }
}, WB = {
  selector: "AG-COLOR-INPUT",
  component: zB
}, $c = 8, Yr = [], _B = class extends L {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-color-panel" tabindex="-1">
            <div data-ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div data-ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div data-ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div data-ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div data-ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div data-ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div data-ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <ag-color-input data-ref="colorInput"></ag-color-input>
                <div data-ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`,
      [WB]
    ), this.H = 1, this.S = 1, this.B = 1, this.A = 1, this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1, this.colorChanged = !1, this.spectrumColor = S, this.spectrumVal = S, this.spectrumDragger = S, this.spectrumHue = S, this.spectrumHueSlider = S, this.spectrumAlpha = S, this.spectrumAlphaSlider = S, this.colorInput = S, this.recentColors = S, this.picker = e.picker;
  }
  wireBeans(e) {
    this._Color = e.agChartsExports._Util.Color;
  }
  postConstruct() {
    this.initTabIndex(), this.initRecentColors(), this.addGuiEventListener("focus", () => this.spectrumColor.focus()), this.addGuiEventListener("keydown", (e) => {
      e.key === w.ENTER && !e.defaultPrevented && this.destroy();
    }), this.addManagedListeners(this.spectrumColor, { keydown: (e) => this.moveDragger(e) }), this.addManagedListeners(this.spectrumAlphaSlider, { keydown: (e) => this.moveAlphaSlider(e) }), this.addManagedListeners(this.spectrumHueSlider, { keydown: (e) => this.moveHueSlider(e) }), this.addManagedListeners(this.spectrumVal, { mousedown: this.onSpectrumDraggerDown.bind(this) }), this.addManagedListeners(this.spectrumHue, { mousedown: this.onSpectrumHueDown.bind(this) }), this.addManagedListeners(this.spectrumAlpha, { mousedown: this.onSpectrumAlphaDown.bind(this) }), this.addGuiEventListener("mousemove", (e) => {
      this.onSpectrumDraggerMove(e), this.onSpectrumHueMove(e), this.onSpectrumAlphaMove(e);
    }), this.addManagedListeners(document, { mouseup: this.onMouseUp.bind(this) }), this.colorInput.onColorChanged(this.setColor.bind(this)), this.addManagedListeners(this.recentColors, {
      click: this.onRecentColorClick.bind(this),
      keydown: (e) => {
        (e.key === w.ENTER || e.key === w.SPACE) && (e.preventDefault(), this.onRecentColorClick(e));
      }
    });
  }
  initTabIndex() {
    const e = this.tabIndex = this.gos.get("tabIndex").toString();
    this.spectrumColor.setAttribute("tabindex", e), this.spectrumHueSlider.setAttribute("tabindex", e), this.spectrumAlphaSlider.setAttribute("tabindex", e);
  }
  refreshSpectrumRect() {
    return this.spectrumValRect = this.spectrumVal.getBoundingClientRect();
  }
  refreshHueRect() {
    return this.spectrumHueRect = this.spectrumHue.getBoundingClientRect();
  }
  refreshAlphaRect() {
    return this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect();
  }
  onSpectrumDraggerDown(e) {
    e.preventDefault(), this.refreshSpectrumRect(), this.isSpectrumDragging = !0, this.moveDragger(e);
  }
  onSpectrumDraggerMove(e) {
    this.isSpectrumDragging && this.moveDragger(e);
  }
  onSpectrumHueDown(e) {
    this.refreshHueRect(), this.isSpectrumHueDragging = !0, this.moveHueSlider(e);
  }
  onSpectrumHueMove(e) {
    this.isSpectrumHueDragging && this.moveHueSlider(e);
  }
  onSpectrumAlphaDown(e) {
    this.refreshAlphaRect(), this.isSpectrumAlphaDragging = !0, this.moveAlphaSlider(e);
  }
  onSpectrumAlphaMove(e) {
    this.isSpectrumAlphaDragging && this.moveAlphaSlider(e);
  }
  onMouseUp() {
    this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1;
  }
  moveDragger(e) {
    const t = this.spectrumValRect;
    if (!t)
      return;
    let s, i;
    if (e instanceof MouseEvent)
      s = e.clientX - t.left, i = e.clientY - t.top;
    else {
      const r = e.key === w.LEFT, o = e.key === w.RIGHT, n = e.key === w.UP, a = e.key === w.DOWN, l = n || a, d = r || o;
      if (!l && !d)
        return;
      e.preventDefault();
      const { x: c, y: h } = this.getSpectrumValue();
      s = c + (d ? r ? -5 : 5 : 0), i = h + (l ? n ? -5 : 5 : 0);
    }
    s = Math.max(s, 0), s = Math.min(s, t.width), i = Math.max(i, 0), i = Math.min(i, t.height), this.setSpectrumValue(s / t.width, 1 - i / t.height);
  }
  moveHueSlider(e) {
    const t = this.spectrumHueRect;
    if (!t)
      return;
    const s = this.moveSlider(this.spectrumHueSlider, e);
    s != null && (this.H = 1 - s / t.width, this.update());
  }
  moveAlphaSlider(e) {
    const t = this.spectrumAlphaRect;
    if (!t)
      return;
    const s = this.moveSlider(this.spectrumAlphaSlider, e);
    s != null && (this.A = s / t.width, this.update());
  }
  moveSlider(e, t) {
    var n;
    const s = e.getBoundingClientRect(), i = (n = e.parentElement) == null ? void 0 : n.getBoundingClientRect();
    if (!e || !i)
      return null;
    const r = s.width / 2;
    let o;
    if (t instanceof MouseEvent)
      o = Math.floor(t.clientX - i.left);
    else {
      const a = t.key === w.LEFT, l = t.key === w.RIGHT;
      if (!a && !l)
        return null;
      t.preventDefault();
      const d = a ? -5 : 5;
      o = parseFloat(e.style.left) + r + d;
    }
    return o = Math.max(o, 0), o = Math.min(o, i.width), e.style.left = o - r + "px", o;
  }
  update(e) {
    const { A: t, S: s, B: i, H: r, _Color: o } = this, n = r * 360, a = o.fromHSB(n, s, i, t), l = a.toRgbaString(), c = o.fromHSB(n, s, i).toRgbaString(), u = o.fromHSB(n, 1, 1).toRgbaString(), p = this.picker;
    o.fromString(p.getValue()).toRgbaString() !== l && (this.colorChanged = !0), p.setValue(l), this.spectrumColor.style.backgroundColor = u, this.spectrumDragger.style.backgroundColor = c, this.spectrumHueSlider.style.backgroundColor = u, this.spectrumAlpha.style.setProperty(
      "--ag-internal-spectrum-alpha-color-from",
      o.fromHSB(n, s, i, 0).toRgbaString()
    ), this.spectrumAlpha.style.setProperty("--ag-internal-spectrum-alpha-color-to", c), this.spectrumAlpha.style.setProperty("--ag-internal-spectrum-alpha-color", l), e || this.colorInput.setColor(a);
  }
  /**
   * @param saturation In the [0, 1] interval.
   * @param brightness In the [0, 1] interval.
   */
  setSpectrumValue(e, t, s) {
    const i = this.spectrumValRect || this.refreshSpectrumRect();
    if (i == null)
      return;
    const r = this.spectrumDragger, o = r.getBoundingClientRect();
    e = Math.max(0, e), e = Math.min(1, e), t = Math.max(0, t), t = Math.min(1, t), this.S = e, this.B = t, r.style.left = e * i.width - o.width / 2 + "px", r.style.top = (1 - t) * i.height - o.height / 2 + "px", this.update(s);
  }
  getSpectrumValue() {
    const e = this.spectrumDragger, t = e.getBoundingClientRect(), s = parseFloat(e.style.left) + t.width / 2, i = parseFloat(e.style.top) + t.height / 2;
    return { x: s, y: i };
  }
  initRecentColors() {
    const e = Yr, t = e.map((s, i) => (
      /* html */
      `<div class="ag-recent-color" id=${i} style="background-color: ${s}; width: 15px; height: 15px;" recent-color="${s}" tabIndex="${this.tabIndex}"></div>`
    ));
    this.recentColors.innerHTML = t.join(""), O(this.recentColors, !!e.length);
  }
  setValue(e) {
    const t = this._Color.fromString(e);
    this.setColor(t, !0);
  }
  setColor(e, t) {
    const [s, i, r] = e.toHSB();
    this.H = (isNaN(s) ? 0 : s) / 360, this.A = e.a;
    const o = this.spectrumHueRect || this.refreshHueRect(), n = this.spectrumAlphaRect || this.refreshAlphaRect();
    this.spectrumHueSlider.style.left = `${(this.H - 1) * -o.width - this.spectrumHueSlider.getBoundingClientRect().width / 2}px`, this.spectrumAlphaSlider.style.left = `${this.A * n.width - this.spectrumAlphaSlider.getBoundingClientRect().width / 2}px`, this.setSpectrumValue(i, r, !t);
  }
  onRecentColorClick(e) {
    const t = e.target;
    if (!A(t.id))
      return;
    const s = parseInt(t.id, 10);
    this.setValue(Yr[s]), this.destroy();
  }
  addRecentColor() {
    const t = this._Color.fromHSB(this.H * 360, this.S, this.B, this.A).toRgbaString();
    let s = Yr;
    !this.colorChanged || s[0] === t || (s = s.filter((i) => i != t), s = [t].concat(s), s.length > $c && (s = s.slice(0, $c)), Yr = s);
  }
  destroy() {
    this.addRecentColor(), super.destroy();
  }
}, Vf = class extends Al {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelColorPicker",
      pickerAriaLabelValue: "Color Picker",
      pickerType: "ag-list",
      className: "ag-color-picker",
      pickerIcon: "chartsColorPicker",
      ...e
    });
  }
  postConstruct() {
    const e = Z(this.beans);
    this.eDisplayFieldColor = e.createElement("span"), this.eDisplayFieldColor.classList.add("ag-color-picker-color"), this.eDisplayFieldText = e.createElement("span"), this.eDisplayFieldText.classList.add("ag-color-picker-value"), this.eDisplayField.appendChild(this.eDisplayFieldColor), this.eDisplayField.appendChild(this.eDisplayFieldText), super.postConstruct(), this.value && this.setValue(this.value);
  }
  createPickerComponent() {
    const e = this.eWrapper.getBoundingClientRect(), t = this.beans.popupSvc.getParentRect();
    return this.createBean(
      new Er({
        closable: !1,
        modal: !0,
        hideTitleBar: !0,
        minWidth: 190,
        width: 190,
        height: 250,
        x: e.right - t.left - 190,
        y: e.top - t.top - 250 - (this.config.pickerGap ?? 0),
        postProcessPopupParams: {
          type: "colorPicker",
          eventSource: this.eWrapper
        }
      })
    );
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent, t = this.createBean(new _B({ picker: this }));
    return e.addCssClass("ag-color-dialog"), t.addDestroyFunc(() => {
      e.isAlive() && this.destroyBean(e);
    }), e.setParentComponent(this), e.setBodyComponent(t), t.setValue(this.getValue()), t.getGui().focus(), e.addDestroyFunc(() => {
      this.isDestroyingPicker ? this.isDestroyingPicker = !1 : (this.beforeHidePicker(), this.isDestroyingPicker = !0, t.isAlive() && this.destroyBean(t), this.isAlive() && this.getFocusableElement().focus());
    }), () => {
      var s;
      return (s = this.pickerComponent) == null ? void 0 : s.close();
    };
  }
  setValue(e) {
    return this.value === e ? this : (this.eDisplayFieldColor.style.backgroundColor = e, this.eDisplayFieldText.textContent = this.beans.agChartsExports._Util.Color.fromString(
      e
    ).toHexString().toUpperCase(), super.setValue(e));
  }
  getValue() {
    return this.value;
  }
}, Ht = {
  selector: "AG-COLOR-PICKER",
  component: Vf
}, UB = class extends L {
  constructor(e) {
    super(), this.chartMenuParamsFactory = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuParamsFactory.addEnableParams(
      "crosshair.enabled",
      {
        cssIdentifier: "charts-advanced-settings-top-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        title: this.chartTranslation.translate("crosshair"),
        suppressEnabledCheckbox: !0,
        useToggle: !0
      }
    ), t = this.chartMenuParamsFactory.getDefaultCheckboxParams(
      "crosshair.label.enabled",
      "crosshairLabel"
    ), s = this.chartMenuParamsFactory.getDefaultCheckboxParams(
      "crosshair.snap",
      "crosshairSnap"
    ), i = this.chartMenuParamsFactory.getDefaultColorPickerParams(
      "crosshair.stroke",
      "color"
    );
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="crosshairGroup">
                <ag-checkbox data-ref="crosshairLabelCheckbox"></ag-checkbox>
                <ag-checkbox data-ref="crosshairSnapCheckbox"></ag-checkbox>
                <ag-color-picker data-ref="crosshairStrokeColorPicker"></ag-color-picker>
            </ag-group-component>
        </div>`,
      [le, Pt, Ht],
      {
        crosshairGroup: e,
        crosshairLabelCheckbox: t,
        crosshairSnapCheckbox: s,
        crosshairStrokeColorPicker: i
      }
    );
  }
}, KB = class extends us {
  constructor(e) {
    super(e, "ag-range-field", "range");
  }
  postConstruct() {
    super.postConstruct();
    const { min: e, max: t, step: s } = this.config;
    e != null && this.setMinValue(e), t != null && this.setMaxValue(t), this.setStep(s || 1);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, {
      input: (e) => {
        const t = e.target.value;
        this.setValue(t);
      }
    });
  }
  setMinValue(e) {
    return this.min = e, this.eInput.setAttribute("min", e.toString()), this;
  }
  setMaxValue(e) {
    return this.max = e, this.eInput.setAttribute("max", e.toString()), this;
  }
  setStep(e) {
    return this.eInput.setAttribute("step", e.toString()), this;
  }
  setValue(e, t) {
    this.min != null && (e = Math.max(parseFloat(e), this.min).toString()), this.max != null && (e = Math.min(parseFloat(e), this.max).toString());
    const s = super.setValue(e, t);
    return this.eInput.value = e, s;
  }
}, $B = {
  selector: "AG-INPUT-RANGE",
  component: KB
}, rt = class extends Ml {
  constructor(e) {
    super(
      e,
      /* html */
      `<div class="ag-slider">
            <label data-ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range data-ref="eSlider"></ag-input-range>
                <ag-input-number-field data-ref="eText"></ag-input-number-field>
            </div>
        </div>`,
      [$B, an]
    ), this.eLabel = S, this.eSlider = S, this.eText = S, this.labelAlignment = "top";
  }
  postConstruct() {
    super.postConstruct(), this.eSlider.addCssClass("ag-slider-field");
    const { minValue: e, maxValue: t, textFieldWidth: s, step: i, value: r, onValueChange: o } = this.config;
    e != null && this.setMinValue(e), t != null && this.setMaxValue(t), s != null && this.setTextFieldWidth(s), i != null && this.setStep(i), r != null && this.setValue(r), o != null && this.onValueChange(o);
  }
  onValueChange(e) {
    return this.addManagedListeners(this.eText, {
      fieldValueChanged: () => {
        const t = parseFloat(this.eText.getValue());
        this.eSlider.setValue(t.toString(), !0), e(t || 0);
      }
    }), this.addManagedListeners(this.eSlider, {
      fieldValueChanged: () => {
        const t = this.eSlider.getValue();
        this.eText.setValue(t, !0), e(parseFloat(t));
      }
    }), this;
  }
  setSliderWidth(e) {
    return this.eSlider.setWidth(e), this;
  }
  setTextFieldWidth(e) {
    return this.eText.setWidth(e), this;
  }
  setMinValue(e) {
    return this.eSlider.setMinValue(e), this.eText.setMin(e), this;
  }
  setMaxValue(e) {
    return this.eSlider.setMaxValue(e), this.eText.setMax(e), this;
  }
  getValue() {
    return this.eText.getValue();
  }
  setValue(e, t) {
    return this.getValue() === e ? this : (this.eText.setValue(e, !0), this.eSlider.setValue(e, !0), t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
  setStep(e) {
    return this.eSlider.setStep(e), this.eText.setStep(e), this;
  }
}, Je = {
  selector: "AG-SLIDER",
  component: rt
}, jB = class extends L {
  constructor(e) {
    super(), this.chartMenuParamsFactory = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuParamsFactory.addEnableParams(
      "navigator.enabled",
      {
        cssIdentifier: "charts-advanced-settings-top-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        title: this.chartTranslation.translate("navigator"),
        suppressEnabledCheckbox: !0,
        useToggle: !0
      }
    ), t = this.chartMenuParamsFactory.getDefaultSliderParams(
      "navigator.height",
      "height",
      60
    );
    t.minValue = 10;
    const s = this.chartMenuParamsFactory.getDefaultCheckboxParams(
      "navigator.miniChart.enabled",
      "miniChart"
    );
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="navigatorGroup">
                <ag-slider data-ref="navigatorHeightSlider"></ag-slider>
                <ag-checkbox data-ref="navigatorMiniChartCheckbox"></ag-checkbox>
            </ag-group-component>
        </div>`,
      [le, Je, Pt],
      {
        navigatorGroup: e,
        navigatorHeightSlider: t,
        navigatorMiniChartCheckbox: s
      }
    );
  }
}, qB = class extends L {
  constructor(e) {
    super(), this.chartMenuParamsFactory = e, this.zoomScrollingStepInput = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuParamsFactory.addEnableParams("zoom.enabled", {
      cssIdentifier: "charts-advanced-settings-top-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0,
      title: this.chartTranslation.translate("zoom"),
      suppressEnabledCheckbox: !0,
      useToggle: !0
    }), t = this.chartMenuParamsFactory.getDefaultCheckboxParams(
      "zoom.enableScrolling",
      "scrollingZoom"
    ), s = this.chartMenuParamsFactory.getDefaultSliderParams(
      "zoom.scrollingStep",
      "scrollingStep",
      1
    );
    s.step = 0.01, s.minValue = s.step;
    const i = this.chartMenuParamsFactory.getDefaultCheckboxParams(
      "zoom.enableSelecting",
      "selectingZoom"
    );
    t.onValueChange = /* @__PURE__ */ ((r) => (o) => {
      r && (r(o), this.zoomScrollingStepInput.setDisabled(!o));
    })(t.onValueChange), this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="zoomGroup">
                <ag-checkbox data-ref="zoomSelectingCheckbox"></ag-checkbox>
                <ag-checkbox data-ref="zoomScrollingCheckbox"></ag-checkbox>
                <ag-slider data-ref="zoomScrollingStepInput"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Pt, Je],
      {
        zoomGroup: e,
        zoomScrollingCheckbox: t,
        zoomScrollingStepInput: s,
        zoomSelectingCheckbox: i
      }
    ), this.zoomScrollingStepInput.setDisabled(!t.value);
  }
}, YB = ["navigator", "zoom", "animation", "crosshair"], XB = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-chart-advanced-settings-wrapper"></div>'
    ), this.chartMenuContext = e;
  }
  postConstruct() {
    this.chartPanelFeature = this.createManagedBean(
      new Bf(
        this.chartMenuContext.chartController,
        this.getGui(),
        "ag-chart-advanced-settings-section",
        (e, t) => this.createPanels(e, t)
      )
    ), this.chartPanelFeature.refreshPanels();
  }
  createPanels(e, t) {
    YB.forEach((s) => {
      if (!this.isGroupPanelShownForSeries(s, t))
        return;
      const i = this.createPanel(s);
      this.chartPanelFeature.addComponent(i);
    });
  }
  isGroupPanelShownForSeries(e, t) {
    return e === "animation" || gs(t);
  }
  createPanel(e) {
    const { chartMenuParamsFactory: t, chartAxisMenuParamsFactory: s } = this.chartMenuContext;
    switch (e) {
      case "navigator":
        return new jB(t);
      case "zoom":
        return new qB(t);
      case "animation":
        return new HB(t);
      case "crosshair":
        return new UB(s);
    }
  }
}, ZB = class extends P {
  constructor() {
    super(...arguments), this.beanName = "advSettingsMenuFactory";
  }
  showMenu(e, t) {
    this.hideMenu();
    const s = this.createBean(new QB(e));
    this.activeDialog = this.createBean(
      new Er({
        title: this.beans.chartTranslation.translate("advancedSettings"),
        component: s,
        width: 300,
        height: 400,
        resizable: !0,
        movable: !0,
        centered: !0,
        closable: !0,
        afterGuiAttached: () => {
          var i;
          (i = bt(s.getGui())[0]) == null || i.focus();
        },
        closedCallback: () => {
          this.activeMenu = this.destroyBean(this.activeMenu), this.activeDialog = void 0, t == null || t.focus({ preventScroll: !0 });
        }
      })
    ), this.activeMenu = s;
  }
  hideMenu() {
    this.activeDialog && this.destroyBean(this.activeDialog);
  }
  destroy() {
    this.activeMenu = this.destroyBean(this.activeMenu), this.activeDialog = this.destroyBean(this.activeDialog), super.destroy();
  }
}, QB = class extends Nt {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-chart-advanced-settings"></div>'
    ), this.chartMenuContext = e;
  }
  postConstruct() {
    this.advancedSettingsPanel = this.createManagedBean(new XB(this.chartMenuContext)), this.getGui().appendChild(this.advancedSettingsPanel.getGui()), this.initialiseTabGuard({
      onTabKeyDown: this.onTabKeyDown.bind(this),
      focusTrapActive: !0
    });
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented)
      return;
    e.preventDefault();
    const t = e.shiftKey, s = this.advancedSettingsPanel.getGui(), i = Pe(this.beans, s, !1, t);
    if (i)
      i.focus();
    else {
      const r = bt(s);
      r.length && r[t ? r.length - 1 : 0].focus();
    }
  }
}, JB = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartMenuListFactory";
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.chartMenuSvc = e.chartMenuSvc, this.chartTranslation = e.chartTranslation;
  }
  showMenuList(e) {
    const { eventSource: t, showMenu: s, chartMenuContext: i } = e, r = this.chartMenuSvc.doChartToolPanelsExist(i.chartController), o = this.mapWithStockItems(
      this.getMenuItems(i.chartController, r),
      i,
      s,
      t,
      r
    );
    if (!o.length)
      return;
    const n = this.createBean(new eV(o));
    this.activeChartMenuList = n;
    let a = -1, l = "left";
    this.gos.get("enableRtl") && (a = 1, l = "right");
    const d = n.getGui();
    this.popupSvc.addPopup({
      modal: !0,
      eChild: d,
      closeOnEsc: !0,
      closedCallback: () => {
        this.destroyBean(n), this.activeChartMenuList = void 0, ys(this.beans) && t.focus({ preventScroll: !0 });
      },
      afterGuiAttached: (c) => n.afterGuiAttached(c),
      positionCallback: () => {
        this.popupSvc.positionPopupByComponent({
          type: "chartMenu",
          eventSource: t,
          ePopup: d,
          alignSide: l,
          nudgeX: 4 * a,
          nudgeY: 4,
          position: "under",
          keepWithinBounds: !0
        });
      },
      ariaLabel: "Chart Menu"
    });
  }
  getMenuItems(e, t) {
    const s = [
      ...t ? ["chartEdit"] : [],
      ...e.isEnterprise() ? ["chartAdvancedSettings"] : [],
      e.isChartLinked() ? "chartUnlink" : "chartLink",
      "chartDownload"
    ], i = this.gos.get("chartMenuItems");
    return i ? Array.isArray(i) ? i : i(
      this.gos.addGridCommonParams({
        defaultItems: s
      })
    ) : s;
  }
  mapWithStockItems(e, t, s, i, r) {
    if (!e)
      return [];
    const o = [];
    return e.forEach((n) => {
      let a;
      if (typeof n == "string" ? a = this.getStockMenuItem(
        n,
        t,
        s,
        i,
        r
      ) : a = { ...n }, !a)
        return;
      const { subMenu: l } = a;
      Array.isArray(l) && (a.subMenu = this.mapWithStockItems(
        l,
        t,
        s,
        i,
        r
      )), o.push(a);
    }), o;
  }
  getStockMenuItem(e, t, s, i, r) {
    switch (e) {
      case "chartEdit":
        return r ? this.createMenuItem(this.chartTranslation.translate("chartEdit"), "chartsMenuEdit", s) : null;
      case "chartAdvancedSettings":
        return this.createMenuItem(
          this.chartTranslation.translate("chartAdvancedSettings"),
          "chartsMenuAdvancedSettings",
          () => this.chartMenuSvc.openAdvancedSettings(t, i)
        );
      case "chartUnlink":
        return t.chartController.isChartLinked() ? this.createMenuItem(
          this.chartTranslation.translate("chartUnlink"),
          "unlinked",
          () => this.chartMenuSvc.toggleLinked(t)
        ) : null;
      case "chartLink":
        return t.chartController.isChartLinked() ? null : this.createMenuItem(
          this.chartTranslation.translate("chartLink"),
          "linked",
          () => this.chartMenuSvc.toggleLinked(t)
        );
      case "chartDownload":
        return this.createMenuItem(
          this.chartTranslation.translate("chartDownload"),
          "chartsDownload",
          () => this.chartMenuSvc.downloadChart(t)
        );
    }
    return null;
  }
  createMenuItem(e, t, s) {
    return {
      name: e,
      icon: B(t, this.beans, null),
      action: s
    };
  }
  destroy() {
    this.destroyBean(this.activeChartMenuList), super.destroy();
  }
}, eV = class extends L {
  constructor(e) {
    super(
      /* html */
      `
            <div data-ref="eChartsMenu" role="presentation" class="ag-menu ag-chart-menu-popup"></div>
        `
    ), this.menuItems = e, this.eChartsMenu = S;
  }
  postConstruct() {
    this.mainMenuList = this.createManagedBean(new Mr(0)), this.mainMenuList.addMenuItems(this.menuItems), this.mainMenuList.addEventListener("closeMenu", this.onHidePopup.bind(this)), this.eChartsMenu.appendChild(this.mainMenuList.getGui());
  }
  onHidePopup() {
    var e;
    (e = this.hidePopupFunc) == null || e.call(this);
  }
  afterGuiAttached({ hidePopup: e }) {
    e && (this.hidePopupFunc = e, this.addDestroyFunc(e)), ve(this.mainMenuList.getGui());
  }
}, tV = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartCrossFilterSvc";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.valueSvc = e.valueSvc, this.filterManager = e.filterManager, J(this.gos, e.rowModel) && (this.clientSideRowModel = e.rowModel);
  }
  filter(e, t = !1) {
    var r;
    const s = ((r = this.filterManager) == null ? void 0 : r.getFilterModel()) ?? {};
    if (t) {
      this.resetFilters(s);
      return;
    }
    const i = this.extractFilterColId(e);
    this.isValidColumnFilter(i) ? this.updateFilters(s, e, i) : R(154, { colId: i });
  }
  resetFilters(e) {
    var s, i;
    Object.keys(e).length > 0 && ((s = this.filterManager) == null || s.setFilterModel(null), (i = this.filterManager) == null || i.onFilterChanged({ source: "api" }));
  }
  updateFilters(e, t, s) {
    var n;
    const i = this.extractFilterColId(t), r = t.datum[i];
    if (r === void 0)
      return;
    const o = r.toString();
    if (t.event.metaKey || t.event.ctrlKey) {
      const a = this.getCurrentGridValuesForCategory(s), l = a.includes(o);
      let d;
      l ? d = a.filter((c) => c !== o) : (d = a, d.push(o)), e[s] = this.getUpdatedFilterModel(s, d);
    } else {
      const a = [o];
      e = { [s]: this.getUpdatedFilterModel(s, a) };
    }
    (n = this.filterManager) == null || n.setFilterModel(e);
  }
  getUpdatedFilterModel(e, t) {
    return this.getColumnFilterType(e) === "agMultiColumnFilter" ? { filterType: "multi", filterModels: [null, { filterType: "set", values: t }] } : { filterType: "set", values: t };
  }
  getCurrentGridValuesForCategory(e) {
    var i;
    const t = [], s = this.getColumnById(e);
    return (i = this.clientSideRowModel) == null || i.forEachNodeAfterFilter((r) => {
      if (s && !r.group) {
        const o = this.valueSvc.getValue(s, r) + "";
        t.includes(o) || t.push(o);
      }
    }), t;
  }
  extractFilterColId(e) {
    return e.xKey || e.calloutLabelKey;
  }
  isValidColumnFilter(e) {
    e.indexOf("-filtered-out") && (e = e.replace("-filtered-out", ""));
    const t = this.getColumnFilterType(e);
    return typeof t == "boolean" ? t : ["agSetColumnFilter", "agMultiColumnFilter"].includes(t);
  }
  getColumnFilterType(e) {
    const t = this.getColumnById(e);
    if (t)
      return t.getColDef().filter;
  }
  getColumnById(e) {
    return this.colModel.getCol(e);
  }
}, sV = [
  "chartUnlink",
  "chartLink",
  "chartDownload",
  "chartMenu"
], ao = {
  settings: "chartSettings",
  data: "chartData",
  format: "chartFormat"
}, iV = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartMenuSvc";
  }
  wireBeans(e) {
    this.advSettingsMenuFactory = e.advSettingsMenuFactory;
  }
  downloadChart(e, t, s, i) {
    e.chartController.getChartProxy().downloadChart(t, s, i);
  }
  toggleLinked(e) {
    e.chartController.detachChartRange();
  }
  openAdvancedSettings(e, t) {
    var s;
    (s = this.advSettingsMenuFactory) == null || s.showMenu(e, t);
  }
  hideAdvancedSettings() {
    var e;
    (e = this.advSettingsMenuFactory) == null || e.hideMenu();
  }
  getChartToolbarOptions() {
    const e = ["chartMenu"], t = this.gos.getCallback("getChartToolbarItems");
    return t ? t({
      defaultItems: e
    }).filter((i) => sV.includes(i) ? !0 : (R(155, { option: i }), !1)) : e;
  }
  getChartToolPanels(e) {
    var n;
    const t = this.gos.get("chartToolPanelsDef");
    let i = ((n = t == null ? void 0 : t.panels) == null ? void 0 : n.map((a) => {
      const l = ao[a];
      return l || R(156, { panel: a }), l;
    }).filter((a) => !!a)) ?? Object.values(ao);
    e.isPivotChart() && (i = i.filter((a) => a !== "chartData"));
    const r = t == null ? void 0 : t.defaultToolPanel, o = r && ao[r] || i[0];
    return {
      panels: i,
      defaultPanel: o
    };
  }
  doesChartToolbarExist() {
    return this.getChartToolbarOptions().length > 0;
  }
  doChartToolPanelsExist(e) {
    const { panels: t } = this.getChartToolPanels(e);
    return t.length > 0;
  }
}, rV = {
  pivotChartTitle: "Pivot Chart",
  rangeChartTitle: "Range Chart",
  settings: "Chart",
  data: "Set Up",
  format: "Customize",
  categories: "Categories",
  defaultCategory: "(None)",
  series: "Series",
  switchCategorySeries: "Switch Category / Series",
  categoryValues: "Category Values",
  seriesLabels: "Series Labels",
  aggregate: "Aggregate",
  xyValues: "X Y Values",
  paired: "Paired Mode",
  axis: "Axis",
  xAxis: "Horizontal Axis",
  yAxis: "Vertical Axis",
  polarAxis: "Polar Axis",
  radiusAxis: "Radius Axis",
  navigator: "Navigator",
  zoom: "Zoom",
  animation: "Animation",
  crosshair: "Crosshair",
  color: "Color",
  thickness: "Thickness",
  preferredLength: "Preferred Length",
  xType: "X Type",
  axisType: "Axis Type",
  automatic: "Automatic",
  category: "Category",
  number: "Number",
  time: "Time",
  timeFormat: "Time Format",
  autoRotate: "Auto Rotate",
  labelRotation: "Rotation",
  circle: "Circle",
  polygon: "Polygon",
  square: "Square",
  cross: "Cross",
  diamond: "Diamond",
  plus: "Plus",
  triangle: "Triangle",
  heart: "Heart",
  orientation: "Orientation",
  fixed: "Fixed",
  parallel: "Parallel",
  perpendicular: "Perpendicular",
  radiusAxisPosition: "Position",
  ticks: "Ticks",
  gridLines: "Grid Lines",
  width: "Width",
  height: "Height",
  length: "Length",
  padding: "Padding",
  spacing: "Spacing",
  chartStyle: "Chart Style",
  title: "Title",
  chartTitles: "Titles",
  chartTitle: "Chart Title",
  chartSubtitle: "Subtitle",
  horizontalAxisTitle: "Horizontal Axis Title",
  verticalAxisTitle: "Vertical Axis Title",
  polarAxisTitle: "Polar Axis Title",
  titlePlaceholder: "Chart Title",
  background: "Background",
  font: "Font",
  weight: "Weight",
  top: "Top",
  right: "Right",
  bottom: "Bottom",
  left: "Left",
  labels: "Labels",
  calloutLabels: "Callout Labels",
  sectorLabels: "Sector Labels",
  positionRatio: "Position Ratio",
  size: "Size",
  shape: "Shape",
  minSize: "Minimum Size",
  maxSize: "Maximum Size",
  legend: "Legend",
  position: "Position",
  markerSize: "Marker Size",
  markerStroke: "Marker Stroke",
  markerPadding: "Marker Padding",
  itemSpacing: "Item Spacing",
  itemPaddingX: "Item Padding X",
  itemPaddingY: "Item Padding Y",
  layoutHorizontalSpacing: "Horizontal Spacing",
  layoutVerticalSpacing: "Vertical Spacing",
  strokeWidth: "Stroke Width",
  offset: "Offset",
  offsets: "Offsets",
  tooltips: "Tooltips",
  callout: "Callout",
  markers: "Markers",
  shadow: "Shadow",
  blur: "Blur",
  xOffset: "X Offset",
  yOffset: "Y Offset",
  lineWidth: "Line Width",
  lineDash: "Line Dash",
  lineDashOffset: "Dash Offset",
  scrollingZoom: "Scrolling",
  scrollingStep: "Scrolling Step",
  selectingZoom: "Selecting",
  durationMillis: "Duration (ms)",
  crosshairLabel: "Label",
  crosshairSnap: "Snap to Node",
  normal: "Normal",
  bold: "Bold",
  italic: "Italic",
  boldItalic: "Bold Italic",
  predefined: "Predefined",
  fillOpacity: "Fill Opacity",
  strokeColor: "Line Color",
  strokeOpacity: "Line Opacity",
  miniChart: "Mini-Chart",
  histogramBinCount: "Bin count",
  connectorLine: "Connector Line",
  seriesItems: "Series Items",
  seriesItemType: "Item Type",
  seriesItemPositive: "Positive",
  seriesItemNegative: "Negative",
  seriesItemLabels: "Item Labels",
  columnGroup: "Column",
  barGroup: "Bar",
  pieGroup: "Pie",
  lineGroup: "Line",
  scatterGroup: "X Y (Scatter)",
  areaGroup: "Area",
  polarGroup: "Polar",
  statisticalGroup: "Statistical",
  hierarchicalGroup: "Hierarchical",
  specializedGroup: "Specialized",
  combinationGroup: "Combination",
  groupedColumnTooltip: "Grouped",
  stackedColumnTooltip: "Stacked",
  normalizedColumnTooltip: "100% Stacked",
  groupedBarTooltip: "Grouped",
  stackedBarTooltip: "Stacked",
  normalizedBarTooltip: "100% Stacked",
  pieTooltip: "Pie",
  donutTooltip: "Donut",
  lineTooltip: "Line",
  stackedLineTooltip: "Stacked",
  normalizedLineTooltip: "100% Stacked",
  groupedAreaTooltip: "Area",
  stackedAreaTooltip: "Stacked",
  normalizedAreaTooltip: "100% Stacked",
  scatterTooltip: "Scatter",
  bubbleTooltip: "Bubble",
  histogramTooltip: "Histogram",
  radialColumnTooltip: "Radial Column",
  radialBarTooltip: "Radial Bar",
  radarLineTooltip: "Radar Line",
  radarAreaTooltip: "Radar Area",
  nightingaleTooltip: "Nightingale",
  rangeBarTooltip: "Range Bar",
  rangeAreaTooltip: "Range Area",
  boxPlotTooltip: "Box Plot",
  treemapTooltip: "Treemap",
  sunburstTooltip: "Sunburst",
  waterfallTooltip: "Waterfall",
  heatmapTooltip: "Heatmap",
  columnLineComboTooltip: "Column & Line",
  areaColumnComboTooltip: "Area & Column",
  customComboTooltip: "Custom Combination",
  innerRadius: "Inner Radius",
  startAngle: "Start Angle",
  endAngle: "End Angle",
  reverseDirection: "Reverse Direction",
  groupPadding: "Group Padding",
  seriesPadding: "Series Padding",
  tile: "Tile",
  whisker: "Whisker",
  cap: "Cap",
  capLengthRatio: "Length Ratio",
  labelPlacement: "Placement",
  inside: "Inside",
  outside: "Outside",
  noDataToChart: "No data available to be charted.",
  pivotChartRequiresPivotMode: "Pivot Chart requires Pivot Mode enabled.",
  chartSettingsToolbarTooltip: "Menu",
  chartLinkToolbarTooltip: "Linked to Grid",
  chartUnlinkToolbarTooltip: "Unlinked from Grid",
  chartDownloadToolbarTooltip: "Download Chart",
  chartMenuToolbarTooltip: "Menu",
  chartEdit: "Edit Chart",
  chartAdvancedSettings: "Advanced Settings",
  chartLink: "Link to Grid",
  chartUnlink: "Unlink from Grid",
  chartDownload: "Download Chart",
  histogramFrequency: "Frequency",
  seriesChartType: "Series Chart Type",
  seriesType: "Series Type",
  secondaryAxis: "Secondary Axis",
  seriesAdd: "Add a series",
  categoryAdd: "Add a category",
  bar: "Bar",
  column: "Column",
  histogram: "Histogram",
  advancedSettings: "Advanced Settings",
  direction: "Direction",
  horizontal: "Horizontal",
  vertical: "Vertical",
  seriesGroupType: "Group Type",
  groupedSeriesGroupType: "Grouped",
  stackedSeriesGroupType: "Stacked",
  normalizedSeriesGroupType: "100% Stacked",
  legendEnabled: "Enabled",
  invalidColor: "Color value is invalid",
  groupedColumnFull: "Grouped Column",
  stackedColumnFull: "Stacked Column",
  normalizedColumnFull: "100% Stacked Column",
  groupedBarFull: "Grouped Bar",
  stackedBarFull: "Stacked Bar",
  normalizedBarFull: "100% Stacked Bar",
  stackedAreaFull: "Stacked Area",
  normalizedAreaFull: "100% Stacked Area",
  stackedLineFull: "Stacked Line",
  normalizedLineFull: "100% Stacked Line",
  customCombo: "Custom Combination",
  // menu items
  groupedColumn: "Grouped",
  stackedColumn: "Stacked",
  pie: "Pie",
  donut: "Donut",
  line: "Line",
  scatter: "Scatter",
  bubble: "Bubble",
  area: "Area",
  stackedArea: "Stacked",
  radarLine: "Radar Line",
  radarArea: "Radar Area",
  nightingale: "Nightingale",
  radialColumn: "Radial Column",
  radialBar: "Radial Bar",
  boxPlot: "Box Plot",
  rangeBar: "Range Bar",
  rangeArea: "Range Area",
  treemap: "Treemap",
  sunburst: "Sunburst",
  waterfall: "Waterfall",
  heatmap: "Heatmap",
  columnLineCombo: "Column & Line",
  AreaColumnCombo: "Area & Column",
  // aria
  ariaChartMenuClose: "Close Chart Edit Menu",
  ariaChartSelected: "Selected",
  // group
  group: "Group",
  // time formats
  timeFormatSlashesDDMMYYYY: "DD/MM/YYYY",
  timeFormatSlashesMMDDYYYY: "MM/DD/YYYY",
  timeFormatSlashesDDMMYY: "DD/MM/YY",
  timeFormatSlashesMMDDYY: "MM/DD/YY",
  timeFormatDotsDDMYY: "DD.M.YY",
  timeFormatDotsMDDYY: "M.DD.YY",
  timeFormatDashesYYYYMMDD: "YYYY-MM-DD",
  timeFormatSpacesDDMMMMYYYY: "DD MMMM YYYY",
  timeFormatHHMMSS: "HH:MM:SS",
  timeFormatHHMMSSAmPm: "HH:MM:SS AM/PM",
  // agg funcs
  sum: "Sum",
  first: "First",
  last: "Last",
  min: "Min",
  max: "Max",
  count: "Count",
  avg: "Average"
}, oV = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartTranslation";
  }
  translate(e) {
    const t = this.getLocaleTextFunc(), s = rV[e];
    return t(e, s);
  }
}, Gi = (e) => (t) => t == null ? !0 : e(t), jc = (e) => typeof e == "string", Nf = (e) => typeof e == "boolean", nV = (e) => typeof e == "object", Ut = (e, t) => (s) => `AG Grid - unable to update chart as invalid params supplied:  \`${e}: ${s}\`, expected ${t}.`, Hf = (e) => `${e} is not supported in AG Charts Community ('ag-charts-enterprise' hasn't been loaded). See https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/ for more details.`, aV = ["doughnut"], id = [
  "type",
  "chartId",
  "chartType",
  "chartThemeName",
  "chartThemeOverrides",
  "unlinkChart"
];
function lV(e) {
  return !!Mf(e) || Jl(e);
}
function dV(e) {
  return aV.includes(e);
}
var cV = Gi(
  (e) => {
    if (lV(e))
      return !0;
    if (dV(e)) {
      const t = yr(e);
      return kt(`The chart type '${e}' has been deprecated. Please use '${t}' instead.`), t;
    }
    return !1;
  }
), hV = Gi((e) => typeof e == "object"), uV = Gi((e) => typeof e == "object"), pV = Gi((e) => typeof e == "string" || typeof e == "function"), zf = (e) => ({
  property: "chartType",
  validationFn: Gi(
    (t) => e || !t || !nB(t)
  ),
  warnMessage: (t) => Hf(`The '${t}' chart type`)
}), Wf = (e) => ({
  property: "switchCategorySeries",
  validationFn: Gi((t) => {
    if (!t || e)
      return !0;
  }),
  warnMessage: () => Hf("'switchCategorySeries' has been ignored as it"),
  warnIfFixed: !0
}), rd = () => [
  { property: "chartId", validationFn: jc, warnMessage: Ut("chartId", "string") },
  {
    property: "chartType",
    validationFn: cV,
    warnMessage: Ut("chartType", "ChartType")
  },
  {
    property: "chartThemeName",
    validationFn: jc,
    warnMessage: Ut("chartThemeName", "string")
  },
  {
    property: "chartThemeOverrides",
    validationFn: hV,
    warnMessage: Ut("chartThemeOverrides", "AgChartThemeOverrides")
  },
  { property: "unlinkChart", validationFn: Nf, warnMessage: Ut("unlinkChart", "boolean") }
], _f = (e) => [
  {
    property: "cellRange",
    validationFn: uV,
    warnMessage: Ut("cellRange", "ChartParamsCellRange")
  },
  {
    property: "suppressChartRanges",
    validationFn: Nf,
    warnMessage: Ut("suppressChartRanges", "boolean")
  },
  {
    property: "aggFunc",
    validationFn: pV,
    warnMessage: Ut("aggFunc", "string or IAggFunc")
  },
  Wf(e)
];
function gV(e, t) {
  switch (e.type) {
    case "rangeChartUpdate":
      return mV(e, t);
    case "pivotChartUpdate":
      return CV(e);
    case "crossFilterChartUpdate":
      return vV(e, t);
    default:
      return kt(
        `Invalid value supplied for 'type': ${e.type}. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`
      ), !1;
  }
}
function fV(e, t) {
  return yn(e, [
    zf(t),
    Wf(t)
  ]);
}
function mV(e, t) {
  const s = [
    ...rd(),
    zf(t),
    ..._f(t),
    {
      property: "seriesChartTypes",
      validationFn: (i) => i === void 0 || Array.isArray(i) && i.every(nV),
      warnMessage: Ut("seriesChartTypes", "Array of SeriesChartType")
    }
  ];
  return yn(
    e,
    s,
    [
      ...id,
      "cellRange",
      "suppressChartRanges",
      "switchCategorySeries",
      "aggFunc",
      "seriesChartTypes",
      "seriesGroupType"
    ],
    "UpdateRangeChartParams"
  );
}
function CV(e) {
  const t = [...rd()];
  return yn(e, t, [...id], "UpdatePivotChartParams");
}
function vV(e, t) {
  const s = [
    ...rd(),
    ..._f(t)
  ];
  return yn(
    e,
    s,
    [...id, "cellRange", "suppressChartRanges", "aggFunc"],
    "UpdateCrossFilterChartParams"
  );
}
function yn(e, t, s, i) {
  let r;
  for (const o of t) {
    const { property: n, validationFn: a, warnMessage: l, warnIfFixed: d } = o;
    if (n in e) {
      const c = e[n], h = a(c);
      if (h === !0)
        continue;
      if (h === !1)
        return kt(l(c)), !1;
      r = r || { ...e }, r[n] = h, d && kt(l(c));
    }
  }
  if (s) {
    for (const o of Object.keys(e))
      if (!s.includes(o))
        return kt(`Unexpected property supplied. ${i} does not contain: \`${o}\`.`), !1;
  }
  return r || !0;
}
var Uf = ["ag-default", "ag-material", "ag-sheets", "ag-polychroma", "ag-vivid"], wV = class extends P {
  constructor(e) {
    super(), this.model = e, this.isEnterprise = () => this.agChartsExports.isEnterprise;
  }
  wireBeans(e) {
    this.rangeSvc = e.rangeSvc, this.agChartsExports = e.agChartsExports;
  }
  postConstruct() {
    this.setChartRange(), this.model.unlinked && this.rangeSvc && this.rangeSvc.setCellRanges([]);
    const e = this.updateForGridChange.bind(this, {});
    this.addManagedEventListeners({
      cellSelectionChanged: (t) => {
        t.id && t.id === this.model.chartId && this.updateForRangeChange();
      },
      columnMoved: e,
      columnPinned: e,
      columnVisible: e,
      columnRowGroupChanged: e,
      modelUpdated: e,
      cellValueChanged: this.updateForDataChange.bind(this)
    });
  }
  update(e) {
    if (!this.validUpdateType(e))
      return !1;
    const t = gV(e, this.agChartsExports.isEnterprise);
    if (!t)
      return !1;
    const s = t === !0 ? e : t;
    return this.applyValidatedChartParams(s), !0;
  }
  applyValidatedChartParams(e) {
    var l;
    const { chartId: t, chartType: s, chartThemeName: i, unlinkChart: r } = e, n = { ...{
      chartId: t,
      pivotChart: this.model.pivotChart,
      chartType: s ?? this.model.chartType,
      chartThemeName: i ?? this.model.chartThemeName,
      unlinkChart: r ?? this.model.unlinked,
      cellRange: this.model.suppliedCellRange,
      switchCategorySeries: this.model.switchCategorySeries,
      aggFunc: this.model.aggFunc,
      seriesChartTypes: void 0,
      suppressChartRanges: !1,
      crossFiltering: !1
    } };
    switch (e.type) {
      case "rangeChartUpdate":
        n.cellRange = this.createCellRange(e) ?? this.model.suppliedCellRange, n.switchCategorySeries = e.switchCategorySeries ?? this.model.switchCategorySeries, n.aggFunc = e.aggFunc ?? this.model.aggFunc, n.seriesChartTypes = e.seriesChartTypes, n.suppressChartRanges = e.suppressChartRanges ?? this.model.suppressChartRanges, n.seriesGroupType = e.seriesGroupType ?? this.model.seriesGroupType;
        break;
      case "crossFilterChartUpdate":
        n.cellRange = this.createCellRange(e) ?? this.model.suppliedCellRange, n.switchCategorySeries = !1, n.aggFunc = e.aggFunc ?? this.model.aggFunc, n.crossFiltering = !0, n.suppressChartRanges = e.suppressChartRanges ?? this.model.suppressChartRanges;
        break;
      case "pivotChartUpdate":
        n.switchCategorySeries = !1;
        break;
    }
    this.model.updateModel(n), n.unlinkChart || n.suppressChartRanges ? (l = this.rangeSvc) == null || l.setCellRanges([]) : this.setChartRange();
  }
  updateForGridChange(e) {
    if (this.model.unlinked)
      return;
    const { maintainColState: t, setColsFromRange: s } = e ?? {};
    this.model.updateCellRanges({ maintainColState: t, setColsFromRange: s }), this.model.updateData(), this.setChartRange();
  }
  updateForDataChange() {
    this.model.unlinked || (this.model.updateData(), this.raiseChartModelUpdateEvent());
  }
  updateForRangeChange() {
    this.updateForGridChange({ setColsFromRange: !0 }), this.raiseChartRangeSelectionChangedEvent();
  }
  updateForPanelChange(e) {
    this.model.updateCellRanges(e), this.model.updateData(), e.skipAnimation && this.getChartProxy().getChartRef().skipAnimations(), this.setChartRange(), this.raiseChartRangeSelectionChangedEvent();
  }
  updateThemeOverrides(e) {
    this.chartProxy.updateThemeOverrides(e);
  }
  getChartUpdateParams(e) {
    const s = this.getSelectedValueColState().map((n) => ({ colId: n.colId, displayName: n.displayName })), i = this.getChartData(), r = this.getSelectedDimensions(), o = {
      data: i,
      groupData: this.model.groupChartData,
      grouping: this.isGrouping(),
      categories: r.map((n) => ({
        id: n.colId,
        name: n.displayName,
        chartDataType: this.model.categoryAxisType ?? this.model.getChartDataType(n.colId)
      })),
      fields: s,
      chartId: this.getChartId(),
      getCrossFilteringContext: () => ({ lastSelectedChartId: "xxx" }),
      //this.params.crossFilteringContext, //TODO
      seriesChartTypes: this.getSeriesChartTypes(),
      updatedOverrides: e,
      seriesGroupType: this.model.seriesGroupType
    };
    return this.isCategorySeriesSwitched() ? this.invertCategorySeriesParams(o) : o;
  }
  invertCategorySeriesParams(e) {
    const [t] = e.categories, s = [{ id: Vt, name: "" }], i = e.data.map((o, n) => {
      const a = `${t.id}:${n}`, l = o[t.id], d = l == null ? "" : String(l);
      return { colId: a, displayName: d };
    }), r = e.fields.map((o) => {
      const n = {
        [Vt]: o.displayName
      };
      for (const [a, l] of e.data.entries()) {
        const d = `${t.id}:${a}`, c = l[o.colId];
        n[d] = c;
      }
      return n;
    });
    return {
      ...e,
      categories: s,
      fields: i,
      data: r
    };
  }
  getChartModel() {
    const e = this.model.pivotChart ? "pivot" : "range", t = this.isComboChart() ? this.model.comboChartModel.seriesChartTypes : void 0;
    return {
      modelType: e,
      chartId: this.model.chartId,
      chartType: this.model.chartType,
      chartThemeName: this.getChartThemeName(),
      chartOptions: this.chartProxy.getChartThemeOverrides(),
      chartPalette: this.chartProxy.getChartPalette(),
      cellRange: this.getCellRangeParams(),
      switchCategorySeries: this.model.switchCategorySeries,
      suppressChartRanges: this.model.suppressChartRanges,
      aggFunc: this.model.aggFunc,
      unlinkChart: this.model.unlinked,
      seriesChartTypes: t,
      seriesGroupType: this.model.seriesGroupType
    };
  }
  getChartId() {
    return this.model.chartId;
  }
  getChartData() {
    return this.model.chartData;
  }
  getChartType() {
    return this.model.chartType;
  }
  setChartType(e) {
    this.updateMultiSeriesAndCategory(this.model.chartType, e), this.model.chartType = e, this.model.comboChartModel.updateSeriesChartTypes(), this.model.switchCategorySeries = !1, this.model.categoryAxisType = void 0, this.model.seriesGroupType = void 0, this.raiseChartModelUpdateEvent(), this.raiseChartOptionsChangedEvent();
  }
  isCategorySeriesSwitched() {
    return this.model.switchCategorySeries && !this.model.isGrouping();
  }
  switchCategorySeries(e) {
    If(this.getChartType()) && (this.model.switchCategorySeries = e, this.raiseChartModelUpdateEvent());
  }
  getAggFunc() {
    return this.model.aggFunc;
  }
  setAggFunc(e, t) {
    this.model.aggFunc !== e && (this.model.aggFunc = e, !t && (this.model.updateData(), this.raiseChartModelUpdateEvent()));
  }
  updateMultiSeriesAndCategory(e, t) {
    const s = (a, l) => {
      let d = 0;
      for (const c of a)
        c.selected && (d >= l ? c.selected = !1 : d++);
      d === 0 && (a[0].selected = !0);
    }, i = qa(t), r = Bo(t), o = i != null && (qa(e) ?? 100) > (i ?? 100), n = r != null && (Bo(e) ?? 100) > (r ?? 100);
    o && s(this.model.dimensionColState, i), n && s(this.model.valueColState, r), (o || n) && (this.model.resetCellRanges(o, n), this.setChartRange(!0));
  }
  setChartThemeName(e, t) {
    this.model.chartThemeName = e, t || (this.raiseChartModelUpdateEvent(), this.raiseChartOptionsChangedEvent());
  }
  getChartThemeName() {
    return this.model.chartThemeName;
  }
  isPivotChart() {
    return this.model.pivotChart;
  }
  isPivotMode() {
    return this.model.isPivotMode();
  }
  isGrouping() {
    return this.model.isGrouping();
  }
  isCrossFilterChart() {
    return this.model.crossFiltering;
  }
  getThemeNames() {
    return this.gos.get("chartThemes") || Uf;
  }
  getThemes() {
    return this.getThemeNames().map((t) => {
      const i = td(t, this.agChartsExports._Theme) ? t : this.chartProxy.lookupCustomChartTheme(t);
      return this.agChartsExports._Theme.getChartTheme(i);
    });
  }
  getPalettes() {
    return this.getThemes().map((t) => t.palette);
  }
  getThemeTemplateParameters() {
    return this.getThemes().map((t) => t.getTemplateParameters());
  }
  getValueColState() {
    return this.model.valueColState.map(this.displayNameMapper.bind(this));
  }
  getSelectedValueColState() {
    return this.getValueColState().filter((e) => e.selected);
  }
  getSelectedDimensions() {
    return this.model.getSelectedDimensions();
  }
  displayNameMapper(e) {
    const { column: t } = e;
    if (t)
      e.displayName = this.model.getColDisplayName(t, this.model.isPivotMode());
    else {
      const s = this.model.colNames[e.colId];
      e.displayName = s ? s.join(" - ") : this.model.getColDisplayName(t);
    }
    return e;
  }
  getColStateForMenu() {
    return { dimensionCols: this.model.dimensionColState, valueCols: this.getValueColState() };
  }
  setChartRange(e = !1) {
    this.rangeSvc && !this.model.suppressChartRanges && !this.model.unlinked && this.rangeSvc.setCellRanges(this.getCellRanges()), e || this.raiseChartModelUpdateEvent();
  }
  detachChartRange() {
    this.model.unlinked = !this.model.unlinked, this.model.unlinked ? this.rangeSvc && this.rangeSvc.setCellRanges([]) : this.updateForGridChange(), this.dispatchLocalEvent({ type: "chartLinkedChanged" });
  }
  setChartProxy(e) {
    this.chartProxy = e;
  }
  getChartProxy() {
    return this.chartProxy;
  }
  isActiveXYChart() {
    return ["scatter", "bubble"].includes(this.getChartType());
  }
  isChartLinked() {
    return !this.model.unlinked;
  }
  customComboExists() {
    const e = this.model.comboChartModel.savedCustomSeriesChartTypes;
    return e && e.length > 0;
  }
  getSeriesChartTypes() {
    return this.model.comboChartModel.seriesChartTypes;
  }
  isComboChart(e) {
    return this.model.isComboChart(e);
  }
  updateSeriesChartType(e, t, s) {
    const i = this.model.comboChartModel.seriesChartTypes.find((r) => r.colId === e);
    if (i) {
      const r = this.model.chartType !== "customCombo";
      r && (this.model.chartType = "customCombo");
      const o = i.chartType;
      t != null && (i.chartType = t), s != null && (i.secondaryAxis = s), this.model.comboChartModel.savedCustomSeriesChartTypes = this.model.comboChartModel.seriesChartTypes, this.model.comboChartModel.updateSeriesChartTypes(), this.updateForDataChange(), r && this.dispatchLocalEvent({
        type: "chartTypeChanged"
      }), o !== t && this.dispatchLocalEvent({
        type: "chartSeriesChartTypeChanged"
      }), this.raiseChartOptionsChangedEvent();
    }
  }
  getActiveSeriesChartTypes() {
    const e = this.getSelectedValueColState().map((t) => t.colId);
    return this.getSeriesChartTypes().filter((t) => e.includes(t.colId));
  }
  getChartSeriesTypes(e) {
    const t = e ?? this.getChartType();
    return this.isComboChart(t) ? ["line", "bar", "area"] : [ne(t)];
  }
  getChartSeriesType() {
    const e = this.getSeriesChartTypes();
    if (e.length === 0)
      return "bar";
    const t = e[0].chartType;
    return t === "columnLineCombo" ? "bar" : t === "areaColumnCombo" ? "area" : ne(t);
  }
  getCellRanges() {
    return [this.model.dimensionCellRange, this.model.valueCellRange].filter((e) => e);
  }
  createCellRange(e) {
    var t;
    return e.cellRange && ((t = this.rangeSvc) == null ? void 0 : t.createPartialCellRangeFromRangeParams(e.cellRange, !0));
  }
  validUpdateType(e) {
    if (!e.type)
      return R(136), !1;
    const t = {
      "Range Chart": () => !this.isPivotChart() && !this.isCrossFilterChart(),
      "Pivot Chart": () => this.isPivotChart(),
      "Cross Filter Chart": () => this.isCrossFilterChart()
    }, s = Object.keys(t).find((r) => t[r]()) ?? "Range Chart", i = e.type === `${s[0].toLowerCase()}${s.slice(1).replace(/ /g, "")}Update`;
    return i || R(137, { currentChartType: s, type: e.type }), i;
  }
  getCellRangeParams() {
    const e = this.getCellRanges(), t = e[0], s = t && t.startRow || null, i = t && t.endRow || null;
    return {
      rowStartIndex: s && s.rowIndex,
      rowStartPinned: s && s.rowPinned,
      rowEndIndex: i && i.rowIndex,
      rowEndPinned: i && i.rowPinned,
      columns: e.reduce(
        (r, o) => r.concat(o.columns.map((n) => n.getId())),
        []
      )
    };
  }
  setCategoryAxisType(e) {
    this.model.categoryAxisType = e, this.raiseChartModelUpdateEvent();
  }
  getSeriesGroupType() {
    return this.model.seriesGroupType ?? this.chartProxy.getSeriesGroupType();
  }
  setSeriesGroupType(e) {
    this.model.seriesGroupType = e, this.raiseChartModelUpdateEvent();
  }
  raiseChartModelUpdateEvent() {
    this.dispatchLocalEvent({ type: "chartModelUpdate" });
  }
  raiseChartUpdatedEvent() {
    this.dispatchLocalEvent({ type: "chartUpdated" });
  }
  raiseChartApiUpdateEvent() {
    this.dispatchLocalEvent({ type: "chartApiUpdate" });
  }
  raiseChartOptionsChangedEvent() {
    const { chartId: e, chartType: t } = this.getChartModel();
    this.eventSvc.dispatchEvent({
      type: "chartOptionsChanged",
      chartId: e,
      chartType: t,
      chartThemeName: this.getChartThemeName(),
      chartOptions: this.chartProxy.getChartThemeOverrides()
    });
  }
  raiseChartRangeSelectionChangedEvent() {
    this.eventSvc.dispatchEvent({
      type: "chartRangeSelectionChanged",
      id: this.model.chartId,
      chartId: this.model.chartId,
      cellRange: this.getCellRangeParams()
    });
  }
  destroy() {
    super.destroy(), this.rangeSvc && this.rangeSvc.setCellRanges([]);
  }
}, yV = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = [
      {
        type: this.getXAxisType(e),
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
    if (this.isNormalised()) {
      const s = t[1];
      s.label = { ...s.label, formatter: (i) => Math.round(i.value) + "%" };
    }
    return t;
  }
  getSeries(e) {
    const [t] = e.categories, s = e.fields.map(
      (i) => ({
        type: this.standaloneChartType,
        xKey: t.id,
        xName: t.name,
        yKey: i.colId,
        yName: i.displayName,
        normalizedTo: this.chartType === "normalizedArea" ? 100 : void 0,
        stacked: ["normalizedArea", "stackedArea"].includes(this.chartType)
      })
    );
    return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(s, e) : s;
  }
  isNormalised() {
    return !this.crossFiltering && this.chartType === "normalizedArea";
  }
};
function qc(e, t) {
  const s = parseInt(e.slice(1, 3), 16), i = parseInt(e.slice(3, 5), 16), r = parseInt(e.slice(5, 7), 16);
  return t ? `rgba(${s}, ${i}, ${r}, ${t})` : `rgba(${s}, ${i}, ${r})`;
}
var bV = /* @__PURE__ */ new Set(["bar", "groupedBar", "stackedBar", "normalizedBar"]), SV = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = [
      {
        type: this.getXAxisType(e),
        position: this.isHorizontal() ? "left" : "bottom"
      },
      {
        type: "number",
        position: this.isHorizontal() ? "bottom" : "left"
      }
    ];
    if (this.isNormalised()) {
      const s = t[1];
      s.label = { ...s.label, formatter: (i) => Math.round(i.value) + "%" };
    }
    return t;
  }
  getSeries(e) {
    const [t] = e.categories, s = e.fields.map(
      (i) => ({
        type: this.standaloneChartType,
        direction: this.isHorizontal() ? "horizontal" : "vertical",
        stacked: this.crossFiltering || lB(this.chartType),
        normalizedTo: this.isNormalised() ? 100 : void 0,
        xKey: t.id,
        xName: t.name,
        yKey: i.colId,
        yName: i.displayName
      })
    );
    return this.crossFiltering ? this.extractCrossFilterSeries(s) : s;
  }
  extractCrossFilterSeries(e) {
    const t = this.getChartPalette(), s = (o, n) => {
      var a, l;
      return {
        ...o,
        highlightStyle: { item: { fill: void 0 } },
        fill: (a = t == null ? void 0 : t.fills) == null ? void 0 : a[n],
        stroke: (l = t == null ? void 0 : t.strokes) == null ? void 0 : l[n],
        listeners: {
          nodeClick: this.crossFilterCallback
        }
      };
    }, i = (o) => {
      const n = o.yKey + "-filtered-out";
      return {
        ...o,
        yKey: n,
        fill: qc(o.fill, "0.3"),
        stroke: qc(o.stroke, "0.3"),
        showInLegend: !1
      };
    }, r = [];
    for (let o = 0; o < e.length; o++) {
      const n = e[o];
      r.push(s(n, o)), r.push(i(s(n, o)));
    }
    return r;
  }
  isNormalised() {
    const e = ["normalizedColumn", "normalizedBar"];
    return !this.crossFiltering && e.includes(this.chartType);
  }
  isHorizontal() {
    return bV.has(this.chartType);
  }
}, xV = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = [
      {
        type: this.getXAxisType(e),
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
    if (this.isNormalised()) {
      const s = t[1];
      s.label = { ...s.label, formatter: (i) => Math.round(i.value) + "%" };
    }
    return t;
  }
  getSeries(e) {
    const [t] = e.categories, s = ["normalizedLine", "stackedLine"].includes(this.chartType), i = e.fields.map(
      (r) => ({
        type: this.standaloneChartType,
        xKey: t.id,
        xName: t.name,
        yKey: r.colId,
        yName: r.displayName,
        normalizedTo: s && this.isNormalised() ? 100 : void 0,
        stacked: s
      })
    );
    return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(i, e) : i;
  }
  isNormalised() {
    const e = ["normalizedLine"];
    return !this.crossFiltering && e.includes(this.chartType);
  }
}, FV = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    return [
      {
        type: "number",
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
  }
  getSeries(e) {
    const [t] = e.categories, s = this.isPaired(), i = this.getSeriesDefinitions(e.fields, s), r = t.id === Vt ? void 0 : t, o = i.map((n) => n != null && n.sizeField ? {
      type: "bubble",
      xKey: n.xField.colId,
      xName: n.xField.displayName ?? void 0,
      yKey: n.yField.colId,
      yName: n.yField.displayName ?? void 0,
      title: `${n.yField.displayName} vs ${n.xField.displayName}`,
      sizeKey: n.sizeField.colId,
      sizeName: n.sizeField.displayName ?? "",
      labelKey: r ? r.id : n.yField.colId,
      labelName: r ? r.name : void 0
    } : {
      type: "scatter",
      xKey: n.xField.colId,
      xName: n.xField.displayName ?? void 0,
      yKey: n.yField.colId,
      yName: n.yField.displayName ?? void 0,
      title: `${n.yField.displayName} vs ${n.xField.displayName}`,
      labelKey: r ? r.id : n.yField.colId,
      labelName: r ? r.name : void 0
    });
    return this.crossFiltering ? this.extractCrossFilterSeries(o, e) : o;
  }
  extractCrossFilterSeries(e, t) {
    const { data: s } = t, i = this.getChartPalette(), r = (d) => `${d}-filtered-out`, o = (d, c) => {
      const h = [1 / 0, -1 / 0];
      if (c != null)
        for (const u of d) {
          const p = u[c] ?? u[r(c)];
          p < h[0] && (h[0] = p), p > h[1] && (h[1] = p);
        }
      if (h[0] <= h[1])
        return h;
    }, n = (d, c) => {
      var g, f;
      const h = (g = i == null ? void 0 : i.fills) == null ? void 0 : g[c], u = (f = i == null ? void 0 : i.strokes) == null ? void 0 : f[c];
      let p;
      if (d.type === "bubble") {
        const { sizeKey: m } = d;
        p = o(s, m);
      }
      return {
        ...d,
        fill: h,
        stroke: u,
        domain: p,
        highlightStyle: { item: { fill: "yellow" } },
        listeners: {
          ...d.listeners,
          nodeClick: this.crossFilterCallback
        }
      };
    }, a = (d) => {
      const { yKey: c, xKey: h } = d;
      let u = {};
      return d.type === "bubble" && (u = { sizeKey: r(d.sizeKey) }), {
        ...d,
        ...u,
        yKey: r(c),
        xKey: r(h),
        fillOpacity: 0.3,
        strokeOpacity: 0.3,
        showInLegend: !1,
        listeners: {
          ...d.listeners,
          nodeClick: (p) => {
            const g = p.datum[r(h)], f = {
              ...p,
              xKey: h,
              datum: { ...p.datum, [h]: g }
            };
            this.crossFilterCallback(f);
          }
        }
      };
    }, l = e.map(n);
    return [...l, ...l.map(a)];
  }
  getSeriesDefinitions(e, t) {
    if (e.length < 2)
      return [];
    const s = this.chartType === "bubble";
    if (t)
      return s ? e.map(
        (r, o) => o % 3 === 0 ? {
          xField: r,
          yField: e[o + 1],
          sizeField: e[o + 2]
        } : null
      ).filter((r) => r && r.yField && r.sizeField) : e.map(
        (r, o) => o % 2 === 0 ? {
          xField: r,
          yField: e[o + 1]
        } : null
      ).filter((r) => r && r.yField);
    const i = e[0];
    return s ? e.map(
      (r, o) => o % 2 === 1 ? {
        xField: i,
        yField: r,
        sizeField: e[o + 1]
      } : null
    ).filter((r) => r && r.sizeField) : e.filter((r, o) => o > 0).map((r) => ({ xField: i, yField: r }));
  }
}, RV = class extends Ms {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = e ? e.fields : [], s = new Map(t.map((n) => [n.colId, n])), { primaryYKeys: i, secondaryYKeys: r } = this.getYKeys(t, e.seriesChartTypes), o = [
      {
        type: this.getXAxisType(e),
        position: "bottom"
      }
    ];
    return i.length > 0 && o.push({
      type: "number",
      keys: i,
      position: "left"
    }), r.length > 0 && r.forEach((n) => {
      const a = s.get(n);
      if (!(a && a.colId === n))
        return;
      const d = {
        type: "number",
        keys: [n],
        position: "right"
      };
      o.push(d);
    }), o;
  }
  getSeries(e) {
    const { fields: t, seriesChartTypes: s } = e, [i] = e.categories;
    return t.map((r) => {
      const o = s.find((n) => n.colId === r.colId);
      if (o) {
        const n = o.chartType, l = ["groupedColumn", "groupedBar"].includes(n) ? { grouped: !0 } : {};
        return {
          type: ne(n),
          xKey: i.id,
          yKey: r.colId,
          yName: r.displayName,
          stacked: ["stackedArea", "stackedColumn"].includes(n),
          ...l
        };
      }
    });
  }
  getYKeys(e, t) {
    const s = [], i = [];
    return e.forEach((r) => {
      const o = r.colId, n = t.find((a) => a.colId === o);
      n && (n.secondaryAxis ? i.push(o) : s.push(o));
    }), { primaryYKeys: s, secondaryYKeys: i };
  }
};
function PV(e) {
  const t = e.currentOffset;
  e.currentOffset -= e.offsetAmount;
  const s = e.currentOffset;
  return e.currentOffset -= e.offsetAmount, { outerRadiusOffset: t, innerRadiusOffset: s };
}
var TV = class extends Ir {
  constructor(e) {
    super(e);
  }
  getUpdateOptions(e, t) {
    return {
      ...t,
      data: this.crossFiltering ? this.getCrossFilterData(e) : e.data,
      series: this.getSeries(e)
    };
  }
  getSeries(e) {
    const [t] = e.categories, s = e.fields.length, i = {
      currentOffset: 0,
      offsetAmount: s > 1 ? 20 : 40
    }, r = this.getFields(e).map(
      (o) => {
        var a;
        const n = {
          type: this.standaloneChartType,
          angleKey: o.colId,
          angleName: o.displayName,
          sectorLabelKey: o.colId,
          calloutLabelName: t.name,
          calloutLabelKey: t.id
        };
        if (this.chartType === "donut" || this.chartType === "doughnut") {
          const { outerRadiusOffset: l, innerRadiusOffset: d } = PV(i), c = o.displayName ? {
            title: { text: o.displayName, showInLegend: s > 1 }
          } : void 0;
          return {
            ...n,
            type: "donut",
            outerRadiusOffset: l,
            innerRadiusOffset: d,
            ...c,
            calloutLine: {
              colors: (a = this.getChartPalette()) == null ? void 0 : a.strokes
            }
          };
        }
        return n;
      }
    );
    return this.crossFiltering ? this.extractCrossFilterSeries(r) : r;
  }
  getCrossFilterData(e) {
    const t = e.fields[0].colId, s = `${t}-filtered-out`;
    return e.data.map((i) => {
      const r = i[t] + i[s];
      return i[`${t}-total`] = r, i[s] = 1, i[t] = i[t] / r, i;
    });
  }
  extractCrossFilterSeries(e) {
    const t = this.getChartPalette(), s = (a) => ({
      ...a,
      legendItemKey: a.calloutLabelKey,
      calloutLabel: { enabled: !1 },
      // hide labels on primary series
      highlightStyle: { item: { fill: void 0 } },
      radiusKey: a.angleKey,
      angleKey: a.angleKey + "-total",
      radiusMin: 0,
      radiusMax: 1,
      listeners: {
        nodeClick: this.crossFilterCallback
      }
    }), i = (a, l) => ({
      ...n,
      radiusKey: l + "-filtered-out",
      fills: this.changeOpacity(a.fills ?? (t == null ? void 0 : t.fills) ?? [], 0.3),
      strokes: this.changeOpacity(a.strokes ?? (t == null ? void 0 : t.strokes) ?? [], 0.3),
      showInLegend: !1
    }), r = e[0], o = r.angleKey, n = s(r);
    return [i(s(r), o), n];
  }
  getFields(e) {
    return this.chartType === "pie" ? e.fields.slice(0, 1) : e.fields;
  }
  changeOpacity(e, t) {
    const s = this.agChartsExports._Util.Color;
    return e.map((i) => {
      const r = s.fromString(i);
      return new s(r.r, r.g, r.b, t).toHexString();
    });
  }
}, DV = class extends L {
  constructor() {
    super(
      /* html */
      '<div class="ag-chart-menu" data-ref="eMenu"></div>'
    ), this.eMenu = S, this.buttonListenersDestroyFuncs = [];
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  updateParams(e) {
    const { buttons: t } = e;
    this.createButtons(t);
  }
  createButtons(e) {
    this.buttonListenersDestroyFuncs.forEach((s) => s == null ? void 0 : s()), this.buttonListenersDestroyFuncs = [];
    const t = this.eMenu;
    X(t), e.forEach((s) => {
      const { buttonName: i, iconName: r, callback: o } = s, n = this.createButton(r), a = this.chartTranslation.translate(
        i + "ToolbarTooltip"
      );
      a && n instanceof HTMLElement && (n.title = a), this.buttonListenersDestroyFuncs.push(
        ...this.addManagedElementListeners(n, {
          click: (l) => o(l.currentTarget)
        })
      ), t.appendChild(n);
    });
  }
  createButton(e) {
    const t = B(e, this.beans);
    t.classList.add("ag-chart-menu-icon");
    const s = Z(this.beans).createElement("button");
    return s.appendChild(t), s.classList.add("ag-chart-menu-toolbar-button"), s;
  }
  destroy() {
    this.buttonListenersDestroyFuncs = [], super.destroy();
  }
}, EV = (
  /*css*/
  ".ag-pill-select{display:flex;flex-direction:column}:where(.ag-pill-select){.ag-column-drop-list{padding:0}.ag-select{padding-top:var(--ag-spacing)}.ag-picker-field-wrapper{background-color:transparent;border:0}.ag-picker-field-display{cursor:pointer;font-weight:500}.ag-picker-field-display,.ag-picker-field-icon{color:var(--ag-chart-menu-label-color)}}"
), MV = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-pill-select" role="presentation"></div>'
    ), this.config = e ?? {};
    const { selectedValueList: t, valueFormatter: s, valueList: i } = this.config;
    this.selectedValues = t ?? [], this.valueList = i ?? [], this.valueFormatter = s ?? ((r) => Q(r)), this.registerCSS(EV);
  }
  postConstruct() {
    const { ariaLabel: e, onValuesChange: t, dragSourceId: s } = this.config;
    this.dropZonePanel = this.createManagedBean(
      new IV(
        {
          getValues: () => this.selectedValues,
          setValues: (r) => this.updateValues(r),
          isDraggable: () => this.selectedValues.length > 1
        },
        (r) => this.valueFormatter(r),
        e,
        s
      )
    ), this.getGui().appendChild(this.dropZonePanel.getGui()), this.initSelect(), t != null && (this.onValuesChange = t);
  }
  setValues(e, t) {
    const { added: s, removed: i, updated: r } = this.getChanges(this.valueList, e);
    let o = !1;
    return (s.length || i.length || r.length) && (o = !0), this.valueList = e, this.updateValues(t, o, !0), this;
  }
  setValueFormatter(e) {
    return this.valueFormatter = e, this;
  }
  initSelect() {
    const e = this.createSelectOptions();
    if (!e.length)
      return !1;
    const { selectPlaceholder: t } = this.config;
    return this.eSelect = this.createBean(
      new Ne({
        options: e,
        placeholder: t,
        onValueChange: (s) => this.addValue(s),
        pickerIcon: "chartsMenuAdd"
      })
    ), this.getGui().appendChild(this.eSelect.getGui()), !0;
  }
  createSelectOptions() {
    const e = [], { maxSelection: t } = this.config;
    return t && this.selectedValues.length >= t || this.valueList.forEach((s) => {
      this.selectedValues.includes(s) || e.push({ value: s, text: this.valueFormatter(s) });
    }), e;
  }
  addValue(e) {
    this.dropZonePanel.addItem(e);
  }
  updateValues(e, t, s) {
    var c, h, u, p, g;
    const i = this.selectedValues;
    this.selectedValues = e;
    const r = this.getChanges(i, e), o = t || r.added.length || r.removed.length, n = q(this.beans), a = (c = this.eSelect) == null ? void 0 : c.getGui().contains(n), l = (h = this.dropZonePanel) == null ? void 0 : h.getGui().contains(n);
    s || (u = this.onValuesChange) == null || u.call(this, r);
    const d = o ? !this.refreshSelect() : !1;
    this.dropZonePanel.refreshGui(), o && a && (d ? this.dropZonePanel.focusList(!0) : (p = this.eSelect) == null || p.getFocusableElement().focus()), l && !e.length && ((g = this.eSelect) == null || g.getFocusableElement().focus());
  }
  getChanges(e, t) {
    const s = t.filter((o) => !e.includes(o)), i = e.filter((o) => !t.includes(o)), r = t.filter((o, n) => e[n] !== o);
    return { added: s, removed: i, updated: r, selected: t };
  }
  refreshSelect() {
    if (!this.eSelect)
      return this.initSelect();
    const e = this.createSelectOptions();
    return e.length ? (this.eSelect.clearOptions().addOptions(e).setValue(void 0, !0), !0) : (ce(this.eSelect.getGui()), this.eSelect = this.destroyBean(this.eSelect), !1);
  }
  destroy() {
    this.destroyBean(this.eSelect), super.destroy();
  }
}, AV = class extends Jg {
  constructor(e, t, s, i, r, o) {
    super(t, s, !1), this.value = e, this.valueFormatter = i, this.draggable = r, this.sourceId = o;
  }
  getItem() {
    return this.value;
  }
  getDisplayName() {
    return this.valueFormatter(this.value);
  }
  getAriaDisplayName() {
    return this.getDisplayName();
  }
  getTooltip() {
  }
  createGetDragItem() {
    return () => ({
      value: this.value
    });
  }
  getDragSourceType() {
    return xt.ChartPanel;
  }
  getDragSourceId() {
    return this.sourceId;
  }
  isDraggable() {
    return this.draggable;
  }
}, IV = class extends Qg {
  constructor(e, t, s, i) {
    super(!1), this.model = e, this.valueFormatter = t, this.ariaLabel = s, this.sourceId = i;
  }
  postConstruct() {
    super.init();
  }
  isItemDroppable(e, t) {
    return this.isSourceEventFromTarget(t) || this.sourceId != null && this.sourceId === t.dragSource.sourceId;
  }
  updateItems(e) {
    this.model.setValues(e);
  }
  getExistingItems() {
    return this.model.getValues();
  }
  getIconName() {
    return this.isPotentialDndItems() ? "move" : "notAllowed";
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  createPillComponent(e, t, s) {
    return new AV(
      e,
      t,
      s,
      this.valueFormatter,
      this.model.isDraggable(),
      this.sourceId
    );
  }
  getItems(e) {
    return [e.value];
  }
  isInterestedIn(e) {
    return e === xt.ChartPanel;
  }
}, Kf = class extends L {
  constructor(e, t, s, i) {
    super(i), this.chartController = e, this.allowMultipleSelection = t, this.maxSelection = s;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  addItem(e) {
    this.groupComp.addItem(e);
  }
  createGroup(e, t, s, i, r) {
    if (this.allowMultipleSelection) {
      const o = e.filter((n) => n.selected);
      this.valuePillSelect = this.groupComp.createManagedBean(
        new MV({
          valueList: e,
          selectedValueList: o,
          valueFormatter: t,
          selectPlaceholder: this.chartTranslation.translate(s),
          dragSourceId: i,
          onValuesChange: (n) => this.onValueChange(n),
          maxSelection: this.maxSelection
        })
      ), this.groupComp.addItem(this.valuePillSelect);
    } else {
      const o = this.createValueSelectParams(e);
      o.onValueChange = (n) => {
        e.forEach((a) => {
          a.selected = !1;
        }), n.selected = !0, n.colId === Vt && this.chartController.setAggFunc(void 0, !0), this.chartController.updateForPanelChange({ updatedColState: n, skipAnimation: r == null ? void 0 : r() });
      }, this.valueSelect = this.groupComp.createManagedBean(new Ne(o)), this.groupComp.addItem(this.valueSelect);
    }
  }
  refreshValueSelect(e) {
    if (!this.valueSelect)
      return;
    const { options: t, value: s } = this.createValueSelectParams(e);
    this.valueSelect.clearOptions().addOptions(t).setValue(s, !0);
  }
  createValueSelectParams(e) {
    let t;
    return {
      options: e.map((i) => {
        const r = i.displayName ?? "";
        return i.selected && (t = i), {
          value: i,
          text: r
        };
      }),
      value: t
    };
  }
  onValueChange({ added: e, updated: t, removed: s, selected: i }) {
    let r, o;
    const n = () => {
      i.forEach((a, l) => {
        a.order = l;
      }), o = !0;
    };
    e.length ? (r = e[0], r.selected = !0, n()) : s.length ? (r = s[0], r.selected = !1) : t.length && (n(), r = t[0]), r && this.chartController.updateForPanelChange({ updatedColState: r, resetOrder: o });
  }
  destroy() {
    this.valuePillSelect = void 0, this.valueSelect = void 0, super.destroy();
  }
}, LV = "sum", kV = class extends Kf {
  constructor(e, t, s, i, r) {
    super(
      e,
      s,
      void 0,
      /* html */
      '<div id="categoriesGroup"></div>'
    ), this.title = t, this.dimensionCols = i, this.isOpen = r;
  }
  postConstruct() {
    this.groupComp = this.createBean(
      new es({
        title: this.title,
        enabled: !0,
        suppressEnabledCheckbox: !0,
        suppressOpenCloseIcons: !1,
        cssIdentifier: "charts-data",
        expanded: this.isOpen
      })
    ), this.createGroup(
      this.dimensionCols,
      (e) => e.displayName ?? "",
      "categoryAdd",
      "categorySelect",
      () => !this.chartController.getAggFunc()
    ), this.createAggFuncControls(this.dimensionCols), this.getGui().appendChild(this.groupComp.getGui());
  }
  refresh(e) {
    var t;
    (t = this.valuePillSelect) == null || t.setValues(
      e,
      e.filter((s) => s.selected)
    ), this.refreshValueSelect(e), this.refreshAggFuncControls(e, this.chartController.getAggFunc());
  }
  createAggFuncControls(e) {
    const t = this.chartController.getAggFunc();
    this.groupComp.addItem(
      this.aggFuncToggle = this.createBean(
        new Ii({
          label: this.chartTranslation.translate("aggregate"),
          labelAlignment: "left",
          labelWidth: "flex",
          inputWidth: "flex",
          value: t != null,
          onValueChange: (s) => {
            var r, o;
            const i = s ? LV : void 0;
            this.chartController.setAggFunc(i), (r = this.aggFuncSelect) == null || r.setValue(i, !0), (o = this.aggFuncSelect) == null || o.setDisplayed(i != null);
          }
        })
      )
    ), this.groupComp.addItem(
      this.aggFuncSelect = this.createBean(
        new Ne({
          options: [
            { value: "sum", text: this.chartTranslation.translate("sum") },
            { value: "first", text: this.chartTranslation.translate("first") },
            { value: "last", text: this.chartTranslation.translate("last") },
            { value: "min", text: this.chartTranslation.translate("min") },
            { value: "max", text: this.chartTranslation.translate("max") },
            { value: "count", text: this.chartTranslation.translate("count") },
            { value: "avg", text: this.chartTranslation.translate("avg") }
          ],
          value: typeof t == "string" ? t : void 0,
          onValueChange: (s) => {
            this.chartController.setAggFunc(s);
          }
        })
      )
    ), this.refreshAggFuncControls(e, t);
  }
  refreshAggFuncControls(e, t) {
    var r, o, n, a;
    const i = e.filter((l) => l.selected).some((l) => l.colId !== Vt);
    (r = this.aggFuncToggle) == null || r.setValue(t != null), (o = this.aggFuncSelect) == null || o.setValue(typeof t == "string" ? t : void 0, !0), (n = this.aggFuncToggle) == null || n.setDisplayed(i), (a = this.aggFuncSelect) == null || a.setDisplayed(i && t != null);
  }
  clearAggFuncControls() {
    this.aggFuncToggle = this.destroyBean(this.aggFuncToggle), this.aggFuncSelect = this.destroyBean(this.aggFuncSelect);
  }
  destroy() {
    this.clearAggFuncControls(), this.groupComp = this.destroyBean(this.groupComp), super.destroy();
  }
}, ei = class extends P {
  constructor(e) {
    super(), this.chartOptionsProxy = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  getDefaultColorPickerParams(e, t, s) {
    return this.addValueParams(
      e,
      {
        label: this.chartTranslation.translate(t ?? "color"),
        labelWidth: "flex",
        inputWidth: "flex",
        labelAlignment: "top",
        pickerGap: 6
      },
      s
    );
  }
  getDefaultNumberInputParams(e, t, s) {
    return this.addValueParams(
      e,
      {
        label: this.chartTranslation.translate(t),
        labelAlignment: "top",
        labelWidth: "flex",
        inputWidth: "flex",
        precision: s == null ? void 0 : s.precision,
        step: s == null ? void 0 : s.step,
        min: s == null ? void 0 : s.min,
        max: s == null ? void 0 : s.max
      },
      {
        parseInputValue: (i) => {
          const r = Number(i);
          return isNaN(r) ? void 0 : r;
        },
        formatInputValue: (i) => i == null ? "" : `${i}`
      }
    );
  }
  getDefaultSliderParams(e, t, s, i) {
    let r = this.chartOptionsProxy.getValue(e) ?? 0;
    i && Array.isArray(r) && (r = r[0]);
    const o = this.getDefaultSliderParamsWithoutValueParams(r, t, s);
    return o.onValueChange = (n) => this.chartOptionsProxy.setValue(e, i ? [n] : n), o;
  }
  getDefaultSliderParamsWithoutValueParams(e, t, s) {
    return {
      label: this.chartTranslation.translate(t),
      minValue: 0,
      maxValue: Math.max(e, s),
      textFieldWidth: 45,
      value: `${e}`
    };
  }
  getDefaultCheckboxParams(e, t, s) {
    const i = this.chartOptionsProxy.getValue(e), r = {
      label: this.chartTranslation.translate(t),
      value: i,
      readOnly: s == null ? void 0 : s.readOnly,
      passive: s == null ? void 0 : s.passive
    };
    return r.onValueChange = (o) => {
      this.chartOptionsProxy.setValue(e, typeof o == "boolean" ? o : void 0);
    }, r;
  }
  getDefaultSelectParams(e, t, s) {
    return this.getDefaultSelectParamsWithoutValueParams(
      t,
      s,
      this.chartOptionsProxy.getValue(e),
      (i) => {
        this.chartOptionsProxy.setValue(e, i);
      }
    );
  }
  getDefaultSelectParamsWithoutValueParams(e, t, s, i) {
    return {
      label: this.chartTranslation.translate(e),
      labelAlignment: "top",
      options: t,
      pickerGap: 6,
      value: s,
      onValueChange: i
    };
  }
  getDefaultFontPanelParams(e, t) {
    const s = (i) => `${e}.${i}`;
    return this.addEnableParams(s("enabled"), {
      name: this.chartTranslation.translate(t),
      suppressEnabledCheckbox: !1,
      chartMenuParamsFactory: this,
      keyMapper: s
    });
  }
  addValueParams(e, t, s) {
    const i = this.chartOptionsProxy.getValue(e);
    return t.value = s != null && s.formatInputValue ? s.formatInputValue(i) : i, t.onValueChange = (r) => {
      const o = s != null && s.parseInputValue ? s.parseInputValue(r) : r;
      this.chartOptionsProxy.setValue(e, o);
    }, t;
  }
  addEnableParams(e, t) {
    return t.enabled = this.chartOptionsProxy.getValue(e) ?? !1, t.onEnableChange = (s) => this.chartOptionsProxy.setValue(e, s), t;
  }
  getChartOptions() {
    return this.chartOptionsProxy;
  }
}, OV = class extends L {
  constructor(e, t) {
    super(), this.chartMenuContext = e, this.isOpen = t, this.chartSpecificGroup = S, this.hasContent = !1;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation, this.chartSvc = e.chartSvc;
  }
  postConstruct() {
    const t = {
      title: this.getTitle(),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      suppressOpenCloseIcons: !1,
      cssIdentifier: "charts-data",
      expanded: this.isOpen,
      items: [...this.createDirectionSelect(), this.createGroupTypeSelect()]
    };
    this.setTemplate(
      /* html */
      `
            <div id="chartSpecificGroup">
                <ag-group-component data-ref="chartSpecificGroup"></ag-group-component>
            </div>`,
      [le],
      {
        chartSpecificGroup: t
      }
    ), this.setDisplayed(this.hasContent);
  }
  refresh() {
    this.hasContent = !1, this.chartSpecificGroup.setTitle(this.getTitle()), this.updateDirectionSelect(), this.updateGroupTypeSelect(), this.setDisplayed(this.hasContent);
  }
  getTitle() {
    const e = this.chartMenuContext.chartController.getChartType();
    return this.chartTranslation.translate(ed(e));
  }
  createDirectionSelect() {
    if (!this.chartSvc.isEnterprise())
      return [];
    const { chartOptionsService: e, chartController: t } = this.chartMenuContext, s = e.getSeriesOptionsProxy(
      () => ne(t.getChartType())
    ), i = this.createManagedBean(
      new ei(s)
    ), r = ["horizontal", "vertical"].map((a) => ({
      value: a,
      text: this.chartTranslation.translate(a)
    })), o = i.getDefaultSelectParams("direction", "direction", r), n = o.onValueChange;
    return o.onValueChange = (a) => {
      n(a), t.raiseChartModelUpdateEvent();
    }, this.directionSelect = this.createManagedBean(new Ne(o)), this.updateDirectionSelect(), [this.directionSelect];
  }
  updateDirectionSelect() {
    const e = hB(this.chartMenuContext.chartController.getChartType());
    this.updateDisplayed(this.directionSelect, e);
  }
  createGroupTypeSelect() {
    const { chartController: e, chartMenuParamsFactory: t } = this.chartMenuContext;
    return this.groupTypeSelect = this.createManagedBean(
      new Ne(
        t.getDefaultSelectParamsWithoutValueParams(
          "seriesGroupType",
          rB.map((s) => ({
            value: s,
            text: this.chartTranslation.translate(`${s}SeriesGroupType`)
          })),
          e.getSeriesGroupType(),
          (s) => e.setSeriesGroupType(s)
        )
      )
    ), this.updateGroupTypeSelect(), this.groupTypeSelect;
  }
  updateGroupTypeSelect() {
    const e = ["radialColumn", "radialBar", "nightingale"].includes(
      this.chartMenuContext.chartController.getChartType()
    );
    this.updateDisplayed(this.groupTypeSelect, e);
  }
  updateDisplayed(e, t) {
    e == null || e.setDisplayed(t), e && (this.hasContent = this.hasContent || t);
  }
}, GV = class extends L {
  constructor(e, t, s) {
    super(
      /* html */
      '<div id="seriesChartTypeGroup"></div>'
    ), this.chartController = e, this.columns = t, this.isOpen = s, this.selectedColIds = [], this.chartTypeComps = /* @__PURE__ */ new Map(), this.secondaryAxisComps = /* @__PURE__ */ new Map();
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    this.createSeriesChartTypeGroup(this.columns);
  }
  refresh(e) {
    Re(this.getValidColIds(e), this.selectedColIds) ? this.refreshComps() : this.recreate(e);
  }
  recreate(e) {
    this.isOpen = this.seriesChartTypeGroupComp.isExpanded(), X(this.getGui()), this.destroyBean(this.seriesChartTypeGroupComp), this.columns = e, this.selectedColIds = [], this.clearComps(), this.postConstruct();
  }
  getValidColIds(e) {
    const t = this.chartController.getSeriesChartTypes();
    return e.filter((s) => s.selected && !!t.filter((i) => i.colId === s.colId)[0]).map(({ colId: s }) => s);
  }
  createSeriesChartTypeGroup(e) {
    this.seriesChartTypeGroupComp = this.createBean(
      new es({
        title: this.chartTranslation.translate("seriesChartType"),
        enabled: !0,
        suppressEnabledCheckbox: !0,
        suppressOpenCloseIcons: !1,
        cssIdentifier: "charts-data",
        expanded: this.isOpen
      })
    );
    const t = this.chartController.getSeriesChartTypes();
    e.forEach((s) => {
      if (!s.selected)
        return;
      const i = t.filter((d) => d.colId === s.colId)[0];
      if (!i)
        return;
      this.selectedColIds.push(s.colId);
      const r = this.seriesChartTypeGroupComp.createManagedBean(
        new es({
          title: s.displayName,
          enabled: !0,
          suppressEnabledCheckbox: !0,
          suppressOpenCloseIcons: !0,
          cssIdentifier: "charts-format-sub-level"
        })
      ), o = (d) => ["groupedColumn", "stackedColumn", "stackedArea"].includes(d), n = this.seriesChartTypeGroupComp.createManagedBean(
        new ri({
          label: this.chartTranslation.translate("secondaryAxis"),
          labelWidth: "flex",
          disabled: o(i.chartType),
          value: !!i.secondaryAxis,
          onValueChange: (d) => this.chartController.updateSeriesChartType(s.colId, void 0, d)
        })
      );
      r.addItem(n);
      const a = ["line", "area", "stackedArea", "groupedColumn", "stackedColumn"].map(
        (d) => ({
          value: d,
          text: this.chartTranslation.translate(ed(d))
        })
      ), l = r.createManagedBean(
        new Ne({
          options: a,
          value: i.chartType,
          onValueChange: (d) => this.chartController.updateSeriesChartType(s.colId, d)
        })
      );
      r.addItem(l), this.seriesChartTypeGroupComp.addItem(r), this.chartTypeComps.set(s.colId, l), this.secondaryAxisComps.set(s.colId, n);
    }), this.getGui().appendChild(this.seriesChartTypeGroupComp.getGui());
  }
  refreshComps() {
    const e = this.chartController.getSeriesChartTypes();
    this.selectedColIds.forEach((t) => {
      const s = e.find((o) => o.colId === t);
      if (!s)
        return;
      const i = this.chartTypeComps.get(t), r = this.secondaryAxisComps.get(t);
      i == null || i.setValue(s.chartType), r == null || r.setValue(!!s.secondaryAxis), r == null || r.setDisabled(this.isSecondaryAxisDisabled(s.chartType));
    });
  }
  clearComps() {
    this.chartTypeComps.clear(), this.secondaryAxisComps.clear();
  }
  isSecondaryAxisDisabled(e) {
    return ["groupedColumn", "stackedColumn", "stackedArea"].includes(e);
  }
  destroy() {
    this.clearComps(), this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp), super.destroy();
  }
}, BV = class extends Kf {
  constructor(e, t, s, i, r, o, n) {
    super(
      e,
      i,
      r,
      /* html */
      '<div id="seriesGroup"></div>'
    ), this.chartOptionsService = t, this.title = s, this.valueCols = o, this.isOpen = n;
  }
  postConstruct() {
    if (this.groupComp = this.createBean(
      new es({
        title: this.title,
        enabled: !0,
        suppressEnabledCheckbox: !0,
        suppressOpenCloseIcons: !1,
        cssIdentifier: "charts-data",
        expanded: this.isOpen
      })
    ), this.chartController.isActiveXYChart()) {
      const e = this.groupComp.createManagedBean(
        new Ii({
          label: this.chartTranslation.translate("paired"),
          labelAlignment: "left",
          labelWidth: "flex",
          inputWidth: "flex",
          value: this.chartOptionsService.getPairedMode(),
          onValueChange: (t) => {
            this.chartOptionsService.setPairedMode(!!t), this.chartController.updateForGridChange({ maintainColState: !0 });
          }
        })
      );
      this.groupComp.addItem(e);
    }
    this.createGroup(this.valueCols, this.generateGetSeriesLabel(this.valueCols), "seriesAdd", "seriesSelect"), this.getGui().appendChild(this.groupComp.getGui());
  }
  refresh(e) {
    var t, s;
    (t = this.valuePillSelect) == null || t.setValueFormatter(this.generateGetSeriesLabel(e)), (s = this.valuePillSelect) == null || s.setValues(
      e,
      e.filter((i) => i.selected)
    ), this.refreshValueSelect(e);
  }
  generateGetSeriesLabel(e) {
    if (!this.chartController.isActiveXYChart())
      return (o) => o.displayName ?? "";
    const t = e.filter((o) => o.selected), s = this.chartController.getChartType() === "bubble", i = this.chartOptionsService.getPairedMode(), r = /* @__PURE__ */ new Map();
    return r.set(0, "X"), r.set(1, "Y"), r.set(2, "size"), (o) => {
      const n = o.displayName ?? "";
      if (!o.selected)
        return n;
      const a = t.indexOf(o);
      if (a === -1)
        return n;
      let l;
      return i ? l = r.get(a % (s ? 3 : 2)) : a === 0 ? l = "X" : l = s && a % 2 === 0 ? "size" : "Y", `${n} (${l})`;
    };
  }
  destroy() {
    this.groupComp = this.destroyBean(this.groupComp), super.destroy();
  }
}, VV = {
  groups: [
    { type: "categories", isOpen: !0 },
    { type: "series", isOpen: !0 },
    { type: "seriesChartType", isOpen: !0 },
    { type: "chartSpecific", isOpen: !0 }
  ]
}, NV = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-chart-data-wrapper ag-scrollable-container"></div>'
    ), this.chartMenuContext = e, this.isSwitchCategorySeriesToggled = !1, this.restoreSwitchCategorySeriesToggleFocus = !1, this.panels = [], this.chartController = e.chartController;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation, this.chartSvc = e.chartSvc;
  }
  postConstruct() {
    this.createSwitchCategorySeriesToggle(), this.isSwitchCategorySeriesToggled = this.chartController.isCategorySeriesSwitched(), this.updatePanels();
    const e = this.updatePanels.bind(this);
    this.addManagedListeners(this.chartController, {
      chartModelUpdate: e,
      chartApiUpdate: e
    });
  }
  destroy() {
    this.clearPanelComponents(), super.destroy();
  }
  updatePanels() {
    var n, a, l, d, c;
    const e = this.chartType, t = this.isSwitchCategorySeriesToggled, { dimensionCols: s, valueCols: i } = this.chartController.getColStateForMenu();
    this.chartType = this.chartController.getChartType(), this.isSwitchCategorySeriesToggled = this.chartController.isCategorySeriesSwitched();
    const r = this.isSwitchCategorySeriesToggled !== t;
    this.canRefresh(e, this.chartType) && !r ? ((n = this.categoriesDataPanel) == null || n.refresh(s), (a = this.seriesDataPanel) == null || a.refresh(i), (l = this.seriesChartTypePanel) == null || l.refresh(i), (d = this.chartSpecificPanel) == null || d.refresh()) : this.recreatePanels(s, i);
    const o = If(this.chartType) && this.chartSvc.isEnterprise() && !this.chartController.isGrouping();
    O(this.switchCategorySeriesToggle.getGui(), o), r && ((c = this.switchCategorySeriesToggle) == null || c.setValue(this.chartController.isCategorySeriesSwitched())), this.restoreSwitchCategorySeriesToggleFocus && (this.restoreSwitchCategorySeriesToggleFocus = !1, o && this.switchCategorySeriesToggle.getFocusableElement().focus());
  }
  canRefresh(e, t) {
    if (e === void 0)
      return !1;
    if (e === t)
      return !0;
    const s = (i) => ["columnLineCombo", "areaColumnCombo", "customCombo"].includes(i);
    return !!(s(e) && s(t));
  }
  recreatePanels(e, t) {
    var r, o;
    this.clearPanelComponents();
    const { chartType: s } = this;
    if (!s)
      return;
    const i = this.chartController.isCategorySeriesSwitched();
    (r = this.getDataPanelDef().groups) == null || r.forEach(({ type: n, isOpen: a }) => {
      n === (i ? "series" : "categories") ? (this.categoriesDataPanel = this.createBean(
        new kV(
          this.chartController,
          this.getCategoryGroupTitle(i),
          this.getCategoryGroupMultipleSelect(s, i),
          e,
          a
        )
      ), this.panels.push(this.categoriesDataPanel)) : n === (i ? "categories" : "series") ? (this.seriesDataPanel = this.createBean(
        new BV(
          this.chartController,
          this.chartMenuContext.chartOptionsService,
          this.getSeriesGroupTitle(i),
          this.getSeriesGroupMultipleSelect(s, i),
          this.getSeriesGroupMaxSelection(s, i),
          t,
          a
        )
      ), this.panels.push(this.seriesDataPanel)) : n === "seriesChartType" ? this.chartController.isComboChart() && (this.seriesChartTypePanel = this.createBean(
        new GV(this.chartController, t, a)
      ), this.panels.push(this.seriesChartTypePanel)) : n === "chartSpecific" ? (this.chartSpecificPanel = this.createBean(new OV(this.chartMenuContext, a)), this.panels.push(this.chartSpecificPanel)) : R(144, { type: n });
    }), (o = i ? this.categoriesDataPanel : this.seriesDataPanel) == null || o.addItem(
      this.switchCategorySeriesToggle.getGui()
    ), this.addPanelComponents();
  }
  addPanelComponents() {
    if (!this.panels.length)
      return;
    const t = Z(this.beans).createDocumentFragment();
    for (const s of this.panels)
      s.addCssClass("ag-chart-data-section"), t.appendChild(s.getGui());
    this.getGui().appendChild(t);
  }
  clearPanelComponents() {
    const e = this.getGui();
    this.panels.forEach((t) => {
      e.removeChild(t.getGui()), this.destroyBean(t);
    }), this.panels = [];
  }
  getDataPanelDef() {
    var e;
    return ((e = this.gos.get("chartToolPanelsDef")) == null ? void 0 : e.dataPanel) ?? VV;
  }
  getCategoryGroupTitle(e) {
    return e ? this.chartTranslation.translate("seriesLabels") : this.chartTranslation.translate(this.chartController.isActiveXYChart() ? "labels" : "categories");
  }
  getCategoryGroupMultipleSelect(e, t) {
    return t ? !1 : qa(e) !== 1;
  }
  getSeriesGroupTitle(e) {
    return e ? this.chartTranslation.translate("categoryValues") : this.chartTranslation.translate(this.chartController.isActiveXYChart() ? "xyValues" : "series");
  }
  getSeriesGroupMultipleSelect(e, t) {
    return this.getSeriesGroupMaxSelection(e, t) !== 1;
  }
  getSeriesGroupMaxSelection(e, t) {
    if (!t)
      return Bo(e);
  }
  createSwitchCategorySeriesToggle() {
    this.switchCategorySeriesToggle = this.createManagedBean(
      new Ii({
        label: this.chartTranslation.translate("switchCategorySeries"),
        labelAlignment: "left",
        labelWidth: "flex",
        inputWidth: "flex",
        value: this.chartController.isCategorySeriesSwitched(),
        onValueChange: (e) => {
          this.restoreSwitchCategorySeriesToggleFocus = !0, this.chartController.switchCategorySeries(e);
        }
      })
    );
  }
}, HV = class extends Ml {
  constructor(e) {
    super(
      e,
      /* html */
      `<div class="ag-angle-select">
            <div data-ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div class="ag-angle-select-field">
                    <div data-ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div data-ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field data-ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`,
      [an]
    ), this.eLabel = S, this.eParentCircle = S, this.eChildCircle = S, this.eAngleValue = S, this.radius = 0, this.offsetX = 0, this.offsetY = 0;
  }
  wireBeans(e) {
    this.dragSvc = e.dragSvc;
  }
  postConstruct() {
    var s;
    super.postConstruct();
    const { value: e, onValueChange: t } = this.config;
    e != null && this.setValue(e, void 0, !0), t != null && this.onValueChange(t), this.dragListener = {
      eElement: this.eParentCircle,
      dragStartPixels: 0,
      onDragStart: () => {
        this.parentCircleRect = this.eParentCircle.getBoundingClientRect();
      },
      onDragging: (i) => this.calculateAngleDrag(i),
      onDragStop: () => {
      }
    }, (s = this.dragSvc) == null || s.addDragSource(this.dragListener), this.eAngleValue.setLabel("").setLabelWidth(5).setInputWidth(45).setMin(0).setMax(360).setValue(`${this.degrees}`).onValueChange((i) => {
      (i == null || i === "") && (i = "0"), i = this.eAngleValue.normalizeValue(i);
      let r = parseFloat(i);
      r > 180 && (r = r - 360), this.setValue(r);
    }), this.updateNumberInput(), A(this.getValue()) && this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString()), this.addManagedListeners(this, {
      fieldValueChanged: () => {
        this.eAngleValue.getInputElement().contains(q(this.beans)) || this.updateNumberInput();
      }
    });
  }
  updateNumberInput() {
    const e = this.normalizeNegativeValue(this.getValue());
    this.eAngleValue.setValue(e.toString());
  }
  positionChildCircle(e) {
    const t = this.parentCircleRect || { width: 24, height: 24 }, s = this.eChildCircle, i = t.width / 2, r = t.height / 2;
    s.style.left = `${i + Math.cos(e) * 8}px`, s.style.top = `${r + Math.sin(e) * 8}px`;
  }
  calculatePolar() {
    const e = this.offsetX, t = this.offsetY, s = Math.atan2(t, e);
    this.degrees = this.toDegrees(s), this.radius = Math.sqrt(e * e + t * t), this.positionChildCircle(s);
  }
  calculateCartesian() {
    const e = this.toRadians(this.getValue()), t = this.getRadius();
    this.setOffsetX(Math.cos(e) * t).setOffsetY(Math.sin(e) * t);
  }
  setOffsetX(e) {
    return this.offsetX !== e && (this.offsetX = e, this.calculatePolar()), this;
  }
  setOffsetY(e) {
    return this.offsetY !== e && (this.offsetY = e, this.calculatePolar()), this;
  }
  calculateAngleDrag(e) {
    const t = this.parentCircleRect, s = t.width / 2, i = t.height / 2, r = e.clientX - t.left, o = e.clientY - t.top, n = r - s, a = o - i, l = Math.atan2(a, n);
    this.setValue(l, !0);
  }
  toDegrees(e) {
    return e / Math.PI * 180;
  }
  toRadians(e) {
    return e / 180 * Math.PI;
  }
  normalizeNegativeValue(e) {
    return e < 0 ? 360 + e : e;
  }
  normalizeAngle180(e) {
    return e %= Math.PI * 2, e < -Math.PI ? e += Math.PI * 2 : e >= Math.PI && (e -= Math.PI * 2), e;
  }
  getRadius() {
    return this.radius;
  }
  setRadius(e) {
    return this.radius === e ? this : (this.radius = e, this.calculateCartesian(), this);
  }
  onValueChange(e) {
    return this.addManagedListeners(this, {
      fieldValueChanged: () => {
        e(this.degrees);
      }
    }), this;
  }
  getValue(e) {
    return e ? this.toRadians(this.degrees) : this.degrees;
  }
  setValue(e, t, s) {
    let i;
    return t ? i = e : i = this.normalizeAngle180(this.toRadians(e)), e = this.toDegrees(i), this.degrees !== e && (this.degrees = Math.floor(e), this.calculateCartesian(), this.positionChildCircle(i), s || this.dispatchLocalEvent({ type: "fieldValueChanged" })), this;
  }
  setWidth(e) {
    return yt(this.getGui(), e), this;
  }
  setDisabled(e) {
    return super.setDisabled(e), this.eAngleValue.setDisabled(e), this;
  }
  destroy() {
    var e;
    (e = this.dragSvc) == null || e.removeDragSource(this.dragListener), super.destroy();
  }
};
function zV(e) {
  return e[0].toUpperCase() + e.substring(1).toLowerCase();
}
var ti = class extends L {
  constructor(e) {
    super(), this.params = e, this.fontGroup = S, this.activeComps = [], this.chartOptions = e.chartMenuParamsFactory.getChartOptions();
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const {
      cssIdentifier: e = "charts-format-sub-level",
      name: t,
      enabled: s,
      onEnableChange: i,
      suppressEnabledCheckbox: r,
      chartMenuParamsFactory: o,
      keyMapper: n
    } = this.params, a = {
      cssIdentifier: e,
      direction: "vertical",
      suppressOpenCloseIcons: !0,
      title: t,
      enabled: s,
      suppressEnabledCheckbox: !0,
      onEnableChange: (l) => {
        i && i(l);
      },
      useToggle: !r
    };
    this.setTemplate(
      /* html */
      `<div class="ag-font-panel">
        <ag-group-component data-ref="fontGroup">
            <ag-select data-ref="familySelect"></ag-select>
            <ag-select data-ref="weightStyleSelect"></ag-select>
            <div class="ag-charts-font-size-color">
                <ag-select data-ref="sizeSelect"></ag-select>
                <ag-color-picker data-ref="colorPicker"></ag-color-picker>
            </div>
        </ag-group-component>
    </div>`,
      [le, Rr, Ht],
      {
        fontGroup: a,
        familySelect: this.getFamilySelectParams(),
        weightStyleSelect: this.getWeightStyleSelectParams(),
        sizeSelect: this.getSizeSelectParams(),
        colorPicker: o.getDefaultColorPickerParams(n("color"))
      }
    ), this.addOrRemoveCssClass("ag-font-panel-no-header", !t);
  }
  addItem(e, t) {
    t ? this.fontGroup.prependItem(e) : this.fontGroup.addItem(e), this.activeComps.push(e);
  }
  setEnabled(e) {
    this.fontGroup.setEnabled(e);
  }
  getFamilySelectParams() {
    const e = [
      "Arial, sans-serif",
      "Aria Black, sans-serif",
      "Book Antiqua,  serif",
      "Charcoal, sans-serif",
      "Comic Sans MS, cursive",
      "Courier, monospace",
      "Courier New, monospace",
      "Gadget, sans-serif",
      "Geneva, sans-serif",
      "Helvetica, sans-serif",
      "Impact, sans-serif",
      "Lucida Console, monospace",
      "Lucida Grande, sans-serif",
      "Lucida Sans Unicode,  sans-serif",
      "Monaco, monospace",
      "Palatino Linotype, serif",
      "Palatino, serif",
      "Times New Roman, serif",
      "Times, serif",
      "Verdana, sans-serif"
    ], t = this.getInitialFontValue("fontFamily");
    let s = e[0];
    if (t) {
      const o = e.map((n) => n.toLowerCase()).indexOf(t.toLowerCase());
      if (o >= 0)
        s = e[o];
      else {
        const n = zV(t);
        e.push(n), s = n;
      }
    }
    const i = e.sort().map((r) => ({ value: r, text: r }));
    return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams(
      "font",
      i,
      `${s}`,
      (r) => this.setFont({ fontFamily: r })
    );
  }
  getSizeSelectParams() {
    const e = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36], t = this.getInitialFontValue("fontSize");
    e.includes(t) || e.push(t);
    const s = e.sort((i, r) => i - r).map((i) => ({ value: `${i}`, text: `${i}` }));
    return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams(
      "size",
      s,
      `${t}`,
      (i) => this.setFont({ fontSize: parseInt(i, 10) })
    );
  }
  getWeightStyleSelectParams() {
    const e = this.getInitialFontValue("fontWeight") ?? "normal", t = this.getInitialFontValue("fontStyle") ?? "normal", s = [
      { name: "normal", weight: "normal", style: "normal" },
      { name: "bold", weight: "bold", style: "normal" },
      { name: "italic", weight: "normal", style: "italic" },
      { name: "boldItalic", weight: "bold", style: "italic" }
    ];
    let i = s.find((o) => o.weight === e && o.style === t);
    i || (i = { name: "predefined", weight: e, style: t }, s.unshift(i));
    const r = s.map((o) => ({
      value: o.name,
      text: this.chartTranslation.translate(o.name)
    }));
    return this.params.chartMenuParamsFactory.getDefaultSelectParamsWithoutValueParams(
      "weight",
      r,
      i.name,
      (o) => {
        const n = s.find((a) => a.name === o);
        this.setFont({ fontWeight: n.weight, fontStyle: n.style });
      }
    );
  }
  destroyActiveComps() {
    this.activeComps.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActiveComps(), super.destroy();
  }
  setFont(e) {
    const { keyMapper: t } = this.params;
    Object.entries(e).forEach(([s, i]) => {
      i && this.chartOptions.setValue(t(s), i);
    });
  }
  getInitialFontValue(e) {
    const { keyMapper: t } = this.params;
    return this.chartOptions.getValue(t(e));
  }
}, WV = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const { chartMenuUtils: e } = this, t = e.addEnableParams("tick.enabled", {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0,
      title: this.chartTranslation.translate("ticks"),
      suppressEnabledCheckbox: !0,
      useToggle: !0
    }), s = e.getDefaultColorPickerParams("tick.stroke"), i = e.getDefaultSliderParams("tick.width", "width", 10), r = e.getDefaultSliderParams("tick.size", "length", 30);
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="axisTicksGroup">
                <ag-color-picker data-ref="axisTicksColorPicker"></ag-color-picker>
                <ag-slider data-ref="axisTicksWidthSlider"></ag-slider>
                <ag-slider data-ref="axisTicksSizeSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        axisTicksGroup: t,
        axisTicksColorPicker: s,
        axisTicksWidthSlider: i,
        axisTicksSizeSlider: r
      }
    );
  }
}, _V = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e, this.chartOptions = e.getChartOptions();
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuUtils.addEnableParams("gridLine.enabled", {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0,
      title: this.chartTranslation.translate("gridLines"),
      suppressEnabledCheckbox: !0,
      useToggle: !0
    }), t = this.getGridLineColorPickerParams("color"), s = this.getGridLineWidthSliderParams("thickness"), i = this.getGridLineDashSliderParams("lineDash");
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="gridLineGroup">
                <ag-color-picker data-ref="gridLineColorPicker"></ag-color-picker>
                <ag-slider data-ref="gridLineWidthSlider"></ag-slider>
                <ag-slider data-ref="gridLineLineDashSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        gridLineGroup: e,
        gridLineColorPicker: t,
        gridLineWidthSlider: s,
        gridLineLineDashSlider: i
      }
    );
  }
  getGridLineColorPickerParams(e) {
    return this.chartMenuUtils.getDefaultColorPickerParams("gridLine.style", e, {
      formatInputValue: (t) => {
        var s;
        return (s = t == null ? void 0 : t[0]) == null ? void 0 : s.stroke;
      },
      parseInputValue: (t) => {
        const s = this.chartOptions.getValue("gridLine.style") ?? [];
        return s.length === 0 ? [{ stroke: t, lineDash: [] }] : [{ ...s[0], stroke: t }];
      }
    });
  }
  getGridLineWidthSliderParams(e) {
    return this.chartMenuUtils.getDefaultSliderParams("gridLine.width", e, 10);
  }
  getGridLineDashSliderParams(e) {
    var r, o;
    const t = this.chartOptions.getValue("gridLine.style"), s = (o = (r = t == null ? void 0 : t[0]) == null ? void 0 : r.lineDash) == null ? void 0 : o[0], i = this.chartMenuUtils.getDefaultSliderParamsWithoutValueParams(s ?? 0, e, 30);
    return i.onValueChange = (n) => {
      const a = this.chartOptions.getValue("gridLine.style.0.stroke");
      this.chartOptions.setValue("gridLine.style", [
        { lineDash: [n], stroke: a }
      ]);
    }, i;
  }
}, UV = "%d %B %Y", Xr = class extends L {
  constructor(e, t) {
    super(), this.axisType = e, this.options = t, this.axisGroup = S, this.axisTypeSelect = S, this.axisPositionSelect = S, this.axisTimeFormatSelect = S, this.activePanels = [], this.axisLabelUpdateFuncs = [];
    const { chartOptionsService: s, seriesType: i } = t;
    this.chartOptionsSeriesProxy = s.getSeriesOptionsProxy(() => i);
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    var m;
    const {
      isExpandedOnInit: e,
      chartOptionsService: t,
      chartController: s,
      registerGroupComponent: i
    } = this.options, r = this.axisType, o = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.translate(r),
      expanded: e,
      suppressEnabledCheckbox: !0
    }, n = t.getCartesianAxisOptionsProxy(this.axisType), a = this.createManagedBean(new ei(n)), l = this.createManagedBean(
      new ei(t.getCartesianAxisThemeOverridesProxy(this.axisType))
    ), d = this.getAxisTypeSelectParams(
      a,
      t.getCartesianAxisAppliedThemeOverridesProxy(this.axisType)
    ), c = this.getAxisPositionSelectParams(a), h = this.getAxisTimeFormatSelectParams(a), u = this.getAxisColorInputParams(l), p = this.getAxisLineWidthSliderParams(l);
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="axisGroup">
                <ag-select data-ref="axisTypeSelect"></ag-select>
                <ag-select data-ref="axisTimeFormatSelect"></ag-select>
                <ag-select data-ref="axisPositionSelect"></ag-select>
                <ag-color-picker data-ref="axisColorInput"></ag-color-picker>
                <ag-slider data-ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Rr, Ht, Je],
      {
        axisGroup: o,
        axisTypeSelect: d ?? void 0,
        axisPositionSelect: c ?? void 0,
        axisTimeFormatSelect: h ?? void 0,
        axisColorInput: u,
        axisLineWidthSlider: p
      }
    ), i(this.axisGroup), this.axisTypeSelect.setDisplayed(!!((m = d.options) != null && m.length)), c || this.removeTemplateComponent(this.axisPositionSelect);
    const g = () => {
      const C = n.getValue("type") === "time";
      O(this.axisTimeFormatSelect.getGui(), C);
    };
    h ? (g(), this.addManagedEventListeners({
      chartOptionsChanged: () => {
        g();
      }
    })) : this.removeTemplateComponent(this.axisTimeFormatSelect), this.initGridLines(l), this.initAxisTicks(l), this.initAxisLabels(l);
    const f = () => this.axisLabelUpdateFuncs.forEach((C) => C());
    this.addManagedListeners(s, {
      chartUpdated: f,
      chartModelUpdate: () => setTimeout(() => {
        this.isAlive() && (this.refreshAxisTypeSelect(a), g());
      })
    });
  }
  getAxisTypeSelectParams(e, t) {
    const s = e.getChartOptions(), i = this.getAxisTypeSelectOptions(), r = e.getDefaultSelectParams("type", "axisType", i);
    return r.onValueChange = (o) => {
      const n = s.getValue("type");
      if (o === n)
        return;
      const a = t.getValue("*"), l = n === "time", d = o === "time", c = l !== d ? d ? UV : void 0 : null;
      if (this.options.chartOptionsService.setCartesianCategoryAxisType(this.axisType, o), c !== null) {
        const h = s.getValue("label") ?? {};
        s.setValue("label", {
          ...h,
          format: c
        });
      }
      t.setValue("*", a);
    }, r;
  }
  refreshAxisTypeSelect(e) {
    const t = this.getAxisTypeSelectOptions(), s = !!t.length;
    this.axisTypeSelect.setDisplayed(s), s && this.axisTypeSelect.clearOptions().addOptions(t).setValue(e.getChartOptions().getValue("type"));
  }
  getAxisTypeSelectOptions() {
    const { chartController: e } = this.options, t = e.getChartType(), s = () => {
      const i = e.getChartData()[0];
      return i ? e.getSelectedDimensions().every((r) => !isNaN(parseFloat(i[r.colId]))) : !1;
    };
    return ["heatmap", "histogram", "boxPlot", "rangeBar", "scatter", "bubble"].includes(t) || e.isGrouping() || !this.isCategoryAxis() || e.isCategorySeriesSwitched() || !s() ? [] : ["category", "number", "time"].map((i) => ({
      value: i,
      text: this.translate(i)
    }));
  }
  isCategoryAxis() {
    const e = this.chartOptionsSeriesProxy.getValue("direction") === "horizontal";
    return e && this.axisType === "yAxis" || !e && this.axisType === "xAxis";
  }
  getAxisPositionSelectParams(e) {
    const t = ((s, i) => {
      switch (s) {
        case "heatmap":
          return null;
        default:
          switch (i) {
            case "xAxis":
              return [
                { value: "top", text: this.translate("top") },
                { value: "bottom", text: this.translate("bottom") }
              ];
            case "yAxis":
              return [
                { value: "left", text: this.translate("left") },
                { value: "right", text: this.translate("right") }
              ];
          }
      }
    })(this.options.chartController.getChartType(), this.axisType);
    return t ? e.getDefaultSelectParams("position", "position", t) : null;
  }
  getAxisTimeFormatSelectParams(e) {
    if (!this.isCategoryAxis())
      return null;
    const t = [
      { value: "%d/%m/%Y", text: this.translate("timeFormatSlashesDDMMYYYY") },
      { value: "%m/%d/%Y", text: this.translate("timeFormatSlashesMMDDYYYY") },
      { value: "%d/%m/%y", text: this.translate("timeFormatSlashesDDMMYY") },
      { value: "%m/%d/%y", text: this.translate("timeFormatSlashesMMDDYY") },
      { value: "%d.%e.%y", text: this.translate("timeFormatDotsDDMYY") },
      { value: "%e.%d.%y", text: this.translate("timeFormatDotsMDDYY") },
      { value: "%Y-%m-%d", text: this.translate("timeFormatDashesYYYYMMDD") },
      { value: "%d %B %Y", text: this.translate("timeFormatSpacesDDMMMMYYYY") },
      { value: "%H:%M:%S", text: this.translate("timeFormatHHMMSS") },
      { value: "%I:%M:%S %p", text: this.translate("timeFormatHHMMSSAmPm") }
    ];
    return e.getDefaultSelectParams("label.format", "timeFormat", t);
  }
  getAxisColorInputParams(e) {
    return e.getDefaultColorPickerParams("line.stroke");
  }
  getAxisLineWidthSliderParams(e) {
    const t = e.getChartOptions(), s = () => t.getValue("line.enabled") ? t.getValue("line.width") : null, i = (o) => {
      t.setValues([
        { expression: "line.enabled", value: o != null },
        { expression: "line.width", value: o ?? 0 }
      ]);
    }, r = e.getDefaultSliderParamsWithoutValueParams(
      s() ?? 0,
      "thickness",
      10
    );
    return r.onValueChange = (o) => {
      i(o === 0 ? null : o);
    }, r;
  }
  initGridLines(e) {
    if (this.options.chartController.getChartType() === "heatmap")
      return;
    const s = this.createBean(new _V(e));
    this.axisGroup.addItem(s), this.activePanels.push(s);
  }
  initAxisTicks(e) {
    if (!this.hasConfigurableAxisTicks())
      return;
    const t = this.createBean(new WV(e));
    this.axisGroup.addItem(t), this.activePanels.push(t);
  }
  hasConfigurableAxisTicks() {
    switch (this.options.chartController.getChartType()) {
      case "radarLine":
      case "radarArea":
      case "rangeBar":
      case "boxPlot":
      case "waterfall":
        return !1;
      default:
        return !0;
    }
  }
  initAxisLabels(e) {
    const t = {
      name: this.translate("labels"),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      chartMenuParamsFactory: e,
      keyMapper: (i) => `label.${i}`
    }, s = this.createBean(new ti(t));
    this.axisGroup.addItem(s), this.activePanels.push(s), this.addAdditionalLabelComps(s, e);
  }
  addAdditionalLabelComps(e, t) {
    this.addLabelPadding(e, t);
    const s = this.createRotationWidget("labelRotation", t), i = this.initLabelRotation(s, t);
    e.addItem(i), e.addItem(s);
  }
  initLabelRotation(e, t) {
    const s = t.getChartOptions(), i = () => s.getValue("label.rotation"), r = () => s.getValue("label.autoRotate"), o = (d) => {
      d && (this.prevRotation = i()), s.setValues([
        { expression: "label.autoRotate", value: d },
        // Clear the rotation option when activating auto-rotate, reinstate the previous value when deactivating
        { expression: "label.rotation", value: d ? void 0 : this.prevRotation }
      ]), e.setDisplayed(!d);
    }, a = typeof i() == "number" ? !1 : r(), l = this.createBean(
      new ri({
        label: this.translate("autoRotate"),
        value: a,
        onValueChange: o
      })
    );
    return e.setDisplayed(!a), l;
  }
  createRotationWidget(e, t) {
    const s = t.getChartOptions(), i = () => s.getValue("label.rotation"), r = (l) => s.setValue("label.rotation", l), n = `${this.chartTranslation.translate(e)} °`, a = new HV({
      label: n,
      labelWidth: "flex",
      value: i() ?? 0,
      onValueChange: r
    });
    return this.axisLabelUpdateFuncs.push(() => {
      a.setValue(i() ?? 0);
    }), this.createBean(a);
  }
  addLabelPadding(e, t) {
    const s = this.createBean(
      new rt(t.getDefaultSliderParams("label.spacing", "padding", 30))
    );
    e.addItem(s);
  }
  translate(e) {
    return this.chartTranslation.translate(e);
  }
  removeTemplateComponent(e) {
    ce(e.getGui()), this.destroyBean(e);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}, KV = class extends L {
  constructor(e) {
    super(), this.options = e, this.axisGroup = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const { isExpandedOnInit: e, chartAxisMenuParamsFactory: t, registerGroupComponent: s } = this.options, i = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.translate("polarAxis"),
      expanded: e,
      suppressEnabledCheckbox: !0
    }, r = t.getDefaultColorPickerParams("line.stroke"), o = t.getDefaultSliderParams(
      "line.width",
      "thickness",
      10
    );
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="axisGroup">
                <ag-color-picker data-ref="axisColorInput"></ag-color-picker>
                <ag-slider data-ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        axisGroup: i,
        axisColorInput: r,
        axisLineWidthSlider: o
      }
    ), s(this.axisGroup), this.initAxis(), this.initAxisLabels(), this.initRadiusAxis();
  }
  initAxis() {
    const e = this.options.chartController.getChartType();
    if (["radarLine", "radarArea"].includes(e)) {
      const s = [
        { value: "circle", text: this.translate("circle") },
        { value: "polygon", text: this.translate("polygon") }
      ];
      this.axisGroup.addItem(
        this.createSelect({
          labelKey: "shape",
          options: s,
          property: "shape"
        })
      );
    }
    e !== "pie" && this.axisGroup.addItem(
      this.createSlider({
        labelKey: "innerRadius",
        defaultMaxValue: 1,
        property: "innerRadiusRatio"
      })
    );
  }
  initAxisLabels() {
    const e = {
      name: this.translate("labels"),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      chartMenuParamsFactory: this.options.chartAxisMenuParamsFactory,
      keyMapper: (i) => `label.${i}`
    }, t = this.createManagedBean(new ti(e)), s = this.createOrientationWidget();
    t.addItem(s), this.axisGroup.addItem(t);
  }
  createOrientationWidget() {
    const e = [
      { value: "fixed", text: this.translate("fixed") },
      { value: "parallel", text: this.translate("parallel") },
      { value: "perpendicular", text: this.translate("perpendicular") }
    ];
    return this.createSelect({
      labelKey: "orientation",
      options: e,
      property: "label.orientation"
    });
  }
  initRadiusAxis() {
    const e = ne(this.options.chartController.getChartType());
    if (!dB(e))
      return;
    const t = [
      this.createSlider({
        labelKey: "groupPadding",
        defaultMaxValue: 1,
        property: "paddingInner"
      }),
      this.createSlider({
        labelKey: "seriesPadding",
        defaultMaxValue: 1,
        property: "groupPaddingInner"
      })
    ], s = this.createManagedBean(
      new es({
        cssIdentifier: "charts-format-sub-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        enabled: !0,
        suppressEnabledCheckbox: !0,
        title: this.translate("padding"),
        items: t
      })
    ).hideEnabledCheckbox(!0).hideOpenCloseIcons(!0);
    this.axisGroup.addItem(s);
  }
  createSlider(e) {
    const { labelKey: t, defaultMaxValue: s, step: i = 0.05, property: r } = e, o = this.options.chartAxisMenuParamsFactory.getDefaultSliderParams(
      r,
      t,
      s
    );
    return o.step = i, this.createManagedBean(new rt(o));
  }
  createSelect(e) {
    const { labelKey: t, options: s, property: i } = e;
    return this.createManagedBean(
      new Ne(this.options.chartAxisMenuParamsFactory.getDefaultSelectParams(i, t, s))
    );
  }
  translate(e) {
    return this.chartTranslation.translate(e);
  }
}, $V = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuUtils.addEnableParams(
      "background.visible",
      {
        cssIdentifier: "charts-format-sub-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        title: this.chartTranslation.translate("background"),
        suppressEnabledCheckbox: !0,
        useToggle: !0
      }
    ), t = this.chartMenuUtils.getDefaultColorPickerParams("background.fill");
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="chartBackgroundGroup">
                <ag-color-picker data-ref="colorPicker"></ag-color-picker>
            </ag-group-component>
        <div>`,
      [le, Ht],
      {
        chartBackgroundGroup: e,
        colorPicker: t
      }
    );
  }
}, jV = class extends L {
  constructor(e, t) {
    super(), this.chartMenuUtils = e, this.chartController = t, this.paddingTopSlider = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0,
      title: this.chartTranslation.translate("padding"),
      suppressEnabledCheckbox: !0
    }, t = (s) => this.chartMenuUtils.getDefaultSliderParams("padding." + s, s, 200);
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="chartPaddingGroup">
                <ag-slider data-ref="paddingTopSlider"></ag-slider>
                <ag-slider data-ref="paddingRightSlider"></ag-slider>
                <ag-slider data-ref="paddingBottomSlider"></ag-slider>
                <ag-slider data-ref="paddingLeftSlider"></ag-slider>
            </ag-group-component>
        <div>`,
      [le, Je],
      {
        chartPaddingGroup: e,
        paddingTopSlider: t("top"),
        paddingRightSlider: t("right"),
        paddingBottomSlider: t("bottom"),
        paddingLeftSlider: t("left")
      }
    ), this.addManagedEventListeners({
      chartOptionsChanged: (s) => {
        this.updateTopPadding(s.chartOptions);
      }
    });
  }
  updateTopPadding(e) {
    const t = [...this.chartController.getChartSeriesTypes(), "common"].map((s) => {
      var i, r;
      return (r = (i = e[s]) == null ? void 0 : i.padding) == null ? void 0 : r.top;
    }).find((s) => s != null);
    t != null && this.paddingTopSlider.setValue(`${t}`);
  }
}, qV = class extends L {
  constructor(e) {
    super(), this.options = e, this.chartGroup = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const {
      chartController: e,
      chartMenuParamsFactory: t,
      isExpandedOnInit: s,
      registerGroupComponent: i
    } = this.options, r = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.chartTranslation.translate("chartStyle"),
      expanded: s,
      suppressEnabledCheckbox: !0,
      items: [
        this.createManagedBean(new jV(t, e)),
        this.createManagedBean(new $V(t))
      ]
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="chartGroup"></ag-group-component>
        </div>`,
      [le],
      { chartGroup: r }
    ), i(this.chartGroup);
  }
}, YV = class extends P {
  constructor(e) {
    super(), this.groupContainer = e, this.id = 0, this.groupComponents = /* @__PURE__ */ new Map();
  }
  addGroupComponent(e) {
    const t = this.id++;
    this.groupComponents.set(t, e), e.isExpanded() && (this.expandedGroupComponent = t), e.onExpandedChange((s) => {
      var i;
      if (s) {
        const r = this.expandedGroupComponent;
        if (this.expandedGroupComponent = t, r != null) {
          const o = e.getGui(), n = o.offsetTop - this.groupContainer.parentElement.scrollTop;
          (i = this.groupComponents.get(r)) == null || i.toggleGroupExpand(!1, !0);
          let a = o.offsetTop - n;
          a < 0 && (a = 0), a !== this.groupContainer.parentElement.scrollTop && (this.groupContainer.parentElement.scrollTop = a);
        }
      } else
        this.expandedGroupComponent = void 0;
    });
  }
  destroy() {
    this.groupComponents.clear(), super.destroy();
  }
}, XV = class extends L {
  constructor(e) {
    super(), this.options = e, this.legendGroup = S, this.isGradient = ["treemap", "sunburst", "heatmap"].includes(e.seriesType), this.key = this.isGradient ? "gradientLegend" : "legend";
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const { chartMenuParamsFactory: e, isExpandedOnInit: t, registerGroupComponent: s } = this.options, i = this.createManagedBean(
      new Ne(
        e.getDefaultSelectParams(
          `${this.key}.position`,
          "position",
          ["top", "right", "bottom", "left"].map((n) => ({
            value: n,
            text: this.chartTranslation.translate(n)
          }))
        )
      )
    ), r = this.createManagedBean(
      new es(
        e.addEnableParams(`${this.key}.enabled`, {
          cssIdentifier: "charts-format-sub-level",
          direction: "vertical",
          suppressOpenCloseIcons: !0,
          title: this.chartTranslation.translate("legendEnabled"),
          suppressEnabledCheckbox: !0,
          useToggle: !0,
          items: [
            this.createLabelPanel(e),
            i,
            ...this.getItems(e)
          ]
        })
      )
    ), o = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.chartTranslation.translate("legend"),
      suppressEnabledCheckbox: !0,
      expanded: t,
      items: [r]
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="legendGroup">
            </ag-group-component>
        </div>`,
      [le],
      {
        legendGroup: o
      }
    ), s(this.legendGroup);
  }
  getItems(e) {
    const t = (s, i, r) => this.createManagedBean(
      new rt(
        e.getDefaultSliderParams(
          `${this.key}.${s}`,
          i,
          r
        )
      )
    );
    return this.isGradient ? [
      this.createManagedBean(
        new ri(
          e.addValueParams("gradientLegend.reverseOrder", {
            label: this.chartTranslation.translate("reverseDirection"),
            labelWidth: "flex"
          })
        )
      ),
      t("gradient.thickness", "thickness", 40),
      t("gradient.preferredLength", "preferredLength", 300),
      t("spacing", "spacing", 200)
    ] : [
      t("spacing", "spacing", 200),
      t("item.marker.size", "markerSize", 40),
      t("item.marker.strokeWidth", "markerStroke", 10),
      t("item.marker.padding", "itemSpacing", 20),
      t("item.paddingX", "layoutHorizontalSpacing", 50),
      t("item.paddingY", "layoutVerticalSpacing", 50)
    ];
  }
  createLabelPanel(e) {
    const t = this.isGradient ? "gradientLegend.scale.label" : "legend.item.label", s = {
      enabled: !0,
      suppressEnabledCheckbox: !0,
      chartMenuParamsFactory: e,
      keyMapper: (i) => `${t}.${i}`,
      cssIdentifier: "charts-format-sub-level-no-header"
    };
    return this.createManagedBean(new ti(s));
  }
}, ZV = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("callout"),
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="calloutGroup">
                <ag-slider data-ref="calloutLengthSlider"></ag-slider>
                <ag-slider data-ref="calloutStrokeWidthSlider"></ag-slider>
                <ag-slider data-ref="labelOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Je],
      {
        calloutGroup: e,
        calloutLengthSlider: this.chartMenuUtils.getDefaultSliderParams("calloutLine.length", "length", 40),
        calloutStrokeWidthSlider: this.chartMenuUtils.getDefaultSliderParams(
          "calloutLine.strokeWidth",
          "strokeWidth",
          10
        ),
        labelOffsetSlider: this.chartMenuUtils.getDefaultSliderParams("calloutLabel.offset", "offset", 30)
      }
    );
  }
}, QV = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("cap"),
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    }, t = this.chartMenuUtils.getDefaultSliderParams(
      "cap.lengthRatio",
      "capLengthRatio",
      1
    );
    t.step = 0.05, this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="capsGroup">
                <ag-slider data-ref="capLengthRatioSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Je],
      {
        capsGroup: e,
        capLengthRatioSlider: t
      }
    );
  }
}, JV = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("connectorLine"),
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="lineGroup">
                <ag-color-picker data-ref="lineColorPicker"></ag-color-picker>
                <ag-slider data-ref="lineStrokeWidthSlider"></ag-slider>
                <ag-slider data-ref="lineOpacitySlider"></ag-slider>
                <ag-slider data-ref="lineDashSlider"></ag-slider>                
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        lineGroup: e,
        lineColorPicker: this.chartMenuUtils.getDefaultColorPickerParams("line.stroke"),
        lineStrokeWidthSlider: this.getSliderParams("strokeWidth", 10, "line.strokeWidth"),
        lineDashSlider: this.getSliderParams("lineDash", 30, "line.lineDash", 1, !0),
        lineOpacitySlider: this.getSliderParams("strokeOpacity", 1, "line.strokeOpacity", 0.05)
      }
    );
  }
  getSliderParams(e, t, s, i = 1, r = !1) {
    const o = this.chartMenuUtils.getDefaultSliderParams(s, e, t, r);
    return o.step = i, o;
  }
};
function $f(e) {
  return ["square", "circle", "cross", "diamond", "plus", "triangle", "heart"].map((t) => ({
    value: t,
    text: e.translate(t)
  }));
}
var eN = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.chartMenuUtils.addEnableParams("marker.enabled", {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("markers"),
      suppressEnabledCheckbox: !0,
      useToggle: !0,
      suppressOpenCloseIcons: !0
    });
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="seriesMarkersGroup">
                <ag-select data-ref="seriesMarkerShapeSelect"></ag-select>
                <ag-slider data-ref="seriesMarkerSizeSlider"></ag-slider>
                <ag-slider data-ref="seriesMarkerStrokeWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Rr, Je],
      {
        seriesMarkersGroup: e,
        seriesMarkerShapeSelect: this.chartMenuUtils.getDefaultSelectParams(
          "marker.shape",
          "shape",
          $f(this.chartTranslation)
        ),
        seriesMarkerSizeSlider: this.chartMenuUtils.getDefaultSliderParams("marker.size", "size", 60),
        seriesMarkerStrokeWidthSlider: this.chartMenuUtils.getDefaultSliderParams(
          "marker.strokeWidth",
          "strokeWidth",
          10
        )
      }
    );
  }
}, tN = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e, this.seriesItemsGroup = S, this.activePanels = [];
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("seriesItems"),
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="seriesItemsGroup">
                <ag-select data-ref="seriesItemSelect"></ag-select>
            </ag-group-component>
        </div>`,
      [le, Rr],
      {
        seriesItemsGroup: e,
        seriesItemSelect: this.getSeriesItemsParams()
      }
    ), this.initSeriesControls();
  }
  getSeriesItemsParams() {
    const e = [
      { value: "positive", text: this.chartTranslation.translate("seriesItemPositive") },
      { value: "negative", text: this.chartTranslation.translate("seriesItemNegative") }
    ], t = (s) => {
      this.destroyActivePanels(), this.initSeriesControls(s);
    };
    return this.chartMenuUtils.getDefaultSelectParamsWithoutValueParams(
      "seriesItemType",
      e,
      "positive",
      t
    );
  }
  initSeriesControls(e = "positive") {
    this.initSlider("strokeWidth", 10, `item.${e}.strokeWidth`), this.initSlider("lineDash", 30, `item.${e}.lineDash`, 1, !0), this.initSlider("strokeOpacity", 1, `item.${e}.strokeOpacity`, 0.05, !1), this.initSlider("fillOpacity", 1, `item.${e}.fillOpacity`, 0.05, !1), this.initItemLabels(e);
  }
  initSlider(e, t, s, i = 1, r = !1) {
    const o = this.chartMenuUtils.getDefaultSliderParams(s, e, t, r);
    o.step = i;
    const n = this.seriesItemsGroup.createManagedBean(new rt(o));
    this.seriesItemsGroup.addItem(n), this.activePanels.push(n);
  }
  initItemLabels(e) {
    const t = this.chartMenuUtils.getDefaultFontPanelParams(
      `item.${e}.label`,
      "seriesItemLabels"
    ), s = this.createBean(new ti(t));
    this.seriesItemsGroup.addItem(s), this.activePanels.push(s);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}, sN = class extends L {
  constructor(e, t = "shadow") {
    super(), this.chartMenuUtils = e, this.propertyKey = t;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = this.propertyKey, t = this.chartMenuUtils.addEnableParams(
      `${e}.enabled`,
      {
        cssIdentifier: "charts-format-sub-level",
        direction: "vertical",
        suppressOpenCloseIcons: !0,
        title: this.chartTranslation.translate("shadow"),
        suppressEnabledCheckbox: !0,
        useToggle: !0
      }
    ), s = this.chartMenuUtils.getDefaultColorPickerParams(`${e}.color`);
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="shadowGroup">
                <ag-color-picker data-ref="shadowColorPicker"></ag-color-picker>
                <ag-slider data-ref="shadowBlurSlider"></ag-slider>
                <ag-slider data-ref="shadowXOffsetSlider"></ag-slider>
                <ag-slider data-ref="shadowYOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        shadowGroup: t,
        shadowColorPicker: s,
        shadowBlurSlider: this.getSliderParams("blur", 0, 20),
        shadowXOffsetSlider: this.getSliderParams("xOffset", -10, 10),
        shadowYOffsetSlider: this.getSliderParams("yOffset", -10, 10)
      }
    );
  }
  getSliderParams(e, t, s) {
    const i = `${this.propertyKey}.${e}`, r = this.chartMenuUtils.getDefaultSliderParams(i, e, s);
    return r.minValue = t, r;
  }
}, iN = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="groupSpacing">
                <ag-slider data-ref="groupPaddingSlider"></ag-slider>
                <ag-slider data-ref="groupSpacingSlider"></ag-slider>
            </ag-group-component>
            <ag-group-component data-ref="tileSpacing">
                <ag-slider data-ref="tilePaddingSlider"></ag-slider>
                <ag-slider data-ref="tileSpacingSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Je],
      {
        groupSpacing: { ...e, title: this.chartTranslation.translate("group") },
        tileSpacing: { ...e, title: this.chartTranslation.translate("tile") },
        groupPaddingSlider: this.getSliderParams("padding", "group.padding"),
        groupSpacingSlider: this.getSliderParams("spacing", "group.gap"),
        tilePaddingSlider: this.getSliderParams("padding", "tile.padding"),
        tileSpacingSlider: this.getSliderParams("spacing", "tile.gap")
      }
    );
  }
  getSliderParams(e, t) {
    return this.chartMenuUtils.getDefaultSliderParams(t, e, 10);
  }
}, rN = class extends L {
  constructor(e) {
    super(), this.chartMenuUtils = e;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      title: this.chartTranslation.translate("whisker"),
      enabled: !0,
      suppressOpenCloseIcons: !0,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="whiskersGroup">
                <ag-color-picker data-ref="whiskerColorPicker"></ag-color-picker>
                <ag-slider data-ref="whiskerThicknessSlider"></ag-slider>
                <ag-slider data-ref="whiskerOpacitySlider"></ag-slider>
                <ag-slider data-ref="whiskerLineDashSlider"></ag-slider>
                <ag-slider data-ref="whiskerLineDashOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`,
      [le, Ht, Je],
      {
        whiskersGroup: e,
        whiskerColorPicker: this.chartMenuUtils.getDefaultColorPickerParams("whisker.stroke"),
        whiskerThicknessSlider: this.chartMenuUtils.getDefaultSliderParams(
          "whisker.strokeWidth",
          "strokeWidth",
          10
        ),
        whiskerOpacitySlider: this.chartMenuUtils.getDefaultSliderParams(
          "whisker.strokeOpacity",
          "strokeOpacity",
          1
        ),
        whiskerLineDashSlider: this.chartMenuUtils.getDefaultSliderParams(
          "whisker.lineDash",
          "lineDash",
          30,
          !0
        ),
        whiskerLineDashOffsetSlider: this.chartMenuUtils.getDefaultSliderParams(
          "whisker.lineDashOffset",
          "lineDashOffset",
          30
        )
      }
    );
  }
}, ue = "tooltips", Ke = "strokeWidth", tt = "lineDash", De = "lineOpacity", st = "fillOpacity", xe = "labels", As = "shadow", oN = class extends L {
  constructor(e) {
    super(), this.options = e, this.seriesGroup = S, this.activePanels = [], this.widgetFuncs = {
      lineWidth: () => this.initStrokeWidth("lineWidth"),
      [Ke]: () => this.initStrokeWidth("strokeWidth"),
      lineColor: () => this.initLineColor(),
      [tt]: () => this.initLineDash(),
      [De]: () => this.initOpacity("strokeOpacity"),
      [st]: () => this.initOpacity("fillOpacity"),
      markers: () => new eN(this.chartMenuUtils),
      [xe]: () => this.initLabels(),
      sectorLabels: () => this.initSectorLabels(),
      [As]: () => new sN(this.chartMenuUtils),
      [ue]: () => this.initTooltips(),
      bins: () => this.initBins(),
      whiskers: () => new rN(this.chartMenuUtils),
      caps: () => new QV(this.chartMenuUtils),
      connectorLine: () => new JV(this.chartMenuUtils),
      seriesItems: () => new tN(this.chartMenuUtils),
      tileSpacing: () => new iN(this.chartMenuUtils),
      shape: () => this.initShape(),
      size: () => this.initSize("size", "size"),
      minSize: () => this.initSize("size", "minSize"),
      maxSize: () => this.initSize("maxSize", "maxSize")
    }, this.seriesWidgetMappings = {
      bar: [ue, Ke, tt, De, st, xe, As],
      pie: [ue, Ke, De, st, xe, "sectorLabels", As],
      donut: [ue, Ke, De, st, xe, "sectorLabels", As],
      line: [ue, "lineWidth", tt, De, "markers", xe],
      scatter: [ue, "shape", "size", Ke, xe],
      bubble: [ue, "shape", "minSize", "maxSize", Ke, xe],
      area: [ue, "lineWidth", tt, De, st, "markers", xe, As],
      histogram: [ue, "bins", Ke, tt, De, st, xe, As],
      "radial-column": [ue, Ke, tt, De, st, xe],
      "radial-bar": [ue, Ke, tt, De, st, xe],
      "radar-line": [ue, Ke, tt, De, "markers", xe],
      "radar-area": [ue, Ke, tt, De, st, "markers", xe],
      nightingale: [ue, Ke, tt, De, st, xe],
      "box-plot": [ue, Ke, tt, De, st, "whiskers", "caps"],
      "range-bar": [ue, Ke, tt, De, st, xe],
      "range-area": [ue, "lineWidth", tt, De, st, "markers", xe, As],
      treemap: [ue, "tileSpacing"],
      sunburst: [ue],
      heatmap: [ue, xe, "lineColor", "lineWidth", De],
      waterfall: [ue, "connectorLine", "seriesItems"]
    }, this.seriesType = e.seriesType;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const {
      isExpandedOnInit: e,
      chartOptionsService: t,
      chartController: s,
      registerGroupComponent: i
    } = this.options, r = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.translate("series"),
      expanded: e,
      suppressEnabledCheckbox: !0
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="seriesGroup">
            </ag-group-component>
        </div>`,
      [le],
      { seriesGroup: r }
    ), i(this.seriesGroup), this.chartMenuUtils = this.createManagedBean(
      new ei(t.getSeriesOptionsProxy(() => this.seriesType))
    ), this.addManagedListeners(s, { chartSeriesChartTypeChanged: this.refreshWidgets.bind(this) }), this.refreshWidgets();
  }
  refreshWidgets() {
    const { chartController: e } = this.options;
    this.destroyActivePanels(), e.getChartProxy().getChart().waitForUpdate().then(() => {
      this.isAlive() && (e.isComboChart() && (this.updateSeriesType(), this.initSeriesSelect()), (this.seriesWidgetMappings[this.seriesType] ?? []).forEach((i) => {
        const r = this.widgetFuncs[i]();
        let o;
        if (Array.isArray(r)) {
          const n = this.createBean(r[0]);
          o = n, r[1](n);
        } else
          o = this.createBean(r);
        this.seriesGroup.addItem(o), this.activePanels.push(o);
      }));
    }).catch((s) => z(105, { e: s }));
  }
  initSeriesSelect() {
    const e = this.createBean(
      new Ne(
        this.chartMenuUtils.getDefaultSelectParamsWithoutValueParams(
          "seriesType",
          this.getSeriesSelectOptions(),
          `${this.seriesType}`,
          (t) => {
            this.seriesType = t, this.refreshWidgets();
          }
        )
      )
    );
    this.seriesGroup.addItem(e), this.activePanels.push(e);
  }
  initTooltips() {
    return new Ii(
      this.chartMenuUtils.addValueParams("tooltip.enabled", {
        label: this.translate("tooltips"),
        labelAlignment: "left",
        labelWidth: "flex",
        inputWidth: "flex"
      })
    );
  }
  initLineColor() {
    return new Vf(this.chartMenuUtils.getDefaultColorPickerParams("stroke", "strokeColor"));
  }
  initStrokeWidth(e) {
    return new rt(this.chartMenuUtils.getDefaultSliderParams("strokeWidth", e, 10));
  }
  initLineDash() {
    return new rt(this.chartMenuUtils.getDefaultSliderParams("lineDash", "lineDash", 30, !0));
  }
  initOpacity(e) {
    const t = this.chartMenuUtils.getDefaultSliderParams(e, e, 1);
    return t.step = 0.05, new rt(t);
  }
  initLabels() {
    const e = Af(this.seriesType), t = e ? "calloutLabel" : "label", s = e ? "calloutLabels" : "labels", i = this.chartMenuUtils.getDefaultFontPanelParams(t, s);
    return [new ti(i), (n) => {
      if (e) {
        const a = n.createManagedBean(new ZV(this.chartMenuUtils));
        n.addItem(a), this.activePanels.push(a);
      }
      if (this.seriesType === "range-bar") {
        const a = [
          { value: "inside", text: this.translate("inside") },
          { value: "outside", text: this.translate("outside") }
        ], l = n.createManagedBean(
          new Ne(
            this.chartMenuUtils.getDefaultSelectParams("label.placement", "labelPlacement", a)
          )
        );
        n.addItem(l), this.activePanels.push(l);
        const d = n.createManagedBean(
          new rt(this.chartMenuUtils.getDefaultSliderParams("label.padding", "padding", 200))
        );
        n.addItem(d), this.activePanels.push(d);
      }
    }];
  }
  initSectorLabels() {
    const e = this.chartMenuUtils.getDefaultFontPanelParams("sectorLabel", "sectorLabels");
    return [new ti(e), (i) => {
      const r = this.chartMenuUtils.getDefaultSliderParams(
        "sectorLabel.positionRatio",
        "positionRatio",
        1
      );
      r.step = 0.05;
      const o = i.createManagedBean(new rt(r));
      i.addItem(o);
    }];
  }
  initBins() {
    const e = this.chartMenuUtils.getDefaultSliderParams("binCount", "histogramBinCount", 20), t = this.chartMenuUtils.getChartOptions(), s = (t.getValue("bins") ?? t.getValue("calculatedBins", !0)).length;
    return e.value = `${s}`, e.maxValue = Math.max(s, 20), new rt(e);
  }
  initShape() {
    return new Ne(
      this.chartMenuUtils.getDefaultSelectParams("shape", "shape", $f(this.chartTranslation))
    );
  }
  initSize(e, t) {
    return new rt(this.chartMenuUtils.getDefaultSliderParams(e, t, 60));
  }
  getSeriesSelectOptions() {
    const e = this.getActiveSeriesTypes();
    return ["area", "bar", "line"].filter((t) => e.includes(t)).map((t) => ({ value: t, text: this.translate(t) }));
  }
  updateSeriesType() {
    const e = this.getActiveSeriesTypes();
    !e.includes(this.seriesType) && e.length > 0 && (this.seriesType = e[0]);
  }
  getActiveSeriesTypes() {
    return this.options.chartController.getActiveSeriesChartTypes().map((e) => ne(e.chartType));
  }
  translate(e) {
    return this.chartTranslation.translate(e);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      ce(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}, Zi = class extends L {
  constructor(e, t, s) {
    super(
      /* html */
      "<div></div>"
    ), this.chartMenuUtils = e, this.name = t, this.key = s, this.chartOptions = e.getChartOptions();
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    this.initFontPanel();
  }
  hasTitle() {
    const e = this.chartOptions.getValue(this.key);
    return e && e.enabled && e.text && e.text.length > 0;
  }
  initFontPanel() {
    const e = this.hasTitle(), t = {
      name: this.chartTranslation.translate(this.name),
      enabled: e,
      suppressEnabledCheckbox: !1,
      chartMenuParamsFactory: this.chartMenuUtils,
      keyMapper: (s) => `${this.key}.${s}`,
      onEnableChange: (s) => this.onEnableChange(s)
    };
    this.fontPanel = this.createManagedBean(new ti(t)), this.fontPanel.addItem(this.createBean(new Tt(this.getTextInputParams())), !0), this.fontPanel.addItem(this.createBean(new rt(this.getSpacingSliderParams()))), this.getGui().appendChild(this.fontPanel.getGui());
  }
  getTextInputParams() {
    return this.chartMenuUtils.addValueParams(`${this.key}.text`, {
      label: this.chartTranslation.translate("title"),
      labelAlignment: "top"
    });
  }
  getSpacingSliderParams() {
    return this.chartMenuUtils.getDefaultSliderParams(`${this.key}.spacing`, "spacing", 100);
  }
  onEnableChange(e) {
    this.chartOptions.setValue(`${this.key}.enabled`, e);
  }
}, nN = class extends Zi {
  wireBeans(e) {
    super.wireBeans(e), this.chartMenuSvc = e.chartMenuSvc;
  }
  postConstruct() {
    this.titlePlaceholder = this.chartTranslation.translate("titlePlaceholder"), super.postConstruct(), this.addManagedEventListeners({
      chartTitleEdit: () => {
        this.fontPanel.setEnabled(this.hasTitle());
      }
    });
  }
  getTextInputParams() {
    const e = super.getTextInputParams();
    return this.shouldOverrideTextWithPlaceholder(e.value) && (e.value = this.titlePlaceholder), e;
  }
  getSpacingSliderParams() {
    const e = super.getSpacingSliderParams();
    return e.value = "10", e;
  }
  onEnableChange(e) {
    if (this.chartMenuSvc.doesChartToolbarExist()) {
      const s = this.chartOptions.getValue("padding.top");
      this.chartOptions.setValue("padding.top", e ? s - 20 : s + 20);
    }
    this.chartOptions.setValue(`${this.key}.enabled`, e);
    const t = this.chartOptions.getValue(`${this.key}.text`);
    e && this.shouldOverrideTextWithPlaceholder(t) && this.chartOptions.setValue(`${this.key}.text`, this.titlePlaceholder);
  }
  shouldOverrideTextWithPlaceholder(e) {
    return e === "Title" || (e == null ? void 0 : e.trim().length) === 0;
  }
}, aN = class extends L {
  constructor(e) {
    super(), this.options = e, this.titleGroup = S;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    const {
      chartMenuParamsFactory: e,
      chartAxisMenuParamsFactory: t,
      chartOptionsService: s,
      seriesType: i,
      isExpandedOnInit: r = !1,
      registerGroupComponent: o
    } = this.options, n = [];
    if (gs(i)) {
      const l = (d) => this.createManagedBean(
        new ei(s.getCartesianAxisThemeOverridesProxy(d))
      );
      n.push(
        this.createManagedBean(new Zi(l("xAxis"), "horizontalAxisTitle", "title"))
      ), n.push(
        this.createManagedBean(new Zi(l("yAxis"), "verticalAxisTitle", "title"))
      );
    } else ja(i) && n.push(
      this.createManagedBean(new Zi(t, "polarAxisTitle", "title"))
    );
    const a = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical",
      title: this.chartTranslation.translate("chartTitles"),
      expanded: r,
      suppressEnabledCheckbox: !0,
      items: [
        this.createManagedBean(new nN(e, "chartTitle", "title")),
        this.createManagedBean(new Zi(e, "chartSubtitle", "subtitle")),
        ...n
      ]
    };
    this.setTemplate(
      /* html */
      `<div>
            <ag-group-component data-ref="titleGroup"></ag-group-component>
        </div>`,
      [le],
      { titleGroup: a }
    ), o(this.titleGroup);
  }
}, lN = {
  groups: [{ type: "chart" }, { type: "titles" }, { type: "legend" }, { type: "series" }, { type: "axis" }]
}, dN = class extends L {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-chart-format-wrapper"></div>'
    ), this.chartMenuContext = e;
  }
  postConstruct() {
    this.groupExpansionFeature = this.createManagedBean(new YV(this.getGui())), this.chartPanelFeature = this.createManagedBean(
      new Bf(
        this.chartMenuContext.chartController,
        this.getGui(),
        "ag-chart-format-section",
        (e, t) => this.createPanels(t)
      )
    ), this.chartPanelFeature.refreshPanels();
  }
  createPanels(e) {
    var s;
    let t = !1;
    (s = this.getFormatPanelDef().groups) == null || s.forEach(({ type: i, isOpen: r = !1 }) => {
      if (!this.isGroupPanelShownInSeries(i, e))
        return;
      r && (t && R(145, { group: i }), t = !0);
      const o = (a) => this.groupExpansionFeature.addGroupComponent(a), n = {
        ...this.chartMenuContext,
        isExpandedOnInit: r,
        seriesType: e,
        registerGroupComponent: o
      };
      switch (i) {
        case "chart":
          this.chartPanelFeature.addComponent(new qV(n));
          break;
        case "titles":
          this.chartPanelFeature.addComponent(new aN(n));
          break;
        case "legend":
          this.chartPanelFeature.addComponent(new XV(n));
          break;
        case "axis":
          ja(e) ? this.chartPanelFeature.addComponent(new KV(n)) : gs(e) && (this.chartPanelFeature.addComponent(new Xr("xAxis", n)), this.chartPanelFeature.addComponent(new Xr("yAxis", n)));
          break;
        case "horizontalAxis":
          this.chartPanelFeature.addComponent(new Xr("xAxis", n));
          break;
        case "verticalAxis":
          this.chartPanelFeature.addComponent(new Xr("yAxis", n));
          break;
        case "series":
          this.chartPanelFeature.addComponent(new oN(n));
          break;
        default:
          R(147, { group: i });
      }
    });
  }
  getFormatPanelDef() {
    var t;
    const e = (t = this.gos.get("chartToolPanelsDef")) == null ? void 0 : t.formatPanel;
    return e || lN;
  }
  isGroupPanelShownInSeries(e, t) {
    return ["chart", "titles", "legend", "series"].includes(e) || gs(t) && ["axis", "horizontalAxis", "verticalAxis"].includes(e) || ja(t) && e === "axis";
  }
};
function Lr(e) {
  const {
    stacked: t,
    size: s,
    padding: i,
    xScalePadding: r,
    xScaleDomain: o,
    yScaleDomain: n,
    agChartsExports: { _Scene: a }
  } = e, l = new a.BandScale();
  l.domain = o, l.range = [i, s - i], l.paddingInner = r, l.paddingOuter = r;
  const d = new a.LinearScale();
  d.domain = n, d.range = [s - i, i];
  const c = (h, u, p) => h.map((g, f) => {
    const m = p.convert(g), C = new a.Rect();
    return C.x = u.convert(f), C.y = m, C.width = u.bandwidth, C.height = p.convert(0) - m, C.strokeWidth = 0, C.crisp = !0, C;
  });
  return t ? e.data.map((h) => c(h, l, d)) : c(e.data, l, d);
}
function jf(e, t, s, i) {
  const r = [0, t[0].length - 1], o = t.reduce(
    (l, d) => (d.forEach((c) => {
      c < l[0] && (l[0] = c), c > l[1] && (l[1] = c);
    }), l),
    [1 / 0, -1 / 0]
  );
  o[0]--, o[o.length - 1]++;
  const n = new e.LinearScale();
  n.domain = r, n.range = [i, s - i];
  const a = new e.LinearScale();
  return a.domain = o, a.range = [s - i, i], { xScale: n, yScale: a };
}
function qf(e, t, s) {
  return e.map(
    (i) => i.map((r, o) => [
      o > 0 ? "lineTo" : "moveTo",
      t.convert(o),
      s.convert(r)
    ])
  );
}
function Yf(e, t) {
  const s = new e.Path();
  return t.forEach(([i, r, o]) => s.path[i](r, o)), s;
}
function cN(e, t, s) {
  return e.map((i, r, o) => {
    const a = [...s ? hN(o, r, t) : Xf(i, t)].reverse().map(([c, h, u]) => ["lineTo", h, u]), l = i[0], d = V(a);
    return (l[1] !== d[1] || l[2] !== d[2]) && a.push(["lineTo", l[1], l[2]]), [...i, ...a];
  });
}
function hN(e, t, s) {
  return t === 0 ? Xf(e[t], s) : [...e[t - 1]];
}
function Xf(e, t) {
  return e.map(([s, i]) => [s, i, t.convert(0)]);
}
function od({ _Scene: e }, t, s, i, r) {
  const { xScale: o, yScale: n } = jf(e, s, i, r), l = qf(s, o, n).map((c) => {
    const h = Yf(e, c);
    return h.strokeWidth = 3, h.lineCap = "round", h.fill = void 0, h;
  }), d = new e.Group();
  return d.setClipRect(new e.BBox(r, r, i - r * 2, i - r * 2)), d.append(l), t.append(d), l;
}
function uN(e, t, s, i, r, o = !1) {
  const { xScale: n, yScale: a } = jf(e, s, i, r), l = cN(qf(s, n, a), a, o), d = new e.Group();
  d.setClipRect(new e.BBox(r, r, i - r * 2, i - r * 2));
  const c = l.map((h) => Yf(e, h));
  return d.append(c), t.append(d), c;
}
function Zf(e) {
  return e.map(
    (t, s, i) => t.map((r, o) => i.slice(0, s + 1).reduce((n, a) => n + a[o], 0))
  );
}
function Qf(e) {
  const t = e.map((s, i) => e.reduce((r, o) => Math.max(r, o[i]), 0));
  return e.map((s) => s.map((i, r) => i / t[r] * 19));
}
function Jf(e, t, s, i, r, o, n = 0) {
  const { _Scene: a } = e, l = new a.LinearScale();
  l.domain = [0, 7], l.range = [-Math.PI, Math.PI].map((g) => g + Math.PI / 2);
  const d = new a.LinearScale();
  d.domain = [0, 10], d.range = [r, o];
  const c = [], h = i / 2, u = s.map((g) => {
    const f = new a.Path();
    return f.strokeWidth = 1, f.strokeOpacity = 0.5, f.lineCap = "round", f.fill = void 0, f.fillOpacity = 0.8, g.forEach((m, C) => {
      const v = l.convert(C), b = r + o - d.convert(m), y = b * Math.cos(v) + h, F = b * Math.sin(v) + h;
      if (f.path[C > 0 ? "lineTo" : "moveTo"](y, F), n > 0) {
        const D = new a.Circle();
        D.x = y, D.y = F, D.size = n, c.push(D);
      }
    }), f.path.closePath(), f;
  }), p = new a.Group();
  return p.append([...u, ...c]), t.append(p), { paths: u, markers: c };
}
function bn(e) {
  let [t, s] = [1 / 0, -1 / 0];
  return { processedData: e.reduce((r, o, n) => {
    const a = n > 0 ? r[n - 1] : void 0;
    r[n] ?? (r[n] = []);
    const l = r[n];
    return o.forEach((d, c) => {
      a && (d += a[c]), l[c] = d, l[c] < t && (t = l[c]), l[c] > s && (s = l[c]);
    }), r;
  }, []), min: t, max: s };
}
var pN = "ag-chart-mini-thumbnail-canvas", Bi = class extends L {
  constructor(e, t, s) {
    super(), this.agChartsExports = t, this.tooltipName = s, this.size = 58, this.padding = 5;
    const { _Scene: i } = t;
    this.root = new i.Group();
    const r = new i.Scene({
      width: this.size,
      height: this.size
    });
    r.canvas.element.classList.add(pN), r.setRoot(this.root), r.setContainer(e), this.scene = r;
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    this.scene.canvas.element.title = this.chartTranslation.translate(this.tooltipName);
    try {
      this.scene.render();
    } catch (e) {
      z(108, { e });
    }
  }
}, We = class extends Bi {
  constructor(e, t, s) {
    super(e, t, s), this.stroke = "gray", this.axisOvershoot = 3;
  }
  postConstruct() {
    const { _Scene: e } = this.agChartsExports, t = this.size, s = this.padding, i = new e.Line();
    i.x1 = s, i.y1 = s, i.x2 = s, i.y2 = t - s + this.axisOvershoot, i.stroke = this.stroke;
    const r = new e.Line();
    r.x1 = s - this.axisOvershoot + 1, r.y1 = t - s, r.x2 = t - s + 1, r.y2 = t - s, r.stroke = this.stroke;
    const o = this.root;
    o.append(i), o.append(r), super.postConstruct();
  }
}, em = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "groupedColumnTooltip"), this.columnData = [2, 3, 4];
    const { root: r, columnData: o, size: n, padding: a } = this;
    this.columns = Lr({
      stacked: !1,
      data: o,
      size: n,
      padding: a,
      xScaleDomain: [0, 1, 2],
      yScaleDomain: [0, 4],
      xScalePadding: 0.3,
      agChartsExports: t
    }), r.append(this.columns), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.columns.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    });
  }
};
em.chartType = "groupedColumn";
var nd = class tm extends We {
  constructor(t, s, i, r, o, n, a = tm.data, l = [0, 16], d = "stackedColumnTooltip") {
    super(t, s, d);
    const { root: c, size: h, padding: u } = this;
    this.stackedColumns = Lr({
      stacked: !0,
      data: a,
      size: h,
      padding: u,
      xScaleDomain: [0, 1, 2],
      yScaleDomain: l,
      xScalePadding: 0.3,
      agChartsExports: s
    }), c.append([].concat.apply([], this.stackedColumns)), this.updateColors(i, r);
  }
  updateColors(t, s) {
    this.stackedColumns.forEach(
      (i, r) => i.forEach((o) => {
        o.fill = t[r], o.stroke = s[r];
      })
    );
  }
};
nd.chartType = "stackedColumn";
nd.data = [
  [8, 12, 16],
  [6, 9, 12],
  [2, 3, 4]
];
var sm = nd, ad = class im extends sm {
  constructor(t, s, i, r, o, n) {
    super(
      t,
      s,
      i,
      r,
      o,
      n,
      im.data,
      [0, 10],
      "normalizedColumnTooltip"
    );
  }
};
ad.chartType = "normalizedColumn";
ad.data = [
  [10, 10, 10],
  [6, 7, 8],
  [2, 4, 6]
];
var gN = ad, rm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "groupedBarTooltip");
    const { _Scene: r } = t, o = this.padding, n = this.size, a = [2, 3, 4], l = new r.BandScale();
    l.domain = [0, 1, 2], l.range = [o, n - o], l.paddingInner = 0.3, l.paddingOuter = 0.3;
    const d = new r.LinearScale();
    d.domain = [0, 4], d.range = [n - o, o];
    const c = d.convert(0), h = l.bandwidth;
    this.bars = a.map((u, p) => {
      const g = new r.Rect();
      return g.x = o, g.y = l.convert(p), g.width = c - d.convert(u), g.height = h, g.strokeWidth = 0, g.crisp = !0, g;
    }), this.updateColors(s, i), this.root.append(this.bars);
  }
  updateColors(e, t) {
    this.bars.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    });
  }
};
rm.chartType = "groupedBar";
var ld = class om extends We {
  constructor(t, s, i, r, o, n, a = om.data, l = [0, 16], d = "stackedBarTooltip") {
    super(t, s, d);
    const { _Scene: c } = s, h = this.size, u = this.padding, p = new c.BandScale();
    p.domain = [0, 1, 2], p.range = [u, h - u], p.paddingInner = 0.3, p.paddingOuter = 0.3;
    const g = new c.LinearScale();
    g.domain = l, g.range = [h - u, u];
    const f = g.convert(0), m = p.bandwidth;
    this.bars = a.map(
      (C) => C.map((v, b) => {
        const y = new c.Rect();
        return y.x = u, y.y = p.convert(b), y.width = f - g.convert(v), y.height = m, y.strokeWidth = 0, y.crisp = !0, y;
      })
    ), this.updateColors(i, r), this.root.append([].concat.apply([], this.bars));
  }
  updateColors(t, s) {
    this.bars.forEach(
      (i, r) => i.forEach((o) => {
        o.fill = t[r], o.stroke = s[r];
      })
    );
  }
};
ld.chartType = "stackedBar";
ld.data = [
  [8, 12, 16],
  [6, 9, 12],
  [2, 3, 4]
];
var nm = ld, dd = class am extends nm {
  constructor(t, s, i, r, o, n) {
    super(
      t,
      s,
      i,
      r,
      o,
      n,
      am.data,
      [0, 10],
      "normalizedBarTooltip"
    );
  }
};
dd.chartType = "normalizedBar";
dd.data = [
  [10, 10, 10],
  [6, 7, 8],
  [2, 4, 6]
];
var fN = dd, Vo = class extends Bi {
  constructor(e, t, s, i, r, o, n = 0.6, a = "donutTooltip") {
    super(e, t, a);
    const {
      size: l,
      padding: d,
      agChartsExports: { _Scene: c }
    } = this, h = (l - d * 2) / 2, u = h + d, p = c.toRadians, g = [
      [p(-90), p(30)],
      [p(30), p(120)],
      [p(120), p(180)],
      [p(180), p(210)],
      [p(210), p(240)],
      [p(240), p(270)]
    ];
    this.sectors = g.map(([f, m]) => {
      const C = new c.Sector();
      return C.centerX = u, C.centerY = u, C.innerRadius = h * n, C.outerRadius = h, C.startAngle = f, C.endAngle = m, C.stroke = void 0, C.strokeWidth = 0, C.inset = 0.75, C;
    }), this.updateColors(s, i), this.root.append(this.sectors);
  }
  updateColors(e, t) {
    this.sectors.forEach((s, i) => {
      s.fill = e[i % e.length], s.stroke = t[i % t.length];
    });
  }
};
Vo.chartType = "donut";
var lm = class extends Vo {
  constructor(e, t, s, i, r, o) {
    super(e, t, s, i, r, o, 0, "pieTooltip");
  }
};
lm.chartType = "pie";
var cd = class dm extends We {
  constructor(t, s, i, r, o, n, a = dm.data, l = "lineTooltip") {
    super(t, s, l);
    const { size: d, padding: c, root: h } = this;
    this.lines = od(s, h, a, d, c), this.updateColors(i, r);
  }
  updateColors(t, s) {
    this.lines.forEach((i, r) => {
      i.stroke = t[r];
    });
  }
};
cd.chartType = "line";
cd.data = [
  [1, 3, 5],
  [2, 6, 4],
  [5, 3, 1]
];
var kr = cd, hd = class cm extends kr {
  constructor(t, s, i, r, o, n, a = cm.data, l = "stackedLineTooltip") {
    super(t, s, i, r, o, n, a, l);
  }
};
hd.chartType = "stackedLine";
hd.data = Zf(kr.data);
var hm = hd, ud = class um extends kr {
  constructor(t, s, i, r, o, n, a = um.data, l = "normalizedLineTooltip") {
    super(t, s, i, r, o, n, a, l);
  }
};
ud.chartType = "normalizedLine";
ud.data = Qf(hm.data);
var mN = ud, pm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "scatterTooltip");
    const {
      size: r,
      padding: o,
      agChartsExports: { _Scene: n }
    } = this, a = [
      [
        [0.3, 3],
        [1.1, 0.9],
        [2, 0.4],
        [3.4, 2.4]
      ],
      [
        [0, 0.3],
        [1, 2],
        [2.4, 1.4],
        [3, 0]
      ]
    ], l = new n.LinearScale();
    l.domain = [-0.5, 4], l.range = [o * 2, r - o];
    const d = new n.LinearScale();
    d.domain = [-0.5, 3.5], d.range = [r - o, o];
    const c = [];
    a.forEach((u) => {
      u.forEach(([p, g]) => {
        const f = new n.Arc();
        f.strokeWidth = 0, f.centerX = l.convert(p), f.centerY = d.convert(g), f.radius = 2.5, c.push(f);
      });
    }), this.points = c, this.updateColors(s, i);
    const h = new n.Group();
    h.setClipRect(new n.BBox(o, o, r - o * 2, r - o * 2)), h.append(this.points), this.root.append(h);
  }
  updateColors(e, t) {
    this.points.forEach((s, i) => {
      s.stroke = t[i % t.length], s.fill = e[i % e.length];
    });
  }
};
pm.chartType = "scatter";
var gm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "bubbleTooltip");
    const {
      size: r,
      padding: o,
      agChartsExports: { _Scene: n }
    } = this, a = [
      [
        [0.1, 0.3, 5],
        [0.5, 0.4, 7],
        [0.2, 0.8, 7]
      ],
      [
        [0.8, 0.7, 5],
        [0.7, 0.3, 9]
      ]
    ], l = new n.LinearScale();
    l.domain = [0, 1], l.range = [o * 2, r - o];
    const d = new n.LinearScale();
    d.domain = [0, 1], d.range = [r - o, o];
    const c = [];
    a.forEach((u) => {
      u.forEach(([p, g, f]) => {
        const m = new n.Arc();
        m.strokeWidth = 0, m.centerX = l.convert(p), m.centerY = d.convert(g), m.radius = f, m.fillOpacity = 0.7, c.push(m);
      });
    }), this.points = c, this.updateColors(s, i);
    const h = new n.Group();
    h.setClipRect(new n.BBox(o, o, r - o * 2, r - o * 2)), h.append(this.points), this.root.append(h);
  }
  updateColors(e, t) {
    this.points.forEach((s, i) => {
      s.stroke = t[i % t.length], s.fill = e[i % e.length];
    });
  }
};
gm.chartType = "bubble";
var pd = class fm extends We {
  constructor(t, s, i, r, o, n, a = fm.data, l = "groupedAreaTooltip", d = !1) {
    super(t, s, l), this.areas = uN(s._Scene, this.root, a, this.size, this.padding, d), this.updateColors(i, r);
  }
  updateColors(t, s) {
    this.areas.forEach((i, r) => {
      i.fill = t[r], i.stroke = s[r], i.strokeWidth = 1, i.strokeOpacity = 0.75, i.fillOpacity = 0.7;
    });
  }
};
pd.chartType = "area";
pd.data = kr.data;
var gd = pd, fd = class mm extends gd {
  constructor(t, s, i, r, o, n, a = mm.data, l = "stackedAreaTooltip") {
    super(
      t,
      s,
      i,
      r,
      o,
      n,
      a,
      l,
      !0
    );
  }
  updateColors(t, s) {
    this.areas.forEach((i, r) => {
      i.fill = t[r], i.stroke = s[r];
    });
  }
};
fd.chartType = "stackedArea";
fd.data = Zf(gd.data);
var md = fd, Cd = class Cm extends md {
  constructor(t, s, i, r, o, n, a = Cm.data, l = "normalizedAreaTooltip") {
    super(t, s, i, r, o, n, a, l);
  }
};
Cd.chartType = "normalizedArea";
Cd.data = Qf(md.data);
var CN = Cd, vm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "histogramTooltip");
    const {
      padding: r,
      size: o,
      agChartsExports: { _Scene: n }
    } = this, a = [2, 5, 11, 13, 10, 6, 1], l = new n.LinearScale();
    l.domain = [0, a.length], l.range = [r, o - r];
    const d = new n.LinearScale();
    d.domain = [0, a.reduce((h, u) => Math.max(h, u), 0)], d.range = [o - r, r];
    const c = d.convert(0);
    this.bars = a.map((h, u) => {
      const p = d.convert(h), g = l.convert(u), f = l.convert(u + 1), m = new n.Rect();
      return m.x = g, m.y = p, m.width = f - g, m.height = c - p, m.strokeWidth = 1, m.strokeOpacity = 0.75, m.crisp = !0, m;
    }), this.updateColors(s, i), this.root.append(this.bars);
  }
  updateColors([e], [t]) {
    this.bars.forEach((s) => {
      s.fill = e, s.stroke = t;
    });
  }
};
vm.chartType = "histogram";
var Vi = class extends Bi {
  constructor(e, t, s) {
    super(e, t, s), this.stroke = "gray", this.showRadiusAxisLine = !0, this.showAngleAxisLines = !0;
  }
  postConstruct() {
    const { _Scene: e } = this.agChartsExports, t = this.size, s = this.padding, i = s * 2, r = (t - i) / 2, o = this.showAngleAxisLines ? [r, r * 0.8, r * 0.6, r * 0.4] : [], n = new e.Line();
    n.x1 = t / 2, n.y1 = s, n.x2 = t / 2, n.y2 = t - s - r - o[o.length - 1], n.stroke = this.stroke, n.strokeOpacity = 0.5, n.fill = void 0, n.visible = this.showRadiusAxisLine;
    const a = s + r;
    this.gridLines = o.map((d, c) => {
      const h = new e.Path();
      return h.path.arc(a, a, d, 0, 2 * Math.PI), h.strokeWidth = 1, h.stroke = this.stroke, h.strokeOpacity = c === 0 ? 0.5 : 0.2, h.fill = void 0, h;
    });
    const l = this.root;
    l.append(n), this.gridLines.length > 0 && l.append(this.gridLines), super.postConstruct();
  }
}, wm = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "radialColumnTooltip"), this.data = [
      [6, 8, 10, 2, 6, 5],
      [4, 4, 3, 6, 4, 4],
      [5, 4, 2, 9, 8, 9]
    ], this.showRadiusAxisLine = !1;
    const {
      padding: r,
      size: o,
      data: n,
      agChartsExports: { _Scene: a }
    } = this, l = (o - r * 2) / 2, c = l * 0.4, h = new a.BandScale();
    h.domain = n[0].map((C, v) => v), h.range = [0, 2 * Math.PI], h.paddingInner = 0, h.paddingOuter = 0;
    const u = h.bandwidth * 0.7, { processedData: p, max: g } = bn(n), f = new a.LinearScale();
    f.domain = [0, g], f.range = [c, l];
    const m = this.size / 2;
    this.series = p.map((C, v) => {
      const y = v === 0 ? void 0 : p[v - 1], F = new a.TranslatableGroup({ zIndex: 1e6 }), D = C.map((x, T) => {
        const I = y == null ? void 0 : y[T], E = f.convert(x), M = f.convert(I ?? 0), N = h.convert(T), _ = N + u, H = a.getRadialColumnWidth(N, _, l, 0.5, 0.5), W = new a.RadialColumnShape();
        return W.columnWidth = H, W.innerRadius = M, W.outerRadius = E, W.startAngle = N, W.endAngle = _, W.isBeveled = !0, W.axisInnerRadius = c, W.axisOuterRadius = l, W.stroke = void 0, W.strokeWidth = 0, W;
      });
      return F.append(D), F.translationX = m, F.translationY = m, F;
    }), this.root.append(this.series), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.series.forEach((s, i) => {
      for (const r of s.children())
        r.fill = e[i % e.length], r.stroke = t[i % t.length];
    });
  }
};
wm.chartType = "radialColumn";
var ym = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "radialBarTooltip"), this.data = [
      [6, 8, 10],
      [4, 4, 3],
      [5, 4, 2]
    ], this.showRadiusAxisLine = !1;
    const {
      size: r,
      padding: o,
      data: n,
      agChartsExports: { _Scene: a }
    } = this, l = (r - o) / 2, c = l * 0.4, h = new a.BandScale();
    h.domain = n[0].map((b, y) => y), h.range = [c, l], h.paddingInner = 0.5, h.paddingOuter = 0;
    const u = h.bandwidth, { processedData: p, max: g } = bn(n), f = new a.LinearScale();
    f.domain = [0, Math.ceil(g * 1.5)];
    const m = 3 / 2 * Math.PI, C = m + 2 * Math.PI;
    f.range = [m, C];
    const v = r / 2;
    this.series = p.map((b, y) => {
      const F = y < 0 ? void 0 : p[y - 1], D = new a.Group({ zIndex: 1e6 }), x = b.map((T, I) => {
        const E = (F == null ? void 0 : F[I]) ?? 0, M = h.convert(I), N = M - u, _ = f.convert(E), H = f.convert(T), W = new a.Sector();
        return W.centerX = v, W.centerY = v, W.innerRadius = N, W.outerRadius = M, W.startAngle = _, W.endAngle = H, W.stroke = void 0, W.strokeWidth = 0, W;
      });
      return D.append(x), D;
    }), this.root.append(this.series), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.series.forEach((s, i) => {
      for (const r of s.children())
        r.fill = e[i % e.length], r.stroke = t[i % t.length];
    });
  }
};
ym.chartType = "radialBar";
var bm = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "radarLineTooltip"), this.markerSize = 4, this.data = [
      [8, 7, 8, 7, 8, 8, 7, 8],
      [6, 8, 5, 10, 6, 7, 4, 6],
      [0, 3, 3, 5, 4, 4, 2, 0]
    ], this.showRadiusAxisLine = !1;
    const { size: r, padding: o, root: n, data: a } = this, l = (r - o * 2) / 2, d = 0, { paths: c, markers: h } = Jf(
      t,
      n,
      a,
      r,
      l,
      d,
      this.markerSize
    );
    this.lines = c, this.markers = h, this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.lines.forEach((s, i) => {
      const r = this.data[i].length;
      s.stroke = e[i];
      const o = i * r, n = o + r;
      this.markers.slice(o, n).forEach((l) => {
        l.stroke = t[i], l.fill = e[i];
      });
    });
  }
};
bm.chartType = "radarLine";
var Sm = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "radarAreaTooltip"), this.data = [
      [8, 10, 5, 7, 4, 1, 5, 8],
      [1, 1, 2, 7, 7, 8, 10, 1],
      [4, 5, 9, 9, 4, 2, 3, 4]
    ];
    const { size: r, padding: o, root: n, data: a } = this;
    this.showRadiusAxisLine = !1;
    const l = (r - o * 2) / 2, d = l - r * 0.3;
    this.areas = Jf(t, n, a, r, l, d).paths, this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.areas.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    });
  }
};
Sm.chartType = "radarArea";
var xm = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "nightingaleTooltip"), this.data = [
      [6, 10, 9, 8, 7, 8],
      [4, 6, 5, 4, 5, 5],
      [3, 5, 4, 3, 4, 7]
    ], this.showRadiusAxisLine = !1;
    const {
      size: r,
      padding: o,
      data: n,
      agChartsExports: { _Scene: a }
    } = this, l = (r - o * 2) / 2, d = new a.BandScale();
    d.domain = n[0].map((f, m) => m), d.range = [-Math.PI, Math.PI], d.paddingInner = 0, d.paddingOuter = 0;
    const c = d.bandwidth * 0.7, { processedData: h, max: u } = bn(n), p = new a.LinearScale();
    p.domain = [0, u], p.range = [0, l];
    const g = r / 2;
    this.series = h.map((f, m) => {
      const C = m < 0 ? void 0 : h[m - 1], v = new a.Group({ zIndex: 1e6 }), b = f.map((y, F) => {
        const D = C == null ? void 0 : C[F], x = p.convert(y), T = p.convert(D ?? 0), I = d.convert(F), E = I + c, M = new a.Sector();
        return M.centerX = g, M.centerY = g, M.innerRadius = T, M.outerRadius = x, M.startAngle = I, M.endAngle = E, M.stroke = void 0, M.strokeWidth = 0, M;
      });
      return v.append(b), v;
    }), this.root.append(this.series), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.series.forEach((s, i) => {
      for (const r of s.children())
        r.fill = e[i % e.length], r.stroke = t[i % t.length];
    });
  }
};
xm.chartType = "nightingale";
var Fm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "rangeBarTooltip");
    const r = [3, 3.5, 3];
    this.bars = this.createRangeBar(this.root, r, this.size, this.padding, "vertical"), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.bars.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    });
  }
  createRangeBar(e, t, s, i, r) {
    const o = r === "horizontal", n = 2 * i, { _Scene: a } = this.agChartsExports, l = new a.BandScale();
    l.domain = t.map((g, f) => f), l.range = [i, s - i], l.paddingInner = 0.3, l.paddingOuter = 0.3;
    const d = 0.7, c = 1.3, h = new a.LinearScale();
    h.domain = [
      t.reduce((g, f) => Math.min(g, f), 1 / 0) * d,
      t.reduce((g, f) => Math.max(g, f), 0) * c
    ], h.range = [n, s - n];
    const u = l.bandwidth, p = t.map((g, f) => {
      const [m, C] = [g * d, g * c], v = l.convert(f), b = h.convert(m), y = h.convert(C) - b, F = new a.Rect();
      return F.x = o ? b : v, F.y = o ? v : b, F.width = o ? y : u, F.height = o ? u : y, F.strokeWidth = 0, F.crisp = !0, F;
    });
    return e.append(p), p;
  }
};
Fm.chartType = "rangeBar";
var Rm = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "rangeAreaTooltip");
    const r = 4, o = [
      ca({ offset: 0.375 * r, length: r, pattern: { low: 3, high: 5, period: r } }),
      ca({ offset: 0.375 * r, length: r, pattern: { low: 2.25, high: 4.25, period: r } }),
      ca({ offset: 0.75 * r, length: r, pattern: { low: 2.5, high: 4.5, period: r } })
    ], n = 1.75, a = o.map(
      (c) => c.map(([h, u]) => ({
        x: h,
        low: u - 0.5 * n,
        high: u + 0.5 * n
      }))
    ), { lines: l, areas: d } = this.createRangeArea(this.root, a, this.size, this.padding);
    this.lines = l, this.areas = d, this.updateColors(s, i);
  }
  updateColors(e, t) {
    e = Xc(e, 1, 2), t = Xc(t, 1, 2), this.lines.forEach(([s, i], r) => {
      s.fill = void 0, s.stroke = t[r], i.fill = void 0, i.stroke = t[r];
    }), this.areas.forEach((s, i) => {
      s.fill = e[i];
    });
  }
  createRangeArea(e, t, s, i) {
    const r = t.reduce((f, m) => m.reduce((C, { x: v }) => Math.min(C, v), f), 1 / 0), o = t.reduce((f, m) => m.reduce((C, { x: v }) => Math.max(C, v), f), -1 / 0), n = t.reduce((f, m) => m.reduce((C, { low: v }) => Math.min(C, v), f), 1 / 0), a = t.reduce(
      (f, m) => m.reduce((C, { high: v }) => Math.max(C, v), f),
      -1 / 0
    ), { _Scene: l } = this.agChartsExports, d = new l.LinearScale();
    d.domain = [r, o], d.range = [i, s - i];
    const c = 2 * i, h = new l.LinearScale();
    h.domain = [n, a], h.range = [s - c, c];
    const u = [], p = [];
    return t.map((f) => {
      const m = new l.Path(), C = new l.Path(), v = new l.Path();
      return u.push([m, C]), p.push(v), m.strokeWidth = 0, C.strokeWidth = 0, v.strokeWidth = 0, v.fillOpacity = 0.8, m.path.clear(), C.path.clear(), v.path.clear(), f.map((b, y) => {
        const { x: F, low: D, high: x } = b, T = d.convert(F), I = h.convert(D), E = h.convert(x), M = y > 0 ? "lineTo" : "moveTo";
        return m.path[M](T, E), C.path[M](T, I), v.path[M](T, E), [T, I];
      });
    }).forEach((f, m) => {
      const C = f.length - 1, v = p[m];
      for (let b = C; b >= 0; b--) {
        const [y, F] = f[b];
        v.path.lineTo(y, F);
      }
    }), e.append(p.concat(...u)), { lines: u, areas: p };
  }
};
Rm.chartType = "rangeArea";
function ca(e) {
  const { offset: t, length: s, pattern: i } = e, r = a(t, s, i), o = 0, n = s;
  return (r.length === 0 || r[0][0] !== o) && r.unshift(l(o, t, i)), r[r.length - 1][0] !== n && r.push(l(n, t, i)), r;
  function a(c, h, u) {
    const { period: p } = u, g = c / p, m = [0, 0.5].map((v) => v - g).map(Yc).sort((v, b) => v - b);
    return Array.from(
      { length: Math.floor(m.length * (p / h)) },
      (v, b) => m[b % m.length] + Math.floor(b / m.length)
    ).map((v) => v * p).map((v) => l(v, c, u));
  }
  function l(c, h, u) {
    return [c, d(h + c, u)];
  }
  function d(c, h) {
    const { low: u, high: p, period: g } = h, f = Yc(c / g), m = f > 0.5 ? 1 - 2 * (f - 0.5) : 2 * f;
    return u + (p - u) * m;
  }
}
function Yc(e) {
  const t = e % 1;
  return t < 0 ? t + 1 : t;
}
function Xc(e, t, s) {
  const i = [...e], r = i[t];
  return i[t] = i[s], i[s] = r, i;
}
var Pm = class extends We {
  constructor(e, t, s, i, r, o) {
    super(e, t, "boxPlotTooltip");
    const {
      size: n,
      padding: a,
      agChartsExports: { _Scene: l }
    } = this, d = [11, 11.5, 10.5], c = 1.2, h = 1.1, u = 0.9, p = 0.8, g = new l.LinearScale();
    g.domain = [
      d.reduce((v, b) => Math.min(v, b), 1 / 0) * p,
      d.reduce((v, b) => Math.max(v, b), 0) * c
    ], g.range = [n - 1.5 * a, a];
    const f = new l.BandScale();
    f.domain = d.map((v, b) => b), f.range = [a, n - a], f.paddingInner = 0.4, f.paddingOuter = 0.2;
    const m = Math.round(f.bandwidth), C = Math.round(f.bandwidth / 2);
    this.boxPlotGroups = d.map((v, b) => {
      const [y, F, D, x] = [
        v * p,
        v * u,
        v * h,
        v * c
      ], T = Math.round(g.convert(D)), I = Math.round(f.convert(b)), E = Math.round(I + m), M = Math.round(g.convert(F)), N = Math.round(g.convert(y)), _ = Math.round(g.convert(v)), H = Math.round(g.convert(x)), W = I + C, K = new l.Group(), se = new l.Rect(), Se = new l.Line(), et = new l.Line(), _e = new l.Line(), zt = new l.Line(), ee = new l.Line();
      return se.x = I, se.y = T, se.width = m, se.height = M - T, se.strokeWidth = 1, se.strokeOpacity = 0.75, se.crisp = !0, this.setLineProperties(Se, I, E, _, _), this.setLineProperties(et, W, W, H, T), this.setLineProperties(_e, W, W, N, M), this.setLineProperties(zt, I, E, H, H), this.setLineProperties(ee, I, E, N, N), K.append([se, Se, et, _e, zt, ee]), K;
    }), this.updateColors(s, i, r, o), this.root.append(this.boxPlotGroups);
  }
  updateColors(e, t, s, i) {
    const {
      agChartsExports: { _Util: r, _Theme: o }
    } = this, n = s == null ? void 0 : s.get(o.themeSymbols.DEFAULT_BACKGROUND_COLOUR), a = (Array.isArray(n) ? n[0] : n) ?? "white";
    this.boxPlotGroups.forEach((l, d) => {
      for (const c of l.children()) {
        const h = e[d % e.length];
        c.fill = i ? h : r.interpolateColor(h, a)(0.7), c.stroke = t[d % t.length];
      }
    });
  }
  setLineProperties(e, t, s, i, r) {
    e.x1 = t, e.x2 = s, e.y1 = i, e.y2 = r, e.strokeOpacity = 0.75;
  }
};
Pm.chartType = "boxPlot";
var Tm = class extends Bi {
  constructor(e, t, s, i, r, o) {
    super(e, t, "treemapTooltip");
    const {
      size: n,
      padding: a,
      agChartsExports: { _Scene: l }
    } = this, d = [
      [1, 1],
      [3, 2, 1]
    ], h = d.length % 2 === 0 ? 0.3 : 0.2, u = [a, n - a], p = d.length, g = p * (p + 1) / 2, f = h / (p - 1), m = u[1] - u[0], C = m - h;
    let v = u[0];
    this.rects = d.reduce((y, F, D) => {
      y ?? (y = []);
      const x = (p - D) / g, T = C * x, I = F.length, E = F.reduce((W, K) => W += K, 0), M = h / (I - 1 || 1), N = I > 1 ? m - h : m;
      let _ = u[0];
      const H = F.map((W) => {
        const K = new l.Rect(), se = N * W / E;
        return K.x = v, K.y = _, K.width = T, K.height = se, K.strokeWidth = 0.75, K.crisp = !0, _ += se + M, K;
      });
      return v += T + f, y.push(...H), y;
    }, []), this.updateColors(s, i, r, o);
    const b = new l.Group();
    b.setClipRect(new l.BBox(a, a, n - a, n - a)), b.append(this.rects), this.root.append(b);
  }
  updateColors(e, t, s, i) {
    const r = s == null ? void 0 : s.get(
      this.agChartsExports._Theme.themeSymbols.DEFAULT_BACKGROUND_COLOUR
    ), o = (Array.isArray(r) ? r[0] : r) ?? "white";
    this.rects.forEach((n, a) => {
      n.fill = e[a % t.length], n.stroke = i ? t[a % t.length] : o;
    });
  }
};
Tm.chartType = "treemap";
var Dm = class extends Vi {
  constructor(e, t, s, i) {
    super(e, t, "sunburstTooltip"), this.data = [
      [[], []],
      [[], []],
      [[], []]
    ], this.angleOffset = -Math.PI / 2, this.innerRadiusRatio = 0, this.showRadiusAxisLine = !1, this.showAngleAxisLines = !1;
    const {
      data: r,
      size: o,
      padding: n,
      angleOffset: a,
      innerRadiusRatio: l,
      agChartsExports: { _Scene: d }
    } = this, c = (o - n * 2) / 2, h = [a + 0, a + 2 * Math.PI], u = Math.abs(h[1] - h[0]), p = [c * l, c], g = Math.abs(p[1] - p[0]);
    let f = 0;
    const m = (F, D) => {
      F.forEach((x) => {
        const T = D + 1;
        f = Math.max(f, T), m(x, T);
      });
    };
    m(r, 0);
    const C = g / f, v = this.size / 2, b = h[0];
    this.series = [];
    const y = (F, D, x, T, I) => {
      if (!Array.isArray(F))
        return;
      const M = D + 1;
      let N = x;
      F.forEach((_, H, W) => {
        let K = I;
        K || (K = new d.Group(), this.series.push(K));
        const se = p[0] + D * C, Se = p[0] + M * C, et = 1 / W.length, _e = N, zt = _e + T * et, ee = new d.Sector();
        ee.centerX = v, ee.centerY = v, ee.innerRadius = se, ee.outerRadius = Se, ee.startAngle = _e, ee.endAngle = zt, ee.stroke = void 0, ee.strokeWidth = 0, ee.inset = 0.75, N = zt, K.append(ee), y(_, M, _e, Math.abs(zt - _e), K);
      });
    };
    y(r, 0, b, u), this.root.append(this.series), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.series.forEach((s, i) => {
      for (const r of s.children())
        r.fill = e[i % e.length], r.stroke = t[i % t.length];
    });
  }
};
Dm.chartType = "sunburst";
var Em = class extends Bi {
  constructor(e, t, s, i, r, o) {
    super(e, t, "heatmapTooltip");
    const {
      size: n,
      padding: a,
      agChartsExports: { _Scene: l }
    } = this, d = 3, c = Array.from(
      { length: d },
      (C, v) => Array.from({ length: d }, (b, y) => y)
    ), h = c.map((C, v) => v), u = new l.BandScale();
    u.domain = h, u.range = [a, n - a], u.paddingInner = 0.01, u.paddingOuter = 0.1;
    const p = new l.BandScale();
    p.domain = h, p.range = [a, n - a], p.paddingInner = 0.01, p.paddingOuter = 0.1;
    const g = u.bandwidth ?? 0, f = p.bandwidth ?? 0;
    this.rects = c.reduce((C, v, b) => {
      C ?? (C = []);
      const y = v.map((F, D) => {
        const x = new l.Rect();
        return x.x = u.convert(b), x.y = p.convert(D), x.width = g, x.height = f, x.strokeWidth = 0, x.crisp = !0, x;
      });
      return C.push(...y), C;
    }, []), this.updateColors(s, i, r, o);
    const m = new l.Group();
    m.setClipRect(new l.BBox(a, a, n - a, n - a)), m.append(this.rects), this.root.append(m);
  }
  updateColors(e, t, s, i) {
    const { _Theme: r, _Util: o } = this.agChartsExports, n = s == null ? void 0 : s.get(r.themeSymbols.DEFAULT_DIVERGING_SERIES_COLOR_RANGE), a = s == null ? void 0 : s.get(r.themeSymbols.DEFAULT_BACKGROUND_COLOUR), l = (Array.isArray(a) ? a[0] : a) ?? "white", d = i ? [e[0], e[1]] : n, c = i ? t[0] : l, h = o.interpolateColor(d[0], d[1]);
    this.rects.forEach((u, p) => {
      u.fill = h(p * 0.2), u.stroke = c;
    });
  }
};
Em.chartType = "heatmap";
var Mm = class extends We {
  constructor(e, t, s, i, r, o) {
    super(e, t, "waterfallTooltip"), this.data = [4, 3, -3, 6, -3], this.bars = this.createWaterfall(this.root, this.data, this.size, this.padding, "vertical").bars, this.updateColors(s, i, r, o);
  }
  updateColors(e, t, s, i) {
    const {
      data: r,
      agChartsExports: {
        _Theme: { themeSymbols: o }
      }
    } = this, n = {
      fill: i ? e[0] : s == null ? void 0 : s.get(o.PALETTE_ALT_UP_FILL),
      stroke: i ? t[0] : s == null ? void 0 : s.get(o.PALETTE_ALT_UP_STROKE)
    }, a = {
      fill: i ? e[1] : s == null ? void 0 : s.get(o.PALETTE_ALT_DOWN_FILL),
      stroke: i ? t[1] : s == null ? void 0 : s.get(o.PALETTE_ALT_DOWN_STROKE)
    };
    this.bars.forEach((l, d) => {
      const c = r[d] >= 0;
      l.fill = c ? n.fill : a.fill, l.stroke = c ? n.stroke : a.stroke;
    });
  }
  createWaterfall(e, t, s, i, r) {
    const o = 2 * i, { processedData: n, min: a, max: l } = bn(t.map((b) => [b])), d = n.reduce((b, y) => b.concat(y), []), { _Scene: c } = this.agChartsExports, h = new c.LinearScale();
    h.domain = [Math.min(a, 0), l], h.range = [s - o, o];
    const u = new c.BandScale();
    u.domain = t.map((b, y) => y), u.range = [i, s - i], u.paddingInner = 0.2, u.paddingOuter = 0.3;
    const p = u.bandwidth, g = new c.Path();
    g.stroke = "#575757", g.strokeWidth = 0;
    const f = Math.floor(g.strokeWidth) % 2 / 2, m = g.path;
    m.clear();
    const C = r === "horizontal", v = d.map((b, y) => {
      const F = y > 0 ? d[y - 1] : 0, x = t[y] > 0, T = Math.round(h.convert(b)), I = Math.round(h.convert(F)), E = (x ? T : I) - f, M = (x ? I : T) + f, N = Math.abs(M - E), _ = u.convert(y), H = new c.Rect();
      H.x = C ? E : _, H.y = C ? _ : E, H.width = C ? N : p, H.height = C ? p : N, H.strokeWidth = 0, H.crisp = !0;
      const W = T + f, K = I + f;
      if (y > 0) {
        const et = C ? K : H.x, _e = C ? H.y : K;
        m.lineTo(et, _e);
      }
      const se = C ? W : H.x, Se = C ? H.y : W;
      return m.moveTo(se, Se), H;
    });
    return e.append([g, ...v]), { bars: v };
  }
};
Mm.chartType = "waterfall";
var Am = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "columnLineComboTooltip"), this.columnData = [3, 4], this.lineData = [[5, 4, 6, 5, 4]];
    const { root: r, columnData: o, lineData: n, size: a, padding: l } = this;
    this.columns = Lr({
      stacked: !1,
      data: o,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 4],
      xScalePadding: 0.5,
      agChartsExports: t
    }), r.append(this.columns), this.lines = od(t, r, n, a, l), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.columns.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    }), this.lines.forEach((s, i) => {
      s.stroke = e[i + 2];
    });
  }
};
Am.chartType = "columnLineCombo";
var Im = class extends We {
  constructor(e, t, s, i) {
    super(e, t, "areaColumnComboTooltip"), this.columnData = [3, 4.5], this.areaData = [[5, 4, 6, 5, 4]];
    const {
      root: r,
      columnData: o,
      areaData: n,
      size: a,
      padding: l,
      agChartsExports: { _Scene: d }
    } = this;
    this.columns = Lr({
      stacked: !1,
      data: o,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 6],
      xScalePadding: 0.5,
      agChartsExports: t
    });
    const c = new d.BandScale();
    c.range = [l, a - l], c.domain = [0, 1, 2, 3, 4], c.paddingInner = 1, c.paddingOuter = 0;
    const h = new d.LinearScale();
    h.range = [a - l, l], h.domain = [0, 6];
    const u = [], p = h.convert(0), g = c.convert(0);
    n.forEach((C, v) => {
      const b = u[v] || (u[v] = []);
      C.forEach((F, D) => {
        const x = F, T = D, I = c.convert(T), E = h.convert(x);
        b[D] = { x: I, y: E };
      });
      const y = c.convert(C.length - 1);
      u[v].push(
        {
          x: y,
          y: p
        },
        {
          x: g,
          y: p
        }
      );
    }), this.areas = u.map((C) => {
      const v = new d.Path();
      v.strokeWidth = 0, v.fillOpacity = 0.8;
      const b = v.path;
      return C.forEach((y, F) => b[F > 0 ? "lineTo" : "moveTo"](y.x, y.y)), v;
    });
    const f = new d.Group();
    f.setClipRect(new d.BBox(l, l, a - l * 2, a - l * 2));
    const m = new d.Group();
    m.setClipRect(new d.BBox(l, l, a - l * 2, a - l * 2)), f.append(this.areas), m.append(this.columns), r.append(f), r.append(m), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.areas.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    }), this.columns.forEach((s, i) => {
      s.fill = e[i + 1], s.stroke = t[i + 1];
    });
  }
};
Im.chartType = "areaColumnCombo";
var Lm = class extends Bi {
  constructor(e, t, s, i) {
    super(e, t, "customComboTooltip"), this.columnData = [3, 4], this.lineData = [[5, 4, 6, 5, 4]];
    const {
      root: r,
      columnData: o,
      lineData: n,
      size: a,
      padding: l,
      agChartsExports: { _Scene: d }
    } = this;
    this.columns = Lr({
      stacked: !1,
      data: o,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 4],
      xScalePadding: 0.5,
      agChartsExports: t
    }), r.append(this.columns), this.lines = od(this.agChartsExports, r, n, a, l);
    const c = "grey", h = 3, u = new d.Line();
    u.x1 = l, u.y1 = l, u.x2 = l, u.y2 = a - l + h, u.stroke = c;
    const p = new d.Line();
    p.x1 = l - h + 1, p.y1 = a - l, p.x2 = a - l + 1, p.y2 = a - l, p.stroke = c;
    const g = new d.Path();
    this.buildPenIconPath(g), g.fill = "whitesmoke", g.stroke = "darkslategrey", g.strokeWidth = 1, r.append([p, u, g]), this.updateColors(s, i);
  }
  updateColors(e, t) {
    this.columns.forEach((s, i) => {
      s.fill = e[i], s.stroke = t[i];
    }), this.lines.forEach((s, i) => {
      s.stroke = e[i + 2];
    });
  }
  buildPenIconPath(e) {
    const { path: t } = e;
    t.moveTo(25.76, 43.46), t.lineTo(31.27, 48.53), t.moveTo(49.86, 22), t.lineTo(49.86, 22), t.cubicCurveTo(49.01994659053345, 21.317514933510974, 47.89593834348529, 21.09645997825817, 46.86, 21.41), t.lineTo(46.86, 21.41), t.cubicCurveTo(45.55460035985361, 21.77260167850787, 44.38777081121966, 22.517979360321792, 43.51, 23.55), t.lineTo(25.51, 43.8), t.lineTo(25.43, 43.89), t.lineTo(23.01, 51.89), t.lineTo(22.83, 52.46), t.lineTo(31.02, 48.86), t.lineTo(49.02, 28.52), t.lineTo(49.02, 28.52), t.cubicCurveTo(49.940716461596224, 27.521914221246085, 50.54302631059587, 26.2720342455763, 50.75, 24.93), t.lineTo(50.75, 24.93), t.cubicCurveTo(50.95363374988308, 23.866379846512814, 50.62080640232334, 22.77066734274871, 49.86, 22), t.closePath(), t.moveTo(41.76, 25.5), t.lineTo(47.34, 30.5), t.moveTo(40.74, 26.65), t.lineTo(46.25, 31.71);
  }
};
Lm.chartType = "customCombo";
var Zc = {
  columnGroup: {
    column: { range: !0, pivot: !0, enterprise: !1, icon: em },
    stackedColumn: { range: !0, pivot: !0, enterprise: !1, icon: sm },
    normalizedColumn: { range: !0, pivot: !0, enterprise: !1, icon: gN }
  },
  barGroup: {
    bar: { range: !0, pivot: !0, enterprise: !1, icon: rm },
    stackedBar: { range: !0, pivot: !0, enterprise: !1, icon: nm },
    normalizedBar: { range: !0, pivot: !0, enterprise: !1, icon: fN }
  },
  pieGroup: {
    pie: { range: !0, pivot: !0, enterprise: !1, icon: lm },
    donut: { range: !0, pivot: !0, enterprise: !1, icon: Vo },
    doughnut: { range: !0, pivot: !0, enterprise: !1, icon: Vo }
  },
  lineGroup: {
    line: { range: !0, pivot: !0, enterprise: !1, icon: kr },
    stackedLine: { range: !0, pivot: !0, enterprise: !1, icon: hm },
    normalizedLine: { range: !0, pivot: !0, enterprise: !1, icon: mN }
  },
  scatterGroup: {
    scatter: { range: !0, pivot: !0, enterprise: !1, icon: pm },
    bubble: { range: !0, pivot: !0, enterprise: !1, icon: gm }
  },
  areaGroup: {
    area: { range: !0, pivot: !0, enterprise: !1, icon: gd },
    stackedArea: { range: !0, pivot: !0, enterprise: !1, icon: md },
    normalizedArea: { range: !0, pivot: !0, enterprise: !1, icon: CN }
  },
  polarGroup: {
    radarLine: { range: !0, pivot: !1, enterprise: !0, icon: bm },
    radarArea: { range: !0, pivot: !1, enterprise: !0, icon: Sm },
    nightingale: { range: !0, pivot: !1, enterprise: !0, icon: xm },
    radialColumn: { range: !0, pivot: !1, enterprise: !0, icon: wm },
    radialBar: { range: !0, pivot: !1, enterprise: !0, icon: ym }
  },
  statisticalGroup: {
    boxPlot: { range: !0, pivot: !1, enterprise: !0, icon: Pm },
    histogram: { range: !0, pivot: !1, enterprise: !1, icon: vm },
    rangeBar: { range: !0, pivot: !1, enterprise: !0, icon: Fm },
    rangeArea: { range: !0, pivot: !1, enterprise: !0, icon: Rm }
  },
  hierarchicalGroup: {
    treemap: { range: !0, pivot: !0, enterprise: !0, icon: Tm },
    sunburst: { range: !0, pivot: !0, enterprise: !0, icon: Dm }
  },
  specializedGroup: {
    heatmap: { range: !0, pivot: !1, enterprise: !0, icon: Em },
    waterfall: { range: !0, pivot: !1, enterprise: !0, icon: Mm }
  },
  combinationGroup: {
    columnLineCombo: { range: !0, pivot: !0, enterprise: !1, icon: Am },
    areaColumnCombo: { range: !0, pivot: !0, enterprise: !1, icon: Im },
    customCombo: { range: !0, pivot: !0, enterprise: !1, icon: Lm }
  }
}, vN = {
  columnGroup: ["column", "stackedColumn", "normalizedColumn"],
  barGroup: ["bar", "stackedBar", "normalizedBar"],
  pieGroup: ["pie", "donut"],
  lineGroup: ["line", "stackedLine", "normalizedLine"],
  areaGroup: ["area", "stackedArea", "normalizedArea"],
  scatterGroup: ["scatter", "bubble"],
  polarGroup: ["radarLine", "radarArea", "nightingale", "radialColumn", "radialBar"],
  statisticalGroup: ["boxPlot", "histogram", "rangeBar", "rangeArea"],
  hierarchicalGroup: ["treemap", "sunburst"],
  specializedGroup: ["heatmap", "waterfall"],
  combinationGroup: ["columnLineCombo", "areaColumnCombo", "customCombo"]
}, wN = class extends L {
  constructor(e, t, s, i, r, o = vN) {
    super(
      /* html */
      '<div class="ag-chart-settings-mini-wrapper"></div>'
    ), this.wrappers = /* @__PURE__ */ new Map(), this.chartController = e, this.fills = t, this.strokes = s, this.themeTemplateParameters = i, this.isCustomTheme = r, this.chartGroups = { ...o };
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    !this.chartController.customComboExists() && this.chartGroups.combinationGroup && (this.chartGroups.combinationGroup = this.chartGroups.combinationGroup.filter(
      (o) => o !== "customCombo"
    ));
    const e = this.getGui(), t = this.chartController.isEnterprise(), s = this.chartController.isPivotChart(), i = !s, r = Object.keys(this.chartGroups).map((o) => {
      const n = o in Zc ? Zc[o] : void 0;
      if (!n)
        return R(148, { group: o }), null;
      const l = (this.chartGroups[o] ?? []).map((d) => {
        const c = d in n ? n[d] : void 0;
        return c ? !t && c.enterprise ? null : i && c.range || s && c.pivot ? c : null : (R(149, { group: o, chartType: d }), null);
      }).filter((d) => d != null);
      return l.length === 0 ? null : {
        label: this.chartTranslation.translate(o),
        items: l
      };
    }).filter((o) => o != null);
    for (const { label: o, items: n } of r) {
      const a = this.createBean(
        new es({
          title: o,
          suppressEnabledCheckbox: !0,
          enabled: !0,
          suppressOpenCloseIcons: !0,
          cssIdentifier: "charts-settings",
          direction: "horizontal",
          suppressKeyboardNavigation: !0
        })
      );
      for (const l of n) {
        const d = l.icon, c = document.createElement("div");
        c.classList.add("ag-chart-mini-thumbnail"), c.setAttribute("tabindex", "0"), c.setAttribute("role", "button");
        const h = d.chartType, u = () => {
          this.chartController.setChartType(h), this.updateSelectedMiniChart();
        };
        this.addManagedListeners(c, {
          click: u,
          keydown: (p) => {
            (p.key == w.ENTER || p.key === w.SPACE) && (p.preventDefault(), u());
          }
        }), this.wrappers.set(h, c), this.createBean(
          new d(
            c,
            this.beans.agChartsExports,
            this.fills,
            this.strokes,
            this.themeTemplateParameters,
            this.isCustomTheme
          )
        ), a.addItem(c);
      }
      e.appendChild(a.getGui());
    }
    this.updateSelectedMiniChart();
  }
  updateSelectedMiniChart() {
    const e = this.chartController.getChartType();
    this.wrappers.forEach((t, s) => {
      const i = s === e;
      t.classList.toggle("ag-selected", i);
      const r = this.chartTranslation.translate(ed(s)), o = i ? `${r}. ${this.chartTranslation.translate("ariaChartSelected")}` : r;
      oe(t, o);
    });
  }
  destroy() {
    this.wrappers.clear(), super.destroy();
  }
}, yN = class extends L {
  constructor(e) {
    super(
      /* html */
      `<div class="ag-chart-settings-wrapper">
            <div data-ref="eMiniChartsContainer" class="ag-chart-settings-mini-charts-container ag-scrollable-container"></div>
            <div data-ref="eNavBar" class="ag-chart-settings-nav-bar">
                <div data-ref="ePrevBtn" class="ag-chart-settings-prev">
                    <button type="button" class="ag-button ag-chart-settings-prev-button"></button>
                </div>
                <div data-ref="eCardSelector" class="ag-chart-settings-card-selector"></div>
                <div data-ref="eNextBtn" class="ag-chart-settings-next">
                    <button type="button" class="ag-button ag-chart-settings-next-button"></button>
                </div>
            </div>
        </div>`
    ), this.chartController = e, this.eMiniChartsContainer = S, this.eNavBar = S, this.eCardSelector = S, this.ePrevBtn = S, this.eNextBtn = S, this.miniChartsContainers = [], this.cardItems = [], this.activePaletteIndex = 0, this.palettes = [], this.themes = [];
  }
  postConstruct() {
    this.resetPalettes(), this.ePrevBtn.insertAdjacentElement("afterbegin", B("chartsThemePrevious", this.beans)), this.eNextBtn.insertAdjacentElement("afterbegin", B("chartsThemeNext", this.beans)), this.addManagedElementListeners(this.ePrevBtn, { click: () => this.setActivePalette(this.getPrev(), "left") }), this.addManagedElementListeners(this.eNextBtn, { click: () => this.setActivePalette(this.getNext(), "right") });
    const e = () => this.resetPalettes(!0);
    this.addManagedListeners(this.chartController, {
      chartTypeChanged: e,
      chartApiUpdate: e
    }), this.scrollSelectedIntoView();
  }
  scrollSelectedIntoView() {
    setTimeout(() => {
      const e = (i) => !i.getGui().classList.contains("ag-hidden"), s = this.miniChartsContainers.find(e).getGui().querySelector(".ag-selected");
      if (s) {
        const i = s.offsetParent;
        i && this.eMiniChartsContainer.scrollTo(0, i.offsetTop);
      }
    }, 250);
  }
  resetPalettes(e) {
    var o, n;
    const t = this.chartController.getPalettes(), s = this.chartController.getThemeTemplateParameters(), i = (n = (o = this.gos.get("chartToolPanelsDef")) == null ? void 0 : o.settingsPanel) == null ? void 0 : n.chartGroupsDef;
    if (Re(t, this.palettes) && !e || this.isAnimating)
      return;
    this.palettes = t, this.themes = this.chartController.getThemeNames(), this.activePaletteIndex = this.themes.findIndex((a) => a === this.chartController.getChartThemeName()), this.cardItems = [], X(this.eCardSelector), this.destroyMiniCharts();
    const { themes: r } = this;
    this.palettes.forEach((a, l) => {
      const d = this.activePaletteIndex === l, { fills: c = [], strokes: h = [] } = a, u = r[l], p = !td(u, this.beans.agChartsExports._Theme), g = this.createBean(
        new wN(
          this.chartController,
          c,
          h,
          s[l],
          p,
          i
        )
      );
      this.miniChartsContainers.push(g), this.eMiniChartsContainer.appendChild(g.getGui()), this.addCardLink(l), d ? g.updateSelectedMiniChart() : g.setDisplayed(!1);
    }), O(this.eNavBar, this.palettes.length > 1), ho(this.cardItems[this.activePaletteIndex], "ag-selected", "ag-not-selected");
  }
  addCardLink(e) {
    const t = document.createElement("div");
    t.classList.add("ag-chart-settings-card-item"), this.addManagedElementListeners(t, {
      click: () => {
        this.setActivePalette(e, e < this.activePaletteIndex ? "left" : "right");
      }
    }), this.eCardSelector.appendChild(t), this.cardItems.push(t);
  }
  getPrev() {
    let e = this.activePaletteIndex - 1;
    return e < 0 && (e = this.palettes.length - 1), e;
  }
  getNext() {
    let e = this.activePaletteIndex + 1;
    return e >= this.palettes.length && (e = 0), e;
  }
  setActivePalette(e, t) {
    if (this.isAnimating || this.activePaletteIndex === e)
      return;
    ho(this.cardItems[e], "ag-selected", "ag-not-selected");
    const s = this.miniChartsContainers[this.activePaletteIndex], i = s.getGui(), r = this.miniChartsContainers[e], o = r.getGui();
    s.updateSelectedMiniChart(), r.updateSelectedMiniChart();
    const n = t === "left" ? -1 : 1, a = o.style.left = `${$s(this.getGui()) * n}px`;
    this.activePaletteIndex = e, this.isAnimating = !0;
    const l = "ag-animating";
    r.setDisplayed(!0), s.addCssClass(l), r.addCssClass(l), this.chartController.setChartThemeName(this.themes[e]), window.setTimeout(() => {
      i.style.left = `${-parseFloat(a)}px`, o.style.left = "0px";
    }, 0), window.setTimeout(() => {
      this.isAnimating = !1, s.removeCssClass(l), r.removeCssClass(l), s.setDisplayed(!1);
    }, 300);
  }
  destroyMiniCharts() {
    X(this.eMiniChartsContainer), this.miniChartsContainers = this.destroyBeans(this.miniChartsContainers);
  }
  destroy() {
    this.destroyMiniCharts(), super.destroy();
  }
}, bN = "data", SN = "format", xN = class extends L {
  constructor(e, t) {
    super(), this.panels = e, this.chartMenuContext = t, this.tabs = [];
  }
  wireBeans(e) {
    this.chartTranslation = e.chartTranslation;
  }
  postConstruct() {
    this.panels.forEach((e) => {
      const t = e.replace("chart", "").toLowerCase(), s = this.createPanel(t), i = this.createTab(e, t, s);
      this.tabs.push(i), this.addDestroyFunc(() => this.destroyBean(s));
    }), this.tabbedLayout = new rf({
      items: this.tabs,
      cssClass: "ag-chart-tabbed-menu",
      keepScrollPosition: !0,
      suppressFocusBodyOnOpen: !0,
      suppressTrapFocus: !0,
      enableCloseButton: !0,
      closeButtonAriaLabel: this.chartTranslation.translate("ariaChartMenuClose"),
      onCloseClicked: () => {
        var e;
        (e = this.eventSource) == null || e.focus({ preventScroll: !0 }), this.dispatchLocalEvent({ type: "closed" });
      }
    }), this.createBean(this.tabbedLayout);
  }
  createTab(e, t, s) {
    const i = document.createElement("div");
    i.classList.add("ag-chart-tab", `ag-chart-${t}`), this.createBean(s), i.appendChild(s.getGui());
    const r = document.createElement("div"), o = this.chartTranslation.translate(t);
    return r.innerText = o, {
      title: r,
      titleLabel: o,
      bodyPromise: U.resolve(i),
      getScrollableContainer: () => i.querySelector(".ag-scrollable-container") || i,
      name: e
    };
  }
  showTab(e) {
    const t = this.tabs[e];
    this.tabbedLayout.showItem(t);
  }
  getGui() {
    return this.tabbedLayout && this.tabbedLayout.getGui();
  }
  showMenu(e, t) {
    var s;
    this.eventSource = e, t || (s = this.tabbedLayout) == null || s.focusHeader(!0);
  }
  destroy() {
    this.parentComponent && this.parentComponent.isAlive() && this.destroyBean(this.parentComponent), super.destroy();
  }
  createPanel(e) {
    switch (e) {
      case bN:
        return new NV(this.chartMenuContext);
      case SN:
        return new dN(this.chartMenuContext);
      default:
        return new yN(this.chartMenuContext.chartController);
    }
  }
}, FN = class extends L {
  constructor(e, t, s) {
    super(
      /* html */
      '<div class="ag-chart-menu-wrapper"></div>'
    ), this.eChartContainer = e, this.eMenuPanelContainer = t, this.chartMenuContext = s, this.buttons = {
      chartLink: { iconName: "linked", callback: () => this.chartMenuSvc.toggleLinked(this.chartMenuContext) },
      chartUnlink: {
        iconName: "unlinked",
        callback: () => this.chartMenuSvc.toggleLinked(this.chartMenuContext)
      },
      chartDownload: {
        iconName: "chartsDownload",
        callback: () => this.chartMenuSvc.downloadChart(this.chartMenuContext)
      },
      chartMenu: { iconName: "chartsMenu", callback: (i) => this.showMenuList(i) }
    }, this.panels = [], this.menuVisible = !1, this.chartController = s.chartController;
  }
  wireBeans(e) {
    this.chartMenuSvc = e.chartMenuSvc, this.chartMenuListFactory = e.chartMenuListFactory, this.environment = e.environment;
  }
  postConstruct() {
    this.chartToolbar = this.createManagedBean(new DV()), this.getGui().appendChild(this.chartToolbar.getGui()), this.refreshToolbarAndPanels(), this.addManagedEventListeners({
      chartCreated: (e) => {
        var t;
        e.chartId === this.chartController.getChartId() && ((t = this.gos.get("chartToolPanelsDef")) != null && t.defaultToolPanel) && this.showMenu({ panel: this.defaultPanel, suppressFocus: !0 });
      }
    }), this.addManagedListeners(this.chartController, {
      chartLinkedChanged: this.refreshToolbarAndPanels.bind(this)
    }), this.refreshMenuClasses(), this.addManagedListeners(this.chartController, { chartApiUpdate: this.refreshToolbarAndPanels.bind(this) });
  }
  isVisible() {
    return this.menuVisible;
  }
  getExtraPaddingDirections() {
    return ["chartMenu", "chartLink", "chartUnlink", "chartDownload"].some(
      (e) => this.chartToolbarOptions.includes(e)
    ) ? ["top"] : [];
  }
  refreshToolbarAndPanels() {
    this.initToolbarOptionsAndPanels(), this.updateToolbar();
  }
  initToolbarOptionsAndPanels() {
    const { panels: e, defaultPanel: t } = this.chartMenuSvc.getChartToolPanels(this.chartController);
    this.panels = e, this.defaultPanel = t, this.chartToolbarOptions = this.chartMenuSvc.getChartToolbarOptions();
  }
  updateToolbar() {
    const e = this.chartToolbarOptions.map((t) => {
      const { iconName: s, callback: i } = this.buttons[t];
      return {
        buttonName: t,
        iconName: s,
        callback: i
      };
    });
    this.chartToolbar.updateParams({ buttons: e });
  }
  createMenuPanel(e) {
    const t = this.menuPanel = this.createBean(
      new Mg({
        height: "100%",
        closable: !0,
        hideTitleBar: !0,
        cssIdentifier: "chart-menu"
      })
    );
    return t.setParentComponent(this), this.eMenuPanelContainer.appendChild(t.getGui()), this.tabbedMenu = this.createBean(new xN(this.panels, this.chartMenuContext)), this.addManagedListeners(this.tabbedMenu, {
      closed: () => {
        this.hideMenu();
      }
    }), this.addManagedListeners(t, { destroyed: () => this.destroyBean(this.tabbedMenu) }), new U((s) => {
      window.setTimeout(() => {
        t.setBodyComponent(this.tabbedMenu), this.tabbedMenu.showTab(e), s(t);
      }, 100);
    });
  }
  showContainer(e, t) {
    this.menuPanel && (this.menuVisible = !0, this.refreshMenuClasses(), this.tabbedMenu.showMenu(e, t));
  }
  showMenu(e) {
    const { panel: t, eventSource: s, suppressFocus: i } = e ?? {};
    if (this.menuPanel && !t)
      this.showContainer(s, i);
    else {
      const r = t || this.defaultPanel;
      let o = this.panels.indexOf(r);
      o < 0 && (R(143, { panel: t }), o = this.panels.indexOf(this.defaultPanel)), this.menuPanel ? (this.tabbedMenu.showTab(o), this.showContainer(s, i)) : this.createMenuPanel(o).then(() => this.showContainer(s, i));
    }
  }
  hideMenu() {
    this.menuVisible = !1, this.refreshMenuClasses();
  }
  refreshMenuClasses() {
    this.eChartContainer.classList.toggle("ag-chart-menu-visible", this.menuVisible), this.eChartContainer.classList.toggle("ag-chart-menu-hidden", !this.menuVisible);
  }
  showMenuList(e) {
    this.chartMenuListFactory.showMenuList({
      eventSource: e,
      showMenu: () => this.showMenu({ eventSource: e }),
      chartMenuContext: this.chartMenuContext
    });
  }
  destroy() {
    super.destroy(), this.menuPanel && this.menuPanel.isAlive() && this.destroyBean(this.menuPanel), this.tabbedMenu && this.tabbedMenu.isAlive() && this.destroyBean(this.tabbedMenu);
  }
}, km = ["number", "category", "time", "grouped-category"], RN = ["angle-category", "angle-number", "radius-category", "radius-number"], PN = [...km, ...RN], TN = class extends P {
  constructor(e) {
    super(), this.chartController = e;
  }
  getChartThemeOverridesProxy() {
    return {
      getValue: (e) => this.getChartOption(e),
      setValue: (e, t) => this.setChartThemeOverrides([{ expression: e, value: t }]),
      setValues: (e) => this.setChartThemeOverrides(e)
    };
  }
  getAxisThemeOverridesProxy() {
    return {
      getValue: (e) => this.getAxisProperty(e),
      setValue: (e, t) => this.setAxisThemeOverrides([{ expression: e, value: t }]),
      setValues: (e) => this.setAxisThemeOverrides(e)
    };
  }
  getCartesianAxisOptionsProxy(e) {
    return {
      getValue: (t) => this.getCartesianAxisProperty(e, t),
      setValue: (t, s) => this.setCartesianAxisOptions(e, [{ expression: t, value: s }]),
      setValues: (t) => this.setCartesianAxisOptions(e, t)
    };
  }
  getCartesianAxisThemeOverridesProxy(e) {
    return {
      getValue: (t) => this.getCartesianAxisProperty(e, t),
      setValue: (t, s) => this.setCartesianAxisThemeOverrides(e, [{ expression: t, value: s }]),
      setValues: (t) => this.setCartesianAxisThemeOverrides(e, t)
    };
  }
  getCartesianAxisAppliedThemeOverridesProxy(e) {
    return {
      getValue: (t) => this.getCartesianAxisThemeOverride(
        e,
        // Allow the caller to specify a wildcard expression to retrieve the whole set of overrides
        t === "*" ? null : t
      ),
      setValue: (t, s) => this.setCartesianAxisThemeOverrides(
        e,
        // Allow the caller to specify a wildcard expression to set the whole set of overrides
        [{ expression: t === "*" ? null : t, value: s }]
      ),
      setValues: (t) => this.setCartesianAxisThemeOverrides(e, t)
    };
  }
  getSeriesOptionsProxy(e) {
    return {
      getValue: (t, s) => this.getSeriesOption(e(), t, s),
      setValue: (t, s) => this.setSeriesOptions(e(), [{ expression: t, value: s }]),
      setValues: (t) => this.setSeriesOptions(e(), t)
    };
  }
  /**
   * Determine the set of theme overrides that should be retained when transitioning from one chart type to another.
   */
  getPersistedChartThemeOverrides(e, t, s, i) {
    const r = this.getRetainedChartThemeOverrideKeys(s, i), o = this.getRetainedChartAxisThemeOverrideKeys(
      null,
      s,
      i
    ), n = this.createChartOptions();
    for (const a of r) {
      const l = this.retrieveChartOptionsThemeOverride(e, s, a);
      l !== void 0 && this.assignChartOptionsThemeOverride(n, i, a, l);
    }
    return t && this.assignPersistedAxisOverrides({
      existingAxes: t,
      retainedChartAxisThemeOverrideKeys: o,
      existingChartOptions: e,
      targetChartOptions: n,
      existingChartType: s,
      targetChartType: i
    }), n.theme.overrides;
  }
  assignPersistedAxisOverrides(e) {
    const {
      existingAxes: t,
      retainedChartAxisThemeOverrideKeys: s,
      existingChartOptions: i,
      targetChartOptions: r,
      existingChartType: o,
      targetChartType: n
    } = e;
    for (const { expression: a, targetAxisTypes: l } of s)
      for (const d of t.map((c) => c.type)) {
        const c = this.retrieveChartOptionsThemeOverride(
          i,
          o,
          ["axes", d, a].join(".")
        );
        if (c !== void 0)
          for (const h of l)
            this.assignChartOptionsThemeOverride(
              r,
              n,
              ["axes", h, a].join("."),
              c
            );
      }
  }
  getRetainedChartThemeOverrideKeys(e, t) {
    const s = ["animation"], i = ["zoom", "navigator"], r = ((o, n) => {
      const a = new Array();
      return gs(ne(o)) && gs(ne(n)) && a.push(...i), a;
    })(e, t);
    return [...s, ...r];
  }
  getRetainedChartAxisThemeOverrideKeys(e, t, s) {
    return gs(ne(t)) && gs(ne(s)) ? this.getRetainedCartesianAxisThemeOverrideKeys(e).map((r) => ({ expression: r, targetAxisTypes: km })) : [];
  }
  getRetainedCartesianAxisThemeOverrideKeys(e) {
    const t = e === "xAxis" ? ["", ".top", ".bottom"] : e === "yAxis" ? ["", ".left", ".right"] : ["", ".left", ".right", ".top", ".bottom"], s = ["crosshair"], i = new Array();
    for (const r of s)
      for (const o of t)
        i.push(`${r}${o}`);
    return i;
  }
  getChartOption(e) {
    return Gs(this.getChart(), e, void 0);
  }
  setChartThemeOverrides(e) {
    const t = this.getChartType(), s = this.createChartOptions();
    for (const { expression: i, value: r } of e)
      this.assignChartOptionsThemeOverride(s, t, i, r);
    this.applyChartOptions(s);
  }
  applyChartOptions(e, t) {
    if (Object.keys(e).length === 0)
      return;
    this.updateChart(e), !(t != null && t.silent) && this.raiseChartOptionsChangedEvent();
  }
  awaitChartOptionUpdate(e) {
    this.chartController.getChartProxy().getChart().waitForUpdate().then(() => e()).catch((s) => z(108, { e: s }));
  }
  getAxisProperty(e) {
    var t;
    return Gs((t = this.getChart().axes) == null ? void 0 : t[0], e, void 0);
  }
  setAxisThemeOverrides(e) {
    var r;
    const t = this.getChart(), s = this.getChartType(), i = this.createChartOptions();
    for (const { expression: o, value: n } of e) {
      const a = (r = t.axes) == null ? void 0 : r.filter((l) => {
        const d = o.split(".");
        let c = l;
        for (const h of d) {
          if (!(h in c))
            return !1;
          c = c[h];
        }
        return !0;
      });
      if (a)
        for (const l of a)
          this.isValidAxisType(l) && this.assignChartAxisThemeOverride(i, s, l.type, null, o, n);
    }
    this.applyChartOptions(i);
  }
  getCartesianAxisProperty(e, t) {
    const s = this.getChartAxes(), i = this.getCartesianAxis(s, e);
    return Gs(i, t, void 0);
  }
  getCartesianAxisThemeOverride(e, t) {
    const s = this.getChartAxes(), i = this.getCartesianAxis(s, e);
    if (!i || !this.isValidAxisType(i))
      return;
    const r = this.getChartType(), o = this.getChart().getOptions();
    return this.retrieveChartAxisThemeOverride(
      o,
      r,
      i.type,
      e === "yAxis" ? ["left", "right"] : ["bottom", "top"],
      t
    );
  }
  setCartesianAxisThemeOverrides(e, t) {
    const s = this.getChartAxes(), i = this.getCartesianAxis(s, e);
    if (!i || !this.isValidAxisType(i))
      return;
    const r = this.getChartType(), o = this.createChartOptions();
    for (const { expression: n, value: a } of t)
      this.assignChartAxisThemeOverride(
        o,
        r,
        i.type,
        e === "yAxis" ? ["left", "right"] : ["bottom", "top"],
        n,
        a
      );
    this.applyChartOptions(o);
  }
  setCartesianAxisOptions(e, t) {
    this.updateCartesianAxisOptions(e, (s, i, r) => {
      const o = i.indexOf(r);
      for (const { expression: n, value: a } of t)
        this.assignChartOption(s, `axes.${o}.${n}`, a);
    });
  }
  updateCartesianAxisOptions(e, t) {
    const s = this.getChart().getOptions(), i = "axes" in s ? s.axes : void 0;
    if (!s || !i)
      return;
    const r = this.getChartAxes(), o = this.getCartesianAxis(r, e);
    if (!o)
      return;
    const n = this.createChartOptions();
    n.axes = i, t(n, r, o, s), this.applyChartOptions(n);
  }
  setCartesianCategoryAxisType(e, t) {
    this.updateCartesianAxisOptions(e, (s, i, r, o) => {
      const n = this.getChartType();
      this.assignPersistedAxisOverrides({
        existingAxes: [r],
        retainedChartAxisThemeOverrideKeys: this.getRetainedChartAxisThemeOverrideKeys(
          e,
          n,
          n
        ),
        existingChartOptions: o,
        targetChartOptions: s,
        existingChartType: n,
        targetChartType: n
      }), this.assignChartOption(s, "axes.0.type", t), this.chartController.setCategoryAxisType(t);
    });
  }
  getCartesianAxis(e, t) {
    if (!(e.length < 2))
      switch (t) {
        case "xAxis":
          return e[0].direction === "x" ? e[0] : e[1];
        case "yAxis":
          return e[1].direction === "y" ? e[1] : e[0];
      }
  }
  getSeriesOption(e, t, s) {
    const i = this.getChart().series.find((r) => DN(e, r));
    return Gs(s ? i : i == null ? void 0 : i.properties.toJson(), t, void 0);
  }
  setSeriesOptions(e, t) {
    const s = this.createChartOptions();
    for (const { expression: i, value: r } of t)
      this.assignChartOptionsSeriesThemeOverride(s, e, `series.${i}`, r);
    this.applyChartOptions(s);
  }
  getPairedMode() {
    return this.chartController.getChartProxy().isPaired();
  }
  setPairedMode(e) {
    this.chartController.getChartProxy().setPaired(e);
  }
  getChartAxes() {
    return this.getChart().axes ?? [];
  }
  retrieveChartAxisThemeOverride(e, t, s, i, r) {
    if (i)
      for (const o of i) {
        const n = this.retrieveChartOptionsThemeOverride(
          e,
          t,
          ["axes", s, o, ...r ? [r] : []].join(".")
        );
        if (n !== void 0)
          return n;
      }
    else
      return this.retrieveChartOptionsThemeOverride(
        e,
        t,
        ["axes", s, ...r ? [r] : []].join(".")
      );
  }
  assignChartAxisThemeOverride(e, t, s, i, r, o) {
    if (i)
      for (const n of i)
        this.assignChartOptionsThemeOverride(
          e,
          t,
          ["axes", s, n, ...r ? [r] : []].join("."),
          o
        );
    else
      this.assignChartOptionsThemeOverride(
        e,
        t,
        ["axes", s, ...r ? [r] : []].join("."),
        o
      );
  }
  isValidAxisType(e) {
    return PN.includes(e.type);
  }
  getChartType() {
    return this.chartController.getChartType();
  }
  getChart() {
    return this.chartController.getChartProxy().getChart();
  }
  updateChart(e) {
    const t = this.chartController.getChartProxy().getChartRef();
    t.skipAnimations(), t.updateDelta(e);
  }
  createChartOptions() {
    return {
      theme: {
        overrides: {}
      }
    };
  }
  retrieveChartOptionsThemeOverride(e, t, s) {
    const i = this.getChartThemeOverridesSeriesTypeKeys(t);
    for (const r of i) {
      const o = this.retrieveChartOptionsSeriesThemeOverride(e, r, s);
      if (o !== void 0)
        return o;
    }
  }
  assignChartOptionsThemeOverride(e, t, s, i) {
    const r = this.getChartThemeOverridesSeriesTypeKeys(t);
    for (const o of r)
      this.assignChartOptionsSeriesThemeOverride(e, o, s, i);
  }
  retrieveChartOptionsSeriesThemeOverride(e, t, s) {
    return this.retrieveChartOption(
      e,
      ["theme", "overrides", t, ...s ? [s] : []].join(".")
    );
  }
  assignChartOptionsSeriesThemeOverride(e, t, s, i) {
    this.assignChartOption(
      e,
      ["theme", "overrides", t, ...s ? [s] : []].join("."),
      i
    );
  }
  getChartThemeOverridesSeriesTypeKeys(e) {
    const t = this.chartController.getChartSeriesTypes(e);
    return this.chartController.isComboChart() && t.push("common"), t;
  }
  retrieveChartOption(e, t) {
    return Gs(e, t, void 0);
  }
  assignChartOption(e, t, s) {
    tB(e, t, s);
  }
  raiseChartOptionsChangedEvent() {
    const e = this.chartController.getChartModel();
    this.eventSvc.dispatchEvent({
      type: "chartOptionsChanged",
      chartId: e.chartId,
      chartType: e.chartType,
      chartThemeName: this.chartController.getChartThemeName(),
      chartOptions: e.chartOptions
    });
  }
  destroy() {
    super.destroy();
  }
};
function DN(e, t) {
  return oB(e) && t.type === e;
}
var EN = class extends L {
  constructor(e) {
    super(
      /* html */
      `
            <div style="height: 100%; width: 100%;">
                <div class="ag-chart" data-ref="eWrapper">
                    <div data-ref="eChartContainer" class="ag-chart-components-wrapper ag-chart-menu-hidden">
                        <div data-ref="eChart" class="ag-chart-canvas-wrapper"></div>
                        <div data-ref="eEmpty" class="ag-chart-empty-text ag-unselectable"></div>
                    </div>
                    <div data-ref="eMenuContainer" class="ag-chart-docked-container"></div>
                </div>
            </div>
            `
    ), this.eChart = S, this.eWrapper = S, this.eChartContainer = S, this.eMenuContainer = S, this.eEmpty = S, this.params = e;
  }
  wireBeans(e) {
    this.crossFilterService = e.chartCrossFilterSvc, this.chartTranslation = e.chartTranslation, this.chartMenuSvc = e.chartMenuSvc, this.focusSvc = e.focusSvc, this.popupSvc = e.popupSvc, this.enterpriseChartProxyFactory = e.enterpriseChartProxyFactory, this.environment = e.environment;
  }
  postConstruct() {
    const e = {
      ...this.params,
      chartType: yr(this.params.chartType),
      chartThemeName: this.getThemeName()
    }, t = this.gos.get("enableRtl");
    this.eWrapper.classList.add(t ? "ag-rtl" : "ag-ltr");
    const s = this.createBean(new GB(e));
    this.chartController = this.createManagedBean(new wV(s)), this.chartOptionsService = this.createManagedBean(new TN(this.chartController)), this.validateCustomThemes(), this.createChart(), this.params.insideDialog ? this.addDialog() : (this.addManagedEventListeners({
      gridStylesChanged: this.updateTheme.bind(this)
    }), this.updateTheme()), this.addMenu(), this.addManagedElementListeners(this.getGui(), { focusin: this.setActiveChartCellRange.bind(this) }), this.addManagedListeners(this.chartController, { chartModelUpdate: this.update.bind(this) }), this.addManagedPropertyListeners(
      ["chartThemeOverrides", "chartThemes"],
      this.reactivePropertyUpdate.bind(this)
    ), this.update(), this.raiseChartCreatedEvent();
  }
  updateTheme() {
    this.environment.applyThemeClasses(this.getGui());
  }
  createChart() {
    let e;
    this.chartProxy && (e = this.chartProxy.destroy({ keepChartInstance: !0 }));
    const t = (r, o) => {
      const n = this.params.crossFilteringContext;
      n.lastSelectedChartId = o ? "" : this.chartController.getChartId(), o && this.params.crossFilteringResetCallback(), this.crossFilterService.filter(r, o);
    }, s = this.chartController.getChartType(), i = {
      agChartsExports: this.beans.agChartsExports,
      chartType: s,
      chartInstance: e,
      getChartThemeName: this.getChartThemeName.bind(this),
      getChartThemes: this.getChartThemes.bind(this),
      customChartThemes: this.gos.get("customChartThemes"),
      getGridOptionsChartThemeOverrides: () => this.getGridOptionsChartThemeOverrides(),
      getExtraPaddingDirections: () => {
        var r;
        return ((r = this.chartMenu) == null ? void 0 : r.getExtraPaddingDirections()) ?? [];
      },
      apiChartThemeOverrides: this.params.chartThemeOverrides,
      crossFiltering: this.params.crossFiltering ?? !1,
      crossFilterCallback: t,
      parentElement: this.eChart,
      grouping: this.chartController.isGrouping(),
      chartThemeToRestore: this.params.chartThemeName,
      chartOptionsToRestore: this.params.chartOptionsToRestore,
      chartPaletteToRestore: this.params.chartPaletteToRestore,
      seriesChartTypes: this.chartController.getSeriesChartTypes(),
      translate: (r) => this.chartTranslation.translate(r)
    };
    if (this.params.chartOptionsToRestore = void 0, this.chartType = s, this.chartProxy = this.createChartProxy(i), !this.chartProxy) {
      R(138, { chartType: i.chartType });
      return;
    }
    this.chartController.setChartProxy(this.chartProxy), this.createMenuContext();
  }
  createMenuContext() {
    if (this.chartMenuContext)
      return;
    const e = this.createManagedBean(
      new ei(this.chartOptionsService.getChartThemeOverridesProxy())
    ), t = this.createManagedBean(
      new ei(this.chartOptionsService.getAxisThemeOverridesProxy())
    );
    this.chartMenuContext = {
      chartController: this.chartController,
      chartOptionsService: this.chartOptionsService,
      chartMenuParamsFactory: e,
      chartAxisMenuParamsFactory: t
    };
  }
  getChartThemeName() {
    return this.chartController.getChartThemeName();
  }
  getChartThemes() {
    return this.chartController.getThemeNames();
  }
  getGridOptionsChartThemeOverrides() {
    return this.gos.get("chartThemeOverrides");
  }
  createChartProxy(e) {
    var i;
    const { chartType: t } = e;
    switch (t) {
      case "column":
      case "bar":
      case "groupedColumn":
      case "stackedColumn":
      case "normalizedColumn":
      case "groupedBar":
      case "stackedBar":
      case "normalizedBar":
        return new SV(e);
      case "pie":
      case "donut":
      case "doughnut":
        return new TV(e);
      case "area":
      case "stackedArea":
      case "normalizedArea":
        return new yV(e);
      case "line":
      case "stackedLine":
      case "normalizedLine":
        return new xV(e);
      case "scatter":
      case "bubble":
        return new FV(e);
      case "columnLineCombo":
      case "areaColumnCombo":
      case "customCombo":
        return new RV(e);
    }
    const s = (i = this.enterpriseChartProxyFactory) == null ? void 0 : i.createChartProxy(e);
    if (!s)
      throw ut(251, { chartType: t });
    return s;
  }
  addDialog() {
    const e = this.chartTranslation.translate(this.params.pivotChart ? "pivotChartTitle" : "rangeChartTitle"), { width: t, height: s } = this.getBestDialogSize(), i = this.params.focusDialogOnOpen ? () => setTimeout(() => ve(this.getGui())) : void 0;
    this.chartDialog = new Er({
      resizable: !0,
      movable: !0,
      maximizable: !0,
      title: e,
      width: t,
      height: s,
      component: this,
      centered: !0,
      closable: !0,
      afterGuiAttached: i,
      postProcessPopupParams: {
        type: "chart"
      }
    }), this.createBean(this.chartDialog), this.chartDialog.addEventListener("destroyed", () => {
      this.destroy(), this.chartMenuSvc.hideAdvancedSettings();
      const r = this.focusSvc.getFocusedCell();
      setTimeout(() => {
        this.focusSvc.isAlive() && (r ? this.focusSvc.setFocusedCell({ ...r, forceBrowserFocus: !0 }) : Eu(this.beans));
      });
    });
  }
  getBestDialogSize() {
    const e = this.popupSvc.getPopupParent(), t = $s(e) * 0.75, s = jo(e) * 0.75, i = 0.553, r = this.chartProxy.getChart();
    let o = this.params.insideDialog ? 850 : r.width, n = this.params.insideDialog ? 470 : r.height;
    return (o > t || n > s) && (o = Math.min(o, t), n = Math.round(o * i), n > s && (n = s, o = Math.min(o, Math.round(n / i)))), { width: o, height: n };
  }
  addMenu() {
    this.params.crossFiltering || (this.chartMenu = this.createBean(
      new FN(this.eChartContainer, this.eMenuContainer, this.chartMenuContext)
    ), this.eChartContainer.appendChild(this.chartMenu.getGui()));
  }
  update(e) {
    if (e != null && e.chartId && !this.chartController.update(e))
      return;
    const t = this.chartTypeChanged(e), s = t || this.chartEmpty ? ((r) => {
      const o = this.chartType, n = r, a = this.chartProxy.getChart(), l = a == null ? void 0 : a.getOptions(), d = a == null ? void 0 : a.axes;
      return this.chartOptionsService.getPersistedChartThemeOverrides(
        l,
        d,
        o,
        n ?? o
      );
    })(t) : void 0;
    t && this.createChart(), s && (e != null && e.chartThemeOverrides) && pe(s, e.chartThemeOverrides);
    const i = s ?? (e == null ? void 0 : e.chartThemeOverrides);
    this.updateChart(i), e != null && e.chartId && this.chartProxy.getChart().waitForUpdate().then(() => {
      this.chartController.raiseChartApiUpdateEvent();
    });
  }
  updateChart(e) {
    const { chartProxy: t } = this, s = this.chartController.getSelectedValueColState(), i = this.chartController.getChartData(), r = this.handleEmptyChart(i, s.length);
    if (this.chartEmpty = r, r) {
      e && this.chartController.updateThemeOverrides(e);
      return;
    }
    const o = this.chartController.getChartUpdateParams(e);
    t.update(o), this.chartProxy.getChart().waitForUpdate().then(() => {
      this.chartController.raiseChartUpdatedEvent();
    });
  }
  chartTypeChanged(e) {
    const [t, s] = [this.chartController.getChartType(), e == null ? void 0 : e.chartType], i = s ? yr(s) : void 0;
    return this.chartType !== t ? i ?? t : i && t !== i ? i : null;
  }
  getChartModel() {
    return this.chartController.getChartModel();
  }
  getChartImageDataURL(e) {
    return this.chartProxy.getChartImageDataURL(e);
  }
  handleEmptyChart(e, t) {
    const s = this.chartController.isPivotChart() && !this.chartController.isPivotMode(), i = this.chartController.getChartType();
    let r = 1;
    this.chartController.isActiveXYChart() ? r = i === "bubble" ? 3 : 2 : Ns(ne(i)) && (r = 0);
    const o = t < r || e.length === 0;
    if (this.eChart) {
      const n = s || o;
      O(this.eChart, !n), O(this.eEmpty, n);
    }
    return s ? (this.eEmpty.innerText = this.chartTranslation.translate("pivotChartRequiresPivotMode"), !0) : o ? (this.eEmpty.innerText = this.chartTranslation.translate("noDataToChart"), !0) : !1;
  }
  downloadChart(e, t, s) {
    this.chartProxy.downloadChart(e, t, s);
  }
  openChartToolPanel(e) {
    const t = e && ao[e];
    this.chartMenu.showMenu({ panel: t });
  }
  closeChartToolPanel() {
    this.chartMenu.hideMenu();
  }
  getChartId() {
    return this.chartController.getChartId();
  }
  getUnderlyingChart() {
    return this.chartProxy.getChartRef();
  }
  crossFilteringReset() {
    this.chartProxy.crossFilteringReset();
  }
  setActiveChartCellRange(e) {
    this.getGui().contains(e.relatedTarget) || this.chartController.setChartRange(!0);
  }
  getThemeName() {
    const e = this.gos.get("chartThemes") || Uf;
    if (e.length === 0)
      throw new Error(ut(254));
    const { chartThemeName: t } = this.params;
    return e.includes(t) ? t : e[0];
  }
  getAllKeysInObjects(e) {
    const t = {};
    return e.filter((s) => s != null).forEach((s) => {
      Object.keys(s).forEach((i) => t[i] = null);
    }), Object.keys(t);
  }
  validateCustomThemes() {
    const e = this.getChartThemes(), t = this.gos.get("customChartThemes");
    t && this.getAllKeysInObjects([t]).forEach((s) => {
      e.includes(s) || R(139, { customThemeName: s });
    });
  }
  reactivePropertyUpdate() {
    this.chartController.setChartThemeName(this.getThemeName(), !0);
    const e = this.getChartId(), t = this.chartController.isCrossFilterChart() ? "crossFilter" : this.getChartModel().modelType, s = this.gos.get("chartThemeOverrides") || {};
    this.update({
      type: `${t}ChartUpdate`,
      chartId: e,
      chartThemeOverrides: s
    });
  }
  raiseChartCreatedEvent() {
    this.chartProxy.getChart().waitForUpdate().then(() => {
      this.eventSvc.dispatchEvent({
        type: "chartCreated",
        chartId: this.chartController.getChartId()
      });
    });
  }
  raiseChartDestroyedEvent() {
    this.eventSvc.dispatchEvent({
      type: "chartDestroyed",
      chartId: this.chartController.getChartId()
    });
  }
  destroy() {
    var t;
    super.destroy(), this.chartProxy && this.chartProxy.destroy(), this.destroyBean(this.chartMenu), this.chartDialog && this.chartDialog.isAlive() && this.destroyBean(this.chartDialog), (t = this.onDestroyColorSchemeChangeListener) == null || t.call(this);
    const e = this.getGui();
    X(e), ce(e), this.raiseChartDestroyedEvent();
  }
};
function MN(e) {
  return e.version, e.version == null && (e.version = KN(e)), e = Ee("23.0.0", e, AN), e = Ee("24.0.0", e, IN), e = Ee("25.1.0", e, LN), e = Ee("26.0.0", e, kN), e = Ee("26.1.0", e, ON), e = Ee("26.2.0", e, GN), e = Ee("28.0.0", e, BN), e = Ee("28.2.0", e, VN), e = Ee("29.0.0", e, NN), e = Ee("29.1.0", e, Om), e = Ee("29.2.0", e, Gm), e = Ee("30.0.0", e, HN), e = Ee("31.0.0", e, zN), e = Ee("32.0.0", e, WN), e = Ee("33.0.0", e, _N), e = UN(e), e = Ee(j, e, (t) => t), e;
}
function AN(e) {
  return e = Fe("chartOptions.legend.item.marker.type", "shape", e), e = Fe("chartOptions.seriesDefaults.marker.type", "shape", e), e = Fe("chartOptions.legend.padding", "spacing", e), e;
}
function IN(e) {
  e = ie("chartOptions.seriesDefaults.marker.minSize", e);
  const {
    chartType: t,
    chartPalette: s,
    // Migrate.
    chartOptions: { xAxis: i, yAxis: r, ...o },
    ...n
  } = e, a = uB(t), l = a == null ? void 0 : a.map((c, h) => ({
    type: c,
    ...h === 0 ? i : r
  }));
  return {
    chartType: t,
    chartThemeName: {
      borneo: "ag-default",
      material: "ag-material",
      bright: "ag-vivid"
    }[s] ?? "ag-default",
    chartOptions: {
      ...o,
      axes: l,
      xAxis: i,
      yAxis: r
    },
    ...n
  };
}
function LN(e) {
  return e = Fe("chartOptions.seriesDefaults.label.minRequiredAngle", "minAngle", e), e;
}
function kN(e) {
  return e = $t("chartOptions.seriesDefaults.highlightStyle", e, ({ dimOpacity: s, ...i }) => ({
    ...i,
    ...s != null ? { series: { dimOpacity: s } } : {}
  })), e = ie("chart", e), e = ie("chartOptions.seriesDefaults.tooltipClass", e), e = ie("chartOptions.seriesDefaults.tooltipTracking", e), e = Jc("chartOptions.axes[].label.rotation", 0, e), e = Jc("chartOptions.axes[].label.rotation", 335, e), e;
}
function ON(e) {
  const t = ({ item: s, series: i, ...r }) => ({
    item: { ...r, ...s },
    ...i ? { series: i } : {}
  });
  return e = $t("chartOptions.seriesDefaults.highlightStyle", e, t), e = $t("chartOptions.series[].highlightStyle", e, t), e;
}
function GN(e) {
  e = lo("chartOptions.seriesDefaults.fill.opacity", "chartOptions.seriesDefaults.fillOpacity", e), e = lo("chartOptions.seriesDefaults.stroke.opacity", "chartOptions.seriesDefaults.strokeOpacity", e), e = lo("chartOptions.seriesDefaults.stroke.width", "chartOptions.seriesDefaults.strokeWidth", e), e = ie("chartOptions.seriesDefaults.fill", e), e = ie("chartOptions.seriesDefaults.stroke", e), e = ie("chartOptions.seriesDefaults.callout.colors", e), e = ie("chartOptions.xAxis", e), e = ie("chartOptions.yAxis", e);
  const {
    chartType: t,
    // disable no-unused-vars because `series` is required here, even though
    // unused, because it serves to take the `series` key out of otherChartOptions
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    chartOptions: { axes: s, series: i, seriesDefaults: r, ...o },
    ...n
  } = e, a = yr(t), l = ne(a), d = [l], c = {};
  if (!Af(l)) {
    const u = { top: {}, bottom: {}, left: {}, right: {} }, p = s.map(({ type: g, ...f }) => ({
      [g]: { ...u, ...f }
    })).reduce(th, {});
    Lf.filter((g) => p[g] == null).forEach((g) => {
      p[g] = { ...u };
    }), c.axes = p;
  }
  const h = d.map((u) => ({
    [u]: {
      ...c,
      series: r,
      ...o
    }
  })).reduce(th, {});
  return e = {
    ...n,
    chartType: a,
    chartOptions: h
  }, e;
}
function BN(e) {
  return e = ie("chartOptions.*.title.padding", e), e = ie("chartOptions.*.subtitle.padding", e), e = ie("chartOptions.*.axes.*.title.padding", e), e = vd("chartOptions.*.axes.*.title.enabled", !1, e), e;
}
function VN(e) {
  return e = Fe("chartOptions.pie.series.callout", "calloutLine", e), e = Fe("chartOptions.pie.series.label", "calloutLabel", e), e = Fe("chartOptions.pie.series.labelKey", "sectorLabelKey", e), e = Fe("chartOptions.pie.series.labelName", "sectorLabelName", e), e = Fe("chartOptions.donut.series.callout", "calloutLine", e), e = Fe("chartOptions.donut.series.label", "calloutLabel", e), e = Fe("chartOptions.donut.series.labelKey", "sectorLabelKey", e), e = Fe("chartOptions.donut.series.labelName", "sectorLabelName", e), e;
}
function NN(e) {
  return e = ji("chartOptions.scatter.series.fill", "chartOptions.scatter.series.marker.fill", e), e = ji(
    "chartOptions.scatter.series.fillOpacity",
    "chartOptions.scatter.series.marker.fillOpacity",
    e
  ), e = ji("chartOptions.scatter.series.stroke", "chartOptions.scatter.series.marker.stroke", e), e = ji(
    "chartOptions.scatter.series.strokeOpacity",
    "chartOptions.scatter.series.marker.strokeOpacity",
    e
  ), e = ji(
    "chartOptions.scatter.series.strokeWidth",
    "chartOptions.scatter.series.marker.strokeWidth",
    e
  ), e = lo("chartOptions.scatter.series.paired", "chartOptions.scatter.paired", e), e;
}
function Om(e) {
  return e = ie("chartOptions.axes[].tick.count", e), e;
}
function Gm(e) {
  return e = $t("chartOptions.*.tooltip", e, ({ tracking: s, ...i }) => {
    const r = { ...i };
    return s === !1 ? (r.position ?? (r.position = { type: "pointer" }), r.range ?? (r.range = "nearest")) : s === !0 && (r.position ?? (r.position = { type: "node" }), r.range ?? (r.range = "nearest")), r;
  }), e;
}
function HN(e) {
  return e = Fe("chartOptions.pie.series.labelKey", "sectorLabelKey", e), e = Fe("chartOptions.pie.series.labelName", "sectorLabelName", e), e = Om(e), e = Gm(e), e = ie("chartOptions.*.series.flipXY", e), e = Bm("chartOptions.common.legend.enabled", !0, e), e = vd("chartOptions.common.legend.position", "right", e), e;
}
function zN(e) {
  const t = {
    "ag-pastel": "ag-sheets",
    "ag-solar": "ag-polychroma"
  }, s = Fe("chartOptions.column", "bar", e), i = t[s.chartThemeName] || s.chartThemeName;
  return {
    ...s,
    chartThemeName: i
  };
}
function WN(e) {
  return e = Ft("chartOptions.*.autoSize", !0, e, (t, s) => {
    t[s] === !0 || t[s] === !1 && (t.minHeight = 600, t.minWidth = 300), delete t[s];
  }), e;
}
function _N(e) {
  return e = ie("chartOptions.*.axes.category.label.format", e), e = ie("chartOptions.*.axes.category.crosshair.label.format", e), e = ie("chartOptions.*.axes.angle-category.label.format", e), e = ie("chartOptions.*.axes.radius-category.label.format", e), e = Fe("chartOptions.*.axes.*.label.padding", "spacing", e), e = Fe("chartOptions.*.navigator.miniChart.label.padding", "spacing", e), e = ie("chartOptions.*.axes.*.crossLines.label.className", e), e = Ft("chartOptions.*.axes.*.crossLines.label.position", !0, e, (t, s) => {
    typeof t[s] == "string" && (t[s] = t[s].replace(/([A-Z])/, "-$1").toLowerCase());
  }), e = ie("chartOptions.bullet", e), e = eh("chartOptions.bar.series.label.placement", e, {
    inside: "inside-center",
    outside: "inside-end"
  }), e = eh("chartOptions.waterfall.series.item.*.label.placement", e, {
    inside: "inside-center",
    start: "outside-start",
    end: "outside-end"
  }), e = ie("chartOptions.*.navigator.min", e), e = ie("chartOptions.*.navigator.max", e), e = ie("chartOptions.*.zoom.ratioX", e), e = ie("chartOptions.*.zoom.ratioY", e), e = ie("chartOptions.*.zoom.rangeX", e), e = ie("chartOptions.*.zoom.rangeY", e), e;
}
function UN(e) {
  return e = ie("chartOptions.*.width", e), e = ie("chartOptions.*.height", e), e = vd("chartOptions.*.axes.category.label.autoRotate", !0, e), e;
}
function KN(e) {
  var d, c;
  const t = e;
  if (e.version != null)
    return e.version;
  const s = (h, ...u) => Object.keys(h || {}).some((p) => u.includes(p)), i = t.chartOptions, r = s(i, "seriesDefaults") ? i == null ? void 0 : i.seriesDefaults : i == null ? void 0 : i[Object.keys(i)[0]], o = {
    "27.0.0": s(t, "seriesChartTypes"),
    "26.2.0": !s(i, "seriesDefaults"),
    "26.1.0": s(r == null ? void 0 : r.highlightStyle, "item"),
    "26.0.0": s(r == null ? void 0 : r.highlightStyle, "series"),
    // '26.0.0': modelAny.chart === undefined,
    "25.1.0": s(r == null ? void 0 : r.label, "minAngle"),
    "25.0.0": s(t, "modelType", "aggFunc", "unlinkChart", "suppressChartRanges") || s(r, "lineDash", "lineDashOffset"),
    "24.0.0": s(t, "chartThemeName", "chart") || s(i, "series"),
    "23.2.0": s(i, "navigator"),
    "23.0.0": s((c = (d = i == null ? void 0 : i.legend) == null ? void 0 : d.item) == null ? void 0 : c.marker, "shape"),
    "22.1.0": s(t, "chartPalette", "chartType")
  }, n = "27.1.0", a = Object.entries(o).filter(([h, u]) => u), [l = n] = a[0];
  return l;
}
function Ee(e, t, s) {
  if (Qc(e) > Qc(t.version)) {
    const i = s(t);
    return i.version = e, i;
  }
  return t;
}
function $N(e) {
  const t = e.includes("-beta") ? e.replace(/-beta.*/, "") : e, s = typeof t == "string" ? t.split(".").map((i) => Number(i)) : [];
  if (s.length !== 3 || s.some((i) => isNaN(i)))
    throw new Error(ut(253, { version: t }));
  return {
    major: s[0],
    minor: s[1],
    patch: s[2]
  };
}
function Qc(e) {
  const { major: t, minor: s, patch: i } = $N(e);
  return t * 1e4 + s * 100 + i;
}
function Jc(e, t, s) {
  return Ft(e, !0, s, (i, r) => {
    i[r] === t && delete i[r];
  });
}
function vd(e, t, s) {
  return Ft(e, !1, s, (i, r) => {
    i[r] == null && (i[r] = t);
  });
}
function Bm(e, t, s) {
  typeof e == "string" && (e = e.split("."));
  const i = e[0];
  return e.length > 1 && (s[i] = Bm(e.slice(1), t, s[i] ?? {})), Object.keys(s).includes(i) || (s[i] = t), s;
}
function lo(e, t, s) {
  let i, r = !1;
  return s = Ft(e, !0, s, (o, n) => {
    r = !0, i = o[n], delete o[n];
  }), r ? Ft(t, !1, s, (o, n) => {
    o[n] = i;
  }) : s;
}
function ji(e, t, s) {
  let i, r = !1;
  return s = Ft(e, !0, s, (o, n) => {
    r = !0, i = o[n], delete o[n];
  }), r ? Ft(t, !1, s, (o, n) => {
    o[n] === void 0 && (o[n] = i);
  }) : s;
}
function Fe(e, t, s) {
  return Ft(e, !0, s, (i, r) => {
    i[t] = i[r], delete i[r];
  });
}
function ie(e, t) {
  return Ft(e, !0, t, (s, i) => delete s[i]);
}
function Ft(e, t, s, i) {
  const r = e instanceof Array ? e : e.split("."), o = r.slice(0, r.length - 1), n = r[r.length - 1];
  return $t(o, s, (a) => {
    const l = Object.keys(a).includes(n);
    if (t && !l)
      return a;
    const d = { ...a };
    return i(d, n), d;
  });
}
function $t(e, t, s) {
  const i = e instanceof Array ? e : e.split(".");
  if (t = { ...t }, i.length === 0)
    return s(t);
  if (i[0].startsWith("{")) {
    const r = i[0].substring(1, i[0].lastIndexOf("}")).split(",");
    for (const o of r)
      t[o] != null && (t[o] = $t(i.slice(1), t[o], s));
  } else if (i[0].endsWith("[]")) {
    const r = i[0].substring(0, e[0].indexOf("["));
    t[r] instanceof Array && (t[r] = t[r].map((o) => $t(i.slice(1), o, s)));
  } else if (i[0] === "*")
    for (const r of Object.keys(t))
      t[r] = $t(i.slice(1), t[r], s);
  else t[i[0]] != null && (t[i[0]] = $t(i.slice(1), t[i[0]], s));
  return t;
}
function eh(e, t, s) {
  return Ft(e, !0, t, (i, r) => {
    typeof i[r] == "string" && (i[r] = s[r] ?? r);
  });
}
var th = (e, t) => ({ ...e, ...t }), jN = class extends P {
  constructor() {
    super(...arguments), this.beanName = "chartSvc", this.activeCharts = /* @__PURE__ */ new Set(), this.activeChartComps = /* @__PURE__ */ new Set(), this.crossFilteringContext = {
      lastSelectedChartId: ""
    }, this.isEnterprise = () => this.agChartsExports.isEnterprise;
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.rangeSvc = e.rangeSvc, this.agChartsExports = e.agChartsExports;
  }
  updateChart(e) {
    if (this.activeChartComps.size === 0) {
      R(124);
      return;
    }
    const t = [...this.activeChartComps].find((s) => s.getChartId() === e.chartId);
    if (!t) {
      R(125, { chartId: e.chartId });
      return;
    }
    t.update(e);
  }
  getChartModels() {
    const e = [], t = (s) => ({ ...s, version: j });
    return this.activeChartComps.forEach((s) => e.push(t(s.getChartModel()))), e;
  }
  getChartRef(e) {
    let t;
    return this.activeCharts.forEach((s) => {
      s.chartId === e && (t = s);
    }), t;
  }
  getChartComp(e) {
    let t;
    return this.activeChartComps.forEach((s) => {
      s.getChartId() === e && (t = s);
    }), t;
  }
  getChartImageDataURL(e) {
    let t;
    return this.activeChartComps.forEach((s) => {
      s.getChartId() === e.chartId && (t = s.getChartImageDataURL(e.fileFormat));
    }), t;
  }
  downloadChart(e) {
    const t = Array.from(this.activeChartComps).find((s) => s.getChartId() === e.chartId);
    t == null || t.downloadChart(e.dimensions, e.fileName, e.fileFormat);
  }
  openChartToolPanel(e) {
    const t = Array.from(this.activeChartComps).find((s) => s.getChartId() === e.chartId);
    t == null || t.openChartToolPanel(e.panel);
  }
  closeChartToolPanel(e) {
    const t = Array.from(this.activeChartComps).find((s) => s.getChartId() === e);
    t == null || t.closeChartToolPanel();
  }
  createChartFromCurrentRange(e = "groupedColumn", t) {
    const s = this.getSelectedRange();
    return this.createChart({ cellRange: s, chartType: e, focusDialogOnOpen: !t });
  }
  restoreChart(e, t) {
    if (!e) {
      R(126);
      return;
    }
    e.version !== j && (e = MN(e));
    let s, i, r, o;
    if (e.modelType === "pivot" ? (this.gos.updateGridOptions({ options: { pivotMode: !0 }, source: "pivotChart" }), s = this.createCellRange(void 0, !0), i = !0, r = !0) : (s = this.createCellRange(e.cellRange), o = e.chartPalette, r = e.suppressChartRanges), !!s)
      return this.createChart({
        ...e,
        cellRange: s,
        pivotChart: i,
        suppressChartRanges: r,
        chartContainer: t,
        chartOptionsToRestore: e.chartOptions,
        chartPaletteToRestore: o
      });
  }
  createRangeChart(e, t) {
    const s = this.createCellRange(e.cellRange);
    if (s)
      return this.createChart({
        ...e,
        cellRange: s,
        focusDialogOnOpen: !t
      });
  }
  createPivotChart(e, t) {
    this.gos.updateGridOptions({ options: { pivotMode: !0 }, source: "pivotChart" });
    const s = this.createCellRange(void 0, !0);
    if (s)
      return this.createChart({
        ...e,
        cellRange: s,
        pivotChart: !0,
        suppressChartRanges: !0,
        focusDialogOnOpen: !t
      });
  }
  createCrossFilterChart(e, t) {
    const s = this.createCellRange(e.cellRange);
    if (!s)
      return;
    const r = typeof e.suppressChartRanges < "u" && e.suppressChartRanges !== null ? e.suppressChartRanges : !0;
    return this.createChart({
      ...e,
      cellRange: s,
      suppressChartRanges: r,
      crossFiltering: !0,
      focusDialogOnOpen: !t
    });
  }
  createChart(e) {
    const t = fV(e, this.agChartsExports.isEnterprise);
    if (!t)
      return;
    e = t === !0 ? e : t;
    const { chartType: s, chartContainer: i } = e, r = this.gos.getCallback("createChartContainer"), o = {
      ...e,
      chartId: this.generateId(),
      chartType: yr(s),
      insideDialog: !(i || r),
      crossFilteringContext: this.crossFilteringContext,
      crossFilteringResetCallback: () => this.activeChartComps.forEach((l) => l.crossFilteringReset())
    }, n = new EN(o);
    this.createBean(n);
    const a = this.createChartRef(n);
    return i ? i.appendChild(a.chartElement) : r ? r(a) : n.addEventListener("destroyed", () => {
      this.activeChartComps.delete(n), this.activeCharts.delete(a);
    }), a;
  }
  createChartRef(e) {
    const t = {
      destroyChart: () => {
        this.activeCharts.has(t) && (this.destroyBean(e), this.activeChartComps.delete(e), this.activeCharts.delete(t));
      },
      focusChart: () => {
        ve(e.getGui());
      },
      chartElement: e.getGui(),
      chart: e.getUnderlyingChart(),
      chartId: e.getChartModel().chartId
    };
    return this.activeCharts.add(t), this.activeChartComps.add(e), t;
  }
  getSelectedRange() {
    var t;
    const e = ((t = this.rangeSvc) == null ? void 0 : t.getCellRanges()) ?? [];
    return e.length > 0 ? e[0] : { columns: [] };
  }
  generateId() {
    return `id-${Math.random().toString(36).substring(2, 18)}`;
  }
  createCellRange(e, t) {
    var r;
    const s = t ? {
      rowStartIndex: null,
      rowStartPinned: void 0,
      rowEndIndex: null,
      rowEndPinned: void 0,
      columns: this.visibleCols.allCols.map((o) => o.getColId())
    } : e, i = s && ((r = this.rangeSvc) == null ? void 0 : r.createPartialCellRangeFromRangeParams(s, !0));
    return i || R(127, { allRange: t }), i;
  }
  destroy() {
    this.activeCharts.forEach((e) => e.destroyChart()), super.destroy();
  }
};
function qN(e) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var t;
    return (t = e.chartSvc) == null ? void 0 : t.getChartModels();
  });
}
function YN(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.getChartRef(t);
  });
}
function XN(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.getChartImageDataURL(t);
  });
}
function ZN(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.downloadChart(t);
  });
}
function QN(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.openChartToolPanel(t);
  });
}
function JN(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.closeChartToolPanel(t.chartId);
  });
}
function e2(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.createRangeChart(t, !0);
  });
}
function t2(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.createPivotChart(t, !0);
  });
}
function s2(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.createCrossFilterChart(t, !0);
  });
}
function i2(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.chartSvc) == null ? void 0 : s.updateChart(t);
  });
}
function r2(e, t, s) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var i;
    return (i = e.chartSvc) == null ? void 0 : i.restoreChart(t, s);
  });
}
var o2 = (
  /*css*/
  `.ag-chart{display:flex;height:100%;position:relative;width:100%}.ag-chart-components-wrapper{display:flex}.ag-chart-canvas-wrapper,.ag-chart-components-wrapper{flex:1 1 auto;position:relative}.ag-chart-menu{background:var(--ag-background-color);background-color:color-mix(in srgb,transparent,var(--ag-background-color) 30%);border-radius:var(--ag-border-radius);display:flex;flex-direction:row;gap:20px;padding:4px 2px;position:absolute;top:8px;width:auto;--ag-icon-size:20px}:where(.ag-ltr) .ag-chart-menu{justify-content:right;right:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}:where(.ag-rtl) .ag-chart-menu{justify-content:left;left:calc(var(--ag-cell-horizontal-padding) + var(--ag-spacing) - 4px)}:where(.ag-chart) .ag-chart-menu{display:none}:where(.ag-chart-menu-hidden:hover) .ag-chart-menu{display:block}.ag-chart-docked-container{min-width:var(--ag-chart-menu-panel-width);position:relative}:where(.ag-chart-menu-hidden)~.ag-chart-docked-container{display:none}.ag-chart-tabbed-menu{display:flex;flex-direction:column;height:100%;overflow:hidden;width:100%}.ag-chart-tabbed-menu-header{cursor:default;flex:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-tabbed-menu-body{align-items:stretch;display:flex;flex:1 1 auto;overflow:hidden;position:relative;&:after{background:linear-gradient(var(--ag-background-color),transparent);content:"";display:block;height:16px;left:0;position:absolute;right:0;top:0}}.ag-chart-tab{overflow:hidden;overflow-y:auto;width:100%}.ag-chart-settings{overflow-x:hidden}.ag-chart-settings-wrapper{display:flex;flex-direction:column;height:100%;overflow:hidden;position:relative;width:100%}.ag-chart-settings-nav-bar{align-items:center;border-top:1px solid var(--ag-border-color);display:flex;height:30px;padding:0 10px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.ag-chart-settings-card-selector{align-items:center;display:flex;flex:1 1 auto;height:100%;justify-content:space-around;padding:0 10px}.ag-chart-settings-card-item{background-color:var(--ag-foreground-color);border-radius:4px;cursor:pointer;height:8px;position:relative;width:8px;&.ag-not-selected{opacity:.2}&:before{background-color:transparent;content:" ";display:block;height:20px;left:50%;margin-left:-10px;margin-top:-10px;position:absolute;top:50%;width:20px}&.ag-selected{background-color:var(--ag-accent-color)}}.ag-chart-settings-next,.ag-chart-settings-prev{flex:none;position:relative;&:focus-within{border-radius:1px;box-shadow:var(--ag-focus-shadow)}}.ag-chart-settings-next-button,.ag-chart-settings-prev-button{cursor:pointer;height:100%;left:0;opacity:0;position:absolute;top:0;width:100%}.ag-chart-settings-mini-charts-container{flex:1 1 auto;overflow:hidden auto;position:relative}.ag-chart-settings-mini-wrapper{display:flex;flex-direction:column;left:0;min-height:100%;overflow:hidden;padding-bottom:var(--ag-widget-container-vertical-padding);position:absolute;top:0;width:100%;&.ag-animating{transition:left .3s;transition-timing-function:ease-in-out}}.ag-chart-mini-thumbnail{border:1px solid var(--ag-border-color);border-radius:5px;cursor:pointer;&.ag-selected{border-color:var(--ag-accent-color);border-width:2px}&:focus-visible{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}}.ag-chart-mini-thumbnail-canvas{display:block}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper,.ag-chart-format-wrapper{display:flex;flex-direction:column;padding-bottom:16px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-chart-advanced-settings-wrapper,.ag-chart-data-wrapper{height:100%;overflow-y:auto}.ag-chart-advanced-settings{background-color:var(--ag-chrome-background-color)}.ag-chart-advanced-settings,.ag-chart-advanced-settings-wrapper{width:100%}.ag-chart-advanced-settings-wrapper{padding-bottom:0}.ag-chart-advanced-settings-section{border-bottom:1px solid var(--ag-border-color);display:flex;margin:0;padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding)}.ag-chart-empty-text{align-items:center;background-color:var(--ag-background-color);display:flex;height:100%;justify-content:center;top:0;width:100%}.ag-charts-font-size-color{align-self:stretch;display:flex;justify-content:space-between}.ag-charts-data-group-item{padding-bottom:var(--ag-widget-container-vertical-padding);position:relative}.ag-charts-data-group-item:where(:not(:last-child)){margin-bottom:var(--ag-spacing)}.ag-chart-menu-icon{border-radius:var(--ag-border-radius);cursor:pointer;margin:2px 0;opacity:.8;&:hover{opacity:1}}.ag-chart-menu-toolbar-button{background-color:unset;border:0;border-radius:1px;padding:0 2px}.ag-chart-data-column-drag-handle{margin-left:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-title-bar{background-color:unset;position:relative}.ag-charts-data-group-container{padding:calc(var(--ag-widget-container-vertical-padding)*.5) var(--ag-widget-container-horizontal-padding)}.ag-charts-data-group-item:where(:not(.ag-charts-format-sub-level-group,.ag-pill-select,.ag-select)){height:var(--ag-list-item-height)}.ag-charts-data-group-item:where(.ag-picker-field){margin-top:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-container,.ag-charts-format-top-level-group-container{margin-left:calc(var(--ag-spacing)*2);padding:var(--ag-spacing)}.ag-charts-advanced-settings-top-level-group-item,.ag-charts-format-top-level-group-item{margin:var(--ag-spacing) 0}.ag-charts-format-sub-level-group-container{display:flex;flex-direction:column;padding:var(--ag-widget-vertical-spacing) 0}.ag-charts-settings-group-container{display:grid;grid-template-columns:60px 1fr 60px 1fr 60px;padding:var(--ag-spacing);row-gap:8px;:where(.ag-chart-mini-thumbnail:nth-child(3n+1)){grid-column:1}:where(.ag-chart-mini-thumbnail:nth-child(3n+2)){grid-column:3}:where(.ag-chart-mini-thumbnail:nth-child(3n+3)){grid-column:5}}.ag-chart-data-section,.ag-chart-format-section{display:flex;margin:0;:where(.ag-label:not(.ag-group-title-bar)){color:var(--ag-chart-menu-label-color)}:where(.ag-label-align-top .ag-label){margin-bottom:var(--ag-widget-vertical-spacing);margin-top:calc(var(--ag-widget-vertical-spacing)*.5)}:where(.ag-slider.ag-label-align-top .ag-label){margin-bottom:0}:where(label){display:inline-block}}.ag-chart-menu-panel{--ag-panel-background-color:var(--ag-chrome-background-color)}:where(.ag-ltr) .ag-chart-menu-panel{border-left:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-chart-menu-panel{border-right:1px solid var(--ag-border-color)}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar{border-top:none;font-weight:500;padding:0 calc(var(--ag-spacing)*1.5)}.ag-charts-format-sub-level-group-title-bar{background:none;font-weight:500;padding:var(--ag-widget-vertical-spacing) 0}.ag-chart-data-wrapper,.ag-chart-format-wrapper,.ag-charts-data-group-container,.ag-charts-data-group-title-bar,.ag-charts-format-sub-level-group,.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-group-item:last-child,.ag-charts-format-top-level-group,.ag-charts-format-top-level-group-item,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-container,.ag-charts-settings-group-title-bar,:where(.ag-charts-format-top-level-group) .ag-charts-format-top-level-group-container{margin:0;padding:0}.ag-charts-data-group-title-bar,.ag-charts-format-top-level-group-title-bar,.ag-charts-settings-group-title-bar{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:relative}.ag-charts-data-group,.ag-charts-format-top-level-group{border-top:1px solid var(--ag-border-color)}:where(.ag-charts-data-group) .ag-charts-data-group-container,:where(.ag-charts-format-top-level-group) .ag-charts-format-top-level-group-container,:where(.ag-charts-settings-group) .ag-charts-settings-group-container{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-charts-format-sub-level-group-container>*,.ag-charts-format-sub-level-no-header-group-container>*,.ag-charts-format-top-level-group-container>*{margin-bottom:var(--ag-widget-vertical-spacing)}.ag-charts-advanced-settings-top-level-group-container{margin:0}:where(.ag-charts-advanced-settings-top-level-group){.ag-charts-advanced-settings-top-level-group-container,.ag-charts-advanced-settings-top-level-group-title-bar{padding:0 var(--ag-widget-container-horizontal-padding)}}.ag-charts-advanced-settings-top-level-group-item{margin-bottom:0;margin-top:calc(var(--ag-widget-vertical-spacing)*2)}.ag-chart-settings-card-item.ag-not-selected:hover{opacity:.35}.ag-angle-select{align-items:center;display:flex}.ag-angle-select-wrapper{display:flex}.ag-angle-select-parent-circle{background-color:var(--ag-background-color);border:1px solid;border-color:var(--ag-border-color);border-radius:12px;display:block;height:24px;position:relative;width:24px}.ag-angle-select-child-circle{background-color:var(--ag-foreground-color);border-radius:3px;height:6px;left:12px;margin-left:-3px;margin-top:-4px;position:absolute;top:4px;width:6px}.ag-slider-wrapper{display:flex;:where(.ag-input-field){flex:1 1 auto}}.ag-color-panel{display:flex;flex-direction:column;padding:var(--ag-spacing);text-align:center;width:100%}.ag-spectrum-color{cursor:default;flex:1 1 auto;overflow:visible;position:relative}.ag-spectrum-fill{inset:0;position:absolute}.ag-spectrum-val{background-image:linear-gradient(0deg,#000,hsla(20,42%,65%,0));cursor:pointer}.ag-spectrum-dragger{background:#000;border:3px solid #fff;border-radius:18px;box-shadow:0 0 2px 0 rgba(0,0,0,.24);cursor:pointer;height:18px;pointer-events:none;position:absolute;width:18px}.ag-spectrum-alpha,.ag-spectrum-hue{cursor:default}.ag-spectrum-hue-background{background:linear-gradient(270deg,red 3%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);height:100%;width:100%}.ag-spectrum-alpha-background{background:linear-gradient(to right,var(--ag-internal-spectrum-alpha-color-from),var(--ag-internal-spectrum-alpha-color-to)),url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><path d="M0 0H2V4H4V2H0Z" fill="%23b2b2b2"/></svg>') 0 0 /4px 4px;height:100%;width:100%}.ag-spectrum-tool{border-radius:2px;cursor:pointer;height:11px;margin-bottom:10px;position:relative}.ag-spectrum-slider{border:2px solid #fff;border-radius:13px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:13px;margin-top:-12px;pointer-events:none;position:absolute;width:13px}:where(.ag-spectrum-alpha) .ag-spectrum-slider{background:linear-gradient(to bottom,var(--ag-internal-spectrum-alpha-color),var(--ag-internal-spectrum-alpha-color)) var(--ag-background-color)}.ag-recent-colors{display:flex;gap:6px;margin-bottom:2px;margin-left:var(--ag-spacing);margin-right:var(--ag-spacing)}.ag-recent-color{border:1px solid var(--ag-border-color);cursor:pointer}.ag-angle-select[disabled]{opacity:.5;pointer-events:none}:where(.ag-ltr) .ag-angle-select-field,:where(.ag-ltr) .ag-slider-field{margin-right:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-angle-select-field,:where(.ag-rtl) .ag-slider-field{margin-left:calc(var(--ag-spacing)*2)}.ag-color-dialog{border-radius:5px}:where(.ag-color-picker){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:var(--ag-spacing)}.ag-picker-field-display{align-items:center;display:flex;flex-direction:row;min-height:var(--ag-list-item-height)}}:where(.ag-ltr) .ag-color-picker-color,:where(.ag-ltr) .ag-color-picker-value{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-color-picker-color,:where(.ag-rtl) .ag-color-picker-value{margin-left:var(--ag-spacing)}.ag-spectrum-tools{padding-bottom:0;padding-left:0;padding-right:0}.ag-spectrum-alpha-background,.ag-spectrum-hue-background{border-radius:2px}.ag-color-input-color,.ag-color-picker-color,.ag-recent-color{border-radius:4px}.ag-spectrum-sat{background-image:linear-gradient(90deg,#fff,hsla(20,42%,65%,0))}.ag-recent-color,.ag-spectrum-color,.ag-spectrum-slider{&:where(:not(:disabled,[readonly])):focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-color-input-color,.ag-color-picker-color{border:1px solid var(--ag-border-color);border-radius:2px;height:var(--ag-icon-size);width:var(--ag-icon-size)}:where(.ag-color-input){.ag-color-input-color{position:absolute}}:where(.ag-ltr) :where(.ag-color-input){.ag-input-field-input{padding-left:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-color-input){.ag-input-field-input{padding-right:calc(var(--ag-icon-size) + var(--ag-spacing)*2)}.ag-color-input-color{margin-right:var(--ag-spacing)}}.ag-range-field{align-items:center;display:flex;:where(.ag-input-wrapper){height:100%}}.ag-range-field-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:none;height:100%;overflow:visible;padding:0;width:100%;&:disabled{opacity:.5}}.ag-range-field-input{&::-webkit-slider-runnable-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&:focus::-webkit-slider-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}&:active::-webkit-slider-runnable-track{background-color:var(--ag-accent-color)}}.ag-range-field-input{&::-moz-range-track{background-color:var(--ag-border-color);border-radius:1.5px;height:3px;margin:0;padding:0;width:100%}&::-moz-ag-range-thumb{-moz-appearance:none;appearance:none;background-color:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:100%;height:var(--ag-icon-size);margin:0;padding:0;transform:translateY(calc(var(--ag-icon-size)*-.5 + 1.5px));width:var(--ag-icon-size)}&:focus::-moz-ag-range-thumb{border-color:var(--ag-accent-color);box-shadow:var(--ag-focus-shadow)}&:active::-moz-ag-range-track{background-color:var(--ag-accent-color)}}`
), Vm = 28, Nm = 6;
function Ya(e) {
  return e && e.match(/\d+\.\d+\.\d+/);
}
function n2({
  gridMajorVersion: e,
  chartsMajorVersion: t
}) {
  const s = parseInt(e, 10), i = parseInt(t, 10), r = s - Vm, o = i - Nm, n = r >= 0;
  return r === o && n;
}
function a2(e) {
  if (!Ya(e))
    return;
  const [t, s] = e.split(".") || [], i = `${t}.${s}.x`, o = parseInt(t, 10) - Vm + Nm;
  if (o < 0)
    return;
  const a = `${o}.${s}.x`;
  return {
    gridMajorMinor: i,
    chartsMajorMinor: a
  };
}
function Zr({
  type: e,
  gridVersion: t,
  chartsVersion: s
}) {
  const i = "AG Grid: AG Grid version is incompatible. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.", r = a2(t);
  if (!r)
    return i;
  const { gridMajorMinor: o, chartsMajorMinor: n } = r;
  return e === "incompatible" ? `AG Grid version ${t} and AG Charts version ${s} is not supported. AG Grid version ${o} should be used with AG Chart ${n}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.` : e === "invalidCharts" ? `AG Grid version ${o} should be used with AG Chart ${n} not ${s}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.` : i;
}
function l2({
  gridVersion: e,
  chartsVersion: t
}) {
  if (!Ya(t))
    return {
      isValid: !1,
      message: Zr({ type: "invalidCharts", gridVersion: e, chartsVersion: t })
    };
  if (!Ya(e))
    return {
      isValid: !1,
      message: Zr({ type: "invalidGrid", gridVersion: e, chartsVersion: t })
    };
  const [s, i] = e.split(".") || [], [r, o, n] = t.split(".") || [], a = n2({
    gridMajorVersion: s,
    chartsMajorVersion: r
  });
  return a && i === o || n.includes("beta") ? {
    isValid: !0
  } : !a || i !== o ? {
    isValid: !1,
    message: Zr({ type: "incompatible", gridVersion: e, chartsVersion: t })
  } : {
    isValid: !1,
    message: Zr({ type: "invalid", gridVersion: e, chartsVersion: t })
  };
}
var d2 = {
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // icon to open charts menu
  chartsMenu: "menu-alt",
  // download chart
  chartsDownload: "save",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus",
  // shown in Integrated Charts tool panel color picker
  chartsColorPicker: "small-down",
  // previous in Integrated Charts settings tool panel theme switcher
  chartsThemePrevious: "previous",
  // next in Integrated Charts settings tool panel theme switcher
  chartsThemeNext: "next"
}, c2 = {
  getChartModels: qN,
  getChartRef: YN,
  getChartImageDataURL: XN,
  downloadChart: ZN,
  openChartToolPanel: QN,
  closeChartToolPanel: JN,
  createRangeChart: e2,
  createPivotChart: t2,
  createCrossFilterChart: s2,
  updateChart: i2,
  restoreChart: r2
}, sh = [
  Ff,
  te,
  Li,
  ts,
  Cn
], ih = "IntegratedCharts", h2 = {
  moduleName: ih,
  version: j,
  dependsOn: sh,
  // included to avoid other false positive warnings about missing modules
  validate: () => ({
    isValid: !1,
    message: Nh(257)
  }),
  with: (e) => {
    var t;
    if (e.setup(), (t = e.setGridContext) == null || t.call(e, !0), e.isEnterprise && e.setLicenseKey) {
      const s = {
        setLicenseKey: e.setLicenseKey
      };
      Xi.setChartsLicenseManager(s);
    }
    return {
      moduleName: ih,
      version: j,
      icons: d2,
      apiFunctions: c2,
      dependsOn: sh,
      css: [o2],
      validate: () => l2({
        gridVersion: j,
        chartsVersion: e.VERSION
      }),
      beans: [
        // bind the params to the constructor to avoid the need for static properties
        eB.bind(null, e),
        jN,
        oV,
        tV,
        JB,
        iV,
        // Include enterprise beans for now for all users as tiny compared to charts bundle size
        NB,
        ZB
      ]
    };
  }
}, rh = [
  gg,
  nO,
  tk,
  s1,
  pO,
  xO,
  bk,
  Sk,
  Ff,
  xk,
  wf,
  q1,
  Y1,
  qG,
  YG,
  Ok,
  l1,
  rL,
  ql,
  Xk,
  Z1,
  aG,
  yG
], oh = "AllEnterprise", u2 = {
  with: (e) => ({
    moduleName: oh,
    version: j,
    dependsOn: [...rh, h2.with(e), JG.with(e)]
  }),
  moduleName: oh,
  version: j,
  dependsOn: rh
};
const zo = class zo {
  constructor() {
    Ct(this, "overloads", []);
    Ct(this, "additionals", []);
    Ct(this, "hasRegisterKeyAndModule", !1);
  }
  static getColumnOverloadsByResourceName(t) {
    return this._instance.overloads.filter((s) => s.resourceColumnRegister.resourceName === t);
  }
  static getColumnAdditionalsByResourceName(t) {
    return this._instance.additionals.filter((s) => s.resourceName === t);
  }
  /**
   * Enregistre une surcharge de colonne
   * Un identifiant unique est créer par enregistrement : `resourceName` + `columnName` + `associationName`
   * Les appels successifs de cette méthode pour une même donnée viendront remplacer la valeur pour un même identifiant
   * @param resourceColumnRegister
   * @param colDef
   */
  static registerColumnOverload(t, s) {
    const i = `${t.resourceName}::${t.columnName}.${t.associationName}`, r = this._instance.overloads.find((o) => o.id === i);
    if (r) {
      r.colDef = s;
      return;
    }
    this._instance.overloads.push({
      resourceColumnRegister: t,
      colDef: s,
      id: i
    });
  }
  /**
   * Enregistre une colonne additionnelle
   * Un identifiant unique est créer par enregistrement, basé sur la propriété colId de la colonne
   * Les appels successifs de cette méthode pour une même donnée viendront remplacer la valeur pour un même identifiant
   * @param resourceName
   * @param colDef
   */
  static registerColumnAdditional(t, s) {
    const i = `additional::${s.colId ?? (/* @__PURE__ */ new Date()).getTime()}`, r = this._instance.additionals.find((o) => o.id === i);
    if (r) {
      r.colDef = s;
      return;
    }
    this._instance.additionals.push({
      resourceName: t,
      colDef: s,
      id: i
    });
  }
  /**
   * Enregistre la clé AgGrid Enterprise et les modules nécéssaire à Query64
   * @param key
   * @param envMode
   */
  static registerAgGridKeyAndModules(t, s) {
    const i = [
      gg,
      u2
    ];
    s && i.push(Hp), Fu.registerModules(i), mg.setLicenseKey(t), this._instance.hasRegisterKeyAndModule = !0;
  }
};
Ct(zo, "_instance", new zo());
let No = zo;
var p2 = Object.defineProperty, g2 = (e, t, s) => t in e ? p2(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, wi = (e, t, s) => g2(e, typeof t != "symbol" ? t + "" : t, s);
class br {
  static getComponentDefinition(t, s) {
    let i;
    return typeof t == "string" ? i = this.searchForComponentInstance(s, t) : i = { extends: Wo({ ...t }) }, i || z(114, { component: t }), i.extends ? (i.extends.setup && (i.setup = i.extends.setup), i.extends.props = this.addParamsToProps(i.extends.props)) : i.props = this.addParamsToProps(i.props), i;
  }
  static addParamsToProps(t) {
    return !t || Array.isArray(t) && t.indexOf("params") === -1 ? t = ["params", ...t || []] : typeof t == "object" && !t.params && (t.params = {
      type: Object
    }), t;
  }
  static createAndMountComponent(t, s, i, r) {
    const o = br.getComponentDefinition(t, i);
    if (!o)
      return;
    const { vNode: n, destroy: a, el: l } = this.mount(
      o,
      { params: Object.freeze(s) },
      i,
      r || {}
    );
    return {
      componentInstance: n.component.proxy,
      element: l,
      destroy: a
    };
  }
  static mount(t, s, i, r) {
    let o = ch(t, s);
    o.appContext = { ...i.appContext, provides: r };
    let n = document.createElement("div");
    return Sd(o, n), { vNode: o, destroy: () => {
      n && Sd(null, n), n = null, o = null;
    }, el: n };
  }
  static searchForComponentInstance(t, s, i = 10, r = !1) {
    let o = null, n = t.parent, a = 0;
    for (; !o && n && n.components && ++a < i; )
      n.components && n.components[s] && (o = n.components[s]), n = n.parent;
    for (a = 0; !o && n && n.$options && ++a < i; ) {
      const l = n;
      l.$options && l.$options.components && l.$options.components[s] ? o = l.$options.components[s] : l[s] && (o = l[s]), n = n.parent;
    }
    for (a = 0; !o && n && n.exposed && ++a < i; ) {
      const l = n;
      l.exposed && l.exposed[s] ? o = l.exposed[s] : l[s] && (o = l[s]), n = n.parent;
    }
    if (!o) {
      const l = t.appContext.components;
      l && l[s] && (o = l[s]);
    }
    return !o && !r ? (z(114, { component: s }), null) : o;
  }
}
class f2 extends cF {
  constructor(t, s) {
    super(), wi(this, "parent"), wi(this, "provides"), this.parent = t, this.provides = s;
  }
  createWrapper(t) {
    const s = this;
    class i extends m2 {
      init(n) {
        super.init(n);
      }
      hasMethod(n) {
        var a, l;
        const d = r.getFrameworkComponentInstance();
        return d[n] ? !0 : ((a = d.$.exposed) == null ? void 0 : a[n]) != null || ((l = d.exposed) == null ? void 0 : l[n]) != null || d.$.setupState[n] != null;
      }
      callMethod(n, a) {
        var l, d;
        const c = this.getFrameworkComponentInstance(), h = r.getFrameworkComponentInstance();
        if (h[n])
          return h[n].apply(c, a);
        {
          const u = ((l = c.$.exposed) == null ? void 0 : l[n]) || ((d = c.exposed) == null ? void 0 : d[n]) || c.$.setupState[n];
          return u == null ? void 0 : u.apply(c, a);
        }
      }
      addMethod(n, a) {
        r[n] = a;
      }
      processMethod(n, a) {
        return n === "refresh" && (this.getFrameworkComponentInstance().params = a[0]), this.hasMethod(n) ? this.callMethod(n, a) : n === "refresh";
      }
      createComponent(n) {
        return s.createComponent(t, n);
      }
    }
    const r = new i();
    return r;
  }
  createComponent(t, s) {
    return br.createAndMountComponent(t, s, this.parent, this.provides);
  }
  createMethodProxy(t, s, i) {
    return function() {
      return t.hasMethod(s) ? t.callMethod(s, arguments) : (i && R(233, { methodName: s }), null);
    };
  }
  destroy() {
    this.parent = null;
  }
}
class m2 {
  constructor() {
    wi(this, "componentInstance"), wi(this, "element"), wi(this, "unmount");
  }
  getGui() {
    return this.element;
  }
  destroy() {
    this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy == "function" && this.getFrameworkComponentInstance().destroy(), this.unmount();
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  init(t) {
    const { componentInstance: s, element: i, destroy: r } = this.createComponent(t);
    this.componentInstance = s, this.unmount = r, this.element = i.firstElementChild ?? i;
  }
}
class C2 extends np {
  constructor(t) {
    super("vue"), wi(this, "parent"), this.parent = t;
  }
  /*
   * vue components are specified in the "components" part of the vue component - as such we need a way to determine
   * if a given component is within that context - this method provides this
   * Note: This is only really used/necessary with cellRendererSelectors
   */
  frameworkComponent(t, s) {
    let i = br.searchForComponentInstance(this.parent, t, 10, !0) ? t : null;
    if (!i && s && s[t]) {
      const r = s[t];
      i = br.searchForComponentInstance(this.parent, r, 10, !0) ? r : null;
    }
    return i;
  }
  isFrameworkComponent(t) {
    return typeof t == "object";
  }
}
function v2() {
  return {
    gridOptions: {},
    modules: [],
    // @START_DEFAULTS@
    statusBar: void 0,
    sideBar: void 0,
    suppressContextMenu: void 0,
    preventDefaultOnContextMenu: void 0,
    allowContextMenuWithControlKey: void 0,
    columnMenu: void 0,
    suppressMenuHide: void 0,
    enableBrowserTooltips: void 0,
    tooltipTrigger: void 0,
    tooltipShowDelay: void 0,
    tooltipHideDelay: void 0,
    tooltipMouseTrack: void 0,
    tooltipShowMode: void 0,
    tooltipInteraction: void 0,
    popupParent: void 0,
    copyHeadersToClipboard: void 0,
    copyGroupHeadersToClipboard: void 0,
    clipboardDelimiter: void 0,
    suppressCopyRowsToClipboard: void 0,
    suppressCopySingleCellRanges: void 0,
    suppressLastEmptyLineOnPaste: void 0,
    suppressClipboardPaste: void 0,
    suppressClipboardApi: void 0,
    suppressCutToClipboard: void 0,
    columnDefs: void 0,
    defaultColDef: void 0,
    defaultColGroupDef: void 0,
    columnTypes: void 0,
    dataTypeDefinitions: void 0,
    maintainColumnOrder: void 0,
    enableStrictPivotColumnOrder: void 0,
    suppressFieldDotNotation: void 0,
    headerHeight: void 0,
    groupHeaderHeight: void 0,
    floatingFiltersHeight: void 0,
    pivotHeaderHeight: void 0,
    pivotGroupHeaderHeight: void 0,
    allowDragFromColumnsToolPanel: void 0,
    suppressMovableColumns: void 0,
    suppressColumnMoveAnimation: void 0,
    suppressMoveWhenColumnDragging: void 0,
    suppressDragLeaveHidesColumns: void 0,
    suppressGroupChangesColumnVisibility: void 0,
    suppressMakeColumnVisibleAfterUnGroup: void 0,
    suppressRowGroupHidesColumns: void 0,
    colResizeDefault: void 0,
    suppressAutoSize: void 0,
    autoSizePadding: void 0,
    skipHeaderOnAutoSize: void 0,
    autoSizeStrategy: void 0,
    components: void 0,
    editType: void 0,
    singleClickEdit: void 0,
    suppressClickEdit: void 0,
    readOnlyEdit: void 0,
    stopEditingWhenCellsLoseFocus: void 0,
    enterNavigatesVertically: void 0,
    enterNavigatesVerticallyAfterEdit: void 0,
    enableCellEditingOnBackspace: void 0,
    undoRedoCellEditing: void 0,
    undoRedoCellEditingLimit: void 0,
    defaultCsvExportParams: void 0,
    suppressCsvExport: void 0,
    defaultExcelExportParams: void 0,
    suppressExcelExport: void 0,
    excelStyles: void 0,
    quickFilterText: void 0,
    cacheQuickFilter: void 0,
    includeHiddenColumnsInQuickFilter: void 0,
    quickFilterParser: void 0,
    quickFilterMatcher: void 0,
    applyQuickFilterBeforePivotOrAgg: void 0,
    excludeChildrenWhenTreeDataFiltering: void 0,
    enableAdvancedFilter: void 0,
    alwaysPassFilter: void 0,
    includeHiddenColumnsInAdvancedFilter: void 0,
    advancedFilterParent: void 0,
    advancedFilterBuilderParams: void 0,
    suppressAdvancedFilterEval: void 0,
    suppressSetFilterByDefault: void 0,
    enableCharts: void 0,
    chartThemes: void 0,
    customChartThemes: void 0,
    chartThemeOverrides: void 0,
    chartToolPanelsDef: void 0,
    chartMenuItems: void 0,
    loadingCellRenderer: void 0,
    loadingCellRendererParams: void 0,
    loadingCellRendererSelector: void 0,
    localeText: void 0,
    masterDetail: void 0,
    keepDetailRows: void 0,
    keepDetailRowsCount: void 0,
    detailCellRenderer: void 0,
    detailCellRendererParams: void 0,
    detailRowHeight: void 0,
    detailRowAutoHeight: void 0,
    context: void 0,
    dragAndDropImageComponent: void 0,
    dragAndDropImageComponentParams: void 0,
    alignedGrids: void 0,
    tabIndex: void 0,
    rowBuffer: void 0,
    valueCache: void 0,
    valueCacheNeverExpires: void 0,
    enableCellExpressions: void 0,
    suppressTouch: void 0,
    suppressFocusAfterRefresh: void 0,
    suppressBrowserResizeObserver: void 0,
    suppressPropertyNamesCheck: void 0,
    suppressChangeDetection: void 0,
    debug: void 0,
    loading: void 0,
    overlayLoadingTemplate: void 0,
    loadingOverlayComponent: void 0,
    loadingOverlayComponentParams: void 0,
    suppressLoadingOverlay: void 0,
    overlayNoRowsTemplate: void 0,
    noRowsOverlayComponent: void 0,
    noRowsOverlayComponentParams: void 0,
    suppressNoRowsOverlay: void 0,
    pagination: void 0,
    paginationPageSize: void 0,
    paginationPageSizeSelector: void 0,
    paginationAutoPageSize: void 0,
    paginateChildRows: void 0,
    suppressPaginationPanel: void 0,
    pivotMode: void 0,
    pivotPanelShow: void 0,
    pivotMaxGeneratedColumns: void 0,
    pivotDefaultExpanded: void 0,
    pivotColumnGroupTotals: void 0,
    pivotRowTotals: void 0,
    pivotSuppressAutoColumn: void 0,
    suppressExpandablePivotGroups: void 0,
    functionsReadOnly: void 0,
    aggFuncs: void 0,
    suppressAggFuncInHeader: void 0,
    alwaysAggregateAtRootLevel: void 0,
    aggregateOnlyChangedColumns: void 0,
    suppressAggFilteredOnly: void 0,
    removePivotHeaderRowWhenSingleValueColumn: void 0,
    animateRows: void 0,
    cellFlashDuration: void 0,
    cellFadeDuration: void 0,
    allowShowChangeAfterFilter: void 0,
    domLayout: void 0,
    ensureDomOrder: void 0,
    enableRtl: void 0,
    suppressColumnVirtualisation: void 0,
    suppressMaxRenderedRowRestriction: void 0,
    suppressRowVirtualisation: void 0,
    rowDragManaged: void 0,
    suppressRowDrag: void 0,
    suppressMoveWhenRowDragging: void 0,
    rowDragEntireRow: void 0,
    rowDragMultiRow: void 0,
    rowDragText: void 0,
    fullWidthCellRenderer: void 0,
    fullWidthCellRendererParams: void 0,
    embedFullWidthRows: void 0,
    groupDisplayType: void 0,
    groupDefaultExpanded: void 0,
    autoGroupColumnDef: void 0,
    groupMaintainOrder: void 0,
    groupSelectsChildren: void 0,
    groupLockGroupColumns: void 0,
    groupAggFiltering: void 0,
    groupTotalRow: void 0,
    grandTotalRow: void 0,
    suppressStickyTotalRow: void 0,
    groupSuppressBlankHeader: void 0,
    groupSelectsFiltered: void 0,
    showOpenedGroup: void 0,
    groupHideParentOfSingleChild: void 0,
    groupRemoveSingleChildren: void 0,
    groupRemoveLowestSingleChildren: void 0,
    groupHideOpenParents: void 0,
    groupAllowUnbalanced: void 0,
    rowGroupPanelShow: void 0,
    groupRowRenderer: void 0,
    groupRowRendererParams: void 0,
    treeData: void 0,
    rowGroupPanelSuppressSort: void 0,
    suppressGroupRowsSticky: void 0,
    pinnedTopRowData: void 0,
    pinnedBottomRowData: void 0,
    rowModelType: void 0,
    rowData: void 0,
    asyncTransactionWaitMillis: void 0,
    suppressModelUpdateAfterUpdateTransaction: void 0,
    datasource: void 0,
    cacheOverflowSize: void 0,
    infiniteInitialRowCount: void 0,
    serverSideInitialRowCount: void 0,
    suppressServerSideFullWidthLoadingRow: void 0,
    cacheBlockSize: void 0,
    maxBlocksInCache: void 0,
    maxConcurrentDatasourceRequests: void 0,
    blockLoadDebounceMillis: void 0,
    purgeClosedRowNodes: void 0,
    serverSideDatasource: void 0,
    serverSideSortAllLevels: void 0,
    serverSideEnableClientSideSort: void 0,
    serverSideOnlyRefreshFilteredGroups: void 0,
    serverSidePivotResultFieldSeparator: void 0,
    viewportDatasource: void 0,
    viewportRowModelPageSize: void 0,
    viewportRowModelBufferSize: void 0,
    alwaysShowHorizontalScroll: void 0,
    alwaysShowVerticalScroll: void 0,
    debounceVerticalScrollbar: void 0,
    suppressHorizontalScroll: void 0,
    suppressScrollOnNewData: void 0,
    suppressScrollWhenPopupsAreOpen: void 0,
    suppressAnimationFrame: void 0,
    suppressMiddleClickScrolls: void 0,
    suppressPreventDefaultOnMouseWheel: void 0,
    scrollbarWidth: void 0,
    rowSelection: void 0,
    cellSelection: void 0,
    rowMultiSelectWithClick: void 0,
    suppressRowDeselection: void 0,
    suppressRowClickSelection: void 0,
    suppressCellFocus: void 0,
    suppressHeaderFocus: void 0,
    selectionColumnDef: void 0,
    suppressMultiRangeSelection: void 0,
    enableCellTextSelection: void 0,
    enableRangeSelection: void 0,
    enableRangeHandle: void 0,
    enableFillHandle: void 0,
    fillHandleDirection: void 0,
    suppressClearOnFillReduction: void 0,
    sortingOrder: void 0,
    accentedSort: void 0,
    unSortIcon: void 0,
    suppressMultiSort: void 0,
    alwaysMultiSort: void 0,
    multiSortKey: void 0,
    suppressMaintainUnsortedOrder: void 0,
    icons: void 0,
    rowHeight: void 0,
    rowStyle: void 0,
    rowClass: void 0,
    rowClassRules: void 0,
    suppressRowHoverHighlight: void 0,
    suppressRowTransform: void 0,
    columnHoverHighlight: void 0,
    gridId: void 0,
    deltaSort: void 0,
    treeDataDisplayType: void 0,
    enableGroupEdit: void 0,
    initialState: void 0,
    theme: void 0,
    loadThemeGoogleFonts: void 0,
    getContextMenuItems: void 0,
    getMainMenuItems: void 0,
    postProcessPopup: void 0,
    processUnpinnedColumns: void 0,
    processCellForClipboard: void 0,
    processHeaderForClipboard: void 0,
    processGroupHeaderForClipboard: void 0,
    processCellFromClipboard: void 0,
    sendToClipboard: void 0,
    processDataFromClipboard: void 0,
    isExternalFilterPresent: void 0,
    doesExternalFilterPass: void 0,
    getChartToolbarItems: void 0,
    createChartContainer: void 0,
    focusGridInnerElement: void 0,
    navigateToNextHeader: void 0,
    tabToNextHeader: void 0,
    navigateToNextCell: void 0,
    tabToNextCell: void 0,
    getLocaleText: void 0,
    getDocument: void 0,
    paginationNumberFormatter: void 0,
    getGroupRowAgg: void 0,
    isGroupOpenByDefault: void 0,
    initialGroupOrderComparator: void 0,
    processPivotResultColDef: void 0,
    processPivotResultColGroupDef: void 0,
    getDataPath: void 0,
    getChildCount: void 0,
    getServerSideGroupLevelParams: void 0,
    isServerSideGroupOpenByDefault: void 0,
    isApplyServerSideTransaction: void 0,
    isServerSideGroup: void 0,
    getServerSideGroupKey: void 0,
    getBusinessKeyForNode: void 0,
    getRowId: void 0,
    resetRowDataOnUpdate: void 0,
    processRowPostCreate: void 0,
    isRowSelectable: void 0,
    isRowMaster: void 0,
    fillOperation: void 0,
    postSortRows: void 0,
    getRowStyle: void 0,
    getRowClass: void 0,
    getRowHeight: void 0,
    isFullWidthRow: void 0,
    // @END_DEFAULTS@
    // @START_EVENT_PROPS@
    "onColumn-everything-changed": void 0,
    "onNew-columns-loaded": void 0,
    "onColumn-pivot-mode-changed": void 0,
    "onPivot-max-columns-exceeded": void 0,
    "onColumn-row-group-changed": void 0,
    "onExpand-or-collapse-all": void 0,
    "onColumn-pivot-changed": void 0,
    "onGrid-columns-changed": void 0,
    "onColumn-value-changed": void 0,
    "onColumn-moved": void 0,
    "onColumn-visible": void 0,
    "onColumn-pinned": void 0,
    "onColumn-group-opened": void 0,
    "onColumn-resized": void 0,
    "onDisplayed-columns-changed": void 0,
    "onVirtual-columns-changed": void 0,
    "onColumn-header-mouse-over": void 0,
    "onColumn-header-mouse-leave": void 0,
    "onColumn-header-clicked": void 0,
    "onColumn-header-context-menu": void 0,
    "onAsync-transactions-flushed": void 0,
    "onRow-group-opened": void 0,
    "onRow-data-updated": void 0,
    "onPinned-row-data-changed": void 0,
    "onRange-selection-changed": void 0,
    "onCell-selection-changed": void 0,
    "onChart-created": void 0,
    "onChart-range-selection-changed": void 0,
    "onChart-options-changed": void 0,
    "onChart-destroyed": void 0,
    "onTool-panel-visible-changed": void 0,
    "onTool-panel-size-changed": void 0,
    "onModel-updated": void 0,
    "onCut-start": void 0,
    "onCut-end": void 0,
    "onPaste-start": void 0,
    "onPaste-end": void 0,
    "onFill-start": void 0,
    "onFill-end": void 0,
    "onCell-selection-delete-start": void 0,
    "onCell-selection-delete-end": void 0,
    "onRange-delete-start": void 0,
    "onRange-delete-end": void 0,
    "onUndo-started": void 0,
    "onUndo-ended": void 0,
    "onRedo-started": void 0,
    "onRedo-ended": void 0,
    "onCell-clicked": void 0,
    "onCell-double-clicked": void 0,
    "onCell-mouse-down": void 0,
    "onCell-context-menu": void 0,
    "onCell-value-changed": void 0,
    "onCell-edit-request": void 0,
    "onRow-value-changed": void 0,
    "onHeader-focused": void 0,
    "onCell-focused": void 0,
    "onRow-selected": void 0,
    "onSelection-changed": void 0,
    "onTooltip-show": void 0,
    "onTooltip-hide": void 0,
    "onCell-key-down": void 0,
    "onCell-mouse-over": void 0,
    "onCell-mouse-out": void 0,
    "onFilter-changed": void 0,
    "onFilter-modified": void 0,
    "onFilter-opened": void 0,
    "onAdvanced-filter-builder-visible-changed": void 0,
    "onSort-changed": void 0,
    "onVirtual-row-removed": void 0,
    "onRow-clicked": void 0,
    "onRow-double-clicked": void 0,
    "onGrid-ready": void 0,
    "onGrid-pre-destroyed": void 0,
    "onGrid-size-changed": void 0,
    "onViewport-changed": void 0,
    "onFirst-data-rendered": void 0,
    "onDrag-started": void 0,
    "onDrag-stopped": void 0,
    "onDrag-cancelled": void 0,
    "onRow-editing-started": void 0,
    "onRow-editing-stopped": void 0,
    "onCell-editing-started": void 0,
    "onCell-editing-stopped": void 0,
    "onBody-scroll": void 0,
    "onBody-scroll-end": void 0,
    "onPagination-changed": void 0,
    "onComponent-state-changed": void 0,
    "onStore-refreshed": void 0,
    "onState-updated": void 0,
    "onColumn-menu-visible-changed": void 0,
    "onContext-menu-visible-changed": void 0,
    "onRow-drag-enter": void 0,
    "onRow-drag-move": void 0,
    "onRow-drag-leave": void 0,
    "onRow-drag-end": void 0,
    "onRow-drag-cancel": void 0
    // @END_EVENT_PROPS@
  };
}
const w2 = (e, t) => {
  let s;
  return () => {
    const i = function() {
      e();
    };
    window.clearTimeout(s), s = window.setTimeout(i, t);
  };
};
function li(e) {
  const t = (s) => Array.isArray(s) ? s.map((i) => t(i)) : qm(s) || Ym(s) || Xm(s) ? t(Zm(s)) : s && typeof s == "object" && Object.keys(s).length > 0 ? Object.keys(s).reduce((i, r) => (i[r] = t(s[r]), i), {}) : s;
  return t(e);
}
const y2 = { ref: "root" }, b2 = /* @__PURE__ */ Wo({
  __name: "AgGridVue",
  props: /* @__PURE__ */ yd(/* @__PURE__ */ jm({
    gridOptions: {},
    modules: {},
    statusBar: {},
    sideBar: { type: [Object, String, Array, Boolean, null] },
    suppressContextMenu: { type: Boolean },
    preventDefaultOnContextMenu: { type: Boolean },
    allowContextMenuWithControlKey: { type: Boolean },
    columnMenu: {},
    suppressMenuHide: { type: Boolean },
    enableBrowserTooltips: { type: Boolean },
    tooltipTrigger: {},
    tooltipShowDelay: {},
    tooltipHideDelay: {},
    tooltipMouseTrack: { type: Boolean },
    tooltipShowMode: {},
    tooltipInteraction: { type: Boolean },
    popupParent: {},
    copyHeadersToClipboard: { type: Boolean },
    copyGroupHeadersToClipboard: { type: Boolean },
    clipboardDelimiter: {},
    suppressCopyRowsToClipboard: { type: Boolean },
    suppressCopySingleCellRanges: { type: Boolean },
    suppressLastEmptyLineOnPaste: { type: Boolean },
    suppressClipboardPaste: { type: Boolean },
    suppressClipboardApi: { type: Boolean },
    suppressCutToClipboard: { type: Boolean },
    columnDefs: {},
    defaultColDef: {},
    defaultColGroupDef: {},
    columnTypes: {},
    dataTypeDefinitions: {},
    maintainColumnOrder: { type: Boolean },
    enableStrictPivotColumnOrder: { type: Boolean },
    suppressFieldDotNotation: { type: Boolean },
    headerHeight: {},
    groupHeaderHeight: {},
    floatingFiltersHeight: {},
    pivotHeaderHeight: {},
    pivotGroupHeaderHeight: {},
    allowDragFromColumnsToolPanel: { type: Boolean },
    suppressMovableColumns: { type: Boolean },
    suppressColumnMoveAnimation: { type: Boolean },
    suppressMoveWhenColumnDragging: { type: Boolean },
    suppressDragLeaveHidesColumns: { type: Boolean },
    suppressGroupChangesColumnVisibility: { type: [Boolean, String] },
    suppressMakeColumnVisibleAfterUnGroup: { type: Boolean },
    suppressRowGroupHidesColumns: { type: Boolean },
    colResizeDefault: {},
    suppressAutoSize: { type: Boolean },
    autoSizePadding: {},
    skipHeaderOnAutoSize: { type: Boolean },
    autoSizeStrategy: {},
    components: {},
    editType: {},
    singleClickEdit: { type: Boolean },
    suppressClickEdit: { type: Boolean },
    readOnlyEdit: { type: Boolean },
    stopEditingWhenCellsLoseFocus: { type: Boolean },
    enterNavigatesVertically: { type: Boolean },
    enterNavigatesVerticallyAfterEdit: { type: Boolean },
    enableCellEditingOnBackspace: { type: Boolean },
    undoRedoCellEditing: { type: Boolean },
    undoRedoCellEditingLimit: {},
    defaultCsvExportParams: {},
    suppressCsvExport: { type: Boolean },
    defaultExcelExportParams: {},
    suppressExcelExport: { type: Boolean },
    excelStyles: {},
    quickFilterText: {},
    cacheQuickFilter: { type: Boolean },
    includeHiddenColumnsInQuickFilter: { type: Boolean },
    quickFilterParser: { type: Function },
    quickFilterMatcher: { type: Function },
    applyQuickFilterBeforePivotOrAgg: { type: Boolean },
    excludeChildrenWhenTreeDataFiltering: { type: Boolean },
    enableAdvancedFilter: { type: Boolean },
    alwaysPassFilter: { type: Function },
    includeHiddenColumnsInAdvancedFilter: { type: Boolean },
    advancedFilterParent: {},
    advancedFilterBuilderParams: {},
    suppressAdvancedFilterEval: { type: Boolean },
    suppressSetFilterByDefault: { type: Boolean },
    enableCharts: { type: Boolean },
    chartThemes: {},
    customChartThemes: {},
    chartThemeOverrides: {},
    chartToolPanelsDef: {},
    chartMenuItems: { type: [Array, Function] },
    loadingCellRenderer: {},
    loadingCellRendererParams: {},
    loadingCellRendererSelector: { type: Function },
    localeText: {},
    masterDetail: { type: Boolean },
    keepDetailRows: { type: Boolean },
    keepDetailRowsCount: {},
    detailCellRenderer: {},
    detailCellRendererParams: {},
    detailRowHeight: {},
    detailRowAutoHeight: { type: Boolean },
    context: {},
    dragAndDropImageComponent: {},
    dragAndDropImageComponentParams: {},
    alignedGrids: { type: [Array, Function] },
    tabIndex: {},
    rowBuffer: {},
    valueCache: { type: Boolean },
    valueCacheNeverExpires: { type: Boolean },
    enableCellExpressions: { type: Boolean },
    suppressTouch: { type: Boolean },
    suppressFocusAfterRefresh: { type: Boolean },
    suppressBrowserResizeObserver: { type: Boolean },
    suppressPropertyNamesCheck: { type: Boolean },
    suppressChangeDetection: { type: Boolean },
    debug: { type: Boolean },
    loading: { type: Boolean },
    overlayLoadingTemplate: {},
    loadingOverlayComponent: {},
    loadingOverlayComponentParams: {},
    suppressLoadingOverlay: { type: Boolean },
    overlayNoRowsTemplate: {},
    noRowsOverlayComponent: {},
    noRowsOverlayComponentParams: {},
    suppressNoRowsOverlay: { type: Boolean },
    pagination: { type: Boolean },
    paginationPageSize: {},
    paginationPageSizeSelector: { type: [Array, Boolean] },
    paginationAutoPageSize: { type: Boolean },
    paginateChildRows: { type: Boolean },
    suppressPaginationPanel: { type: Boolean },
    pivotMode: { type: Boolean },
    pivotPanelShow: {},
    pivotMaxGeneratedColumns: {},
    pivotDefaultExpanded: {},
    pivotColumnGroupTotals: {},
    pivotRowTotals: {},
    pivotSuppressAutoColumn: { type: Boolean },
    suppressExpandablePivotGroups: { type: Boolean },
    functionsReadOnly: { type: Boolean },
    aggFuncs: {},
    suppressAggFuncInHeader: { type: Boolean },
    alwaysAggregateAtRootLevel: { type: Boolean },
    aggregateOnlyChangedColumns: { type: Boolean },
    suppressAggFilteredOnly: { type: Boolean },
    removePivotHeaderRowWhenSingleValueColumn: { type: Boolean },
    animateRows: { type: Boolean },
    cellFlashDuration: {},
    cellFadeDuration: {},
    allowShowChangeAfterFilter: { type: Boolean },
    domLayout: {},
    ensureDomOrder: { type: Boolean },
    enableRtl: { type: Boolean },
    suppressColumnVirtualisation: { type: Boolean },
    suppressMaxRenderedRowRestriction: { type: Boolean },
    suppressRowVirtualisation: { type: Boolean },
    rowDragManaged: { type: Boolean },
    suppressRowDrag: { type: Boolean },
    suppressMoveWhenRowDragging: { type: Boolean },
    rowDragEntireRow: { type: Boolean },
    rowDragMultiRow: { type: Boolean },
    rowDragText: { type: Function },
    fullWidthCellRenderer: {},
    fullWidthCellRendererParams: {},
    embedFullWidthRows: { type: Boolean },
    groupDisplayType: {},
    groupDefaultExpanded: {},
    autoGroupColumnDef: {},
    groupMaintainOrder: { type: Boolean },
    groupSelectsChildren: { type: Boolean },
    groupLockGroupColumns: {},
    groupAggFiltering: { type: [Boolean, Function] },
    groupTotalRow: { type: [String, Function] },
    grandTotalRow: {},
    suppressStickyTotalRow: { type: [Boolean, String] },
    groupSuppressBlankHeader: { type: Boolean },
    groupSelectsFiltered: { type: Boolean },
    showOpenedGroup: { type: Boolean },
    groupHideParentOfSingleChild: { type: [Boolean, String] },
    groupRemoveSingleChildren: { type: Boolean },
    groupRemoveLowestSingleChildren: { type: Boolean },
    groupHideOpenParents: { type: Boolean },
    groupAllowUnbalanced: { type: Boolean },
    rowGroupPanelShow: {},
    groupRowRenderer: {},
    groupRowRendererParams: {},
    treeData: { type: Boolean },
    rowGroupPanelSuppressSort: { type: Boolean },
    suppressGroupRowsSticky: { type: Boolean },
    pinnedTopRowData: {},
    pinnedBottomRowData: {},
    rowModelType: {},
    rowData: {},
    asyncTransactionWaitMillis: {},
    suppressModelUpdateAfterUpdateTransaction: { type: Boolean },
    datasource: {},
    cacheOverflowSize: {},
    infiniteInitialRowCount: {},
    serverSideInitialRowCount: {},
    suppressServerSideFullWidthLoadingRow: { type: Boolean },
    cacheBlockSize: {},
    maxBlocksInCache: {},
    maxConcurrentDatasourceRequests: {},
    blockLoadDebounceMillis: {},
    purgeClosedRowNodes: { type: Boolean },
    serverSideDatasource: {},
    serverSideSortAllLevels: { type: Boolean },
    serverSideEnableClientSideSort: { type: Boolean },
    serverSideOnlyRefreshFilteredGroups: { type: Boolean },
    serverSidePivotResultFieldSeparator: {},
    viewportDatasource: {},
    viewportRowModelPageSize: {},
    viewportRowModelBufferSize: {},
    alwaysShowHorizontalScroll: { type: Boolean },
    alwaysShowVerticalScroll: { type: Boolean },
    debounceVerticalScrollbar: { type: Boolean },
    suppressHorizontalScroll: { type: Boolean },
    suppressScrollOnNewData: { type: Boolean },
    suppressScrollWhenPopupsAreOpen: { type: Boolean },
    suppressAnimationFrame: { type: Boolean },
    suppressMiddleClickScrolls: { type: Boolean },
    suppressPreventDefaultOnMouseWheel: { type: Boolean },
    scrollbarWidth: {},
    rowSelection: {},
    cellSelection: { type: [Boolean, Object] },
    rowMultiSelectWithClick: { type: Boolean },
    suppressRowDeselection: { type: Boolean },
    suppressRowClickSelection: { type: Boolean },
    suppressCellFocus: { type: Boolean },
    suppressHeaderFocus: { type: Boolean },
    selectionColumnDef: {},
    suppressMultiRangeSelection: { type: Boolean },
    enableCellTextSelection: { type: Boolean },
    enableRangeSelection: { type: Boolean },
    enableRangeHandle: { type: Boolean },
    enableFillHandle: { type: Boolean },
    fillHandleDirection: {},
    suppressClearOnFillReduction: { type: Boolean },
    sortingOrder: {},
    accentedSort: { type: Boolean },
    unSortIcon: { type: Boolean },
    suppressMultiSort: { type: Boolean },
    alwaysMultiSort: { type: Boolean },
    multiSortKey: {},
    suppressMaintainUnsortedOrder: { type: Boolean },
    icons: {},
    rowHeight: {},
    rowStyle: {},
    rowClass: {},
    rowClassRules: {},
    suppressRowHoverHighlight: { type: Boolean },
    suppressRowTransform: { type: Boolean },
    columnHoverHighlight: { type: Boolean },
    gridId: {},
    deltaSort: { type: Boolean },
    treeDataDisplayType: {},
    enableGroupEdit: { type: Boolean },
    initialState: {},
    theme: {},
    loadThemeGoogleFonts: { type: Boolean },
    getContextMenuItems: { type: Function },
    getMainMenuItems: { type: Function },
    postProcessPopup: { type: Function },
    processUnpinnedColumns: { type: Function },
    processCellForClipboard: { type: Function },
    processHeaderForClipboard: { type: Function },
    processGroupHeaderForClipboard: { type: Function },
    processCellFromClipboard: { type: Function },
    sendToClipboard: { type: Function },
    processDataFromClipboard: { type: Function },
    isExternalFilterPresent: { type: Function },
    doesExternalFilterPass: { type: Function },
    getChartToolbarItems: { type: Function },
    createChartContainer: { type: Function },
    focusGridInnerElement: { type: Function },
    navigateToNextHeader: { type: Function },
    tabToNextHeader: { type: Function },
    navigateToNextCell: { type: Function },
    tabToNextCell: { type: Function },
    getLocaleText: { type: Function },
    getDocument: { type: Function },
    paginationNumberFormatter: { type: Function },
    getGroupRowAgg: { type: Function },
    isGroupOpenByDefault: { type: Function },
    initialGroupOrderComparator: { type: Function },
    processPivotResultColDef: { type: Function },
    processPivotResultColGroupDef: { type: Function },
    getDataPath: { type: Function },
    getChildCount: { type: Function },
    getServerSideGroupLevelParams: { type: Function },
    isServerSideGroupOpenByDefault: { type: Function },
    isApplyServerSideTransaction: { type: Function },
    isServerSideGroup: { type: Function },
    getServerSideGroupKey: { type: Function },
    getBusinessKeyForNode: { type: Function },
    getRowId: { type: Function },
    resetRowDataOnUpdate: { type: Boolean },
    processRowPostCreate: { type: Function },
    isRowSelectable: { type: Function },
    isRowMaster: { type: Function },
    fillOperation: { type: Function },
    postSortRows: { type: Function },
    getRowStyle: { type: Function },
    getRowClass: { type: Function },
    getRowHeight: { type: Function },
    isFullWidthRow: { type: Function },
    "onTool-panel-visible-changed": {},
    "onTool-panel-size-changed": {},
    "onColumn-menu-visible-changed": {},
    "onContext-menu-visible-changed": {},
    "onCut-start": {},
    "onCut-end": {},
    "onPaste-start": {},
    "onPaste-end": {},
    "onColumn-visible": {},
    "onColumn-pinned": {},
    "onColumn-resized": {},
    "onColumn-moved": {},
    "onColumn-value-changed": {},
    "onColumn-pivot-mode-changed": {},
    "onColumn-pivot-changed": {},
    "onColumn-group-opened": {},
    "onNew-columns-loaded": {},
    "onGrid-columns-changed": {},
    "onDisplayed-columns-changed": {},
    "onVirtual-columns-changed": {},
    "onColumn-everything-changed": {},
    "onColumn-header-mouse-over": {},
    "onColumn-header-mouse-leave": {},
    "onColumn-header-clicked": {},
    "onColumn-header-context-menu": {},
    "onComponent-state-changed": {},
    "onCell-value-changed": {},
    "onCell-edit-request": {},
    "onRow-value-changed": {},
    "onCell-editing-started": {},
    "onCell-editing-stopped": {},
    "onRow-editing-started": {},
    "onRow-editing-stopped": {},
    "onUndo-started": {},
    "onUndo-ended": {},
    "onRedo-started": {},
    "onRedo-ended": {},
    "onCell-selection-delete-start": {},
    "onCell-selection-delete-end": {},
    "onRange-delete-start": {},
    "onRange-delete-end": {},
    "onFill-start": {},
    "onFill-end": {},
    "onFilter-opened": {},
    "onFilter-changed": {},
    "onFilter-modified": {},
    "onAdvanced-filter-builder-visible-changed": {},
    "onChart-created": {},
    "onChart-range-selection-changed": {},
    "onChart-options-changed": {},
    "onChart-destroyed": {},
    "onCell-key-down": {},
    "onGrid-ready": {},
    "onGrid-pre-destroyed": {},
    "onFirst-data-rendered": {},
    "onGrid-size-changed": {},
    "onModel-updated": {},
    "onVirtual-row-removed": {},
    "onViewport-changed": {},
    "onBody-scroll": {},
    "onBody-scroll-end": {},
    "onDrag-started": {},
    "onDrag-stopped": {},
    "onDrag-cancelled": {},
    "onState-updated": {},
    "onPagination-changed": {},
    "onRow-drag-enter": {},
    "onRow-drag-move": {},
    "onRow-drag-leave": {},
    "onRow-drag-end": {},
    "onRow-drag-cancel": {},
    "onColumn-row-group-changed": {},
    "onRow-group-opened": {},
    "onExpand-or-collapse-all": {},
    "onPivot-max-columns-exceeded": {},
    "onPinned-row-data-changed": {},
    "onRow-data-updated": {},
    "onAsync-transactions-flushed": {},
    "onStore-refreshed": {},
    "onHeader-focused": {},
    "onCell-clicked": {},
    "onCell-double-clicked": {},
    "onCell-focused": {},
    "onCell-mouse-over": {},
    "onCell-mouse-out": {},
    "onCell-mouse-down": {},
    "onRow-clicked": {},
    "onRow-double-clicked": {},
    "onRow-selected": {},
    "onSelection-changed": {},
    "onCell-context-menu": {},
    "onRange-selection-changed": {},
    "onCell-selection-changed": {},
    "onTooltip-show": {},
    "onTooltip-hide": {},
    "onSort-changed": {}
  }, v2()), {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ yd(["update:modelValue"], ["update:modelValue"]),
  setup(e, { expose: t, emit: s }) {
    const i = e, r = Wm("root"), o = it(void 0), n = it(!1), a = it(!1), l = it(!1), d = it({}), c = it(null), h = _m(i);
    Aa.filter((x) => x != "gridOptions").forEach((x) => {
      bd(
        () => h[x],
        (T, I) => {
          F(x, T);
        },
        { deep: !0 }
      );
    });
    const u = /* @__PURE__ */ new Set(["rowDataUpdated", "cellValueChanged", "rowValueChanged"]), p = Um(e, "modelValue"), g = it(!1), f = s;
    bd(
      p,
      (x, T) => {
        n.value && (g.value = !0, F("rowData", li(x), li(T)));
      },
      { deep: !0 }
    );
    const m = w2(() => {
      f("update:modelValue", li(b()));
    }, 20), C = (x) => {
      l.value && u.has(x) && m();
    }, v = () => p.value || i.rowData || i.gridOptions.rowData, b = () => {
      const x = [];
      return o == null || o.value.forEachNode((T) => {
        x.push(T.data);
      }), x;
    }, y = (x) => (T) => {
      if (a.value)
        return;
      T === "gridReady" && (l.value = !0);
      const I = or.has(T);
      I && !x || !I && x || u.has(T) && (g.value || C(T), g.value = !1);
    }, F = (x, T, I) => {
      if (n.value) {
        let E = T.value || T;
        x === "rowData" && E != null && (E = li(E)), d.value[x] = E, c.value == null && (c.value = window.setTimeout(() => {
          c.value = null, VC(d.value, o.value), d.value = {};
        }, 0));
      }
    }, D = () => Object.create(xn().provides);
    return dh(() => {
      Fu.registerModules([pg]);
      const x = new f2(xn(), D()), T = {
        globalListener: y(),
        globalSyncListener: y(!0),
        frameworkOverrides: new C2(xn()),
        providedBeanInstances: {
          frameworkCompWrapper: x
        },
        modules: i.modules
      }, I = Km(
        BC(li(i.gridOptions), i, [
          ...Aa,
          ...kp.map((M) => dl(M))
        ])
      ), E = v();
      E !== void 0 && (I.rowData = li(E)), o.value = Lp(r.value, I, T), n.value = !0;
    }), $m(() => {
      var x;
      n.value && ((x = o == null ? void 0 : o.value) == null || x.destroy(), a.value = !0);
    }), t({
      api: o
    }), (x, T) => (pi(), ui("div", y2, null, 512));
  }
}), S2 = {
  selectAll: "(Tout sélectionner)",
  selectAllSearchResults: "(Sélectionner tous les résultats)",
  searchOoo: "Recherche…",
  blanks: "(Vides)",
  noMatches: "Aucun résultat",
  filterOoo: "Filtrage...",
  equals: "Égal",
  notEqual: "Différent",
  empty: "Vide",
  notEmpty: "Non vide",
  lessThan: "Inférieur",
  greaterThan: "Supérieur",
  lessThanOrEqual: "Inférieur ou égal",
  greaterThanOrEqual: "Supérieur ou égal",
  after: "Après",
  before: "Avant",
  inRange: "Entre",
  inRangeStart: "de",
  inRangeEnd: "à",
  contains: "Contient",
  notContains: "Ne contient pas",
  startsWith: "Commence par",
  endsWith: "Termine par",
  dateFormatOoo: "DD/MM/YYYY",
  andCondition: "ET",
  orCondition: "OU",
  applyFilter: "Appliquer",
  resetFilter: "RÀZ",
  clearFilter: "Effacer",
  cancelFilter: "Annuler",
  textFilter: "Filtre Texte",
  numberFilter: "Filtre Nombre",
  dateFilter: "Filtre Date",
  setFilter: "Filtre Ensemble",
  columns: "Colonnes",
  filters: "Filtres",
  pivotMode: "Mode Pivot",
  groups: "Groupes de lignes",
  rowGroupColumnsEmptyMessage: "Glissez les colonnes ici pour faire des regroupements",
  values: "Valeurs",
  valueColumnsEmptyMessage: "Glissez ici pour aggréger",
  pivots: "Noms des colonnes",
  pivotColumnsEmptyMessage: "Glissez ici pour définir les noms de colonnes",
  group: "Regroupement",
  loadingOoo: "Chargement...",
  noRowsToShow: "Aucune ligne",
  enabled: "Activé",
  pinColumn: "Épingler la colonne",
  pinLeft: "À gauche",
  pinRight: "À droite",
  noPin: "Nulle part",
  valueAggregation: "Aggregation de valeurs",
  autosizeThiscolumn: "Autodimensionner cette colonne",
  autosizeAllColumns: "Autodimensionner toutes les colonnes",
  groupBy: "Grouper par",
  ungroupBy: "Dégrouper par",
  resetColumns: "RÀZ des colonnes",
  expandAll: "Tout déplier",
  collapseAll: "Tout replier",
  copy: "Copier",
  ctrlC: "Ctrl+C",
  copyWithGroupHeaders: "Copier avec les entêtes groupées",
  copyWithHeaders: "Copier avec les entêtes",
  paste: "Coller",
  ctrlV: "Ctrl+V",
  export: "Exporter",
  csvExport: "CSV Export",
  excelExport: "Excel Export (.xlsx)",
  excelXmlExport: "Excel Export (.xml)",
  sum: "Somme",
  min: "Min",
  max: "Max",
  none: "Aucun",
  count: "Count",
  avg: "Moyenne",
  filteredRows: "Filtré",
  selectedRows: "Selectionné",
  totalRows: "Nb lignes total",
  totalAndFilteredRows: "Lignes",
  more: "Plus",
  to: "à",
  of: "sur",
  page: "Page",
  nextPage: "Page suivante",
  lastPage: "Dernière page",
  firstPage: "Première page",
  previousPage: "Page précédente",
  pivotChartAndPivotMode: "Pivot Chart & Pivot Mode",
  pivotChart: "Pivot Chart",
  chartRange: "Graphique sur une plage",
  columnChart: "Colonne",
  groupedColumn: "Groupé",
  stackedColumn: "Empilé",
  normalizedColumn: "100% Empilé",
  barChart: "Barre",
  groupedBar: "Groupé",
  stackedBar: "Empilé",
  normalizedBar: "100% Empilé",
  pieChart: "Circulaire",
  pie: "Circulaire",
  doughnut: "Anneau",
  line: "Ligne",
  xyChart: "X Y (Dispersion)",
  scatter: "Dispersion",
  bubble: "Bulles",
  areaChart: "Aires",
  area: "Aires",
  stackedArea: "Empilé",
  normalizedArea: "100% Empilé",
  histogramChart: "Histogramme",
  pivotChartTitle: "Pivot Chart",
  rangeChartTitle: "Range Chart",
  settings: "Settings",
  data: "Data",
  format: "Format",
  categories: "Categories",
  defaultCategory: "(None)",
  series: "Series",
  xyValues: "X Y Values",
  paired: "Paired Mode",
  axis: "Axis",
  navigator: "Navigator",
  color: "Color",
  thickness: "Thickness",
  xType: "X Type",
  automatic: "Automatic",
  category: "Category",
  number: "Number",
  time: "Time",
  xRotation: "X Rotation",
  yRotation: "Y Rotation",
  ticks: "Ticks",
  width: "Width",
  height: "Height",
  length: "Length",
  padding: "Padding",
  spacing: "Spacing",
  chart: "Chart",
  title: "Title",
  titlePlaceholder: "Chart title - double click to edit",
  background: "Background",
  font: "Font",
  top: "Haut",
  right: "Droit",
  bottom: "Bas",
  left: "Gauche",
  labels: "Labels",
  size: "Size",
  minSize: "Minimum Size",
  maxSize: "Maximum Size",
  legend: "Legend",
  position: "Position",
  markerSize: "Marker Size",
  markerStroke: "Marker Stroke",
  markerPadding: "Marker Padding",
  itemSpacing: "Item Spacing",
  itemPaddingX: "Item Padding X",
  itemPaddingY: "Item Padding Y",
  layoutHorizontalSpacing: "Horizontal Spacing",
  layoutVerticalSpacing: "Vertical Spacing",
  strokeWidth: "Stroke Width",
  offset: "Offset",
  offsets: "Offsets",
  tooltips: "Tooltips",
  callout: "Callout",
  markers: "Markers",
  shadow: "Shadow",
  blur: "Blur",
  xOffset: "X Offset",
  yOffset: "Y Offset",
  lineWidth: "Line Width",
  normal: "Normal",
  bold: "Bold",
  italic: "Italic",
  boldItalic: "Bold Italic",
  predefined: "Predefined",
  fillOpacity: "Fill Opacity",
  strokeOpacity: "Line Opacity",
  histogramBinCount: "Bin count",
  columnGroup: "Column",
  barGroup: "Bar",
  pieGroup: "Pie",
  lineGroup: "Line",
  scatterGroup: "X Y (Scatter)",
  areaGroup: "Area",
  histogramGroup: "Histogram",
  groupedColumnTooltip: "Grouped",
  stackedColumnTooltip: "Stacked",
  normalizedColumnTooltip: "100% Stacked",
  groupedBarTooltip: "Grouped",
  stackedBarTooltip: "Stacked",
  normalizedBarTooltip: "100% Stacked",
  pieTooltip: "Pie",
  doughnutTooltip: "Doughnut",
  lineTooltip: "Line",
  groupedAreaTooltip: "Area",
  stackedAreaTooltip: "Stacked",
  normalizedAreaTooltip: "100% Stacked",
  scatterTooltip: "Scatter",
  bubbleTooltip: "Bubble",
  histogramTooltip: "Histogram",
  noDataToChart: "No data available to be charted.",
  pivotChartRequiresPivotMode: "Pivot Chart requires Pivot Mode enabled.",
  rowDragRow: "ligne",
  rowDragRows: "lignes",
  sortAscending: "Tri ascendant",
  sortDescending: "Tri descendant",
  columnChooser: "Choix des colonnes",
  chooseColumns: "Choisir des colonnes"
}, x2 = { style: { display: "flex", "flex-direction": "column" } }, nh = /* @__PURE__ */ Wo({
  __name: "CellDefaultListValue",
  props: {
    params: {}
  },
  setup(e) {
    const t = e;
    return (s, i) => (pi(), ui("div", x2, [
      Qm("div", null, [
        (pi(!0), ui(Jm, null, eC(t.params.value, (r) => (pi(), ui("div", { key: r }, "- " + hh(r), 1))), 128))
      ])
    ]));
  }
});
class Ho {
  constructor(t, s, i, r, o, n) {
    Ct(this, "resourceName");
    Ct(this, "globalColumnSettings");
    Ct(this, "hasManyColumnSettings");
    Ct(this, "actionColumnSettings");
    Ct(this, "overloadSettings");
    Ct(this, "additionalSettings");
    this.resourceName = t, s && (s == null ? void 0 : s.columnTypeConfig) === void 0 && (s.columnTypeConfig = Ho.getColumnTypesDefaultConfig()), this.globalColumnSettings = {
      columnTypeConfig: (s == null ? void 0 : s.columnTypeConfig) ?? Ho.getColumnTypesDefaultConfig(),
      columnDateFormater: (s == null ? void 0 : s.columnDateFormater) ?? ((a) => {
        const l = new Date(a), d = l.getDate(), c = l.getMonth() + 1, h = l.getFullYear(), u = l.getHours(), p = l.getMinutes();
        return (d < 10 ? "0" : "") + d + "/" + (c < 10 ? "0" : "") + c + "/" + h + " " + ((u < 10 ? "0" : "") + u + ":" + ((p < 10 ? "0" : "") + p));
      })
    }, this.hasManyColumnSettings = i ?? {
      purgeNullValue: !1,
      customComponent: nh
    }, this.actionColumnSettings = r, this.overloadSettings = o ?? [], No.getColumnOverloadsByResourceName(this.resourceName).forEach(
      (a) => {
        this.overloadSettings.push(a);
      }
    ), this.additionalSettings = n ?? [], No.getColumnAdditionalsByResourceName(this.resourceName).forEach(
      (a) => {
        this.additionalSettings.push(a);
      }
    );
  }
  static getColumnTypesDefaultConfig() {
    return {
      textColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agTextColumnFilter",
        filterParams: {
          filterOptions: ["contains", "notContains"]
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      keywordColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agTextColumnFilter",
        filterParams: {
          filterOptions: [
            "contains",
            "equals",
            "notEqual",
            "notContains",
            {
              displayKey: "empty",
              displayName: "Vide",
              predicate: function(t, s) {
                return String(s).length === 0;
              },
              numberOfInputs: 0
            },
            {
              displayKey: "notEmpty",
              displayName: "Non vide",
              predicate: function(t, s) {
                return String(s).length > 0;
              },
              numberOfInputs: 0
            }
          ]
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      floatColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agNumberColumnFilter",
        filterParams: {
          filterOptions: ["contains", "equals", "greaterThan", "lessThan"]
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      numberColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agNumberColumnFilter",
        filterParams: {
          filterOptions: ["equals", "greaterThan", "lessThan", "inRange"]
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      dateColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agDateColumnFilter",
        filterParams: {
          buttons: ["reset"],
          browserDatePicker: !0,
          filterOptions: [
            "equals",
            "notEqual",
            "inRange",
            "greaterThan",
            "lessThan"
          ]
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      booleanColumn: {
        floatingFilter: !0,
        resizable: !0,
        sortable: !0,
        enableRowGroup: !0,
        columnGroupShow: "open",
        filter: "agTextColumnFilter",
        filterParams: {
          filterOptions: ["equals"],
          suppressAndOrCondition: !0,
          textMatcher: (t) => {
            if (!t.filterText) return !0;
            const s = t.filterText.trim().toLowerCase(), i = ["oui", "ou", "o", "true"], r = ["non", "no", "n", "false"];
            return i.includes(s) ? t.value === !0 : r.includes(s) ? t.value === !1 : !1;
          }
        },
        mainMenuItems: [
          "sortAscending",
          "sortDescending",
          "columnChooser",
          "rowGroup",
          "pinSubMenu"
        ]
      },
      objectColumn: {
        floatingFilter: !1,
        filter: !1,
        sortable: !1,
        resizable: !0,
        autoHeight: !0,
        suppressHeaderFilterButton: !0,
        columnGroupShow: "open",
        mainMenuItems: ["columnChooser"]
      },
      actionColumn: {
        resizable: !1,
        initialHide: !1,
        hide: !1,
        floatingFilter: !1,
        sortable: !1,
        pinned: "right",
        columnGroupShow: "open",
        cellClass: "bg-grey-2 flex flex-center row no-wrap",
        mainMenuItems: ["columnChooser"]
      }
    };
  }
  getResourceColumnsDefault(t, s) {
    return this.getAllResourceColumns(t, s);
  }
  getResourceColumnsByProfils(t, s, i) {
    let o = this.getAllResourceColumns(
      s,
      i
    );
    return o.forEach((n) => {
      if (n.colId === "defaultActions") return;
      const a = t.find((l) => n.colId === l.field_name);
      a ? (n.hide = !a.visible, n.width = a.width, n.context.order = a.order) : n.hide = !0;
    }), o = o.sort((n, a) => {
      var l, d;
      return Number((l = n.context) == null ? void 0 : l.order) - Number((d = a.context) == null ? void 0 : d.order);
    }), o = o.filter((n) => n), o;
  }
  getAllResourceColumns(t, s) {
    var r;
    const i = [];
    return t.forEach((o) => {
      let n;
      switch (o.field_type) {
        case "string":
          n = this.getGenericColumnString(o);
          break;
        case "number":
          n = this.getGenericColumnNumber(o);
          break;
        case "boolean":
          n = this.getGenericColumnBoolean(o);
          break;
        case "date":
          n = this.getGenericColumnDate(o);
          break;
        case "object":
          n = this.getGenericColumnObject(o);
          break;
      }
      n.context || (n.context = {}), n.hide = o.association_type !== null, o.raw_field_name === "id" && (n.enableRowGroup = !1), o.association_type !== null && (n.valueGetter = this.getGenericColumnValueGetterRelation(n), o.association_type === "has_many" && (n.autoHeight = !0, n.cellRenderer = this.hasManyColumnSettings.customComponent ?? nh));
      const a = this.overloadSettings.find((l) => l.resourceColumnRegister.columnName === o.raw_field_name && (l.resourceColumnRegister.associationName === o.association_name || l.resourceColumnRegister.associationName === void 0 && o.association_name === null));
      a && (n = a.colDef), i.push(n);
    }), (r = this.actionColumnSettings) != null && r.defaultComponent && i.push(
      this.getGenericColumnAction(
        s,
        this.actionColumnSettings.defaultComponent
      )
    ), this.additionalSettings.forEach((o) => {
      i.push(o.colDef);
    }), i;
  }
  getGenericColumnAction(t, s) {
    return {
      headerName: "Actions",
      type: "actionColumn",
      colId: "defaultActions",
      cellRenderer: s,
      cellRendererParams: {
        resourceName: t
      },
      width: 107
    };
  }
  getGenericColumnString(t) {
    return {
      headerName: t.label_name,
      colId: t.field_name,
      valueGetter: (s) => s.data ? s.data[t.raw_field_name] : "",
      type: "keywordColumn",
      filter: "agTextColumnFilter"
    };
  }
  getGenericColumnNumber(t) {
    return {
      headerName: t.label_name,
      colId: t.field_name,
      valueGetter: (s) => s.data ? s.data[t.raw_field_name] : "",
      type: "numberColumn",
      filter: "agNumberColumnFilter"
    };
  }
  getGenericColumnDate(t) {
    return {
      headerName: t.label_name,
      colId: t.field_name,
      type: "dateColumn",
      filter: "agDateColumnFilter",
      valueGetter: (s) => s.data ? this.globalColumnSettings.columnDateFormater(
        s.data[t.raw_field_name]
      ) : "",
      width: 150
    };
  }
  getGenericColumnBoolean(t) {
    return {
      headerName: t.label_name,
      colId: t.field_name,
      type: "booleanColumn",
      valueGetter: (s) => !s.data || s.data[t.raw_field_name] === void 0 || s.data[t.raw_field_name] === null ? "" : s.data[t.raw_field_name] ? "Oui" : "Non",
      width: 150
    };
  }
  getGenericColumnObject(t) {
    return {
      headerName: t.label_name,
      colId: t.field_name,
      type: "objectColumn",
      filter: "agTextColumnFilter",
      valueGetter: () => "",
      width: 150
    };
  }
  getGenericColumnValueGetterRelation(t) {
    if (!t.colId) return () => null;
    const s = t.valueGetter, i = t.colId.split("::").at(-1), r = t.colId.split(".").at(0);
    return !r || !s || typeof s != "function" ? () => null : i === "has_many" || i === "has_and_belongs_to_many" ? (o) => !o.data || !o.data[r] ? "" : o.data[r].map(
      (n) => s({ ...o, data: n })
    ) : i === "belongs_to" || i === "has_one" ? (o) => !o.data || !o.data[r] ? "" : s({
      ...o,
      data: o.data[r]
    }) : () => null;
  }
}
const F2 = {
  key: 0,
  style: { display: "flex", "flex-direction": "column", height: "100%" }
}, R2 = {
  key: 0,
  style: { display: "flex", "flex-direction": "row", "justify-content": "end", "align-items": "center", padding: "4px 4px", "padding-right": "8px" }
}, D2 = /* @__PURE__ */ Wo({
  __name: "Query64Grid",
  props: {
    resourceName: {},
    getMetadata: { type: Function, default: async () => [] },
    getRows: { type: Function, default: async () => ({ items: [], length: 0 }) },
    showRowCount: { type: Boolean, default: !0 },
    aggridTheme: { default: Nx },
    gridStyle: { default: "box-shadow: 0 1px 8px rgba(0, 0, 0, 0.2), 0 3px 4px rgba(0, 0, 0, 0.14), 0 3px 3px -2px rgba(0, 0, 0, 0.12);" },
    globalColumnSettings: {},
    hasManyColumnSettings: {},
    actionColumnSettings: {},
    overloads: {},
    additionals: {},
    initialGridParams: {},
    context: {}
  },
  setup(e, { expose: t }) {
    const s = e;
    let i = [];
    const r = new Ho(
      s.resourceName,
      s.globalColumnSettings,
      s.hasManyColumnSettings,
      s.actionColumnSettings,
      s.overloads,
      s.additionals
    ), o = it({
      localeText: S2,
      suppressMiddleClickScrolls: !0,
      rowSelection: "multiple",
      rowModelType: "serverSide",
      rowGroupPanelShow: "onlyWhenGrouping",
      groupDisplayType: "singleColumn",
      autoGroupColumnDef: {
        minWidth: 200,
        cellRendererParams: {
          innerRenderer: (x) => (x.node.key = x.data.__group_key ?? null, x.data.__label)
        }
      },
      columnTypes: r.globalColumnSettings.columnTypeConfig,
      columnDefs: [],
      serverSideDatasource: g(),
      getRowId: u,
      getChildCount: p,
      maxConcurrentDatasourceRequests: 1,
      cacheBlockSize: 50,
      maxBlocksInCache: 4,
      rowHeight: 35
    }), n = it(), a = it("0 ligne"), l = it(!0), d = it(
      null
    ), c = it([]);
    async function h() {
      i = await s.getMetadata({
        resourceName: s.resourceName,
        context: s.context
      });
    }
    function u(x) {
      return x.data.id ? x.data.id.toString() : x.data.__id.toString();
    }
    function p(x) {
      return x.__childCount;
    }
    function g() {
      return {
        getRows: (x) => {
          var M;
          const T = ((M = x.api.getColumns()) == null ? void 0 : M.filter((N) => N.isVisible()).map((N) => N.getColId())) ?? [];
          if (T.length === 0) {
            x.success({
              rowData: [],
              rowCount: 0
            });
            return;
          }
          const I = JSON.stringify({
            ...x.request,
            endRow: 0,
            startRow: 0,
            sortModel: []
          }) !== JSON.stringify({
            ...d.value,
            endRow: 0,
            startRow: 0,
            sortModel: []
          }) || c.value.join(", ") !== T.join(", ");
          c.value = T, d.value = x.request;
          const E = x.api.getRowGroupColumns().map((N) => N.getColId());
          T.push(...E), s.getRows({
            resourceName: s.resourceName,
            agGridServerParams: { ...x.request },
            columnsToDisplay: T,
            shallReturnCount: I,
            context: s.context
          }).then((N) => {
            let _ = [];
            x.request.rowGroupCols.length !== 0 && x.request.rowGroupCols.length !== x.request.groupKeys.length || (_ = T.filter((K) => K.includes(".")).map((K) => K.split(".").at(0) ?? ""));
            const W = N.items.map((K) => (_.forEach((se) => {
              K[se] = JSON.parse(K[se]);
            }), K));
            I ? x.success({
              rowData: W,
              rowCount: N.length
            }) : x.success({
              rowData: W
            });
          }).catch((N) => {
            x.fail(), console.error(N);
          });
        }
      };
    }
    function f(x) {
      if (!n.value || !i) return;
      let T;
      x ? T = r.getResourceColumnsByProfils(
        x,
        i,
        s.resourceName
      ) : T = r.getResourceColumnsDefault(
        i,
        s.resourceName
      ), n.value.setGridOption("columnDefs", T);
    }
    function m(x, T, I) {
      if (n.value && (x && n.value.setFilterModel(x), T && n.value.applyColumnState({ state: T }), I)) {
        const E = n.value.getAllGridColumns(), M = I.map((N) => E.find((_) => _.getColId() == N.field)).filter((N) => N !== void 0);
        n.value.setRowGroupColumns(M);
      }
    }
    function C(x, T, I, E) {
      n.value && (f(x), m(T, I, E));
    }
    function v() {
      n.value && n.value.refreshServerSide();
    }
    function b() {
      if (!n.value) return;
      const x = n.value.getDisplayedRowCount();
      a.value = `${x} ligne${x > 0 ? "s" : ""}`;
    }
    function y() {
      var T;
      if (!((T = s.initialGridParams) != null && T.gridOptions)) return;
      const x = [
        "localeText",
        "rowModelType",
        "columnTypes",
        "columnDefs",
        "serverSideDatasource",
        "getRowId",
        "getChildCount"
      ];
      Object.entries(s.initialGridParams.gridOptions).forEach(
        (I) => {
          const E = I;
          x.includes(E[0]) || (o.value[E[0]] = I[1]);
        }
      );
    }
    function F() {
      const x = o.value.onGridReady;
      o.value.onGridReady = (E) => {
        var M, N, _, H;
        n.value = E.api, C(
          (M = s.initialGridParams) == null ? void 0 : M.columnProfils,
          (N = s.initialGridParams) == null ? void 0 : N.filterModel,
          (_ = s.initialGridParams) == null ? void 0 : _.sortModel,
          (H = s.initialGridParams) == null ? void 0 : H.rowgroupCols
        ), x && x(E);
      };
      const T = o.value.onModelUpdated;
      o.value.onModelUpdated = (E) => {
        T && T(E), setTimeout(() => {
          b();
        }, 100);
      };
      const I = o.value.onColumnVisible;
      o.value.onColumnVisible = (E) => {
        I && I(E), !(!E.column || !E.visible || !n.value) && n.value.refreshServerSide();
      };
    }
    function D() {
      n.value && (n.value.setFilterModel(null), n.value.resetColumnState(), n.value.setRowGroupColumns([]));
    }
    return dh(async () => {
      y(), await h(), F(), l.value = !1;
    }), t({
      resetGridParams: D,
      updateGridParams: C,
      updateRows: v,
      gridOptions: o,
      gridApi: n,
      lastGetRowsParams: d,
      isLoadingSettingUpGrid: l
    }), (x, T) => l.value ? xd("", !0) : (pi(), ui("div", F2, [
      ch(tC(b2), {
        gridOptions: o.value,
        theme: s.aggridTheme,
        style: sC(`height: 100%; width: 100%; ${s.gridStyle}`)
      }, null, 8, ["gridOptions", "theme", "style"]),
      s.showRowCount ? (pi(), ui("div", R2, hh(a.value), 1)) : xd("", !0)
    ]));
  }
});
export {
  No as Query64,
  D2 as Query64Grid
};
